/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const Authentication = $root.Authentication = (() => {

    /**
     * Namespace Authentication.
     * @exports Authentication
     * @namespace
     */
    const Authentication = {};

    /**
     * SupportedLanguage enum.
     * @name Authentication.SupportedLanguage
     * @enum {string}
     * @property {number} ENGLISH=0 ENGLISH value
     * @property {number} ARABIC=1 ARABIC value
     * @property {number} BRITISH=2 BRITISH value
     * @property {number} CHINESE=3 CHINESE value
     * @property {number} CHINESE_HONG_KONG=4 CHINESE_HONG_KONG value
     * @property {number} CHINESE_TAIWAN=5 CHINESE_TAIWAN value
     * @property {number} DUTCH=6 DUTCH value
     * @property {number} FRENCH=7 FRENCH value
     * @property {number} GERMAN=8 GERMAN value
     * @property {number} GREEK=9 GREEK value
     * @property {number} HEBREW=10 HEBREW value
     * @property {number} ITALIAN=11 ITALIAN value
     * @property {number} JAPANESE=12 JAPANESE value
     * @property {number} KOREAN=13 KOREAN value
     * @property {number} POLISH=14 POLISH value
     * @property {number} PORTUGUESE=15 PORTUGUESE value
     * @property {number} PORTUGUESE_BRAZIL=16 PORTUGUESE_BRAZIL value
     * @property {number} ROMANIAN=17 ROMANIAN value
     * @property {number} RUSSIAN=18 RUSSIAN value
     * @property {number} SLOVAK=19 SLOVAK value
     * @property {number} SPANISH=20 SPANISH value
     */
    Authentication.SupportedLanguage = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENGLISH"] = 0;
        values[valuesById[1] = "ARABIC"] = 1;
        values[valuesById[2] = "BRITISH"] = 2;
        values[valuesById[3] = "CHINESE"] = 3;
        values[valuesById[4] = "CHINESE_HONG_KONG"] = 4;
        values[valuesById[5] = "CHINESE_TAIWAN"] = 5;
        values[valuesById[6] = "DUTCH"] = 6;
        values[valuesById[7] = "FRENCH"] = 7;
        values[valuesById[8] = "GERMAN"] = 8;
        values[valuesById[9] = "GREEK"] = 9;
        values[valuesById[10] = "HEBREW"] = 10;
        values[valuesById[11] = "ITALIAN"] = 11;
        values[valuesById[12] = "JAPANESE"] = 12;
        values[valuesById[13] = "KOREAN"] = 13;
        values[valuesById[14] = "POLISH"] = 14;
        values[valuesById[15] = "PORTUGUESE"] = 15;
        values[valuesById[16] = "PORTUGUESE_BRAZIL"] = 16;
        values[valuesById[17] = "ROMANIAN"] = 17;
        values[valuesById[18] = "RUSSIAN"] = 18;
        values[valuesById[19] = "SLOVAK"] = 19;
        values[valuesById[20] = "SPANISH"] = 20;
        return values;
    })();

    /**
     * LoginType enum.
     * @name Authentication.LoginType
     * @enum {string}
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} SSO=1 SSO value
     * @property {number} BIO=2 BIO value
     * @property {number} ALTERNATE=3 ALTERNATE value
     * @property {number} OFFLINE=4 OFFLINE value
     */
    Authentication.LoginType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "SSO"] = 1;
        values[valuesById[2] = "BIO"] = 2;
        values[valuesById[3] = "ALTERNATE"] = 3;
        values[valuesById[4] = "OFFLINE"] = 4;
        return values;
    })();

    /**
     * DeviceStatus enum.
     * @name Authentication.DeviceStatus
     * @enum {string}
     * @property {number} NEED_APPROVAL=0 NEED_APPROVAL value
     * @property {number} OK=1 OK value
     * @property {number} DEVICE_DISABLED=2 DEVICE_DISABLED value
     */
    Authentication.DeviceStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NEED_APPROVAL"] = 0;
        values[valuesById[1] = "OK"] = 1;
        values[valuesById[2] = "DEVICE_DISABLED"] = 2;
        return values;
    })();

    /**
     * LicenseStatus enum.
     * @name Authentication.LicenseStatus
     * @enum {string}
     * @property {number} OTHER=0 OTHER value
     * @property {number} ACTIVE=1 ACTIVE value
     * @property {number} EXPIRED=2 EXPIRED value
     * @property {number} DISABLED=3 DISABLED value
     */
    Authentication.LicenseStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OTHER"] = 0;
        values[valuesById[1] = "ACTIVE"] = 1;
        values[valuesById[2] = "EXPIRED"] = 2;
        values[valuesById[3] = "DISABLED"] = 3;
        return values;
    })();

    /**
     * AccountType enum.
     * @name Authentication.AccountType
     * @enum {string}
     * @property {number} CONSUMER=0 CONSUMER value
     * @property {number} FAMILY=1 FAMILY value
     * @property {number} ENTERPRISE=2 ENTERPRISE value
     */
    Authentication.AccountType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CONSUMER"] = 0;
        values[valuesById[1] = "FAMILY"] = 1;
        values[valuesById[2] = "ENTERPRISE"] = 2;
        return values;
    })();

    /**
     * SessionTokenType enum.
     * @name Authentication.SessionTokenType
     * @enum {string}
     * @property {number} NO_RESTRICTION=0 NO_RESTRICTION value
     * @property {number} ACCOUNT_RECOVERY=1 ACCOUNT_RECOVERY value
     * @property {number} SHARE_ACCOUNT=2 SHARE_ACCOUNT value
     * @property {number} PURCHASE=3 PURCHASE value
     * @property {number} RESTRICT=4 RESTRICT value
     * @property {number} ACCEPT_INVITE=5 ACCEPT_INVITE value
     */
    Authentication.SessionTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_RESTRICTION"] = 0;
        values[valuesById[1] = "ACCOUNT_RECOVERY"] = 1;
        values[valuesById[2] = "SHARE_ACCOUNT"] = 2;
        values[valuesById[3] = "PURCHASE"] = 3;
        values[valuesById[4] = "RESTRICT"] = 4;
        values[valuesById[5] = "ACCEPT_INVITE"] = 5;
        return values;
    })();

    /**
     * Version enum.
     * @name Authentication.Version
     * @enum {string}
     * @property {number} invalid_version=0 invalid_version value
     * @property {number} default_version=1 default_version value
     * @property {number} second_version=2 second_version value
     */
    Authentication.Version = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "invalid_version"] = 0;
        values[valuesById[1] = "default_version"] = 1;
        values[valuesById[2] = "second_version"] = 2;
        return values;
    })();

    Authentication.ApiRequest = (function() {

        /**
         * Properties of an ApiRequest.
         * @memberof Authentication
         * @interface IApiRequest
         * @property {Uint8Array|null} [encryptedTransmissionKey] ApiRequest encryptedTransmissionKey
         * @property {number|null} [publicKeyId] ApiRequest publicKeyId
         * @property {string|null} [locale] ApiRequest locale
         * @property {Uint8Array|null} [encryptedPayload] ApiRequest encryptedPayload
         * @property {number|null} [encryptionType] ApiRequest encryptionType
         * @property {string|null} [recaptcha] ApiRequest recaptcha
         */

        /**
         * Constructs a new ApiRequest.
         * @memberof Authentication
         * @classdesc Represents an ApiRequest.
         * @implements IApiRequest
         * @constructor
         * @param {Authentication.IApiRequest=} [properties] Properties to set
         */
        function ApiRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiRequest encryptedTransmissionKey.
         * @member {Uint8Array} encryptedTransmissionKey
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptedTransmissionKey = $util.newBuffer([]);

        /**
         * ApiRequest publicKeyId.
         * @member {number} publicKeyId
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.publicKeyId = 0;

        /**
         * ApiRequest locale.
         * @member {string} locale
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.locale = "";

        /**
         * ApiRequest encryptedPayload.
         * @member {Uint8Array} encryptedPayload
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptedPayload = $util.newBuffer([]);

        /**
         * ApiRequest encryptionType.
         * @member {number} encryptionType
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptionType = 0;

        /**
         * ApiRequest recaptcha.
         * @member {string} recaptcha
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.recaptcha = "";

        /**
         * Creates a new ApiRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest=} [properties] Properties to set
         * @returns {Authentication.ApiRequest} ApiRequest instance
         */
        ApiRequest.create = function create(properties) {
            return new ApiRequest(properties);
        };

        /**
         * Encodes the specified ApiRequest message. Does not implicitly {@link Authentication.ApiRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest} message ApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTransmissionKey);
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.publicKeyId);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPayload);
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.encryptionType);
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.recaptcha);
            return writer;
        };

        /**
         * Encodes the specified ApiRequest message, length delimited. Does not implicitly {@link Authentication.ApiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest} message ApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApiRequest} ApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApiRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTransmissionKey = reader.bytes();
                    break;
                case 2:
                    message.publicKeyId = reader.int32();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.encryptedPayload = reader.bytes();
                    break;
                case 5:
                    message.encryptionType = reader.int32();
                    break;
                case 6:
                    message.recaptcha = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApiRequest} ApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiRequest message.
         * @function verify
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                if (!(message.encryptedTransmissionKey && typeof message.encryptedTransmissionKey.length === "number" || $util.isString(message.encryptedTransmissionKey)))
                    return "encryptedTransmissionKey: buffer expected";
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                if (!$util.isInteger(message.publicKeyId))
                    return "publicKeyId: integer expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                if (!(message.encryptedPayload && typeof message.encryptedPayload.length === "number" || $util.isString(message.encryptedPayload)))
                    return "encryptedPayload: buffer expected";
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                if (!$util.isInteger(message.encryptionType))
                    return "encryptionType: integer expected";
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                if (!$util.isString(message.recaptcha))
                    return "recaptcha: string expected";
            return null;
        };

        /**
         * Creates an ApiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApiRequest} ApiRequest
         */
        ApiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApiRequest)
                return object;
            let message = new $root.Authentication.ApiRequest();
            if (object.encryptedTransmissionKey != null)
                if (typeof object.encryptedTransmissionKey === "string")
                    $util.base64.decode(object.encryptedTransmissionKey, message.encryptedTransmissionKey = $util.newBuffer($util.base64.length(object.encryptedTransmissionKey)), 0);
                else if (object.encryptedTransmissionKey.length)
                    message.encryptedTransmissionKey = object.encryptedTransmissionKey;
            if (object.publicKeyId != null)
                message.publicKeyId = object.publicKeyId | 0;
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedPayload != null)
                if (typeof object.encryptedPayload === "string")
                    $util.base64.decode(object.encryptedPayload, message.encryptedPayload = $util.newBuffer($util.base64.length(object.encryptedPayload)), 0);
                else if (object.encryptedPayload.length)
                    message.encryptedPayload = object.encryptedPayload;
            if (object.encryptionType != null)
                message.encryptionType = object.encryptionType | 0;
            if (object.recaptcha != null)
                message.recaptcha = String(object.recaptcha);
            return message;
        };

        /**
         * Creates a plain object from an ApiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.ApiRequest} message ApiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedTransmissionKey = "";
                else {
                    object.encryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTransmissionKey = $util.newBuffer(object.encryptedTransmissionKey);
                }
                object.publicKeyId = 0;
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedPayload = "";
                else {
                    object.encryptedPayload = [];
                    if (options.bytes !== Array)
                        object.encryptedPayload = $util.newBuffer(object.encryptedPayload);
                }
                object.encryptionType = 0;
                object.recaptcha = "";
            }
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                object.encryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.encryptedTransmissionKey, 0, message.encryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTransmissionKey) : message.encryptedTransmissionKey;
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                object.publicKeyId = message.publicKeyId;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                object.encryptedPayload = options.bytes === String ? $util.base64.encode(message.encryptedPayload, 0, message.encryptedPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPayload) : message.encryptedPayload;
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                object.encryptionType = message.encryptionType;
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                object.recaptcha = message.recaptcha;
            return object;
        };

        /**
         * Converts this ApiRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ApiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiRequest;
    })();

    Authentication.ApiRequestPayload = (function() {

        /**
         * Properties of an ApiRequestPayload.
         * @memberof Authentication
         * @interface IApiRequestPayload
         * @property {Uint8Array|null} [payload] ApiRequestPayload payload
         * @property {Uint8Array|null} [encryptedSessionToken] ApiRequestPayload encryptedSessionToken
         * @property {Uint8Array|null} [timeToken] ApiRequestPayload timeToken
         * @property {number|null} [apiVersion] ApiRequestPayload apiVersion
         */

        /**
         * Constructs a new ApiRequestPayload.
         * @memberof Authentication
         * @classdesc Represents an ApiRequestPayload.
         * @implements IApiRequestPayload
         * @constructor
         * @param {Authentication.IApiRequestPayload=} [properties] Properties to set
         */
        function ApiRequestPayload(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiRequestPayload payload.
         * @member {Uint8Array} payload
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.payload = $util.newBuffer([]);

        /**
         * ApiRequestPayload encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * ApiRequestPayload timeToken.
         * @member {Uint8Array} timeToken
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.timeToken = $util.newBuffer([]);

        /**
         * ApiRequestPayload apiVersion.
         * @member {number} apiVersion
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.apiVersion = 0;

        /**
         * Creates a new ApiRequestPayload instance using the specified properties.
         * @function create
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload=} [properties] Properties to set
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload instance
         */
        ApiRequestPayload.create = function create(properties) {
            return new ApiRequestPayload(properties);
        };

        /**
         * Encodes the specified ApiRequestPayload message. Does not implicitly {@link Authentication.ApiRequestPayload.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload} message ApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedSessionToken);
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.timeToken);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.apiVersion);
            return writer;
        };

        /**
         * Encodes the specified ApiRequestPayload message, length delimited. Does not implicitly {@link Authentication.ApiRequestPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload} message ApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiRequestPayload message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApiRequestPayload();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 3:
                    message.timeToken = reader.bytes();
                    break;
                case 4:
                    message.apiVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiRequestPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiRequestPayload message.
         * @function verify
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiRequestPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                if (!(message.timeToken && typeof message.timeToken.length === "number" || $util.isString(message.timeToken)))
                    return "timeToken: buffer expected";
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                if (!$util.isInteger(message.apiVersion))
                    return "apiVersion: integer expected";
            return null;
        };

        /**
         * Creates an ApiRequestPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         */
        ApiRequestPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApiRequestPayload)
                return object;
            let message = new $root.Authentication.ApiRequestPayload();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.timeToken != null)
                if (typeof object.timeToken === "string")
                    $util.base64.decode(object.timeToken, message.timeToken = $util.newBuffer($util.base64.length(object.timeToken)), 0);
                else if (object.timeToken.length)
                    message.timeToken = object.timeToken;
            if (object.apiVersion != null)
                message.apiVersion = object.apiVersion | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApiRequestPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.ApiRequestPayload} message ApiRequestPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiRequestPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                if (options.bytes === String)
                    object.timeToken = "";
                else {
                    object.timeToken = [];
                    if (options.bytes !== Array)
                        object.timeToken = $util.newBuffer(object.timeToken);
                }
                object.apiVersion = 0;
            }
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                object.timeToken = options.bytes === String ? $util.base64.encode(message.timeToken, 0, message.timeToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.timeToken) : message.timeToken;
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = message.apiVersion;
            return object;
        };

        /**
         * Converts this ApiRequestPayload to JSON.
         * @function toJSON
         * @memberof Authentication.ApiRequestPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiRequestPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiRequestPayload;
    })();

    Authentication.Transform = (function() {

        /**
         * Properties of a Transform.
         * @memberof Authentication
         * @interface ITransform
         * @property {Uint8Array|null} [key] Transform key
         * @property {Uint8Array|null} [encryptedDeviceToken] Transform encryptedDeviceToken
         */

        /**
         * Constructs a new Transform.
         * @memberof Authentication
         * @classdesc Represents a Transform.
         * @implements ITransform
         * @constructor
         * @param {Authentication.ITransform=} [properties] Properties to set
         */
        function Transform(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transform key.
         * @member {Uint8Array} key
         * @memberof Authentication.Transform
         * @instance
         */
        Transform.prototype.key = $util.newBuffer([]);

        /**
         * Transform encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.Transform
         * @instance
         */
        Transform.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new Transform instance using the specified properties.
         * @function create
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform=} [properties] Properties to set
         * @returns {Authentication.Transform} Transform instance
         */
        Transform.create = function create(properties) {
            return new Transform(properties);
        };

        /**
         * Encodes the specified Transform message. Does not implicitly {@link Authentication.Transform.verify|verify} messages.
         * @function encode
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified Transform message, length delimited. Does not implicitly {@link Authentication.Transform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transform message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.Transform();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transform message.
         * @function verify
         * @memberof Authentication.Transform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a Transform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.Transform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.Transform} Transform
         */
        Transform.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.Transform)
                return object;
            let message = new $root.Authentication.Transform();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a Transform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.Transform} message Transform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this Transform to JSON.
         * @function toJSON
         * @memberof Authentication.Transform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transform;
    })();

    Authentication.DeviceRequest = (function() {

        /**
         * Properties of a DeviceRequest.
         * @memberof Authentication
         * @interface IDeviceRequest
         * @property {string|null} [clientVersion] DeviceRequest clientVersion
         * @property {string|null} [deviceName] DeviceRequest deviceName
         */

        /**
         * Constructs a new DeviceRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceRequest.
         * @implements IDeviceRequest
         * @constructor
         * @param {Authentication.IDeviceRequest=} [properties] Properties to set
         */
        function DeviceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.clientVersion = "";

        /**
         * DeviceRequest deviceName.
         * @member {string} deviceName
         * @memberof Authentication.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.deviceName = "";

        /**
         * Creates a new DeviceRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceRequest} DeviceRequest instance
         */
        DeviceRequest.create = function create(properties) {
            return new DeviceRequest(properties);
        };

        /**
         * Encodes the specified DeviceRequest message. Does not implicitly {@link Authentication.DeviceRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            return writer;
        };

        /**
         * Encodes the specified DeviceRequest message, length delimited. Does not implicitly {@link Authentication.DeviceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRequest message.
         * @function verify
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            return null;
        };

        /**
         * Creates a DeviceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceRequest} DeviceRequest
         */
        DeviceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceRequest)
                return object;
            let message = new $root.Authentication.DeviceRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            return message;
        };

        /**
         * Creates a plain object from a DeviceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.DeviceRequest} message DeviceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.deviceName = "";
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            return object;
        };

        /**
         * Converts this DeviceRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRequest;
    })();

    Authentication.AuthRequest = (function() {

        /**
         * Properties of an AuthRequest.
         * @memberof Authentication
         * @interface IAuthRequest
         * @property {string|null} [clientVersion] AuthRequest clientVersion
         * @property {string|null} [username] AuthRequest username
         * @property {Uint8Array|null} [encryptedDeviceToken] AuthRequest encryptedDeviceToken
         */

        /**
         * Constructs a new AuthRequest.
         * @memberof Authentication
         * @classdesc Represents an AuthRequest.
         * @implements IAuthRequest
         * @constructor
         * @param {Authentication.IAuthRequest=} [properties] Properties to set
         */
        function AuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientVersion = "";

        /**
         * AuthRequest username.
         * @member {string} username
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.username = "";

        /**
         * AuthRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new AuthRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest=} [properties] Properties to set
         * @returns {Authentication.AuthRequest} AuthRequest instance
         */
        AuthRequest.create = function create(properties) {
            return new AuthRequest(properties);
        };

        /**
         * Encodes the specified AuthRequest message. Does not implicitly {@link Authentication.AuthRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified AuthRequest message, length delimited. Does not implicitly {@link Authentication.AuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.AuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRequest message.
         * @function verify
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates an AuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.AuthRequest} AuthRequest
         */
        AuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.AuthRequest)
                return object;
            let message = new $root.Authentication.AuthRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.username != null)
                message.username = String(object.username);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from an AuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.AuthRequest} message AuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.username = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this AuthRequest to JSON.
         * @function toJSON
         * @memberof Authentication.AuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthRequest;
    })();

    Authentication.NewUserMinimumParams = (function() {

        /**
         * Properties of a NewUserMinimumParams.
         * @memberof Authentication
         * @interface INewUserMinimumParams
         * @property {number|null} [minimumIterations] NewUserMinimumParams minimumIterations
         * @property {Array.<string>|null} [passwordMatchRegex] NewUserMinimumParams passwordMatchRegex
         * @property {Array.<string>|null} [passwordMatchDescription] NewUserMinimumParams passwordMatchDescription
         */

        /**
         * Constructs a new NewUserMinimumParams.
         * @memberof Authentication
         * @classdesc Represents a NewUserMinimumParams.
         * @implements INewUserMinimumParams
         * @constructor
         * @param {Authentication.INewUserMinimumParams=} [properties] Properties to set
         */
        function NewUserMinimumParams(properties) {
            this.passwordMatchRegex = [];
            this.passwordMatchDescription = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewUserMinimumParams minimumIterations.
         * @member {number} minimumIterations
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.minimumIterations = 0;

        /**
         * NewUserMinimumParams passwordMatchRegex.
         * @member {Array.<string>} passwordMatchRegex
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.passwordMatchRegex = $util.emptyArray;

        /**
         * NewUserMinimumParams passwordMatchDescription.
         * @member {Array.<string>} passwordMatchDescription
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.passwordMatchDescription = $util.emptyArray;

        /**
         * Creates a new NewUserMinimumParams instance using the specified properties.
         * @function create
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams=} [properties] Properties to set
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams instance
         */
        NewUserMinimumParams.create = function create(properties) {
            return new NewUserMinimumParams(properties);
        };

        /**
         * Encodes the specified NewUserMinimumParams message. Does not implicitly {@link Authentication.NewUserMinimumParams.verify|verify} messages.
         * @function encode
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams} message NewUserMinimumParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewUserMinimumParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minimumIterations);
            if (message.passwordMatchRegex != null && message.passwordMatchRegex.length)
                for (let i = 0; i < message.passwordMatchRegex.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.passwordMatchRegex[i]);
            if (message.passwordMatchDescription != null && message.passwordMatchDescription.length)
                for (let i = 0; i < message.passwordMatchDescription.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.passwordMatchDescription[i]);
            return writer;
        };

        /**
         * Encodes the specified NewUserMinimumParams message, length delimited. Does not implicitly {@link Authentication.NewUserMinimumParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams} message NewUserMinimumParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewUserMinimumParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewUserMinimumParams message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewUserMinimumParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.NewUserMinimumParams();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minimumIterations = reader.int32();
                    break;
                case 2:
                    if (!(message.passwordMatchRegex && message.passwordMatchRegex.length))
                        message.passwordMatchRegex = [];
                    message.passwordMatchRegex.push(reader.string());
                    break;
                case 3:
                    if (!(message.passwordMatchDescription && message.passwordMatchDescription.length))
                        message.passwordMatchDescription = [];
                    message.passwordMatchDescription.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewUserMinimumParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewUserMinimumParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewUserMinimumParams message.
         * @function verify
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewUserMinimumParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                if (!$util.isInteger(message.minimumIterations))
                    return "minimumIterations: integer expected";
            if (message.passwordMatchRegex != null && message.hasOwnProperty("passwordMatchRegex")) {
                if (!Array.isArray(message.passwordMatchRegex))
                    return "passwordMatchRegex: array expected";
                for (let i = 0; i < message.passwordMatchRegex.length; ++i)
                    if (!$util.isString(message.passwordMatchRegex[i]))
                        return "passwordMatchRegex: string[] expected";
            }
            if (message.passwordMatchDescription != null && message.hasOwnProperty("passwordMatchDescription")) {
                if (!Array.isArray(message.passwordMatchDescription))
                    return "passwordMatchDescription: array expected";
                for (let i = 0; i < message.passwordMatchDescription.length; ++i)
                    if (!$util.isString(message.passwordMatchDescription[i]))
                        return "passwordMatchDescription: string[] expected";
            }
            return null;
        };

        /**
         * Creates a NewUserMinimumParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         */
        NewUserMinimumParams.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.NewUserMinimumParams)
                return object;
            let message = new $root.Authentication.NewUserMinimumParams();
            if (object.minimumIterations != null)
                message.minimumIterations = object.minimumIterations | 0;
            if (object.passwordMatchRegex) {
                if (!Array.isArray(object.passwordMatchRegex))
                    throw TypeError(".Authentication.NewUserMinimumParams.passwordMatchRegex: array expected");
                message.passwordMatchRegex = [];
                for (let i = 0; i < object.passwordMatchRegex.length; ++i)
                    message.passwordMatchRegex[i] = String(object.passwordMatchRegex[i]);
            }
            if (object.passwordMatchDescription) {
                if (!Array.isArray(object.passwordMatchDescription))
                    throw TypeError(".Authentication.NewUserMinimumParams.passwordMatchDescription: array expected");
                message.passwordMatchDescription = [];
                for (let i = 0; i < object.passwordMatchDescription.length; ++i)
                    message.passwordMatchDescription[i] = String(object.passwordMatchDescription[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a NewUserMinimumParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.NewUserMinimumParams} message NewUserMinimumParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewUserMinimumParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.passwordMatchRegex = [];
                object.passwordMatchDescription = [];
            }
            if (options.defaults)
                object.minimumIterations = 0;
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                object.minimumIterations = message.minimumIterations;
            if (message.passwordMatchRegex && message.passwordMatchRegex.length) {
                object.passwordMatchRegex = [];
                for (let j = 0; j < message.passwordMatchRegex.length; ++j)
                    object.passwordMatchRegex[j] = message.passwordMatchRegex[j];
            }
            if (message.passwordMatchDescription && message.passwordMatchDescription.length) {
                object.passwordMatchDescription = [];
                for (let j = 0; j < message.passwordMatchDescription.length; ++j)
                    object.passwordMatchDescription[j] = message.passwordMatchDescription[j];
            }
            return object;
        };

        /**
         * Converts this NewUserMinimumParams to JSON.
         * @function toJSON
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewUserMinimumParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewUserMinimumParams;
    })();

    Authentication.SsoRequestParams = (function() {

        /**
         * Properties of a SsoRequestParams.
         * @memberof Authentication
         * @interface ISsoRequestParams
         * @property {string|null} [action] SsoRequestParams action
         * @property {string|null} [dest] SsoRequestParams dest
         * @property {boolean|null} [embedded] SsoRequestParams embedded
         * @property {boolean|null} [json] SsoRequestParams json
         * @property {string|null} [key] SsoRequestParams key
         */

        /**
         * Constructs a new SsoRequestParams.
         * @memberof Authentication
         * @classdesc Represents a SsoRequestParams.
         * @implements ISsoRequestParams
         * @constructor
         * @param {Authentication.ISsoRequestParams=} [properties] Properties to set
         */
        function SsoRequestParams(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoRequestParams action.
         * @member {string} action
         * @memberof Authentication.SsoRequestParams
         * @instance
         */
        SsoRequestParams.prototype.action = "";

        /**
         * SsoRequestParams dest.
         * @member {string} dest
         * @memberof Authentication.SsoRequestParams
         * @instance
         */
        SsoRequestParams.prototype.dest = "";

        /**
         * SsoRequestParams embedded.
         * @member {boolean} embedded
         * @memberof Authentication.SsoRequestParams
         * @instance
         */
        SsoRequestParams.prototype.embedded = false;

        /**
         * SsoRequestParams json.
         * @member {boolean} json
         * @memberof Authentication.SsoRequestParams
         * @instance
         */
        SsoRequestParams.prototype.json = false;

        /**
         * SsoRequestParams key.
         * @member {string} key
         * @memberof Authentication.SsoRequestParams
         * @instance
         */
        SsoRequestParams.prototype.key = "";

        /**
         * Creates a new SsoRequestParams instance using the specified properties.
         * @function create
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Authentication.ISsoRequestParams=} [properties] Properties to set
         * @returns {Authentication.SsoRequestParams} SsoRequestParams instance
         */
        SsoRequestParams.create = function create(properties) {
            return new SsoRequestParams(properties);
        };

        /**
         * Encodes the specified SsoRequestParams message. Does not implicitly {@link Authentication.SsoRequestParams.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Authentication.ISsoRequestParams} message SsoRequestParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoRequestParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.action);
            if (message.dest != null && message.hasOwnProperty("dest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dest);
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.embedded);
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.json);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.key);
            return writer;
        };

        /**
         * Encodes the specified SsoRequestParams message, length delimited. Does not implicitly {@link Authentication.SsoRequestParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Authentication.ISsoRequestParams} message SsoRequestParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoRequestParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoRequestParams message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SsoRequestParams} SsoRequestParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoRequestParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SsoRequestParams();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.action = reader.string();
                    break;
                case 2:
                    message.dest = reader.string();
                    break;
                case 3:
                    message.embedded = reader.bool();
                    break;
                case 4:
                    message.json = reader.bool();
                    break;
                case 5:
                    message.key = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoRequestParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SsoRequestParams} SsoRequestParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoRequestParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoRequestParams message.
         * @function verify
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoRequestParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.action != null && message.hasOwnProperty("action"))
                if (!$util.isString(message.action))
                    return "action: string expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!$util.isString(message.dest))
                    return "dest: string expected";
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                if (typeof message.embedded !== "boolean")
                    return "embedded: boolean expected";
            if (message.json != null && message.hasOwnProperty("json"))
                if (typeof message.json !== "boolean")
                    return "json: boolean expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            return null;
        };

        /**
         * Creates a SsoRequestParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SsoRequestParams} SsoRequestParams
         */
        SsoRequestParams.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SsoRequestParams)
                return object;
            let message = new $root.Authentication.SsoRequestParams();
            if (object.action != null)
                message.action = String(object.action);
            if (object.dest != null)
                message.dest = String(object.dest);
            if (object.embedded != null)
                message.embedded = Boolean(object.embedded);
            if (object.json != null)
                message.json = Boolean(object.json);
            if (object.key != null)
                message.key = String(object.key);
            return message;
        };

        /**
         * Creates a plain object from a SsoRequestParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SsoRequestParams
         * @static
         * @param {Authentication.SsoRequestParams} message SsoRequestParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoRequestParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.action = "";
                object.dest = "";
                object.embedded = false;
                object.json = false;
                object.key = "";
            }
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = message.action;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = message.dest;
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                object.embedded = message.embedded;
            if (message.json != null && message.hasOwnProperty("json"))
                object.json = message.json;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            return object;
        };

        /**
         * Converts this SsoRequestParams to JSON.
         * @function toJSON
         * @memberof Authentication.SsoRequestParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoRequestParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoRequestParams;
    })();

    Authentication.PreLoginRequest = (function() {

        /**
         * Properties of a PreLoginRequest.
         * @memberof Authentication
         * @interface IPreLoginRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] PreLoginRequest authRequest
         * @property {Authentication.LoginType|null} [loginType] PreLoginRequest loginType
         * @property {Uint8Array|null} [twoFactorToken] PreLoginRequest twoFactorToken
         * @property {Authentication.ISsoRequestParams|null} [ssoRequestParams] PreLoginRequest ssoRequestParams
         */

        /**
         * Constructs a new PreLoginRequest.
         * @memberof Authentication
         * @classdesc Represents a PreLoginRequest.
         * @implements IPreLoginRequest
         * @constructor
         * @param {Authentication.IPreLoginRequest=} [properties] Properties to set
         */
        function PreLoginRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreLoginRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.authRequest = null;

        /**
         * PreLoginRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.loginType = 0;

        /**
         * PreLoginRequest twoFactorToken.
         * @member {Uint8Array} twoFactorToken
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.twoFactorToken = $util.newBuffer([]);

        /**
         * PreLoginRequest ssoRequestParams.
         * @member {Authentication.ISsoRequestParams|null|undefined} ssoRequestParams
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.ssoRequestParams = null;

        /**
         * Creates a new PreLoginRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest=} [properties] Properties to set
         * @returns {Authentication.PreLoginRequest} PreLoginRequest instance
         */
        PreLoginRequest.create = function create(properties) {
            return new PreLoginRequest(properties);
        };

        /**
         * Encodes the specified PreLoginRequest message. Does not implicitly {@link Authentication.PreLoginRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest} message PreLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.loginType);
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.twoFactorToken);
            if (message.ssoRequestParams != null && message.hasOwnProperty("ssoRequestParams"))
                $root.Authentication.SsoRequestParams.encode(message.ssoRequestParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PreLoginRequest message, length delimited. Does not implicitly {@link Authentication.PreLoginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest} message PreLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreLoginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.PreLoginRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.loginType = reader.int32();
                    break;
                case 3:
                    message.twoFactorToken = reader.bytes();
                    break;
                case 4:
                    message.ssoRequestParams = $root.Authentication.SsoRequestParams.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreLoginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreLoginRequest message.
         * @function verify
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreLoginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                if (!(message.twoFactorToken && typeof message.twoFactorToken.length === "number" || $util.isString(message.twoFactorToken)))
                    return "twoFactorToken: buffer expected";
            if (message.ssoRequestParams != null && message.hasOwnProperty("ssoRequestParams")) {
                let error = $root.Authentication.SsoRequestParams.verify(message.ssoRequestParams);
                if (error)
                    return "ssoRequestParams." + error;
            }
            return null;
        };

        /**
         * Creates a PreLoginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         */
        PreLoginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.PreLoginRequest)
                return object;
            let message = new $root.Authentication.PreLoginRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.PreLoginRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.twoFactorToken != null)
                if (typeof object.twoFactorToken === "string")
                    $util.base64.decode(object.twoFactorToken, message.twoFactorToken = $util.newBuffer($util.base64.length(object.twoFactorToken)), 0);
                else if (object.twoFactorToken.length)
                    message.twoFactorToken = object.twoFactorToken;
            if (object.ssoRequestParams != null) {
                if (typeof object.ssoRequestParams !== "object")
                    throw TypeError(".Authentication.PreLoginRequest.ssoRequestParams: object expected");
                message.ssoRequestParams = $root.Authentication.SsoRequestParams.fromObject(object.ssoRequestParams);
            }
            return message;
        };

        /**
         * Creates a plain object from a PreLoginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.PreLoginRequest} message PreLoginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreLoginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.loginType = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.twoFactorToken = "";
                else {
                    object.twoFactorToken = [];
                    if (options.bytes !== Array)
                        object.twoFactorToken = $util.newBuffer(object.twoFactorToken);
                }
                object.ssoRequestParams = null;
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                object.twoFactorToken = options.bytes === String ? $util.base64.encode(message.twoFactorToken, 0, message.twoFactorToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.twoFactorToken) : message.twoFactorToken;
            if (message.ssoRequestParams != null && message.hasOwnProperty("ssoRequestParams"))
                object.ssoRequestParams = $root.Authentication.SsoRequestParams.toObject(message.ssoRequestParams, options);
            return object;
        };

        /**
         * Converts this PreLoginRequest to JSON.
         * @function toJSON
         * @memberof Authentication.PreLoginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreLoginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreLoginRequest;
    })();

    Authentication.LoginRequest = (function() {

        /**
         * Properties of a LoginRequest.
         * @memberof Authentication
         * @interface ILoginRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] LoginRequest authRequest
         * @property {Authentication.LoginType|null} [loginType] LoginRequest loginType
         * @property {Uint8Array|null} [authenticationHashPrime] LoginRequest authenticationHashPrime
         * @property {Uint8Array|null} [randomHashKey] LoginRequest randomHashKey
         * @property {Uint8Array|null} [encryptedTwoFactorToken] LoginRequest encryptedTwoFactorToken
         * @property {Uint8Array|null} [encryptedBreachWatchToken] LoginRequest encryptedBreachWatchToken
         */

        /**
         * Constructs a new LoginRequest.
         * @memberof Authentication
         * @classdesc Represents a LoginRequest.
         * @implements ILoginRequest
         * @constructor
         * @param {Authentication.ILoginRequest=} [properties] Properties to set
         */
        function LoginRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.authRequest = null;

        /**
         * LoginRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.loginType = 0;

        /**
         * LoginRequest authenticationHashPrime.
         * @member {Uint8Array} authenticationHashPrime
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.authenticationHashPrime = $util.newBuffer([]);

        /**
         * LoginRequest randomHashKey.
         * @member {Uint8Array} randomHashKey
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.randomHashKey = $util.newBuffer([]);

        /**
         * LoginRequest encryptedTwoFactorToken.
         * @member {Uint8Array} encryptedTwoFactorToken
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.encryptedTwoFactorToken = $util.newBuffer([]);

        /**
         * LoginRequest encryptedBreachWatchToken.
         * @member {Uint8Array} encryptedBreachWatchToken
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.encryptedBreachWatchToken = $util.newBuffer([]);

        /**
         * Creates a new LoginRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest=} [properties] Properties to set
         * @returns {Authentication.LoginRequest} LoginRequest instance
         */
        LoginRequest.create = function create(properties) {
            return new LoginRequest(properties);
        };

        /**
         * Encodes the specified LoginRequest message. Does not implicitly {@link Authentication.LoginRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest} message LoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.loginType);
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.authenticationHashPrime);
            if (message.randomHashKey != null && message.hasOwnProperty("randomHashKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.randomHashKey);
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedTwoFactorToken);
            if (message.encryptedBreachWatchToken != null && message.hasOwnProperty("encryptedBreachWatchToken"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedBreachWatchToken);
            return writer;
        };

        /**
         * Encodes the specified LoginRequest message, length delimited. Does not implicitly {@link Authentication.LoginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest} message LoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginRequest} LoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.loginType = reader.int32();
                    break;
                case 3:
                    message.authenticationHashPrime = reader.bytes();
                    break;
                case 4:
                    message.randomHashKey = reader.bytes();
                    break;
                case 5:
                    message.encryptedTwoFactorToken = reader.bytes();
                    break;
                case 6:
                    message.encryptedBreachWatchToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginRequest} LoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginRequest message.
         * @function verify
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                if (!(message.authenticationHashPrime && typeof message.authenticationHashPrime.length === "number" || $util.isString(message.authenticationHashPrime)))
                    return "authenticationHashPrime: buffer expected";
            if (message.randomHashKey != null && message.hasOwnProperty("randomHashKey"))
                if (!(message.randomHashKey && typeof message.randomHashKey.length === "number" || $util.isString(message.randomHashKey)))
                    return "randomHashKey: buffer expected";
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                if (!(message.encryptedTwoFactorToken && typeof message.encryptedTwoFactorToken.length === "number" || $util.isString(message.encryptedTwoFactorToken)))
                    return "encryptedTwoFactorToken: buffer expected";
            if (message.encryptedBreachWatchToken != null && message.hasOwnProperty("encryptedBreachWatchToken"))
                if (!(message.encryptedBreachWatchToken && typeof message.encryptedBreachWatchToken.length === "number" || $util.isString(message.encryptedBreachWatchToken)))
                    return "encryptedBreachWatchToken: buffer expected";
            return null;
        };

        /**
         * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginRequest} LoginRequest
         */
        LoginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginRequest)
                return object;
            let message = new $root.Authentication.LoginRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.LoginRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.authenticationHashPrime != null)
                if (typeof object.authenticationHashPrime === "string")
                    $util.base64.decode(object.authenticationHashPrime, message.authenticationHashPrime = $util.newBuffer($util.base64.length(object.authenticationHashPrime)), 0);
                else if (object.authenticationHashPrime.length)
                    message.authenticationHashPrime = object.authenticationHashPrime;
            if (object.randomHashKey != null)
                if (typeof object.randomHashKey === "string")
                    $util.base64.decode(object.randomHashKey, message.randomHashKey = $util.newBuffer($util.base64.length(object.randomHashKey)), 0);
                else if (object.randomHashKey.length)
                    message.randomHashKey = object.randomHashKey;
            if (object.encryptedTwoFactorToken != null)
                if (typeof object.encryptedTwoFactorToken === "string")
                    $util.base64.decode(object.encryptedTwoFactorToken, message.encryptedTwoFactorToken = $util.newBuffer($util.base64.length(object.encryptedTwoFactorToken)), 0);
                else if (object.encryptedTwoFactorToken.length)
                    message.encryptedTwoFactorToken = object.encryptedTwoFactorToken;
            if (object.encryptedBreachWatchToken != null)
                if (typeof object.encryptedBreachWatchToken === "string")
                    $util.base64.decode(object.encryptedBreachWatchToken, message.encryptedBreachWatchToken = $util.newBuffer($util.base64.length(object.encryptedBreachWatchToken)), 0);
                else if (object.encryptedBreachWatchToken.length)
                    message.encryptedBreachWatchToken = object.encryptedBreachWatchToken;
            return message;
        };

        /**
         * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.LoginRequest} message LoginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.loginType = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.authenticationHashPrime = "";
                else {
                    object.authenticationHashPrime = [];
                    if (options.bytes !== Array)
                        object.authenticationHashPrime = $util.newBuffer(object.authenticationHashPrime);
                }
                if (options.bytes === String)
                    object.randomHashKey = "";
                else {
                    object.randomHashKey = [];
                    if (options.bytes !== Array)
                        object.randomHashKey = $util.newBuffer(object.randomHashKey);
                }
                if (options.bytes === String)
                    object.encryptedTwoFactorToken = "";
                else {
                    object.encryptedTwoFactorToken = [];
                    if (options.bytes !== Array)
                        object.encryptedTwoFactorToken = $util.newBuffer(object.encryptedTwoFactorToken);
                }
                if (options.bytes === String)
                    object.encryptedBreachWatchToken = "";
                else {
                    object.encryptedBreachWatchToken = [];
                    if (options.bytes !== Array)
                        object.encryptedBreachWatchToken = $util.newBuffer(object.encryptedBreachWatchToken);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                object.authenticationHashPrime = options.bytes === String ? $util.base64.encode(message.authenticationHashPrime, 0, message.authenticationHashPrime.length) : options.bytes === Array ? Array.prototype.slice.call(message.authenticationHashPrime) : message.authenticationHashPrime;
            if (message.randomHashKey != null && message.hasOwnProperty("randomHashKey"))
                object.randomHashKey = options.bytes === String ? $util.base64.encode(message.randomHashKey, 0, message.randomHashKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.randomHashKey) : message.randomHashKey;
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                object.encryptedTwoFactorToken = options.bytes === String ? $util.base64.encode(message.encryptedTwoFactorToken, 0, message.encryptedTwoFactorToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTwoFactorToken) : message.encryptedTwoFactorToken;
            if (message.encryptedBreachWatchToken != null && message.hasOwnProperty("encryptedBreachWatchToken"))
                object.encryptedBreachWatchToken = options.bytes === String ? $util.base64.encode(message.encryptedBreachWatchToken, 0, message.encryptedBreachWatchToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedBreachWatchToken) : message.encryptedBreachWatchToken;
            return object;
        };

        /**
         * Converts this LoginRequest to JSON.
         * @function toJSON
         * @memberof Authentication.LoginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginRequest;
    })();

    Authentication.RegistrationRequest = (function() {

        /**
         * Properties of a RegistrationRequest.
         * @memberof Authentication
         * @interface IRegistrationRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] RegistrationRequest authRequest
         * @property {Authentication.IUserAuthRequest|null} [userAuthRequest] RegistrationRequest userAuthRequest
         * @property {Uint8Array|null} [encryptedClientKey] RegistrationRequest encryptedClientKey
         * @property {Uint8Array|null} [encryptedPrivateKey] RegistrationRequest encryptedPrivateKey
         * @property {Uint8Array|null} [publicKey] RegistrationRequest publicKey
         * @property {string|null} [verificationCode] RegistrationRequest verificationCode
         * @property {Uint8Array|null} [deprecatedAuthHashHash] RegistrationRequest deprecatedAuthHashHash
         * @property {Uint8Array|null} [deprecatedEncryptedClientKey] RegistrationRequest deprecatedEncryptedClientKey
         * @property {Uint8Array|null} [deprecatedEncryptedPrivateKey] RegistrationRequest deprecatedEncryptedPrivateKey
         * @property {Uint8Array|null} [deprecatedEncryptionParams] RegistrationRequest deprecatedEncryptionParams
         */

        /**
         * Constructs a new RegistrationRequest.
         * @memberof Authentication
         * @classdesc Represents a RegistrationRequest.
         * @implements IRegistrationRequest
         * @constructor
         * @param {Authentication.IRegistrationRequest=} [properties] Properties to set
         */
        function RegistrationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegistrationRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.authRequest = null;

        /**
         * RegistrationRequest userAuthRequest.
         * @member {Authentication.IUserAuthRequest|null|undefined} userAuthRequest
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.userAuthRequest = null;

        /**
         * RegistrationRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * RegistrationRequest encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * RegistrationRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * RegistrationRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.verificationCode = "";

        /**
         * RegistrationRequest deprecatedAuthHashHash.
         * @member {Uint8Array} deprecatedAuthHashHash
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedAuthHashHash = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptedClientKey.
         * @member {Uint8Array} deprecatedEncryptedClientKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptedClientKey = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptedPrivateKey.
         * @member {Uint8Array} deprecatedEncryptedPrivateKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptedPrivateKey = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptionParams.
         * @member {Uint8Array} deprecatedEncryptionParams
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptionParams = $util.newBuffer([]);

        /**
         * Creates a new RegistrationRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest=} [properties] Properties to set
         * @returns {Authentication.RegistrationRequest} RegistrationRequest instance
         */
        RegistrationRequest.create = function create(properties) {
            return new RegistrationRequest(properties);
        };

        /**
         * Encodes the specified RegistrationRequest message. Does not implicitly {@link Authentication.RegistrationRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest} message RegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegistrationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                $root.Authentication.UserAuthRequest.encode(message.userAuthRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedClientKey);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPrivateKey);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.verificationCode);
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.deprecatedAuthHashHash);
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.deprecatedEncryptedClientKey);
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.deprecatedEncryptedPrivateKey);
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.deprecatedEncryptionParams);
            return writer;
        };

        /**
         * Encodes the specified RegistrationRequest message, length delimited. Does not implicitly {@link Authentication.RegistrationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest} message RegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegistrationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegistrationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegistrationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegistrationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.userAuthRequest = $root.Authentication.UserAuthRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 4:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                case 6:
                    message.verificationCode = reader.string();
                    break;
                case 7:
                    message.deprecatedAuthHashHash = reader.bytes();
                    break;
                case 8:
                    message.deprecatedEncryptedClientKey = reader.bytes();
                    break;
                case 9:
                    message.deprecatedEncryptedPrivateKey = reader.bytes();
                    break;
                case 10:
                    message.deprecatedEncryptionParams = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegistrationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegistrationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegistrationRequest message.
         * @function verify
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegistrationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest")) {
                let error = $root.Authentication.UserAuthRequest.verify(message.userAuthRequest);
                if (error)
                    return "userAuthRequest." + error;
            }
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                if (!(message.deprecatedAuthHashHash && typeof message.deprecatedAuthHashHash.length === "number" || $util.isString(message.deprecatedAuthHashHash)))
                    return "deprecatedAuthHashHash: buffer expected";
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                if (!(message.deprecatedEncryptedClientKey && typeof message.deprecatedEncryptedClientKey.length === "number" || $util.isString(message.deprecatedEncryptedClientKey)))
                    return "deprecatedEncryptedClientKey: buffer expected";
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                if (!(message.deprecatedEncryptedPrivateKey && typeof message.deprecatedEncryptedPrivateKey.length === "number" || $util.isString(message.deprecatedEncryptedPrivateKey)))
                    return "deprecatedEncryptedPrivateKey: buffer expected";
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                if (!(message.deprecatedEncryptionParams && typeof message.deprecatedEncryptionParams.length === "number" || $util.isString(message.deprecatedEncryptionParams)))
                    return "deprecatedEncryptionParams: buffer expected";
            return null;
        };

        /**
         * Creates a RegistrationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         */
        RegistrationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegistrationRequest)
                return object;
            let message = new $root.Authentication.RegistrationRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.RegistrationRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            if (object.userAuthRequest != null) {
                if (typeof object.userAuthRequest !== "object")
                    throw TypeError(".Authentication.RegistrationRequest.userAuthRequest: object expected");
                message.userAuthRequest = $root.Authentication.UserAuthRequest.fromObject(object.userAuthRequest);
            }
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.deprecatedAuthHashHash != null)
                if (typeof object.deprecatedAuthHashHash === "string")
                    $util.base64.decode(object.deprecatedAuthHashHash, message.deprecatedAuthHashHash = $util.newBuffer($util.base64.length(object.deprecatedAuthHashHash)), 0);
                else if (object.deprecatedAuthHashHash.length)
                    message.deprecatedAuthHashHash = object.deprecatedAuthHashHash;
            if (object.deprecatedEncryptedClientKey != null)
                if (typeof object.deprecatedEncryptedClientKey === "string")
                    $util.base64.decode(object.deprecatedEncryptedClientKey, message.deprecatedEncryptedClientKey = $util.newBuffer($util.base64.length(object.deprecatedEncryptedClientKey)), 0);
                else if (object.deprecatedEncryptedClientKey.length)
                    message.deprecatedEncryptedClientKey = object.deprecatedEncryptedClientKey;
            if (object.deprecatedEncryptedPrivateKey != null)
                if (typeof object.deprecatedEncryptedPrivateKey === "string")
                    $util.base64.decode(object.deprecatedEncryptedPrivateKey, message.deprecatedEncryptedPrivateKey = $util.newBuffer($util.base64.length(object.deprecatedEncryptedPrivateKey)), 0);
                else if (object.deprecatedEncryptedPrivateKey.length)
                    message.deprecatedEncryptedPrivateKey = object.deprecatedEncryptedPrivateKey;
            if (object.deprecatedEncryptionParams != null)
                if (typeof object.deprecatedEncryptionParams === "string")
                    $util.base64.decode(object.deprecatedEncryptionParams, message.deprecatedEncryptionParams = $util.newBuffer($util.base64.length(object.deprecatedEncryptionParams)), 0);
                else if (object.deprecatedEncryptionParams.length)
                    message.deprecatedEncryptionParams = object.deprecatedEncryptionParams;
            return message;
        };

        /**
         * Creates a plain object from a RegistrationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.RegistrationRequest} message RegistrationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegistrationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.userAuthRequest = null;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.verificationCode = "";
                if (options.bytes === String)
                    object.deprecatedAuthHashHash = "";
                else {
                    object.deprecatedAuthHashHash = [];
                    if (options.bytes !== Array)
                        object.deprecatedAuthHashHash = $util.newBuffer(object.deprecatedAuthHashHash);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptedClientKey = "";
                else {
                    object.deprecatedEncryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptedClientKey = $util.newBuffer(object.deprecatedEncryptedClientKey);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptedPrivateKey = "";
                else {
                    object.deprecatedEncryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptedPrivateKey = $util.newBuffer(object.deprecatedEncryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptionParams = "";
                else {
                    object.deprecatedEncryptionParams = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptionParams = $util.newBuffer(object.deprecatedEncryptionParams);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                object.userAuthRequest = $root.Authentication.UserAuthRequest.toObject(message.userAuthRequest, options);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                object.deprecatedAuthHashHash = options.bytes === String ? $util.base64.encode(message.deprecatedAuthHashHash, 0, message.deprecatedAuthHashHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedAuthHashHash) : message.deprecatedAuthHashHash;
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                object.deprecatedEncryptedClientKey = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptedClientKey, 0, message.deprecatedEncryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptedClientKey) : message.deprecatedEncryptedClientKey;
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                object.deprecatedEncryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptedPrivateKey, 0, message.deprecatedEncryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptedPrivateKey) : message.deprecatedEncryptedPrivateKey;
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                object.deprecatedEncryptionParams = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptionParams, 0, message.deprecatedEncryptionParams.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptionParams) : message.deprecatedEncryptionParams;
            return object;
        };

        /**
         * Converts this RegistrationRequest to JSON.
         * @function toJSON
         * @memberof Authentication.RegistrationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegistrationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegistrationRequest;
    })();

    Authentication.DeviceResponse = (function() {

        /**
         * Properties of a DeviceResponse.
         * @memberof Authentication
         * @interface IDeviceResponse
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceResponse encryptedDeviceToken
         * @property {Authentication.DeviceStatus|null} [status] DeviceResponse status
         */

        /**
         * Constructs a new DeviceResponse.
         * @memberof Authentication
         * @classdesc Represents a DeviceResponse.
         * @implements IDeviceResponse
         * @constructor
         * @param {Authentication.IDeviceResponse=} [properties] Properties to set
         */
        function DeviceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceResponse encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceResponse
         * @instance
         */
        DeviceResponse.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceResponse status.
         * @member {Authentication.DeviceStatus} status
         * @memberof Authentication.DeviceResponse
         * @instance
         */
        DeviceResponse.prototype.status = 0;

        /**
         * Creates a new DeviceResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse=} [properties] Properties to set
         * @returns {Authentication.DeviceResponse} DeviceResponse instance
         */
        DeviceResponse.create = function create(properties) {
            return new DeviceResponse(properties);
        };

        /**
         * Encodes the specified DeviceResponse message. Does not implicitly {@link Authentication.DeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse} message DeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified DeviceResponse message, length delimited. Does not implicitly {@link Authentication.DeviceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse} message DeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceResponse} DeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceResponse} DeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceResponse message.
         * @function verify
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceResponse} DeviceResponse
         */
        DeviceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceResponse)
                return object;
            let message = new $root.Authentication.DeviceResponse();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            switch (object.status) {
            case "NEED_APPROVAL":
            case 0:
                message.status = 0;
                break;
            case "OK":
            case 1:
                message.status = 1;
                break;
            case "DEVICE_DISABLED":
            case 2:
                message.status = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.DeviceResponse} message DeviceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.status = options.enums === String ? "NEED_APPROVAL" : 0;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Authentication.DeviceStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this DeviceResponse to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceResponse;
    })();

    Authentication.Salt = (function() {

        /**
         * Properties of a Salt.
         * @memberof Authentication
         * @interface ISalt
         * @property {number|null} [iterations] Salt iterations
         * @property {Uint8Array|null} [salt] Salt salt
         * @property {number|null} [algorithm] Salt algorithm
         * @property {Uint8Array|null} [uid] Salt uid
         * @property {string|null} [name] Salt name
         */

        /**
         * Constructs a new Salt.
         * @memberof Authentication
         * @classdesc Represents a Salt.
         * @implements ISalt
         * @constructor
         * @param {Authentication.ISalt=} [properties] Properties to set
         */
        function Salt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Salt iterations.
         * @member {number} iterations
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.iterations = 0;

        /**
         * Salt salt.
         * @member {Uint8Array} salt
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.salt = $util.newBuffer([]);

        /**
         * Salt algorithm.
         * @member {number} algorithm
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.algorithm = 0;

        /**
         * Salt uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.uid = $util.newBuffer([]);

        /**
         * Salt name.
         * @member {string} name
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.name = "";

        /**
         * Creates a new Salt instance using the specified properties.
         * @function create
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt=} [properties] Properties to set
         * @returns {Authentication.Salt} Salt instance
         */
        Salt.create = function create(properties) {
            return new Salt(properties);
        };

        /**
         * Encodes the specified Salt message. Does not implicitly {@link Authentication.Salt.verify|verify} messages.
         * @function encode
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.iterations);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.algorithm);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.uid);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Salt message, length delimited. Does not implicitly {@link Authentication.Salt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Salt message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.Salt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iterations = reader.int32();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.algorithm = reader.int32();
                    break;
                case 4:
                    message.uid = reader.bytes();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Salt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Salt message.
         * @function verify
         * @memberof Authentication.Salt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Salt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Salt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.Salt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.Salt} Salt
         */
        Salt.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.Salt)
                return object;
            let message = new $root.Authentication.Salt();
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Salt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.Salt} message Salt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Salt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.iterations = 0;
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.algorithm = 0;
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.name = "";
            }
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Salt to JSON.
         * @function toJSON
         * @memberof Authentication.Salt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Salt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Salt;
    })();

    Authentication.TwoFactorChannel = (function() {

        /**
         * Properties of a TwoFactorChannel.
         * @memberof Authentication
         * @interface ITwoFactorChannel
         * @property {number|null} [type] TwoFactorChannel type
         */

        /**
         * Constructs a new TwoFactorChannel.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorChannel.
         * @implements ITwoFactorChannel
         * @constructor
         * @param {Authentication.ITwoFactorChannel=} [properties] Properties to set
         */
        function TwoFactorChannel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorChannel type.
         * @member {number} type
         * @memberof Authentication.TwoFactorChannel
         * @instance
         */
        TwoFactorChannel.prototype.type = 0;

        /**
         * Creates a new TwoFactorChannel instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel=} [properties] Properties to set
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel instance
         */
        TwoFactorChannel.create = function create(properties) {
            return new TwoFactorChannel(properties);
        };

        /**
         * Encodes the specified TwoFactorChannel message. Does not implicitly {@link Authentication.TwoFactorChannel.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel} message TwoFactorChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorChannel message, length delimited. Does not implicitly {@link Authentication.TwoFactorChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel} message TwoFactorChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorChannel message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorChannel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorChannel message.
         * @function verify
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        /**
         * Creates a TwoFactorChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         */
        TwoFactorChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorChannel)
                return object;
            let message = new $root.Authentication.TwoFactorChannel();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.TwoFactorChannel} message TwoFactorChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this TwoFactorChannel to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorChannel;
    })();

    Authentication.SsoUserInfo = (function() {

        /**
         * Properties of a SsoUserInfo.
         * @memberof Authentication
         * @interface ISsoUserInfo
         * @property {string|null} [companyName] SsoUserInfo companyName
         * @property {string|null} [samlRequest] SsoUserInfo samlRequest
         * @property {string|null} [samlRequestType] SsoUserInfo samlRequestType
         * @property {string|null} [ssoDomainName] SsoUserInfo ssoDomainName
         * @property {string|null} [url] SsoUserInfo url
         */

        /**
         * Constructs a new SsoUserInfo.
         * @memberof Authentication
         * @classdesc Represents a SsoUserInfo.
         * @implements ISsoUserInfo
         * @constructor
         * @param {Authentication.ISsoUserInfo=} [properties] Properties to set
         */
        function SsoUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoUserInfo companyName.
         * @member {string} companyName
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.companyName = "";

        /**
         * SsoUserInfo samlRequest.
         * @member {string} samlRequest
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.samlRequest = "";

        /**
         * SsoUserInfo samlRequestType.
         * @member {string} samlRequestType
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.samlRequestType = "";

        /**
         * SsoUserInfo ssoDomainName.
         * @member {string} ssoDomainName
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.ssoDomainName = "";

        /**
         * SsoUserInfo url.
         * @member {string} url
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.url = "";

        /**
         * Creates a new SsoUserInfo instance using the specified properties.
         * @function create
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo=} [properties] Properties to set
         * @returns {Authentication.SsoUserInfo} SsoUserInfo instance
         */
        SsoUserInfo.create = function create(properties) {
            return new SsoUserInfo(properties);
        };

        /**
         * Encodes the specified SsoUserInfo message. Does not implicitly {@link Authentication.SsoUserInfo.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo} message SsoUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.companyName);
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.samlRequest);
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.samlRequestType);
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ssoDomainName);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified SsoUserInfo message, length delimited. Does not implicitly {@link Authentication.SsoUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo} message SsoUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SsoUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.companyName = reader.string();
                    break;
                case 2:
                    message.samlRequest = reader.string();
                    break;
                case 3:
                    message.samlRequestType = reader.string();
                    break;
                case 4:
                    message.ssoDomainName = reader.string();
                    break;
                case 5:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoUserInfo message.
         * @function verify
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                if (!$util.isString(message.companyName))
                    return "companyName: string expected";
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                if (!$util.isString(message.samlRequest))
                    return "samlRequest: string expected";
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                if (!$util.isString(message.samlRequestType))
                    return "samlRequestType: string expected";
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                if (!$util.isString(message.ssoDomainName))
                    return "ssoDomainName: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a SsoUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         */
        SsoUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SsoUserInfo)
                return object;
            let message = new $root.Authentication.SsoUserInfo();
            if (object.companyName != null)
                message.companyName = String(object.companyName);
            if (object.samlRequest != null)
                message.samlRequest = String(object.samlRequest);
            if (object.samlRequestType != null)
                message.samlRequestType = String(object.samlRequestType);
            if (object.ssoDomainName != null)
                message.ssoDomainName = String(object.ssoDomainName);
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a SsoUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.SsoUserInfo} message SsoUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoUserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.companyName = "";
                object.samlRequest = "";
                object.samlRequestType = "";
                object.ssoDomainName = "";
                object.url = "";
            }
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                object.companyName = message.companyName;
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                object.samlRequest = message.samlRequest;
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                object.samlRequestType = message.samlRequestType;
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                object.ssoDomainName = message.ssoDomainName;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this SsoUserInfo to JSON.
         * @function toJSON
         * @memberof Authentication.SsoUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoUserInfo;
    })();

    Authentication.PreLoginResponse = (function() {

        /**
         * Properties of a PreLoginResponse.
         * @memberof Authentication
         * @interface IPreLoginResponse
         * @property {Authentication.DeviceStatus|null} [deviceStatus] PreLoginResponse deviceStatus
         * @property {Array.<Authentication.ISalt>|null} [salt] PreLoginResponse salt
         * @property {Array.<Authentication.ITwoFactorChannel>|null} [OBSOLETE_FIELD] PreLoginResponse OBSOLETE_FIELD
         * @property {Authentication.ISsoUserInfo|null} [ssoUserInfo] PreLoginResponse ssoUserInfo
         */

        /**
         * Constructs a new PreLoginResponse.
         * @memberof Authentication
         * @classdesc Represents a PreLoginResponse.
         * @implements IPreLoginResponse
         * @constructor
         * @param {Authentication.IPreLoginResponse=} [properties] Properties to set
         */
        function PreLoginResponse(properties) {
            this.salt = [];
            this.OBSOLETE_FIELD = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreLoginResponse deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.deviceStatus = 0;

        /**
         * PreLoginResponse salt.
         * @member {Array.<Authentication.ISalt>} salt
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.salt = $util.emptyArray;

        /**
         * PreLoginResponse OBSOLETE_FIELD.
         * @member {Array.<Authentication.ITwoFactorChannel>} OBSOLETE_FIELD
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.OBSOLETE_FIELD = $util.emptyArray;

        /**
         * PreLoginResponse ssoUserInfo.
         * @member {Authentication.ISsoUserInfo|null|undefined} ssoUserInfo
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.ssoUserInfo = null;

        /**
         * Creates a new PreLoginResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse=} [properties] Properties to set
         * @returns {Authentication.PreLoginResponse} PreLoginResponse instance
         */
        PreLoginResponse.create = function create(properties) {
            return new PreLoginResponse(properties);
        };

        /**
         * Encodes the specified PreLoginResponse message. Does not implicitly {@link Authentication.PreLoginResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse} message PreLoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.deviceStatus);
            if (message.salt != null && message.salt.length)
                for (let i = 0; i < message.salt.length; ++i)
                    $root.Authentication.Salt.encode(message.salt[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.OBSOLETE_FIELD != null && message.OBSOLETE_FIELD.length)
                for (let i = 0; i < message.OBSOLETE_FIELD.length; ++i)
                    $root.Authentication.TwoFactorChannel.encode(message.OBSOLETE_FIELD[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo"))
                $root.Authentication.SsoUserInfo.encode(message.ssoUserInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PreLoginResponse message, length delimited. Does not implicitly {@link Authentication.PreLoginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse} message PreLoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreLoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.PreLoginResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceStatus = reader.int32();
                    break;
                case 2:
                    if (!(message.salt && message.salt.length))
                        message.salt = [];
                    message.salt.push($root.Authentication.Salt.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.OBSOLETE_FIELD && message.OBSOLETE_FIELD.length))
                        message.OBSOLETE_FIELD = [];
                    message.OBSOLETE_FIELD.push($root.Authentication.TwoFactorChannel.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.ssoUserInfo = $root.Authentication.SsoUserInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreLoginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreLoginResponse message.
         * @function verify
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreLoginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.salt != null && message.hasOwnProperty("salt")) {
                if (!Array.isArray(message.salt))
                    return "salt: array expected";
                for (let i = 0; i < message.salt.length; ++i) {
                    let error = $root.Authentication.Salt.verify(message.salt[i]);
                    if (error)
                        return "salt." + error;
                }
            }
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD")) {
                if (!Array.isArray(message.OBSOLETE_FIELD))
                    return "OBSOLETE_FIELD: array expected";
                for (let i = 0; i < message.OBSOLETE_FIELD.length; ++i) {
                    let error = $root.Authentication.TwoFactorChannel.verify(message.OBSOLETE_FIELD[i]);
                    if (error)
                        return "OBSOLETE_FIELD." + error;
                }
            }
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo")) {
                let error = $root.Authentication.SsoUserInfo.verify(message.ssoUserInfo);
                if (error)
                    return "ssoUserInfo." + error;
            }
            return null;
        };

        /**
         * Creates a PreLoginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         */
        PreLoginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.PreLoginResponse)
                return object;
            let message = new $root.Authentication.PreLoginResponse();
            switch (object.deviceStatus) {
            case "NEED_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED":
            case 2:
                message.deviceStatus = 2;
                break;
            }
            if (object.salt) {
                if (!Array.isArray(object.salt))
                    throw TypeError(".Authentication.PreLoginResponse.salt: array expected");
                message.salt = [];
                for (let i = 0; i < object.salt.length; ++i) {
                    if (typeof object.salt[i] !== "object")
                        throw TypeError(".Authentication.PreLoginResponse.salt: object expected");
                    message.salt[i] = $root.Authentication.Salt.fromObject(object.salt[i]);
                }
            }
            if (object.OBSOLETE_FIELD) {
                if (!Array.isArray(object.OBSOLETE_FIELD))
                    throw TypeError(".Authentication.PreLoginResponse.OBSOLETE_FIELD: array expected");
                message.OBSOLETE_FIELD = [];
                for (let i = 0; i < object.OBSOLETE_FIELD.length; ++i) {
                    if (typeof object.OBSOLETE_FIELD[i] !== "object")
                        throw TypeError(".Authentication.PreLoginResponse.OBSOLETE_FIELD: object expected");
                    message.OBSOLETE_FIELD[i] = $root.Authentication.TwoFactorChannel.fromObject(object.OBSOLETE_FIELD[i]);
                }
            }
            if (object.ssoUserInfo != null) {
                if (typeof object.ssoUserInfo !== "object")
                    throw TypeError(".Authentication.PreLoginResponse.ssoUserInfo: object expected");
                message.ssoUserInfo = $root.Authentication.SsoUserInfo.fromObject(object.ssoUserInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a PreLoginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.PreLoginResponse} message PreLoginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreLoginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.salt = [];
                object.OBSOLETE_FIELD = [];
            }
            if (options.defaults) {
                object.deviceStatus = options.enums === String ? "NEED_APPROVAL" : 0;
                object.ssoUserInfo = null;
            }
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            if (message.salt && message.salt.length) {
                object.salt = [];
                for (let j = 0; j < message.salt.length; ++j)
                    object.salt[j] = $root.Authentication.Salt.toObject(message.salt[j], options);
            }
            if (message.OBSOLETE_FIELD && message.OBSOLETE_FIELD.length) {
                object.OBSOLETE_FIELD = [];
                for (let j = 0; j < message.OBSOLETE_FIELD.length; ++j)
                    object.OBSOLETE_FIELD[j] = $root.Authentication.TwoFactorChannel.toObject(message.OBSOLETE_FIELD[j], options);
            }
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo"))
                object.ssoUserInfo = $root.Authentication.SsoUserInfo.toObject(message.ssoUserInfo, options);
            return object;
        };

        /**
         * Converts this PreLoginResponse to JSON.
         * @function toJSON
         * @memberof Authentication.PreLoginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreLoginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreLoginResponse;
    })();

    Authentication.LoginResponse = (function() {

        /**
         * Properties of a LoginResponse.
         * @memberof Authentication
         * @interface ILoginResponse
         * @property {Uint8Array|null} [encryrptedSessionToken] LoginResponse encryrptedSessionToken
         * @property {Authentication.ILicense|null} [vault] LoginResponse vault
         * @property {Authentication.ILicense|null} [chat] LoginResponse chat
         * @property {Authentication.ILicense|null} [storage] LoginResponse storage
         * @property {Authentication.ILicense|null} [breachWatch] LoginResponse breachWatch
         * @property {Authentication.AccountType|null} [accountType] LoginResponse accountType
         * @property {Uint8Array|null} [encryptedDAT] LoginResponse encryptedDAT
         * @property {Uint8Array|null} [encryptedPAT] LoginResponse encryptedPAT
         * @property {Uint8Array|null} [encryptedEAT] LoginResponse encryptedEAT
         * @property {Uint8Array|null} [encryptedDataKey] LoginResponse encryptedDataKey
         * @property {Array.<Authentication.SessionTokenType>|null} [sessionTokenType] LoginResponse sessionTokenType
         */

        /**
         * Constructs a new LoginResponse.
         * @memberof Authentication
         * @classdesc Represents a LoginResponse.
         * @implements ILoginResponse
         * @constructor
         * @param {Authentication.ILoginResponse=} [properties] Properties to set
         */
        function LoginResponse(properties) {
            this.sessionTokenType = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResponse encryrptedSessionToken.
         * @member {Uint8Array} encryrptedSessionToken
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryrptedSessionToken = $util.newBuffer([]);

        /**
         * LoginResponse vault.
         * @member {Authentication.ILicense|null|undefined} vault
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.vault = null;

        /**
         * LoginResponse chat.
         * @member {Authentication.ILicense|null|undefined} chat
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.chat = null;

        /**
         * LoginResponse storage.
         * @member {Authentication.ILicense|null|undefined} storage
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.storage = null;

        /**
         * LoginResponse breachWatch.
         * @member {Authentication.ILicense|null|undefined} breachWatch
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.breachWatch = null;

        /**
         * LoginResponse accountType.
         * @member {Authentication.AccountType} accountType
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.accountType = 0;

        /**
         * LoginResponse encryptedDAT.
         * @member {Uint8Array} encryptedDAT
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedDAT = $util.newBuffer([]);

        /**
         * LoginResponse encryptedPAT.
         * @member {Uint8Array} encryptedPAT
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedPAT = $util.newBuffer([]);

        /**
         * LoginResponse encryptedEAT.
         * @member {Uint8Array} encryptedEAT
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedEAT = $util.newBuffer([]);

        /**
         * LoginResponse encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * LoginResponse sessionTokenType.
         * @member {Array.<Authentication.SessionTokenType>} sessionTokenType
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.sessionTokenType = $util.emptyArray;

        /**
         * Creates a new LoginResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse=} [properties] Properties to set
         * @returns {Authentication.LoginResponse} LoginResponse instance
         */
        LoginResponse.create = function create(properties) {
            return new LoginResponse(properties);
        };

        /**
         * Encodes the specified LoginResponse message. Does not implicitly {@link Authentication.LoginResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryrptedSessionToken != null && message.hasOwnProperty("encryrptedSessionToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryrptedSessionToken);
            if (message.vault != null && message.hasOwnProperty("vault"))
                $root.Authentication.License.encode(message.vault, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.chat != null && message.hasOwnProperty("chat"))
                $root.Authentication.License.encode(message.chat, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.storage != null && message.hasOwnProperty("storage"))
                $root.Authentication.License.encode(message.storage, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch"))
                $root.Authentication.License.encode(message.breachWatch, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.accountType);
            if (message.encryptedDAT != null && message.hasOwnProperty("encryptedDAT"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.encryptedDAT);
            if (message.encryptedPAT != null && message.hasOwnProperty("encryptedPAT"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encryptedPAT);
            if (message.encryptedEAT != null && message.hasOwnProperty("encryptedEAT"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.encryptedEAT);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.encryptedDataKey);
            if (message.sessionTokenType != null && message.sessionTokenType.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (let i = 0; i < message.sessionTokenType.length; ++i)
                    writer.int32(message.sessionTokenType[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LoginResponse message, length delimited. Does not implicitly {@link Authentication.LoginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryrptedSessionToken = reader.bytes();
                    break;
                case 2:
                    message.vault = $root.Authentication.License.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chat = $root.Authentication.License.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.storage = $root.Authentication.License.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.breachWatch = $root.Authentication.License.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.accountType = reader.int32();
                    break;
                case 7:
                    message.encryptedDAT = reader.bytes();
                    break;
                case 8:
                    message.encryptedPAT = reader.bytes();
                    break;
                case 9:
                    message.encryptedEAT = reader.bytes();
                    break;
                case 10:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 11:
                    if (!(message.sessionTokenType && message.sessionTokenType.length))
                        message.sessionTokenType = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.sessionTokenType.push(reader.int32());
                    } else
                        message.sessionTokenType.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginResponse message.
         * @function verify
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryrptedSessionToken != null && message.hasOwnProperty("encryrptedSessionToken"))
                if (!(message.encryrptedSessionToken && typeof message.encryrptedSessionToken.length === "number" || $util.isString(message.encryrptedSessionToken)))
                    return "encryrptedSessionToken: buffer expected";
            if (message.vault != null && message.hasOwnProperty("vault")) {
                let error = $root.Authentication.License.verify(message.vault);
                if (error)
                    return "vault." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                let error = $root.Authentication.License.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            if (message.storage != null && message.hasOwnProperty("storage")) {
                let error = $root.Authentication.License.verify(message.storage);
                if (error)
                    return "storage." + error;
            }
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch")) {
                let error = $root.Authentication.License.verify(message.breachWatch);
                if (error)
                    return "breachWatch." + error;
            }
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                switch (message.accountType) {
                default:
                    return "accountType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.encryptedDAT != null && message.hasOwnProperty("encryptedDAT"))
                if (!(message.encryptedDAT && typeof message.encryptedDAT.length === "number" || $util.isString(message.encryptedDAT)))
                    return "encryptedDAT: buffer expected";
            if (message.encryptedPAT != null && message.hasOwnProperty("encryptedPAT"))
                if (!(message.encryptedPAT && typeof message.encryptedPAT.length === "number" || $util.isString(message.encryptedPAT)))
                    return "encryptedPAT: buffer expected";
            if (message.encryptedEAT != null && message.hasOwnProperty("encryptedEAT"))
                if (!(message.encryptedEAT && typeof message.encryptedEAT.length === "number" || $util.isString(message.encryptedEAT)))
                    return "encryptedEAT: buffer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType")) {
                if (!Array.isArray(message.sessionTokenType))
                    return "sessionTokenType: array expected";
                for (let i = 0; i < message.sessionTokenType.length; ++i)
                    switch (message.sessionTokenType[i]) {
                    default:
                        return "sessionTokenType: enum value[] expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginResponse} LoginResponse
         */
        LoginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginResponse)
                return object;
            let message = new $root.Authentication.LoginResponse();
            if (object.encryrptedSessionToken != null)
                if (typeof object.encryrptedSessionToken === "string")
                    $util.base64.decode(object.encryrptedSessionToken, message.encryrptedSessionToken = $util.newBuffer($util.base64.length(object.encryrptedSessionToken)), 0);
                else if (object.encryrptedSessionToken.length)
                    message.encryrptedSessionToken = object.encryrptedSessionToken;
            if (object.vault != null) {
                if (typeof object.vault !== "object")
                    throw TypeError(".Authentication.LoginResponse.vault: object expected");
                message.vault = $root.Authentication.License.fromObject(object.vault);
            }
            if (object.chat != null) {
                if (typeof object.chat !== "object")
                    throw TypeError(".Authentication.LoginResponse.chat: object expected");
                message.chat = $root.Authentication.License.fromObject(object.chat);
            }
            if (object.storage != null) {
                if (typeof object.storage !== "object")
                    throw TypeError(".Authentication.LoginResponse.storage: object expected");
                message.storage = $root.Authentication.License.fromObject(object.storage);
            }
            if (object.breachWatch != null) {
                if (typeof object.breachWatch !== "object")
                    throw TypeError(".Authentication.LoginResponse.breachWatch: object expected");
                message.breachWatch = $root.Authentication.License.fromObject(object.breachWatch);
            }
            switch (object.accountType) {
            case "CONSUMER":
            case 0:
                message.accountType = 0;
                break;
            case "FAMILY":
            case 1:
                message.accountType = 1;
                break;
            case "ENTERPRISE":
            case 2:
                message.accountType = 2;
                break;
            }
            if (object.encryptedDAT != null)
                if (typeof object.encryptedDAT === "string")
                    $util.base64.decode(object.encryptedDAT, message.encryptedDAT = $util.newBuffer($util.base64.length(object.encryptedDAT)), 0);
                else if (object.encryptedDAT.length)
                    message.encryptedDAT = object.encryptedDAT;
            if (object.encryptedPAT != null)
                if (typeof object.encryptedPAT === "string")
                    $util.base64.decode(object.encryptedPAT, message.encryptedPAT = $util.newBuffer($util.base64.length(object.encryptedPAT)), 0);
                else if (object.encryptedPAT.length)
                    message.encryptedPAT = object.encryptedPAT;
            if (object.encryptedEAT != null)
                if (typeof object.encryptedEAT === "string")
                    $util.base64.decode(object.encryptedEAT, message.encryptedEAT = $util.newBuffer($util.base64.length(object.encryptedEAT)), 0);
                else if (object.encryptedEAT.length)
                    message.encryptedEAT = object.encryptedEAT;
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            if (object.sessionTokenType) {
                if (!Array.isArray(object.sessionTokenType))
                    throw TypeError(".Authentication.LoginResponse.sessionTokenType: array expected");
                message.sessionTokenType = [];
                for (let i = 0; i < object.sessionTokenType.length; ++i)
                    switch (object.sessionTokenType[i]) {
                    default:
                    case "NO_RESTRICTION":
                    case 0:
                        message.sessionTokenType[i] = 0;
                        break;
                    case "ACCOUNT_RECOVERY":
                    case 1:
                        message.sessionTokenType[i] = 1;
                        break;
                    case "SHARE_ACCOUNT":
                    case 2:
                        message.sessionTokenType[i] = 2;
                        break;
                    case "PURCHASE":
                    case 3:
                        message.sessionTokenType[i] = 3;
                        break;
                    case "RESTRICT":
                    case 4:
                        message.sessionTokenType[i] = 4;
                        break;
                    case "ACCEPT_INVITE":
                    case 5:
                        message.sessionTokenType[i] = 5;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.LoginResponse} message LoginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sessionTokenType = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryrptedSessionToken = "";
                else {
                    object.encryrptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryrptedSessionToken = $util.newBuffer(object.encryrptedSessionToken);
                }
                object.vault = null;
                object.chat = null;
                object.storage = null;
                object.breachWatch = null;
                object.accountType = options.enums === String ? "CONSUMER" : 0;
                if (options.bytes === String)
                    object.encryptedDAT = "";
                else {
                    object.encryptedDAT = [];
                    if (options.bytes !== Array)
                        object.encryptedDAT = $util.newBuffer(object.encryptedDAT);
                }
                if (options.bytes === String)
                    object.encryptedPAT = "";
                else {
                    object.encryptedPAT = [];
                    if (options.bytes !== Array)
                        object.encryptedPAT = $util.newBuffer(object.encryptedPAT);
                }
                if (options.bytes === String)
                    object.encryptedEAT = "";
                else {
                    object.encryptedEAT = [];
                    if (options.bytes !== Array)
                        object.encryptedEAT = $util.newBuffer(object.encryptedEAT);
                }
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
            }
            if (message.encryrptedSessionToken != null && message.hasOwnProperty("encryrptedSessionToken"))
                object.encryrptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryrptedSessionToken, 0, message.encryrptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryrptedSessionToken) : message.encryrptedSessionToken;
            if (message.vault != null && message.hasOwnProperty("vault"))
                object.vault = $root.Authentication.License.toObject(message.vault, options);
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = $root.Authentication.License.toObject(message.chat, options);
            if (message.storage != null && message.hasOwnProperty("storage"))
                object.storage = $root.Authentication.License.toObject(message.storage, options);
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch"))
                object.breachWatch = $root.Authentication.License.toObject(message.breachWatch, options);
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                object.accountType = options.enums === String ? $root.Authentication.AccountType[message.accountType] : message.accountType;
            if (message.encryptedDAT != null && message.hasOwnProperty("encryptedDAT"))
                object.encryptedDAT = options.bytes === String ? $util.base64.encode(message.encryptedDAT, 0, message.encryptedDAT.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDAT) : message.encryptedDAT;
            if (message.encryptedPAT != null && message.hasOwnProperty("encryptedPAT"))
                object.encryptedPAT = options.bytes === String ? $util.base64.encode(message.encryptedPAT, 0, message.encryptedPAT.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPAT) : message.encryptedPAT;
            if (message.encryptedEAT != null && message.hasOwnProperty("encryptedEAT"))
                object.encryptedEAT = options.bytes === String ? $util.base64.encode(message.encryptedEAT, 0, message.encryptedEAT.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedEAT) : message.encryptedEAT;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.sessionTokenType && message.sessionTokenType.length) {
                object.sessionTokenType = [];
                for (let j = 0; j < message.sessionTokenType.length; ++j)
                    object.sessionTokenType[j] = options.enums === String ? $root.Authentication.SessionTokenType[message.sessionTokenType[j]] : message.sessionTokenType[j];
            }
            return object;
        };

        /**
         * Converts this LoginResponse to JSON.
         * @function toJSON
         * @memberof Authentication.LoginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginResponse;
    })();

    Authentication.License = (function() {

        /**
         * Properties of a License.
         * @memberof Authentication
         * @interface ILicense
         * @property {number|Long|null} [created] License created
         * @property {number|Long|null} [expiration] License expiration
         * @property {Authentication.LicenseStatus|null} [licenseStatus] License licenseStatus
         * @property {boolean|null} [paid] License paid
         * @property {string|null} [message] License message
         */

        /**
         * Constructs a new License.
         * @memberof Authentication
         * @classdesc Represents a License.
         * @implements ILicense
         * @constructor
         * @param {Authentication.ILicense=} [properties] Properties to set
         */
        function License(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * License created.
         * @member {number|Long} created
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License expiration.
         * @member {number|Long} expiration
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License licenseStatus.
         * @member {Authentication.LicenseStatus} licenseStatus
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.licenseStatus = 0;

        /**
         * License paid.
         * @member {boolean} paid
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.paid = false;

        /**
         * License message.
         * @member {string} message
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.message = "";

        /**
         * Creates a new License instance using the specified properties.
         * @function create
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense=} [properties] Properties to set
         * @returns {Authentication.License} License instance
         */
        License.create = function create(properties) {
            return new License(properties);
        };

        /**
         * Encodes the specified License message. Does not implicitly {@link Authentication.License.verify|verify} messages.
         * @function encode
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.licenseStatus);
            if (message.paid != null && message.hasOwnProperty("paid"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.paid);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified License message, length delimited. Does not implicitly {@link Authentication.License.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a License message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.License();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.licenseStatus = reader.int32();
                    break;
                case 4:
                    message.paid = reader.bool();
                    break;
                case 5:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a License message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a License message.
         * @function verify
         * @memberof Authentication.License
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        License.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                switch (message.licenseStatus) {
                default:
                    return "licenseStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.paid != null && message.hasOwnProperty("paid"))
                if (typeof message.paid !== "boolean")
                    return "paid: boolean expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a License message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.License
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.License} License
         */
        License.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.License)
                return object;
            let message = new $root.Authentication.License();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            switch (object.licenseStatus) {
            case "OTHER":
            case 0:
                message.licenseStatus = 0;
                break;
            case "ACTIVE":
            case 1:
                message.licenseStatus = 1;
                break;
            case "EXPIRED":
            case 2:
                message.licenseStatus = 2;
                break;
            case "DISABLED":
            case 3:
                message.licenseStatus = 3;
                break;
            }
            if (object.paid != null)
                message.paid = Boolean(object.paid);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a License message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.License
         * @static
         * @param {Authentication.License} message License
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        License.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.licenseStatus = options.enums === String ? "OTHER" : 0;
                object.paid = false;
                object.message = "";
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                object.licenseStatus = options.enums === String ? $root.Authentication.LicenseStatus[message.licenseStatus] : message.licenseStatus;
            if (message.paid != null && message.hasOwnProperty("paid"))
                object.paid = message.paid;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this License to JSON.
         * @function toJSON
         * @memberof Authentication.License
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        License.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return License;
    })();

    Authentication.OwnerlessRecord = (function() {

        /**
         * Properties of an OwnerlessRecord.
         * @memberof Authentication
         * @interface IOwnerlessRecord
         * @property {Uint8Array|null} [recordUid] OwnerlessRecord recordUid
         * @property {Uint8Array|null} [recordKey] OwnerlessRecord recordKey
         * @property {number|null} [status] OwnerlessRecord status
         */

        /**
         * Constructs a new OwnerlessRecord.
         * @memberof Authentication
         * @classdesc Represents an OwnerlessRecord.
         * @implements IOwnerlessRecord
         * @constructor
         * @param {Authentication.IOwnerlessRecord=} [properties] Properties to set
         */
        function OwnerlessRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwnerlessRecord recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.recordUid = $util.newBuffer([]);

        /**
         * OwnerlessRecord recordKey.
         * @member {Uint8Array} recordKey
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.recordKey = $util.newBuffer([]);

        /**
         * OwnerlessRecord status.
         * @member {number} status
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.status = 0;

        /**
         * Creates a new OwnerlessRecord instance using the specified properties.
         * @function create
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord=} [properties] Properties to set
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord instance
         */
        OwnerlessRecord.create = function create(properties) {
            return new OwnerlessRecord(properties);
        };

        /**
         * Encodes the specified OwnerlessRecord message. Does not implicitly {@link Authentication.OwnerlessRecord.verify|verify} messages.
         * @function encode
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord} message OwnerlessRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordKey);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified OwnerlessRecord message, length delimited. Does not implicitly {@link Authentication.OwnerlessRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord} message OwnerlessRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwnerlessRecord message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.OwnerlessRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordKey = reader.bytes();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OwnerlessRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwnerlessRecord message.
         * @function verify
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwnerlessRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                if (!(message.recordKey && typeof message.recordKey.length === "number" || $util.isString(message.recordKey)))
                    return "recordKey: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            return null;
        };

        /**
         * Creates an OwnerlessRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         */
        OwnerlessRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.OwnerlessRecord)
                return object;
            let message = new $root.Authentication.OwnerlessRecord();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.recordKey != null)
                if (typeof object.recordKey === "string")
                    $util.base64.decode(object.recordKey, message.recordKey = $util.newBuffer($util.base64.length(object.recordKey)), 0);
                else if (object.recordKey.length)
                    message.recordKey = object.recordKey;
            if (object.status != null)
                message.status = object.status | 0;
            return message;
        };

        /**
         * Creates a plain object from an OwnerlessRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.OwnerlessRecord} message OwnerlessRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwnerlessRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.recordKey = "";
                else {
                    object.recordKey = [];
                    if (options.bytes !== Array)
                        object.recordKey = $util.newBuffer(object.recordKey);
                }
                object.status = 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                object.recordKey = options.bytes === String ? $util.base64.encode(message.recordKey, 0, message.recordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordKey) : message.recordKey;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this OwnerlessRecord to JSON.
         * @function toJSON
         * @memberof Authentication.OwnerlessRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwnerlessRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OwnerlessRecord;
    })();

    Authentication.OwnerlessRecords = (function() {

        /**
         * Properties of an OwnerlessRecords.
         * @memberof Authentication
         * @interface IOwnerlessRecords
         * @property {Array.<Authentication.IOwnerlessRecord>|null} [ownerlessRecord] OwnerlessRecords ownerlessRecord
         */

        /**
         * Constructs a new OwnerlessRecords.
         * @memberof Authentication
         * @classdesc Represents an OwnerlessRecords.
         * @implements IOwnerlessRecords
         * @constructor
         * @param {Authentication.IOwnerlessRecords=} [properties] Properties to set
         */
        function OwnerlessRecords(properties) {
            this.ownerlessRecord = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwnerlessRecords ownerlessRecord.
         * @member {Array.<Authentication.IOwnerlessRecord>} ownerlessRecord
         * @memberof Authentication.OwnerlessRecords
         * @instance
         */
        OwnerlessRecords.prototype.ownerlessRecord = $util.emptyArray;

        /**
         * Creates a new OwnerlessRecords instance using the specified properties.
         * @function create
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords=} [properties] Properties to set
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords instance
         */
        OwnerlessRecords.create = function create(properties) {
            return new OwnerlessRecords(properties);
        };

        /**
         * Encodes the specified OwnerlessRecords message. Does not implicitly {@link Authentication.OwnerlessRecords.verify|verify} messages.
         * @function encode
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords} message OwnerlessRecords message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecords.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerlessRecord != null && message.ownerlessRecord.length)
                for (let i = 0; i < message.ownerlessRecord.length; ++i)
                    $root.Authentication.OwnerlessRecord.encode(message.ownerlessRecord[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OwnerlessRecords message, length delimited. Does not implicitly {@link Authentication.OwnerlessRecords.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords} message OwnerlessRecords message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecords.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwnerlessRecords message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecords.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.OwnerlessRecords();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ownerlessRecord && message.ownerlessRecord.length))
                        message.ownerlessRecord = [];
                    message.ownerlessRecord.push($root.Authentication.OwnerlessRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OwnerlessRecords message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecords.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwnerlessRecords message.
         * @function verify
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwnerlessRecords.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerlessRecord != null && message.hasOwnProperty("ownerlessRecord")) {
                if (!Array.isArray(message.ownerlessRecord))
                    return "ownerlessRecord: array expected";
                for (let i = 0; i < message.ownerlessRecord.length; ++i) {
                    let error = $root.Authentication.OwnerlessRecord.verify(message.ownerlessRecord[i]);
                    if (error)
                        return "ownerlessRecord." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OwnerlessRecords message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         */
        OwnerlessRecords.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.OwnerlessRecords)
                return object;
            let message = new $root.Authentication.OwnerlessRecords();
            if (object.ownerlessRecord) {
                if (!Array.isArray(object.ownerlessRecord))
                    throw TypeError(".Authentication.OwnerlessRecords.ownerlessRecord: array expected");
                message.ownerlessRecord = [];
                for (let i = 0; i < object.ownerlessRecord.length; ++i) {
                    if (typeof object.ownerlessRecord[i] !== "object")
                        throw TypeError(".Authentication.OwnerlessRecords.ownerlessRecord: object expected");
                    message.ownerlessRecord[i] = $root.Authentication.OwnerlessRecord.fromObject(object.ownerlessRecord[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OwnerlessRecords message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.OwnerlessRecords} message OwnerlessRecords
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwnerlessRecords.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ownerlessRecord = [];
            if (message.ownerlessRecord && message.ownerlessRecord.length) {
                object.ownerlessRecord = [];
                for (let j = 0; j < message.ownerlessRecord.length; ++j)
                    object.ownerlessRecord[j] = $root.Authentication.OwnerlessRecord.toObject(message.ownerlessRecord[j], options);
            }
            return object;
        };

        /**
         * Converts this OwnerlessRecords to JSON.
         * @function toJSON
         * @memberof Authentication.OwnerlessRecords
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwnerlessRecords.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OwnerlessRecords;
    })();

    Authentication.UserAuthRequest = (function() {

        /**
         * Properties of a UserAuthRequest.
         * @memberof Authentication
         * @interface IUserAuthRequest
         * @property {Uint8Array|null} [uid] UserAuthRequest uid
         * @property {Uint8Array|null} [salt] UserAuthRequest salt
         * @property {number|null} [iterations] UserAuthRequest iterations
         * @property {Uint8Array|null} [encryptedClientKey] UserAuthRequest encryptedClientKey
         * @property {Uint8Array|null} [authHash] UserAuthRequest authHash
         * @property {Uint8Array|null} [encryptedDataKey] UserAuthRequest encryptedDataKey
         * @property {Authentication.LoginType|null} [loginType] UserAuthRequest loginType
         * @property {string|null} [name] UserAuthRequest name
         * @property {number|null} [algorithm] UserAuthRequest algorithm
         */

        /**
         * Constructs a new UserAuthRequest.
         * @memberof Authentication
         * @classdesc Represents a UserAuthRequest.
         * @implements IUserAuthRequest
         * @constructor
         * @param {Authentication.IUserAuthRequest=} [properties] Properties to set
         */
        function UserAuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAuthRequest uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.uid = $util.newBuffer([]);

        /**
         * UserAuthRequest salt.
         * @member {Uint8Array} salt
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.salt = $util.newBuffer([]);

        /**
         * UserAuthRequest iterations.
         * @member {number} iterations
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.iterations = 0;

        /**
         * UserAuthRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * UserAuthRequest authHash.
         * @member {Uint8Array} authHash
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.authHash = $util.newBuffer([]);

        /**
         * UserAuthRequest encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * UserAuthRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.loginType = 0;

        /**
         * UserAuthRequest name.
         * @member {string} name
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.name = "";

        /**
         * UserAuthRequest algorithm.
         * @member {number} algorithm
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.algorithm = 0;

        /**
         * Creates a new UserAuthRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest=} [properties] Properties to set
         * @returns {Authentication.UserAuthRequest} UserAuthRequest instance
         */
        UserAuthRequest.create = function create(properties) {
            return new UserAuthRequest(properties);
        };

        /**
         * Encodes the specified UserAuthRequest message. Does not implicitly {@link Authentication.UserAuthRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.iterations);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedClientKey);
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.authHash);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedDataKey);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.loginType);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.algorithm);
            return writer;
        };

        /**
         * Encodes the specified UserAuthRequest message, length delimited. Does not implicitly {@link Authentication.UserAuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserAuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.iterations = reader.int32();
                    break;
                case 4:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 5:
                    message.authHash = reader.bytes();
                    break;
                case 6:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 7:
                    message.loginType = reader.int32();
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 9:
                    message.algorithm = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserAuthRequest message.
         * @function verify
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserAuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                if (!(message.authHash && typeof message.authHash.length === "number" || $util.isString(message.authHash)))
                    return "authHash: buffer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            return null;
        };

        /**
         * Creates a UserAuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         */
        UserAuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserAuthRequest)
                return object;
            let message = new $root.Authentication.UserAuthRequest();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.authHash != null)
                if (typeof object.authHash === "string")
                    $util.base64.decode(object.authHash, message.authHash = $util.newBuffer($util.base64.length(object.authHash)), 0);
                else if (object.authHash.length)
                    message.authHash = object.authHash;
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserAuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.UserAuthRequest} message UserAuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserAuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.iterations = 0;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.authHash = "";
                else {
                    object.authHash = [];
                    if (options.bytes !== Array)
                        object.authHash = $util.newBuffer(object.authHash);
                }
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
                object.loginType = options.enums === String ? "NORMAL" : 0;
                object.name = "";
                object.algorithm = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                object.authHash = options.bytes === String ? $util.base64.encode(message.authHash, 0, message.authHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.authHash) : message.authHash;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            return object;
        };

        /**
         * Converts this UserAuthRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UserAuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserAuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserAuthRequest;
    })();

    Authentication.UidRequest = (function() {

        /**
         * Properties of an UidRequest.
         * @memberof Authentication
         * @interface IUidRequest
         * @property {Array.<Uint8Array>|null} [uid] UidRequest uid
         */

        /**
         * Constructs a new UidRequest.
         * @memberof Authentication
         * @classdesc Represents an UidRequest.
         * @implements IUidRequest
         * @constructor
         * @param {Authentication.IUidRequest=} [properties] Properties to set
         */
        function UidRequest(properties) {
            this.uid = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UidRequest uid.
         * @member {Array.<Uint8Array>} uid
         * @memberof Authentication.UidRequest
         * @instance
         */
        UidRequest.prototype.uid = $util.emptyArray;

        /**
         * Creates a new UidRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest=} [properties] Properties to set
         * @returns {Authentication.UidRequest} UidRequest instance
         */
        UidRequest.create = function create(properties) {
            return new UidRequest(properties);
        };

        /**
         * Encodes the specified UidRequest message. Does not implicitly {@link Authentication.UidRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest} message UidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.uid.length)
                for (let i = 0; i < message.uid.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid[i]);
            return writer;
        };

        /**
         * Encodes the specified UidRequest message, length delimited. Does not implicitly {@link Authentication.UidRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest} message UidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UidRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UidRequest} UidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UidRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.uid && message.uid.length))
                        message.uid = [];
                    message.uid.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UidRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UidRequest} UidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UidRequest message.
         * @function verify
         * @memberof Authentication.UidRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UidRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid")) {
                if (!Array.isArray(message.uid))
                    return "uid: array expected";
                for (let i = 0; i < message.uid.length; ++i)
                    if (!(message.uid[i] && typeof message.uid[i].length === "number" || $util.isString(message.uid[i])))
                        return "uid: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an UidRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UidRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UidRequest} UidRequest
         */
        UidRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UidRequest)
                return object;
            let message = new $root.Authentication.UidRequest();
            if (object.uid) {
                if (!Array.isArray(object.uid))
                    throw TypeError(".Authentication.UidRequest.uid: array expected");
                message.uid = [];
                for (let i = 0; i < object.uid.length; ++i)
                    if (typeof object.uid[i] === "string")
                        $util.base64.decode(object.uid[i], message.uid[i] = $util.newBuffer($util.base64.length(object.uid[i])), 0);
                    else if (object.uid[i].length)
                        message.uid[i] = object.uid[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an UidRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.UidRequest} message UidRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UidRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.uid = [];
            if (message.uid && message.uid.length) {
                object.uid = [];
                for (let j = 0; j < message.uid.length; ++j)
                    object.uid[j] = options.bytes === String ? $util.base64.encode(message.uid[j], 0, message.uid[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.uid[j]) : message.uid[j];
            }
            return object;
        };

        /**
         * Converts this UidRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UidRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UidRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UidRequest;
    })();

    Authentication.DeviceClientVersionUpdateRequest = (function() {

        /**
         * Properties of a DeviceClientVersionUpdateRequest.
         * @memberof Authentication
         * @interface IDeviceClientVersionUpdateRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceClientVersionUpdateRequest encryptedDeviceToken
         * @property {string|null} [clientVersion] DeviceClientVersionUpdateRequest clientVersion
         */

        /**
         * Constructs a new DeviceClientVersionUpdateRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceClientVersionUpdateRequest.
         * @implements IDeviceClientVersionUpdateRequest
         * @constructor
         * @param {Authentication.IDeviceClientVersionUpdateRequest=} [properties] Properties to set
         */
        function DeviceClientVersionUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceClientVersionUpdateRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @instance
         */
        DeviceClientVersionUpdateRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceClientVersionUpdateRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @instance
         */
        DeviceClientVersionUpdateRequest.prototype.clientVersion = "";

        /**
         * Creates a new DeviceClientVersionUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Authentication.IDeviceClientVersionUpdateRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceClientVersionUpdateRequest} DeviceClientVersionUpdateRequest instance
         */
        DeviceClientVersionUpdateRequest.create = function create(properties) {
            return new DeviceClientVersionUpdateRequest(properties);
        };

        /**
         * Encodes the specified DeviceClientVersionUpdateRequest message. Does not implicitly {@link Authentication.DeviceClientVersionUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Authentication.IDeviceClientVersionUpdateRequest} message DeviceClientVersionUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceClientVersionUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            return writer;
        };

        /**
         * Encodes the specified DeviceClientVersionUpdateRequest message, length delimited. Does not implicitly {@link Authentication.DeviceClientVersionUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Authentication.IDeviceClientVersionUpdateRequest} message DeviceClientVersionUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceClientVersionUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceClientVersionUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceClientVersionUpdateRequest} DeviceClientVersionUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceClientVersionUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceClientVersionUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceClientVersionUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceClientVersionUpdateRequest} DeviceClientVersionUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceClientVersionUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceClientVersionUpdateRequest message.
         * @function verify
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceClientVersionUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            return null;
        };

        /**
         * Creates a DeviceClientVersionUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceClientVersionUpdateRequest} DeviceClientVersionUpdateRequest
         */
        DeviceClientVersionUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceClientVersionUpdateRequest)
                return object;
            let message = new $root.Authentication.DeviceClientVersionUpdateRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            return message;
        };

        /**
         * Creates a plain object from a DeviceClientVersionUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @static
         * @param {Authentication.DeviceClientVersionUpdateRequest} message DeviceClientVersionUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceClientVersionUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.clientVersion = "";
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            return object;
        };

        /**
         * Converts this DeviceClientVersionUpdateRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceClientVersionUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceClientVersionUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceClientVersionUpdateRequest;
    })();

    Authentication.ConvertUserToV3Request = (function() {

        /**
         * Properties of a ConvertUserToV3Request.
         * @memberof Authentication
         * @interface IConvertUserToV3Request
         * @property {Authentication.IAuthRequest|null} [authRequest] ConvertUserToV3Request authRequest
         * @property {Authentication.IUserAuthRequest|null} [userAuthRequest] ConvertUserToV3Request userAuthRequest
         * @property {Uint8Array|null} [encryptedClientKey] ConvertUserToV3Request encryptedClientKey
         * @property {Uint8Array|null} [encryptedPrivateKey] ConvertUserToV3Request encryptedPrivateKey
         * @property {Uint8Array|null} [publicKey] ConvertUserToV3Request publicKey
         */

        /**
         * Constructs a new ConvertUserToV3Request.
         * @memberof Authentication
         * @classdesc Represents a ConvertUserToV3Request.
         * @implements IConvertUserToV3Request
         * @constructor
         * @param {Authentication.IConvertUserToV3Request=} [properties] Properties to set
         */
        function ConvertUserToV3Request(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConvertUserToV3Request authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.authRequest = null;

        /**
         * ConvertUserToV3Request userAuthRequest.
         * @member {Authentication.IUserAuthRequest|null|undefined} userAuthRequest
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.userAuthRequest = null;

        /**
         * ConvertUserToV3Request encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * ConvertUserToV3Request encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * ConvertUserToV3Request publicKey.
         * @member {Uint8Array} publicKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.publicKey = $util.newBuffer([]);

        /**
         * Creates a new ConvertUserToV3Request instance using the specified properties.
         * @function create
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request=} [properties] Properties to set
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request instance
         */
        ConvertUserToV3Request.create = function create(properties) {
            return new ConvertUserToV3Request(properties);
        };

        /**
         * Encodes the specified ConvertUserToV3Request message. Does not implicitly {@link Authentication.ConvertUserToV3Request.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request} message ConvertUserToV3Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConvertUserToV3Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                $root.Authentication.UserAuthRequest.encode(message.userAuthRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedClientKey);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPrivateKey);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified ConvertUserToV3Request message, length delimited. Does not implicitly {@link Authentication.ConvertUserToV3Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request} message ConvertUserToV3Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConvertUserToV3Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConvertUserToV3Request message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConvertUserToV3Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ConvertUserToV3Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.userAuthRequest = $root.Authentication.UserAuthRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 4:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConvertUserToV3Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConvertUserToV3Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConvertUserToV3Request message.
         * @function verify
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConvertUserToV3Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest")) {
                let error = $root.Authentication.UserAuthRequest.verify(message.userAuthRequest);
                if (error)
                    return "userAuthRequest." + error;
            }
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            return null;
        };

        /**
         * Creates a ConvertUserToV3Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         */
        ConvertUserToV3Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ConvertUserToV3Request)
                return object;
            let message = new $root.Authentication.ConvertUserToV3Request();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.ConvertUserToV3Request.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            if (object.userAuthRequest != null) {
                if (typeof object.userAuthRequest !== "object")
                    throw TypeError(".Authentication.ConvertUserToV3Request.userAuthRequest: object expected");
                message.userAuthRequest = $root.Authentication.UserAuthRequest.fromObject(object.userAuthRequest);
            }
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };

        /**
         * Creates a plain object from a ConvertUserToV3Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.ConvertUserToV3Request} message ConvertUserToV3Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConvertUserToV3Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.userAuthRequest = null;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                object.userAuthRequest = $root.Authentication.UserAuthRequest.toObject(message.userAuthRequest, options);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };

        /**
         * Converts this ConvertUserToV3Request to JSON.
         * @function toJSON
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConvertUserToV3Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConvertUserToV3Request;
    })();

    Authentication.RevisionResponse = (function() {

        /**
         * Properties of a RevisionResponse.
         * @memberof Authentication
         * @interface IRevisionResponse
         * @property {number|Long|null} [revision] RevisionResponse revision
         */

        /**
         * Constructs a new RevisionResponse.
         * @memberof Authentication
         * @classdesc Represents a RevisionResponse.
         * @implements IRevisionResponse
         * @constructor
         * @param {Authentication.IRevisionResponse=} [properties] Properties to set
         */
        function RevisionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RevisionResponse revision.
         * @member {number|Long} revision
         * @memberof Authentication.RevisionResponse
         * @instance
         */
        RevisionResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RevisionResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse=} [properties] Properties to set
         * @returns {Authentication.RevisionResponse} RevisionResponse instance
         */
        RevisionResponse.create = function create(properties) {
            return new RevisionResponse(properties);
        };

        /**
         * Encodes the specified RevisionResponse message. Does not implicitly {@link Authentication.RevisionResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse} message RevisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevisionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revision);
            return writer;
        };

        /**
         * Encodes the specified RevisionResponse message, length delimited. Does not implicitly {@link Authentication.RevisionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse} message RevisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RevisionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RevisionResponse} RevisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevisionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RevisionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.revision = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RevisionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RevisionResponse} RevisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevisionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RevisionResponse message.
         * @function verify
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RevisionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            return null;
        };

        /**
         * Creates a RevisionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RevisionResponse} RevisionResponse
         */
        RevisionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RevisionResponse)
                return object;
            let message = new $root.Authentication.RevisionResponse();
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RevisionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.RevisionResponse} message RevisionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RevisionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            return object;
        };

        /**
         * Converts this RevisionResponse to JSON.
         * @function toJSON
         * @memberof Authentication.RevisionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RevisionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RevisionResponse;
    })();

    Authentication.ChangeEmailRequest = (function() {

        /**
         * Properties of a ChangeEmailRequest.
         * @memberof Authentication
         * @interface IChangeEmailRequest
         * @property {string|null} [newEmail] ChangeEmailRequest newEmail
         */

        /**
         * Constructs a new ChangeEmailRequest.
         * @memberof Authentication
         * @classdesc Represents a ChangeEmailRequest.
         * @implements IChangeEmailRequest
         * @constructor
         * @param {Authentication.IChangeEmailRequest=} [properties] Properties to set
         */
        function ChangeEmailRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailRequest newEmail.
         * @member {string} newEmail
         * @memberof Authentication.ChangeEmailRequest
         * @instance
         */
        ChangeEmailRequest.prototype.newEmail = "";

        /**
         * Creates a new ChangeEmailRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest=} [properties] Properties to set
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest instance
         */
        ChangeEmailRequest.create = function create(properties) {
            return new ChangeEmailRequest(properties);
        };

        /**
         * Encodes the specified ChangeEmailRequest message. Does not implicitly {@link Authentication.ChangeEmailRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest} message ChangeEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.newEmail);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailRequest message, length delimited. Does not implicitly {@link Authentication.ChangeEmailRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest} message ChangeEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeEmailRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newEmail = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailRequest message.
         * @function verify
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                if (!$util.isString(message.newEmail))
                    return "newEmail: string expected";
            return null;
        };

        /**
         * Creates a ChangeEmailRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         */
        ChangeEmailRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeEmailRequest)
                return object;
            let message = new $root.Authentication.ChangeEmailRequest();
            if (object.newEmail != null)
                message.newEmail = String(object.newEmail);
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.ChangeEmailRequest} message ChangeEmailRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.newEmail = "";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                object.newEmail = message.newEmail;
            return object;
        };

        /**
         * Converts this ChangeEmailRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeEmailRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailRequest;
    })();

    Authentication.ChangeEmailResponse = (function() {

        /**
         * Properties of a ChangeEmailResponse.
         * @memberof Authentication
         * @interface IChangeEmailResponse
         * @property {Uint8Array|null} [encryptedChangeEmailToken] ChangeEmailResponse encryptedChangeEmailToken
         */

        /**
         * Constructs a new ChangeEmailResponse.
         * @memberof Authentication
         * @classdesc Represents a ChangeEmailResponse.
         * @implements IChangeEmailResponse
         * @constructor
         * @param {Authentication.IChangeEmailResponse=} [properties] Properties to set
         */
        function ChangeEmailResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailResponse encryptedChangeEmailToken.
         * @member {Uint8Array} encryptedChangeEmailToken
         * @memberof Authentication.ChangeEmailResponse
         * @instance
         */
        ChangeEmailResponse.prototype.encryptedChangeEmailToken = $util.newBuffer([]);

        /**
         * Creates a new ChangeEmailResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse=} [properties] Properties to set
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse instance
         */
        ChangeEmailResponse.create = function create(properties) {
            return new ChangeEmailResponse(properties);
        };

        /**
         * Encodes the specified ChangeEmailResponse message. Does not implicitly {@link Authentication.ChangeEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse} message ChangeEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedChangeEmailToken);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailResponse message, length delimited. Does not implicitly {@link Authentication.ChangeEmailResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse} message ChangeEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeEmailResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedChangeEmailToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailResponse message.
         * @function verify
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                if (!(message.encryptedChangeEmailToken && typeof message.encryptedChangeEmailToken.length === "number" || $util.isString(message.encryptedChangeEmailToken)))
                    return "encryptedChangeEmailToken: buffer expected";
            return null;
        };

        /**
         * Creates a ChangeEmailResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         */
        ChangeEmailResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeEmailResponse)
                return object;
            let message = new $root.Authentication.ChangeEmailResponse();
            if (object.encryptedChangeEmailToken != null)
                if (typeof object.encryptedChangeEmailToken === "string")
                    $util.base64.decode(object.encryptedChangeEmailToken, message.encryptedChangeEmailToken = $util.newBuffer($util.base64.length(object.encryptedChangeEmailToken)), 0);
                else if (object.encryptedChangeEmailToken.length)
                    message.encryptedChangeEmailToken = object.encryptedChangeEmailToken;
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.ChangeEmailResponse} message ChangeEmailResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedChangeEmailToken = "";
                else {
                    object.encryptedChangeEmailToken = [];
                    if (options.bytes !== Array)
                        object.encryptedChangeEmailToken = $util.newBuffer(object.encryptedChangeEmailToken);
                }
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                object.encryptedChangeEmailToken = options.bytes === String ? $util.base64.encode(message.encryptedChangeEmailToken, 0, message.encryptedChangeEmailToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedChangeEmailToken) : message.encryptedChangeEmailToken;
            return object;
        };

        /**
         * Converts this ChangeEmailResponse to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeEmailResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailResponse;
    })();

    Authentication.EmailVerificationLinkResponse = (function() {

        /**
         * Properties of an EmailVerificationLinkResponse.
         * @memberof Authentication
         * @interface IEmailVerificationLinkResponse
         * @property {boolean|null} [emailVerified] EmailVerificationLinkResponse emailVerified
         */

        /**
         * Constructs a new EmailVerificationLinkResponse.
         * @memberof Authentication
         * @classdesc Represents an EmailVerificationLinkResponse.
         * @implements IEmailVerificationLinkResponse
         * @constructor
         * @param {Authentication.IEmailVerificationLinkResponse=} [properties] Properties to set
         */
        function EmailVerificationLinkResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmailVerificationLinkResponse emailVerified.
         * @member {boolean} emailVerified
         * @memberof Authentication.EmailVerificationLinkResponse
         * @instance
         */
        EmailVerificationLinkResponse.prototype.emailVerified = false;

        /**
         * Creates a new EmailVerificationLinkResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse=} [properties] Properties to set
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse instance
         */
        EmailVerificationLinkResponse.create = function create(properties) {
            return new EmailVerificationLinkResponse(properties);
        };

        /**
         * Encodes the specified EmailVerificationLinkResponse message. Does not implicitly {@link Authentication.EmailVerificationLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse} message EmailVerificationLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationLinkResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.emailVerified);
            return writer;
        };

        /**
         * Encodes the specified EmailVerificationLinkResponse message, length delimited. Does not implicitly {@link Authentication.EmailVerificationLinkResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse} message EmailVerificationLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationLinkResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmailVerificationLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationLinkResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.EmailVerificationLinkResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailVerified = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmailVerificationLinkResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationLinkResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmailVerificationLinkResponse message.
         * @function verify
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmailVerificationLinkResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                if (typeof message.emailVerified !== "boolean")
                    return "emailVerified: boolean expected";
            return null;
        };

        /**
         * Creates an EmailVerificationLinkResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         */
        EmailVerificationLinkResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.EmailVerificationLinkResponse)
                return object;
            let message = new $root.Authentication.EmailVerificationLinkResponse();
            if (object.emailVerified != null)
                message.emailVerified = Boolean(object.emailVerified);
            return message;
        };

        /**
         * Creates a plain object from an EmailVerificationLinkResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.EmailVerificationLinkResponse} message EmailVerificationLinkResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmailVerificationLinkResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.emailVerified = false;
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                object.emailVerified = message.emailVerified;
            return object;
        };

        /**
         * Converts this EmailVerificationLinkResponse to JSON.
         * @function toJSON
         * @memberof Authentication.EmailVerificationLinkResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmailVerificationLinkResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmailVerificationLinkResponse;
    })();

    Authentication.SecurityData = (function() {

        /**
         * Properties of a SecurityData.
         * @memberof Authentication
         * @interface ISecurityData
         * @property {Uint8Array|null} [uid] SecurityData uid
         * @property {Uint8Array|null} [data] SecurityData data
         */

        /**
         * Constructs a new SecurityData.
         * @memberof Authentication
         * @classdesc Represents a SecurityData.
         * @implements ISecurityData
         * @constructor
         * @param {Authentication.ISecurityData=} [properties] Properties to set
         */
        function SecurityData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityData uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.SecurityData
         * @instance
         */
        SecurityData.prototype.uid = $util.newBuffer([]);

        /**
         * SecurityData data.
         * @member {Uint8Array} data
         * @memberof Authentication.SecurityData
         * @instance
         */
        SecurityData.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new SecurityData instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData=} [properties] Properties to set
         * @returns {Authentication.SecurityData} SecurityData instance
         */
        SecurityData.create = function create(properties) {
            return new SecurityData(properties);
        };

        /**
         * Encodes the specified SecurityData message. Does not implicitly {@link Authentication.SecurityData.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData} message SecurityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified SecurityData message, length delimited. Does not implicitly {@link Authentication.SecurityData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData} message SecurityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityData message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityData} SecurityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityData} SecurityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityData message.
         * @function verify
         * @memberof Authentication.SecurityData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a SecurityData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityData} SecurityData
         */
        SecurityData.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityData)
                return object;
            let message = new $root.Authentication.SecurityData();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a SecurityData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.SecurityData} message SecurityData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this SecurityData to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityData;
    })();

    Authentication.SecurityDataRequest = (function() {

        /**
         * Properties of a SecurityDataRequest.
         * @memberof Authentication
         * @interface ISecurityDataRequest
         * @property {Array.<Authentication.ISecurityData>|null} [recordSecurityData] SecurityDataRequest recordSecurityData
         * @property {Array.<Authentication.ISecurityData>|null} [masterPasswordSecurityData] SecurityDataRequest masterPasswordSecurityData
         */

        /**
         * Constructs a new SecurityDataRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityDataRequest.
         * @implements ISecurityDataRequest
         * @constructor
         * @param {Authentication.ISecurityDataRequest=} [properties] Properties to set
         */
        function SecurityDataRequest(properties) {
            this.recordSecurityData = [];
            this.masterPasswordSecurityData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityDataRequest recordSecurityData.
         * @member {Array.<Authentication.ISecurityData>} recordSecurityData
         * @memberof Authentication.SecurityDataRequest
         * @instance
         */
        SecurityDataRequest.prototype.recordSecurityData = $util.emptyArray;

        /**
         * SecurityDataRequest masterPasswordSecurityData.
         * @member {Array.<Authentication.ISecurityData>} masterPasswordSecurityData
         * @memberof Authentication.SecurityDataRequest
         * @instance
         */
        SecurityDataRequest.prototype.masterPasswordSecurityData = $util.emptyArray;

        /**
         * Creates a new SecurityDataRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest instance
         */
        SecurityDataRequest.create = function create(properties) {
            return new SecurityDataRequest(properties);
        };

        /**
         * Encodes the specified SecurityDataRequest message. Does not implicitly {@link Authentication.SecurityDataRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest} message SecurityDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityDataRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordSecurityData != null && message.recordSecurityData.length)
                for (let i = 0; i < message.recordSecurityData.length; ++i)
                    $root.Authentication.SecurityData.encode(message.recordSecurityData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.masterPasswordSecurityData != null && message.masterPasswordSecurityData.length)
                for (let i = 0; i < message.masterPasswordSecurityData.length; ++i)
                    $root.Authentication.SecurityData.encode(message.masterPasswordSecurityData[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityDataRequest message, length delimited. Does not implicitly {@link Authentication.SecurityDataRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest} message SecurityDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityDataRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityDataRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityDataRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.recordSecurityData && message.recordSecurityData.length))
                        message.recordSecurityData = [];
                    message.recordSecurityData.push($root.Authentication.SecurityData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.masterPasswordSecurityData && message.masterPasswordSecurityData.length))
                        message.masterPasswordSecurityData = [];
                    message.masterPasswordSecurityData.push($root.Authentication.SecurityData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityDataRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityDataRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityDataRequest message.
         * @function verify
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityDataRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordSecurityData != null && message.hasOwnProperty("recordSecurityData")) {
                if (!Array.isArray(message.recordSecurityData))
                    return "recordSecurityData: array expected";
                for (let i = 0; i < message.recordSecurityData.length; ++i) {
                    let error = $root.Authentication.SecurityData.verify(message.recordSecurityData[i]);
                    if (error)
                        return "recordSecurityData." + error;
                }
            }
            if (message.masterPasswordSecurityData != null && message.hasOwnProperty("masterPasswordSecurityData")) {
                if (!Array.isArray(message.masterPasswordSecurityData))
                    return "masterPasswordSecurityData: array expected";
                for (let i = 0; i < message.masterPasswordSecurityData.length; ++i) {
                    let error = $root.Authentication.SecurityData.verify(message.masterPasswordSecurityData[i]);
                    if (error)
                        return "masterPasswordSecurityData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityDataRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         */
        SecurityDataRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityDataRequest)
                return object;
            let message = new $root.Authentication.SecurityDataRequest();
            if (object.recordSecurityData) {
                if (!Array.isArray(object.recordSecurityData))
                    throw TypeError(".Authentication.SecurityDataRequest.recordSecurityData: array expected");
                message.recordSecurityData = [];
                for (let i = 0; i < object.recordSecurityData.length; ++i) {
                    if (typeof object.recordSecurityData[i] !== "object")
                        throw TypeError(".Authentication.SecurityDataRequest.recordSecurityData: object expected");
                    message.recordSecurityData[i] = $root.Authentication.SecurityData.fromObject(object.recordSecurityData[i]);
                }
            }
            if (object.masterPasswordSecurityData) {
                if (!Array.isArray(object.masterPasswordSecurityData))
                    throw TypeError(".Authentication.SecurityDataRequest.masterPasswordSecurityData: array expected");
                message.masterPasswordSecurityData = [];
                for (let i = 0; i < object.masterPasswordSecurityData.length; ++i) {
                    if (typeof object.masterPasswordSecurityData[i] !== "object")
                        throw TypeError(".Authentication.SecurityDataRequest.masterPasswordSecurityData: object expected");
                    message.masterPasswordSecurityData[i] = $root.Authentication.SecurityData.fromObject(object.masterPasswordSecurityData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityDataRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.SecurityDataRequest} message SecurityDataRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityDataRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.recordSecurityData = [];
                object.masterPasswordSecurityData = [];
            }
            if (message.recordSecurityData && message.recordSecurityData.length) {
                object.recordSecurityData = [];
                for (let j = 0; j < message.recordSecurityData.length; ++j)
                    object.recordSecurityData[j] = $root.Authentication.SecurityData.toObject(message.recordSecurityData[j], options);
            }
            if (message.masterPasswordSecurityData && message.masterPasswordSecurityData.length) {
                object.masterPasswordSecurityData = [];
                for (let j = 0; j < message.masterPasswordSecurityData.length; ++j)
                    object.masterPasswordSecurityData[j] = $root.Authentication.SecurityData.toObject(message.masterPasswordSecurityData[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityDataRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityDataRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityDataRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityDataRequest;
    })();

    Authentication.SecurityReportIncrementalData = (function() {

        /**
         * Properties of a SecurityReportIncrementalData.
         * @memberof Authentication
         * @interface ISecurityReportIncrementalData
         * @property {number|Long|null} [enterpriseUserId] SecurityReportIncrementalData enterpriseUserId
         * @property {Uint8Array|null} [currentSecurityData] SecurityReportIncrementalData currentSecurityData
         * @property {number|Long|null} [currentSecurityDataRevision] SecurityReportIncrementalData currentSecurityDataRevision
         * @property {Uint8Array|null} [oldSecurityData] SecurityReportIncrementalData oldSecurityData
         * @property {number|Long|null} [oldSecurityDataRevision] SecurityReportIncrementalData oldSecurityDataRevision
         */

        /**
         * Constructs a new SecurityReportIncrementalData.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportIncrementalData.
         * @implements ISecurityReportIncrementalData
         * @constructor
         * @param {Authentication.ISecurityReportIncrementalData=} [properties] Properties to set
         */
        function SecurityReportIncrementalData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportIncrementalData enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportIncrementalData currentSecurityData.
         * @member {Uint8Array} currentSecurityData
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.currentSecurityData = $util.newBuffer([]);

        /**
         * SecurityReportIncrementalData currentSecurityDataRevision.
         * @member {number|Long} currentSecurityDataRevision
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.currentSecurityDataRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportIncrementalData oldSecurityData.
         * @member {Uint8Array} oldSecurityData
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.oldSecurityData = $util.newBuffer([]);

        /**
         * SecurityReportIncrementalData oldSecurityDataRevision.
         * @member {number|Long} oldSecurityDataRevision
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.oldSecurityDataRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SecurityReportIncrementalData instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData=} [properties] Properties to set
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData instance
         */
        SecurityReportIncrementalData.create = function create(properties) {
            return new SecurityReportIncrementalData(properties);
        };

        /**
         * Encodes the specified SecurityReportIncrementalData message. Does not implicitly {@link Authentication.SecurityReportIncrementalData.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData} message SecurityReportIncrementalData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportIncrementalData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.currentSecurityData);
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.currentSecurityDataRevision);
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.oldSecurityData);
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.oldSecurityDataRevision);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportIncrementalData message, length delimited. Does not implicitly {@link Authentication.SecurityReportIncrementalData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData} message SecurityReportIncrementalData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportIncrementalData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportIncrementalData message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportIncrementalData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportIncrementalData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.currentSecurityData = reader.bytes();
                    break;
                case 3:
                    message.currentSecurityDataRevision = reader.int64();
                    break;
                case 4:
                    message.oldSecurityData = reader.bytes();
                    break;
                case 5:
                    message.oldSecurityDataRevision = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportIncrementalData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportIncrementalData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportIncrementalData message.
         * @function verify
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportIncrementalData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                if (!(message.currentSecurityData && typeof message.currentSecurityData.length === "number" || $util.isString(message.currentSecurityData)))
                    return "currentSecurityData: buffer expected";
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                if (!$util.isInteger(message.currentSecurityDataRevision) && !(message.currentSecurityDataRevision && $util.isInteger(message.currentSecurityDataRevision.low) && $util.isInteger(message.currentSecurityDataRevision.high)))
                    return "currentSecurityDataRevision: integer|Long expected";
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                if (!(message.oldSecurityData && typeof message.oldSecurityData.length === "number" || $util.isString(message.oldSecurityData)))
                    return "oldSecurityData: buffer expected";
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                if (!$util.isInteger(message.oldSecurityDataRevision) && !(message.oldSecurityDataRevision && $util.isInteger(message.oldSecurityDataRevision.low) && $util.isInteger(message.oldSecurityDataRevision.high)))
                    return "oldSecurityDataRevision: integer|Long expected";
            return null;
        };

        /**
         * Creates a SecurityReportIncrementalData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         */
        SecurityReportIncrementalData.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportIncrementalData)
                return object;
            let message = new $root.Authentication.SecurityReportIncrementalData();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.currentSecurityData != null)
                if (typeof object.currentSecurityData === "string")
                    $util.base64.decode(object.currentSecurityData, message.currentSecurityData = $util.newBuffer($util.base64.length(object.currentSecurityData)), 0);
                else if (object.currentSecurityData.length)
                    message.currentSecurityData = object.currentSecurityData;
            if (object.currentSecurityDataRevision != null)
                if ($util.Long)
                    (message.currentSecurityDataRevision = $util.Long.fromValue(object.currentSecurityDataRevision)).unsigned = false;
                else if (typeof object.currentSecurityDataRevision === "string")
                    message.currentSecurityDataRevision = parseInt(object.currentSecurityDataRevision, 10);
                else if (typeof object.currentSecurityDataRevision === "number")
                    message.currentSecurityDataRevision = object.currentSecurityDataRevision;
                else if (typeof object.currentSecurityDataRevision === "object")
                    message.currentSecurityDataRevision = new $util.LongBits(object.currentSecurityDataRevision.low >>> 0, object.currentSecurityDataRevision.high >>> 0).toNumber();
            if (object.oldSecurityData != null)
                if (typeof object.oldSecurityData === "string")
                    $util.base64.decode(object.oldSecurityData, message.oldSecurityData = $util.newBuffer($util.base64.length(object.oldSecurityData)), 0);
                else if (object.oldSecurityData.length)
                    message.oldSecurityData = object.oldSecurityData;
            if (object.oldSecurityDataRevision != null)
                if ($util.Long)
                    (message.oldSecurityDataRevision = $util.Long.fromValue(object.oldSecurityDataRevision)).unsigned = false;
                else if (typeof object.oldSecurityDataRevision === "string")
                    message.oldSecurityDataRevision = parseInt(object.oldSecurityDataRevision, 10);
                else if (typeof object.oldSecurityDataRevision === "number")
                    message.oldSecurityDataRevision = object.oldSecurityDataRevision;
                else if (typeof object.oldSecurityDataRevision === "object")
                    message.oldSecurityDataRevision = new $util.LongBits(object.oldSecurityDataRevision.low >>> 0, object.oldSecurityDataRevision.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportIncrementalData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.SecurityReportIncrementalData} message SecurityReportIncrementalData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportIncrementalData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.currentSecurityData = "";
                else {
                    object.currentSecurityData = [];
                    if (options.bytes !== Array)
                        object.currentSecurityData = $util.newBuffer(object.currentSecurityData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.currentSecurityDataRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.currentSecurityDataRevision = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.oldSecurityData = "";
                else {
                    object.oldSecurityData = [];
                    if (options.bytes !== Array)
                        object.oldSecurityData = $util.newBuffer(object.oldSecurityData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.oldSecurityDataRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oldSecurityDataRevision = options.longs === String ? "0" : 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                object.currentSecurityData = options.bytes === String ? $util.base64.encode(message.currentSecurityData, 0, message.currentSecurityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentSecurityData) : message.currentSecurityData;
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                if (typeof message.currentSecurityDataRevision === "number")
                    object.currentSecurityDataRevision = options.longs === String ? String(message.currentSecurityDataRevision) : message.currentSecurityDataRevision;
                else
                    object.currentSecurityDataRevision = options.longs === String ? $util.Long.prototype.toString.call(message.currentSecurityDataRevision) : options.longs === Number ? new $util.LongBits(message.currentSecurityDataRevision.low >>> 0, message.currentSecurityDataRevision.high >>> 0).toNumber() : message.currentSecurityDataRevision;
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                object.oldSecurityData = options.bytes === String ? $util.base64.encode(message.oldSecurityData, 0, message.oldSecurityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.oldSecurityData) : message.oldSecurityData;
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                if (typeof message.oldSecurityDataRevision === "number")
                    object.oldSecurityDataRevision = options.longs === String ? String(message.oldSecurityDataRevision) : message.oldSecurityDataRevision;
                else
                    object.oldSecurityDataRevision = options.longs === String ? $util.Long.prototype.toString.call(message.oldSecurityDataRevision) : options.longs === Number ? new $util.LongBits(message.oldSecurityDataRevision.low >>> 0, message.oldSecurityDataRevision.high >>> 0).toNumber() : message.oldSecurityDataRevision;
            return object;
        };

        /**
         * Converts this SecurityReportIncrementalData to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportIncrementalData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportIncrementalData;
    })();

    Authentication.SecurityReport = (function() {

        /**
         * Properties of a SecurityReport.
         * @memberof Authentication
         * @interface ISecurityReport
         * @property {number|Long|null} [enterpriseUserId] SecurityReport enterpriseUserId
         * @property {Uint8Array|null} [encryptedReportData] SecurityReport encryptedReportData
         * @property {number|Long|null} [revision] SecurityReport revision
         * @property {string|null} [twoFactor] SecurityReport twoFactor
         * @property {number|Long|null} [lastLogin] SecurityReport lastLogin
         * @property {number|null} [numberOfReusedPassword] SecurityReport numberOfReusedPassword
         * @property {Array.<Authentication.ISecurityReportIncrementalData>|null} [securityReportIncrementalData] SecurityReport securityReportIncrementalData
         */

        /**
         * Constructs a new SecurityReport.
         * @memberof Authentication
         * @classdesc Represents a SecurityReport.
         * @implements ISecurityReport
         * @constructor
         * @param {Authentication.ISecurityReport=} [properties] Properties to set
         */
        function SecurityReport(properties) {
            this.securityReportIncrementalData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReport enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport encryptedReportData.
         * @member {Uint8Array} encryptedReportData
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.encryptedReportData = $util.newBuffer([]);

        /**
         * SecurityReport revision.
         * @member {number|Long} revision
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport twoFactor.
         * @member {string} twoFactor
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.twoFactor = "";

        /**
         * SecurityReport lastLogin.
         * @member {number|Long} lastLogin
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.lastLogin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport numberOfReusedPassword.
         * @member {number} numberOfReusedPassword
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.numberOfReusedPassword = 0;

        /**
         * SecurityReport securityReportIncrementalData.
         * @member {Array.<Authentication.ISecurityReportIncrementalData>} securityReportIncrementalData
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.securityReportIncrementalData = $util.emptyArray;

        /**
         * Creates a new SecurityReport instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport=} [properties] Properties to set
         * @returns {Authentication.SecurityReport} SecurityReport instance
         */
        SecurityReport.create = function create(properties) {
            return new SecurityReport(properties);
        };

        /**
         * Encodes the specified SecurityReport message. Does not implicitly {@link Authentication.SecurityReport.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport} message SecurityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedReportData);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.revision);
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.twoFactor);
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lastLogin);
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.numberOfReusedPassword);
            if (message.securityReportIncrementalData != null && message.securityReportIncrementalData.length)
                for (let i = 0; i < message.securityReportIncrementalData.length; ++i)
                    $root.Authentication.SecurityReportIncrementalData.encode(message.securityReportIncrementalData[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityReport message, length delimited. Does not implicitly {@link Authentication.SecurityReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport} message SecurityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReport message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReport} SecurityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.encryptedReportData = reader.bytes();
                    break;
                case 3:
                    message.revision = reader.int64();
                    break;
                case 4:
                    message.twoFactor = reader.string();
                    break;
                case 5:
                    message.lastLogin = reader.int64();
                    break;
                case 6:
                    message.numberOfReusedPassword = reader.int32();
                    break;
                case 7:
                    if (!(message.securityReportIncrementalData && message.securityReportIncrementalData.length))
                        message.securityReportIncrementalData = [];
                    message.securityReportIncrementalData.push($root.Authentication.SecurityReportIncrementalData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReport} SecurityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReport message.
         * @function verify
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                if (!(message.encryptedReportData && typeof message.encryptedReportData.length === "number" || $util.isString(message.encryptedReportData)))
                    return "encryptedReportData: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                if (!$util.isString(message.twoFactor))
                    return "twoFactor: string expected";
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (!$util.isInteger(message.lastLogin) && !(message.lastLogin && $util.isInteger(message.lastLogin.low) && $util.isInteger(message.lastLogin.high)))
                    return "lastLogin: integer|Long expected";
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                if (!$util.isInteger(message.numberOfReusedPassword))
                    return "numberOfReusedPassword: integer expected";
            if (message.securityReportIncrementalData != null && message.hasOwnProperty("securityReportIncrementalData")) {
                if (!Array.isArray(message.securityReportIncrementalData))
                    return "securityReportIncrementalData: array expected";
                for (let i = 0; i < message.securityReportIncrementalData.length; ++i) {
                    let error = $root.Authentication.SecurityReportIncrementalData.verify(message.securityReportIncrementalData[i]);
                    if (error)
                        return "securityReportIncrementalData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReport} SecurityReport
         */
        SecurityReport.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReport)
                return object;
            let message = new $root.Authentication.SecurityReport();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.encryptedReportData != null)
                if (typeof object.encryptedReportData === "string")
                    $util.base64.decode(object.encryptedReportData, message.encryptedReportData = $util.newBuffer($util.base64.length(object.encryptedReportData)), 0);
                else if (object.encryptedReportData.length)
                    message.encryptedReportData = object.encryptedReportData;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.twoFactor != null)
                message.twoFactor = String(object.twoFactor);
            if (object.lastLogin != null)
                if ($util.Long)
                    (message.lastLogin = $util.Long.fromValue(object.lastLogin)).unsigned = false;
                else if (typeof object.lastLogin === "string")
                    message.lastLogin = parseInt(object.lastLogin, 10);
                else if (typeof object.lastLogin === "number")
                    message.lastLogin = object.lastLogin;
                else if (typeof object.lastLogin === "object")
                    message.lastLogin = new $util.LongBits(object.lastLogin.low >>> 0, object.lastLogin.high >>> 0).toNumber();
            if (object.numberOfReusedPassword != null)
                message.numberOfReusedPassword = object.numberOfReusedPassword | 0;
            if (object.securityReportIncrementalData) {
                if (!Array.isArray(object.securityReportIncrementalData))
                    throw TypeError(".Authentication.SecurityReport.securityReportIncrementalData: array expected");
                message.securityReportIncrementalData = [];
                for (let i = 0; i < object.securityReportIncrementalData.length; ++i) {
                    if (typeof object.securityReportIncrementalData[i] !== "object")
                        throw TypeError(".Authentication.SecurityReport.securityReportIncrementalData: object expected");
                    message.securityReportIncrementalData[i] = $root.Authentication.SecurityReportIncrementalData.fromObject(object.securityReportIncrementalData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.SecurityReport} message SecurityReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReportIncrementalData = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedReportData = "";
                else {
                    object.encryptedReportData = [];
                    if (options.bytes !== Array)
                        object.encryptedReportData = $util.newBuffer(object.encryptedReportData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.twoFactor = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastLogin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastLogin = options.longs === String ? "0" : 0;
                object.numberOfReusedPassword = 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                object.encryptedReportData = options.bytes === String ? $util.base64.encode(message.encryptedReportData, 0, message.encryptedReportData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedReportData) : message.encryptedReportData;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                object.twoFactor = message.twoFactor;
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (typeof message.lastLogin === "number")
                    object.lastLogin = options.longs === String ? String(message.lastLogin) : message.lastLogin;
                else
                    object.lastLogin = options.longs === String ? $util.Long.prototype.toString.call(message.lastLogin) : options.longs === Number ? new $util.LongBits(message.lastLogin.low >>> 0, message.lastLogin.high >>> 0).toNumber() : message.lastLogin;
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                object.numberOfReusedPassword = message.numberOfReusedPassword;
            if (message.securityReportIncrementalData && message.securityReportIncrementalData.length) {
                object.securityReportIncrementalData = [];
                for (let j = 0; j < message.securityReportIncrementalData.length; ++j)
                    object.securityReportIncrementalData[j] = $root.Authentication.SecurityReportIncrementalData.toObject(message.securityReportIncrementalData[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityReport to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReport;
    })();

    Authentication.SecurityReportSaveRequest = (function() {

        /**
         * Properties of a SecurityReportSaveRequest.
         * @memberof Authentication
         * @interface ISecurityReportSaveRequest
         * @property {Array.<Authentication.ISecurityReport>|null} [securityReport] SecurityReportSaveRequest securityReport
         */

        /**
         * Constructs a new SecurityReportSaveRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportSaveRequest.
         * @implements ISecurityReportSaveRequest
         * @constructor
         * @param {Authentication.ISecurityReportSaveRequest=} [properties] Properties to set
         */
        function SecurityReportSaveRequest(properties) {
            this.securityReport = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportSaveRequest securityReport.
         * @member {Array.<Authentication.ISecurityReport>} securityReport
         * @memberof Authentication.SecurityReportSaveRequest
         * @instance
         */
        SecurityReportSaveRequest.prototype.securityReport = $util.emptyArray;

        /**
         * Creates a new SecurityReportSaveRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest instance
         */
        SecurityReportSaveRequest.create = function create(properties) {
            return new SecurityReportSaveRequest(properties);
        };

        /**
         * Encodes the specified SecurityReportSaveRequest message. Does not implicitly {@link Authentication.SecurityReportSaveRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest} message SecurityReportSaveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportSaveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityReport != null && message.securityReport.length)
                for (let i = 0; i < message.securityReport.length; ++i)
                    $root.Authentication.SecurityReport.encode(message.securityReport[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityReportSaveRequest message, length delimited. Does not implicitly {@link Authentication.SecurityReportSaveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest} message SecurityReportSaveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportSaveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportSaveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportSaveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportSaveRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityReport && message.securityReport.length))
                        message.securityReport = [];
                    message.securityReport.push($root.Authentication.SecurityReport.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportSaveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportSaveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportSaveRequest message.
         * @function verify
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportSaveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityReport != null && message.hasOwnProperty("securityReport")) {
                if (!Array.isArray(message.securityReport))
                    return "securityReport: array expected";
                for (let i = 0; i < message.securityReport.length; ++i) {
                    let error = $root.Authentication.SecurityReport.verify(message.securityReport[i]);
                    if (error)
                        return "securityReport." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityReportSaveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         */
        SecurityReportSaveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportSaveRequest)
                return object;
            let message = new $root.Authentication.SecurityReportSaveRequest();
            if (object.securityReport) {
                if (!Array.isArray(object.securityReport))
                    throw TypeError(".Authentication.SecurityReportSaveRequest.securityReport: array expected");
                message.securityReport = [];
                for (let i = 0; i < object.securityReport.length; ++i) {
                    if (typeof object.securityReport[i] !== "object")
                        throw TypeError(".Authentication.SecurityReportSaveRequest.securityReport: object expected");
                    message.securityReport[i] = $root.Authentication.SecurityReport.fromObject(object.securityReport[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportSaveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.SecurityReportSaveRequest} message SecurityReportSaveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportSaveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReport = [];
            if (message.securityReport && message.securityReport.length) {
                object.securityReport = [];
                for (let j = 0; j < message.securityReport.length; ++j)
                    object.securityReport[j] = $root.Authentication.SecurityReport.toObject(message.securityReport[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityReportSaveRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportSaveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportSaveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportSaveRequest;
    })();

    Authentication.SecurityReportRequest = (function() {

        /**
         * Properties of a SecurityReportRequest.
         * @memberof Authentication
         * @interface ISecurityReportRequest
         * @property {number|Long|null} [fromPage] SecurityReportRequest fromPage
         */

        /**
         * Constructs a new SecurityReportRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportRequest.
         * @implements ISecurityReportRequest
         * @constructor
         * @param {Authentication.ISecurityReportRequest=} [properties] Properties to set
         */
        function SecurityReportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportRequest fromPage.
         * @member {number|Long} fromPage
         * @memberof Authentication.SecurityReportRequest
         * @instance
         */
        SecurityReportRequest.prototype.fromPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SecurityReportRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest instance
         */
        SecurityReportRequest.create = function create(properties) {
            return new SecurityReportRequest(properties);
        };

        /**
         * Encodes the specified SecurityReportRequest message. Does not implicitly {@link Authentication.SecurityReportRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest} message SecurityReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fromPage);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportRequest message, length delimited. Does not implicitly {@link Authentication.SecurityReportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest} message SecurityReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fromPage = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportRequest message.
         * @function verify
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (!$util.isInteger(message.fromPage) && !(message.fromPage && $util.isInteger(message.fromPage.low) && $util.isInteger(message.fromPage.high)))
                    return "fromPage: integer|Long expected";
            return null;
        };

        /**
         * Creates a SecurityReportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         */
        SecurityReportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportRequest)
                return object;
            let message = new $root.Authentication.SecurityReportRequest();
            if (object.fromPage != null)
                if ($util.Long)
                    (message.fromPage = $util.Long.fromValue(object.fromPage)).unsigned = false;
                else if (typeof object.fromPage === "string")
                    message.fromPage = parseInt(object.fromPage, 10);
                else if (typeof object.fromPage === "number")
                    message.fromPage = object.fromPage;
                else if (typeof object.fromPage === "object")
                    message.fromPage = new $util.LongBits(object.fromPage.low >>> 0, object.fromPage.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.SecurityReportRequest} message SecurityReportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fromPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromPage = options.longs === String ? "0" : 0;
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (typeof message.fromPage === "number")
                    object.fromPage = options.longs === String ? String(message.fromPage) : message.fromPage;
                else
                    object.fromPage = options.longs === String ? $util.Long.prototype.toString.call(message.fromPage) : options.longs === Number ? new $util.LongBits(message.fromPage.low >>> 0, message.fromPage.high >>> 0).toNumber() : message.fromPage;
            return object;
        };

        /**
         * Converts this SecurityReportRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportRequest;
    })();

    Authentication.SecurityReportResponse = (function() {

        /**
         * Properties of a SecurityReportResponse.
         * @memberof Authentication
         * @interface ISecurityReportResponse
         * @property {Uint8Array|null} [enterprisePrivateKey] SecurityReportResponse enterprisePrivateKey
         * @property {Array.<Authentication.ISecurityReport>|null} [securityReport] SecurityReportResponse securityReport
         * @property {number|Long|null} [asOfRevision] SecurityReportResponse asOfRevision
         * @property {number|Long|null} [fromPage] SecurityReportResponse fromPage
         * @property {number|Long|null} [toPage] SecurityReportResponse toPage
         * @property {boolean|null} [complete] SecurityReportResponse complete
         */

        /**
         * Constructs a new SecurityReportResponse.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportResponse.
         * @implements ISecurityReportResponse
         * @constructor
         * @param {Authentication.ISecurityReportResponse=} [properties] Properties to set
         */
        function SecurityReportResponse(properties) {
            this.securityReport = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportResponse enterprisePrivateKey.
         * @member {Uint8Array} enterprisePrivateKey
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.enterprisePrivateKey = $util.newBuffer([]);

        /**
         * SecurityReportResponse securityReport.
         * @member {Array.<Authentication.ISecurityReport>} securityReport
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.securityReport = $util.emptyArray;

        /**
         * SecurityReportResponse asOfRevision.
         * @member {number|Long} asOfRevision
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.asOfRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse fromPage.
         * @member {number|Long} fromPage
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.fromPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse toPage.
         * @member {number|Long} toPage
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.toPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse complete.
         * @member {boolean} complete
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.complete = false;

        /**
         * Creates a new SecurityReportResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse=} [properties] Properties to set
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse instance
         */
        SecurityReportResponse.create = function create(properties) {
            return new SecurityReportResponse(properties);
        };

        /**
         * Encodes the specified SecurityReportResponse message. Does not implicitly {@link Authentication.SecurityReportResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse} message SecurityReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePrivateKey);
            if (message.securityReport != null && message.securityReport.length)
                for (let i = 0; i < message.securityReport.length; ++i)
                    $root.Authentication.SecurityReport.encode(message.securityReport[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.asOfRevision);
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromPage);
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.toPage);
            if (message.complete != null && message.hasOwnProperty("complete"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.complete);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportResponse message, length delimited. Does not implicitly {@link Authentication.SecurityReportResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse} message SecurityReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePrivateKey = reader.bytes();
                    break;
                case 2:
                    if (!(message.securityReport && message.securityReport.length))
                        message.securityReport = [];
                    message.securityReport.push($root.Authentication.SecurityReport.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.asOfRevision = reader.int64();
                    break;
                case 4:
                    message.fromPage = reader.int64();
                    break;
                case 5:
                    message.toPage = reader.int64();
                    break;
                case 6:
                    message.complete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportResponse message.
         * @function verify
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                if (!(message.enterprisePrivateKey && typeof message.enterprisePrivateKey.length === "number" || $util.isString(message.enterprisePrivateKey)))
                    return "enterprisePrivateKey: buffer expected";
            if (message.securityReport != null && message.hasOwnProperty("securityReport")) {
                if (!Array.isArray(message.securityReport))
                    return "securityReport: array expected";
                for (let i = 0; i < message.securityReport.length; ++i) {
                    let error = $root.Authentication.SecurityReport.verify(message.securityReport[i]);
                    if (error)
                        return "securityReport." + error;
                }
            }
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                if (!$util.isInteger(message.asOfRevision) && !(message.asOfRevision && $util.isInteger(message.asOfRevision.low) && $util.isInteger(message.asOfRevision.high)))
                    return "asOfRevision: integer|Long expected";
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (!$util.isInteger(message.fromPage) && !(message.fromPage && $util.isInteger(message.fromPage.low) && $util.isInteger(message.fromPage.high)))
                    return "fromPage: integer|Long expected";
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                if (!$util.isInteger(message.toPage) && !(message.toPage && $util.isInteger(message.toPage.low) && $util.isInteger(message.toPage.high)))
                    return "toPage: integer|Long expected";
            if (message.complete != null && message.hasOwnProperty("complete"))
                if (typeof message.complete !== "boolean")
                    return "complete: boolean expected";
            return null;
        };

        /**
         * Creates a SecurityReportResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         */
        SecurityReportResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportResponse)
                return object;
            let message = new $root.Authentication.SecurityReportResponse();
            if (object.enterprisePrivateKey != null)
                if (typeof object.enterprisePrivateKey === "string")
                    $util.base64.decode(object.enterprisePrivateKey, message.enterprisePrivateKey = $util.newBuffer($util.base64.length(object.enterprisePrivateKey)), 0);
                else if (object.enterprisePrivateKey.length)
                    message.enterprisePrivateKey = object.enterprisePrivateKey;
            if (object.securityReport) {
                if (!Array.isArray(object.securityReport))
                    throw TypeError(".Authentication.SecurityReportResponse.securityReport: array expected");
                message.securityReport = [];
                for (let i = 0; i < object.securityReport.length; ++i) {
                    if (typeof object.securityReport[i] !== "object")
                        throw TypeError(".Authentication.SecurityReportResponse.securityReport: object expected");
                    message.securityReport[i] = $root.Authentication.SecurityReport.fromObject(object.securityReport[i]);
                }
            }
            if (object.asOfRevision != null)
                if ($util.Long)
                    (message.asOfRevision = $util.Long.fromValue(object.asOfRevision)).unsigned = false;
                else if (typeof object.asOfRevision === "string")
                    message.asOfRevision = parseInt(object.asOfRevision, 10);
                else if (typeof object.asOfRevision === "number")
                    message.asOfRevision = object.asOfRevision;
                else if (typeof object.asOfRevision === "object")
                    message.asOfRevision = new $util.LongBits(object.asOfRevision.low >>> 0, object.asOfRevision.high >>> 0).toNumber();
            if (object.fromPage != null)
                if ($util.Long)
                    (message.fromPage = $util.Long.fromValue(object.fromPage)).unsigned = false;
                else if (typeof object.fromPage === "string")
                    message.fromPage = parseInt(object.fromPage, 10);
                else if (typeof object.fromPage === "number")
                    message.fromPage = object.fromPage;
                else if (typeof object.fromPage === "object")
                    message.fromPage = new $util.LongBits(object.fromPage.low >>> 0, object.fromPage.high >>> 0).toNumber();
            if (object.toPage != null)
                if ($util.Long)
                    (message.toPage = $util.Long.fromValue(object.toPage)).unsigned = false;
                else if (typeof object.toPage === "string")
                    message.toPage = parseInt(object.toPage, 10);
                else if (typeof object.toPage === "number")
                    message.toPage = object.toPage;
                else if (typeof object.toPage === "object")
                    message.toPage = new $util.LongBits(object.toPage.low >>> 0, object.toPage.high >>> 0).toNumber();
            if (object.complete != null)
                message.complete = Boolean(object.complete);
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.SecurityReportResponse} message SecurityReportResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReport = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.enterprisePrivateKey = "";
                else {
                    object.enterprisePrivateKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePrivateKey = $util.newBuffer(object.enterprisePrivateKey);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.asOfRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.asOfRevision = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fromPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromPage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.toPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toPage = options.longs === String ? "0" : 0;
                object.complete = false;
            }
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                object.enterprisePrivateKey = options.bytes === String ? $util.base64.encode(message.enterprisePrivateKey, 0, message.enterprisePrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePrivateKey) : message.enterprisePrivateKey;
            if (message.securityReport && message.securityReport.length) {
                object.securityReport = [];
                for (let j = 0; j < message.securityReport.length; ++j)
                    object.securityReport[j] = $root.Authentication.SecurityReport.toObject(message.securityReport[j], options);
            }
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                if (typeof message.asOfRevision === "number")
                    object.asOfRevision = options.longs === String ? String(message.asOfRevision) : message.asOfRevision;
                else
                    object.asOfRevision = options.longs === String ? $util.Long.prototype.toString.call(message.asOfRevision) : options.longs === Number ? new $util.LongBits(message.asOfRevision.low >>> 0, message.asOfRevision.high >>> 0).toNumber() : message.asOfRevision;
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (typeof message.fromPage === "number")
                    object.fromPage = options.longs === String ? String(message.fromPage) : message.fromPage;
                else
                    object.fromPage = options.longs === String ? $util.Long.prototype.toString.call(message.fromPage) : options.longs === Number ? new $util.LongBits(message.fromPage.low >>> 0, message.fromPage.high >>> 0).toNumber() : message.fromPage;
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                if (typeof message.toPage === "number")
                    object.toPage = options.longs === String ? String(message.toPage) : message.toPage;
                else
                    object.toPage = options.longs === String ? $util.Long.prototype.toString.call(message.toPage) : options.longs === Number ? new $util.LongBits(message.toPage.low >>> 0, message.toPage.high >>> 0).toNumber() : message.toPage;
            if (message.complete != null && message.hasOwnProperty("complete"))
                object.complete = message.complete;
            return object;
        };

        /**
         * Converts this SecurityReportResponse to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportResponse;
    })();

    Authentication.ReusedPasswordsRequest = (function() {

        /**
         * Properties of a ReusedPasswordsRequest.
         * @memberof Authentication
         * @interface IReusedPasswordsRequest
         * @property {number|null} [count] ReusedPasswordsRequest count
         */

        /**
         * Constructs a new ReusedPasswordsRequest.
         * @memberof Authentication
         * @classdesc Represents a ReusedPasswordsRequest.
         * @implements IReusedPasswordsRequest
         * @constructor
         * @param {Authentication.IReusedPasswordsRequest=} [properties] Properties to set
         */
        function ReusedPasswordsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReusedPasswordsRequest count.
         * @member {number} count
         * @memberof Authentication.ReusedPasswordsRequest
         * @instance
         */
        ReusedPasswordsRequest.prototype.count = 0;

        /**
         * Creates a new ReusedPasswordsRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest=} [properties] Properties to set
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest instance
         */
        ReusedPasswordsRequest.create = function create(properties) {
            return new ReusedPasswordsRequest(properties);
        };

        /**
         * Encodes the specified ReusedPasswordsRequest message. Does not implicitly {@link Authentication.ReusedPasswordsRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest} message ReusedPasswordsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReusedPasswordsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ReusedPasswordsRequest message, length delimited. Does not implicitly {@link Authentication.ReusedPasswordsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest} message ReusedPasswordsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReusedPasswordsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReusedPasswordsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReusedPasswordsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ReusedPasswordsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReusedPasswordsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReusedPasswordsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReusedPasswordsRequest message.
         * @function verify
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReusedPasswordsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a ReusedPasswordsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         */
        ReusedPasswordsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ReusedPasswordsRequest)
                return object;
            let message = new $root.Authentication.ReusedPasswordsRequest();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a ReusedPasswordsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.ReusedPasswordsRequest} message ReusedPasswordsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReusedPasswordsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this ReusedPasswordsRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ReusedPasswordsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReusedPasswordsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReusedPasswordsRequest;
    })();

    Authentication.SummaryConsoleReport = (function() {

        /**
         * Properties of a SummaryConsoleReport.
         * @memberof Authentication
         * @interface ISummaryConsoleReport
         * @property {number|null} [reportType] SummaryConsoleReport reportType
         * @property {Uint8Array|null} [reportData] SummaryConsoleReport reportData
         */

        /**
         * Constructs a new SummaryConsoleReport.
         * @memberof Authentication
         * @classdesc Represents a SummaryConsoleReport.
         * @implements ISummaryConsoleReport
         * @constructor
         * @param {Authentication.ISummaryConsoleReport=} [properties] Properties to set
         */
        function SummaryConsoleReport(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SummaryConsoleReport reportType.
         * @member {number} reportType
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         */
        SummaryConsoleReport.prototype.reportType = 0;

        /**
         * SummaryConsoleReport reportData.
         * @member {Uint8Array} reportData
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         */
        SummaryConsoleReport.prototype.reportData = $util.newBuffer([]);

        /**
         * Creates a new SummaryConsoleReport instance using the specified properties.
         * @function create
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport=} [properties] Properties to set
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport instance
         */
        SummaryConsoleReport.create = function create(properties) {
            return new SummaryConsoleReport(properties);
        };

        /**
         * Encodes the specified SummaryConsoleReport message. Does not implicitly {@link Authentication.SummaryConsoleReport.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport} message SummaryConsoleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryConsoleReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reportType);
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reportData);
            return writer;
        };

        /**
         * Encodes the specified SummaryConsoleReport message, length delimited. Does not implicitly {@link Authentication.SummaryConsoleReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport} message SummaryConsoleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryConsoleReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SummaryConsoleReport message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryConsoleReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SummaryConsoleReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reportType = reader.int32();
                    break;
                case 2:
                    message.reportData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SummaryConsoleReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryConsoleReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SummaryConsoleReport message.
         * @function verify
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SummaryConsoleReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                if (!$util.isInteger(message.reportType))
                    return "reportType: integer expected";
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                if (!(message.reportData && typeof message.reportData.length === "number" || $util.isString(message.reportData)))
                    return "reportData: buffer expected";
            return null;
        };

        /**
         * Creates a SummaryConsoleReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         */
        SummaryConsoleReport.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SummaryConsoleReport)
                return object;
            let message = new $root.Authentication.SummaryConsoleReport();
            if (object.reportType != null)
                message.reportType = object.reportType | 0;
            if (object.reportData != null)
                if (typeof object.reportData === "string")
                    $util.base64.decode(object.reportData, message.reportData = $util.newBuffer($util.base64.length(object.reportData)), 0);
                else if (object.reportData.length)
                    message.reportData = object.reportData;
            return message;
        };

        /**
         * Creates a plain object from a SummaryConsoleReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.SummaryConsoleReport} message SummaryConsoleReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SummaryConsoleReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.reportType = 0;
                if (options.bytes === String)
                    object.reportData = "";
                else {
                    object.reportData = [];
                    if (options.bytes !== Array)
                        object.reportData = $util.newBuffer(object.reportData);
                }
            }
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                object.reportType = message.reportType;
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                object.reportData = options.bytes === String ? $util.base64.encode(message.reportData, 0, message.reportData.length) : options.bytes === Array ? Array.prototype.slice.call(message.reportData) : message.reportData;
            return object;
        };

        /**
         * Converts this SummaryConsoleReport to JSON.
         * @function toJSON
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SummaryConsoleReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SummaryConsoleReport;
    })();

    /**
     * ObjectTypes enum.
     * @name Authentication.ObjectTypes
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} SHARED_FOLDER_USER=1 SHARED_FOLDER_USER value
     * @property {number} SHARED_FOLDER_TEAM=2 SHARED_FOLDER_TEAM value
     * @property {number} USER_FOLDER=3 USER_FOLDER value
     * @property {number} TEAM_USER=4 TEAM_USER value
     */
    Authentication.ObjectTypes = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "SHARED_FOLDER_USER"] = 1;
        values[valuesById[2] = "SHARED_FOLDER_TEAM"] = 2;
        values[valuesById[3] = "USER_FOLDER"] = 3;
        values[valuesById[4] = "TEAM_USER"] = 4;
        return values;
    })();

    Authentication.ChangeToKeyTypeOne = (function() {

        /**
         * Properties of a ChangeToKeyTypeOne.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOne
         * @property {Authentication.ObjectTypes|null} [objectType] ChangeToKeyTypeOne objectType
         * @property {Uint8Array|null} [primaryUid] ChangeToKeyTypeOne primaryUid
         * @property {Uint8Array|null} [secondaryUid] ChangeToKeyTypeOne secondaryUid
         * @property {Uint8Array|null} [key] ChangeToKeyTypeOne key
         */

        /**
         * Constructs a new ChangeToKeyTypeOne.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOne.
         * @implements IChangeToKeyTypeOne
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOne=} [properties] Properties to set
         */
        function ChangeToKeyTypeOne(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOne objectType.
         * @member {Authentication.ObjectTypes} objectType
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.objectType = 0;

        /**
         * ChangeToKeyTypeOne primaryUid.
         * @member {Uint8Array} primaryUid
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.primaryUid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOne secondaryUid.
         * @member {Uint8Array} secondaryUid
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.secondaryUid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOne key.
         * @member {Uint8Array} key
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new ChangeToKeyTypeOne instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne instance
         */
        ChangeToKeyTypeOne.create = function create(properties) {
            return new ChangeToKeyTypeOne(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOne message. Does not implicitly {@link Authentication.ChangeToKeyTypeOne.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne} message ChangeToKeyTypeOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOne.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.objectType);
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.primaryUid);
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.secondaryUid);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOne message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOne.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne} message ChangeToKeyTypeOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOne.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOne message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOne.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOne();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.objectType = reader.int32();
                    break;
                case 2:
                    message.primaryUid = reader.bytes();
                    break;
                case 3:
                    message.secondaryUid = reader.bytes();
                    break;
                case 4:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOne message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOne.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOne message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOne.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                switch (message.objectType) {
                default:
                    return "objectType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                if (!(message.primaryUid && typeof message.primaryUid.length === "number" || $util.isString(message.primaryUid)))
                    return "primaryUid: buffer expected";
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                if (!(message.secondaryUid && typeof message.secondaryUid.length === "number" || $util.isString(message.secondaryUid)))
                    return "secondaryUid: buffer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOne message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         */
        ChangeToKeyTypeOne.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOne)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOne();
            switch (object.objectType) {
            case "RECORD":
            case 0:
                message.objectType = 0;
                break;
            case "SHARED_FOLDER_USER":
            case 1:
                message.objectType = 1;
                break;
            case "SHARED_FOLDER_TEAM":
            case 2:
                message.objectType = 2;
                break;
            case "USER_FOLDER":
            case 3:
                message.objectType = 3;
                break;
            case "TEAM_USER":
            case 4:
                message.objectType = 4;
                break;
            }
            if (object.primaryUid != null)
                if (typeof object.primaryUid === "string")
                    $util.base64.decode(object.primaryUid, message.primaryUid = $util.newBuffer($util.base64.length(object.primaryUid)), 0);
                else if (object.primaryUid.length)
                    message.primaryUid = object.primaryUid;
            if (object.secondaryUid != null)
                if (typeof object.secondaryUid === "string")
                    $util.base64.decode(object.secondaryUid, message.secondaryUid = $util.newBuffer($util.base64.length(object.secondaryUid)), 0);
                else if (object.secondaryUid.length)
                    message.secondaryUid = object.secondaryUid;
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOne message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.ChangeToKeyTypeOne} message ChangeToKeyTypeOne
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOne.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.objectType = options.enums === String ? "RECORD" : 0;
                if (options.bytes === String)
                    object.primaryUid = "";
                else {
                    object.primaryUid = [];
                    if (options.bytes !== Array)
                        object.primaryUid = $util.newBuffer(object.primaryUid);
                }
                if (options.bytes === String)
                    object.secondaryUid = "";
                else {
                    object.secondaryUid = [];
                    if (options.bytes !== Array)
                        object.secondaryUid = $util.newBuffer(object.secondaryUid);
                }
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            }
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                object.objectType = options.enums === String ? $root.Authentication.ObjectTypes[message.objectType] : message.objectType;
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                object.primaryUid = options.bytes === String ? $util.base64.encode(message.primaryUid, 0, message.primaryUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.primaryUid) : message.primaryUid;
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                object.secondaryUid = options.bytes === String ? $util.base64.encode(message.secondaryUid, 0, message.secondaryUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondaryUid) : message.secondaryUid;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOne to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOne.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOne;
    })();

    Authentication.ChangeToKeyTypeOneRequest = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneRequest.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneRequest
         * @property {Array.<Authentication.IChangeToKeyTypeOne>|null} [changeToKeyTypeOne] ChangeToKeyTypeOneRequest changeToKeyTypeOne
         */

        /**
         * Constructs a new ChangeToKeyTypeOneRequest.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneRequest.
         * @implements IChangeToKeyTypeOneRequest
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneRequest=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneRequest(properties) {
            this.changeToKeyTypeOne = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneRequest changeToKeyTypeOne.
         * @member {Array.<Authentication.IChangeToKeyTypeOne>} changeToKeyTypeOne
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @instance
         */
        ChangeToKeyTypeOneRequest.prototype.changeToKeyTypeOne = $util.emptyArray;

        /**
         * Creates a new ChangeToKeyTypeOneRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest instance
         */
        ChangeToKeyTypeOneRequest.create = function create(properties) {
            return new ChangeToKeyTypeOneRequest(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneRequest message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changeToKeyTypeOne != null && message.changeToKeyTypeOne.length)
                for (let i = 0; i < message.changeToKeyTypeOne.length; ++i)
                    $root.Authentication.ChangeToKeyTypeOne.encode(message.changeToKeyTypeOne[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneRequest message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.changeToKeyTypeOne && message.changeToKeyTypeOne.length))
                        message.changeToKeyTypeOne = [];
                    message.changeToKeyTypeOne.push($root.Authentication.ChangeToKeyTypeOne.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneRequest message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changeToKeyTypeOne != null && message.hasOwnProperty("changeToKeyTypeOne")) {
                if (!Array.isArray(message.changeToKeyTypeOne))
                    return "changeToKeyTypeOne: array expected";
                for (let i = 0; i < message.changeToKeyTypeOne.length; ++i) {
                    let error = $root.Authentication.ChangeToKeyTypeOne.verify(message.changeToKeyTypeOne[i]);
                    if (error)
                        return "changeToKeyTypeOne." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         */
        ChangeToKeyTypeOneRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneRequest)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneRequest();
            if (object.changeToKeyTypeOne) {
                if (!Array.isArray(object.changeToKeyTypeOne))
                    throw TypeError(".Authentication.ChangeToKeyTypeOneRequest.changeToKeyTypeOne: array expected");
                message.changeToKeyTypeOne = [];
                for (let i = 0; i < object.changeToKeyTypeOne.length; ++i) {
                    if (typeof object.changeToKeyTypeOne[i] !== "object")
                        throw TypeError(".Authentication.ChangeToKeyTypeOneRequest.changeToKeyTypeOne: object expected");
                    message.changeToKeyTypeOne[i] = $root.Authentication.ChangeToKeyTypeOne.fromObject(object.changeToKeyTypeOne[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.ChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.changeToKeyTypeOne = [];
            if (message.changeToKeyTypeOne && message.changeToKeyTypeOne.length) {
                object.changeToKeyTypeOne = [];
                for (let j = 0; j < message.changeToKeyTypeOne.length; ++j)
                    object.changeToKeyTypeOne[j] = $root.Authentication.ChangeToKeyTypeOne.toObject(message.changeToKeyTypeOne[j], options);
            }
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneRequest;
    })();

    Authentication.ChangeToKeyTypeOneStatus = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneStatus.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneStatus
         * @property {Uint8Array|null} [uid] ChangeToKeyTypeOneStatus uid
         * @property {string|null} [type] ChangeToKeyTypeOneStatus type
         * @property {string|null} [status] ChangeToKeyTypeOneStatus status
         * @property {string|null} [reason] ChangeToKeyTypeOneStatus reason
         */

        /**
         * Constructs a new ChangeToKeyTypeOneStatus.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneStatus.
         * @implements IChangeToKeyTypeOneStatus
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneStatus=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneStatus uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.uid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOneStatus type.
         * @member {string} type
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.type = "";

        /**
         * ChangeToKeyTypeOneStatus status.
         * @member {string} status
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.status = "";

        /**
         * ChangeToKeyTypeOneStatus reason.
         * @member {string} reason
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.reason = "";

        /**
         * Creates a new ChangeToKeyTypeOneStatus instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus instance
         */
        ChangeToKeyTypeOneStatus.create = function create(properties) {
            return new ChangeToKeyTypeOneStatus(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneStatus message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneStatus.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneStatus message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.type = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneStatus message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         */
        ChangeToKeyTypeOneStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneStatus)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneStatus();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.type != null)
                message.type = String(object.type);
            if (object.status != null)
                message.status = String(object.status);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.ChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.type = "";
                object.status = "";
                object.reason = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneStatus to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneStatus;
    })();

    Authentication.ChangeToKeyTypeOneResponse = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneResponse.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneResponse
         * @property {Array.<Authentication.IChangeToKeyTypeOneStatus>|null} [changeToKeyTypeOneStatus] ChangeToKeyTypeOneResponse changeToKeyTypeOneStatus
         */

        /**
         * Constructs a new ChangeToKeyTypeOneResponse.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneResponse.
         * @implements IChangeToKeyTypeOneResponse
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneResponse=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneResponse(properties) {
            this.changeToKeyTypeOneStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneResponse changeToKeyTypeOneStatus.
         * @member {Array.<Authentication.IChangeToKeyTypeOneStatus>} changeToKeyTypeOneStatus
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @instance
         */
        ChangeToKeyTypeOneResponse.prototype.changeToKeyTypeOneStatus = $util.emptyArray;

        /**
         * Creates a new ChangeToKeyTypeOneResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse instance
         */
        ChangeToKeyTypeOneResponse.create = function create(properties) {
            return new ChangeToKeyTypeOneResponse(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneResponse message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changeToKeyTypeOneStatus != null && message.changeToKeyTypeOneStatus.length)
                for (let i = 0; i < message.changeToKeyTypeOneStatus.length; ++i)
                    $root.Authentication.ChangeToKeyTypeOneStatus.encode(message.changeToKeyTypeOneStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneResponse message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.changeToKeyTypeOneStatus && message.changeToKeyTypeOneStatus.length))
                        message.changeToKeyTypeOneStatus = [];
                    message.changeToKeyTypeOneStatus.push($root.Authentication.ChangeToKeyTypeOneStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneResponse message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changeToKeyTypeOneStatus != null && message.hasOwnProperty("changeToKeyTypeOneStatus")) {
                if (!Array.isArray(message.changeToKeyTypeOneStatus))
                    return "changeToKeyTypeOneStatus: array expected";
                for (let i = 0; i < message.changeToKeyTypeOneStatus.length; ++i) {
                    let error = $root.Authentication.ChangeToKeyTypeOneStatus.verify(message.changeToKeyTypeOneStatus[i]);
                    if (error)
                        return "changeToKeyTypeOneStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         */
        ChangeToKeyTypeOneResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneResponse)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneResponse();
            if (object.changeToKeyTypeOneStatus) {
                if (!Array.isArray(object.changeToKeyTypeOneStatus))
                    throw TypeError(".Authentication.ChangeToKeyTypeOneResponse.changeToKeyTypeOneStatus: array expected");
                message.changeToKeyTypeOneStatus = [];
                for (let i = 0; i < object.changeToKeyTypeOneStatus.length; ++i) {
                    if (typeof object.changeToKeyTypeOneStatus[i] !== "object")
                        throw TypeError(".Authentication.ChangeToKeyTypeOneResponse.changeToKeyTypeOneStatus: object expected");
                    message.changeToKeyTypeOneStatus[i] = $root.Authentication.ChangeToKeyTypeOneStatus.fromObject(object.changeToKeyTypeOneStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.ChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.changeToKeyTypeOneStatus = [];
            if (message.changeToKeyTypeOneStatus && message.changeToKeyTypeOneStatus.length) {
                object.changeToKeyTypeOneStatus = [];
                for (let j = 0; j < message.changeToKeyTypeOneStatus.length; ++j)
                    object.changeToKeyTypeOneStatus[j] = $root.Authentication.ChangeToKeyTypeOneStatus.toObject(message.changeToKeyTypeOneStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneResponse to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneResponse;
    })();

    /**
     * ProcessTokenType enum.
     * @name Authentication.ProcessTokenType
     * @enum {string}
     * @property {number} CHANGE_EMAIL=0 CHANGE_EMAIL value
     * @property {number} EMAIL_VERIFICATION=1 EMAIL_VERIFICATION value
     * @property {number} IP_ADDRESS_VERIFICATION=2 IP_ADDRESS_VERIFICATION value
     */
    Authentication.ProcessTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CHANGE_EMAIL"] = 0;
        values[valuesById[1] = "EMAIL_VERIFICATION"] = 1;
        values[valuesById[2] = "IP_ADDRESS_VERIFICATION"] = 2;
        return values;
    })();

    Authentication.ProcessToken = (function() {

        /**
         * Properties of a ProcessToken.
         * @memberof Authentication
         * @interface IProcessToken
         * @property {Authentication.ProcessTokenType|null} [processTokenType] ProcessToken processTokenType
         * @property {Uint8Array|null} [payload] ProcessToken payload
         */

        /**
         * Constructs a new ProcessToken.
         * @memberof Authentication
         * @classdesc Represents a ProcessToken.
         * @implements IProcessToken
         * @constructor
         * @param {Authentication.IProcessToken=} [properties] Properties to set
         */
        function ProcessToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProcessToken processTokenType.
         * @member {Authentication.ProcessTokenType} processTokenType
         * @memberof Authentication.ProcessToken
         * @instance
         */
        ProcessToken.prototype.processTokenType = 0;

        /**
         * ProcessToken payload.
         * @member {Uint8Array} payload
         * @memberof Authentication.ProcessToken
         * @instance
         */
        ProcessToken.prototype.payload = $util.newBuffer([]);

        /**
         * Creates a new ProcessToken instance using the specified properties.
         * @function create
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Authentication.IProcessToken=} [properties] Properties to set
         * @returns {Authentication.ProcessToken} ProcessToken instance
         */
        ProcessToken.create = function create(properties) {
            return new ProcessToken(properties);
        };

        /**
         * Encodes the specified ProcessToken message. Does not implicitly {@link Authentication.ProcessToken.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Authentication.IProcessToken} message ProcessToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.processTokenType);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ProcessToken message, length delimited. Does not implicitly {@link Authentication.ProcessToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Authentication.IProcessToken} message ProcessToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProcessToken message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ProcessToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ProcessToken} ProcessToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ProcessToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.processTokenType = reader.int32();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProcessToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ProcessToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ProcessToken} ProcessToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProcessToken message.
         * @function verify
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProcessToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                switch (message.processTokenType) {
                default:
                    return "processTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            return null;
        };

        /**
         * Creates a ProcessToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ProcessToken} ProcessToken
         */
        ProcessToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ProcessToken)
                return object;
            let message = new $root.Authentication.ProcessToken();
            switch (object.processTokenType) {
            case "CHANGE_EMAIL":
            case 0:
                message.processTokenType = 0;
                break;
            case "EMAIL_VERIFICATION":
            case 1:
                message.processTokenType = 1;
                break;
            case "IP_ADDRESS_VERIFICATION":
            case 2:
                message.processTokenType = 2;
                break;
            }
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            return message;
        };

        /**
         * Creates a plain object from a ProcessToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ProcessToken
         * @static
         * @param {Authentication.ProcessToken} message ProcessToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProcessToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.processTokenType = options.enums === String ? "CHANGE_EMAIL" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
            }
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                object.processTokenType = options.enums === String ? $root.Authentication.ProcessTokenType[message.processTokenType] : message.processTokenType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            return object;
        };

        /**
         * Converts this ProcessToken to JSON.
         * @function toJSON
         * @memberof Authentication.ProcessToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProcessToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProcessToken;
    })();

    Authentication.SetKey = (function() {

        /**
         * Properties of a SetKey.
         * @memberof Authentication
         * @interface ISetKey
         * @property {number|Long|null} [id] SetKey id
         * @property {Uint8Array|null} [key] SetKey key
         */

        /**
         * Constructs a new SetKey.
         * @memberof Authentication
         * @classdesc Represents a SetKey.
         * @implements ISetKey
         * @constructor
         * @param {Authentication.ISetKey=} [properties] Properties to set
         */
        function SetKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetKey id.
         * @member {number|Long} id
         * @memberof Authentication.SetKey
         * @instance
         */
        SetKey.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetKey key.
         * @member {Uint8Array} key
         * @memberof Authentication.SetKey
         * @instance
         */
        SetKey.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new SetKey instance using the specified properties.
         * @function create
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey=} [properties] Properties to set
         * @returns {Authentication.SetKey} SetKey instance
         */
        SetKey.create = function create(properties) {
            return new SetKey(properties);
        };

        /**
         * Encodes the specified SetKey message. Does not implicitly {@link Authentication.SetKey.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey} message SetKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified SetKey message, length delimited. Does not implicitly {@link Authentication.SetKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey} message SetKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetKey message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SetKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SetKey} SetKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SetKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SetKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SetKey} SetKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetKey message.
         * @function verify
         * @memberof Authentication.SetKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a SetKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SetKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SetKey} SetKey
         */
        SetKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SetKey)
                return object;
            let message = new $root.Authentication.SetKey();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a SetKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.SetKey} message SetKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this SetKey to JSON.
         * @function toJSON
         * @memberof Authentication.SetKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetKey;
    })();

    Authentication.SetKeyRequest = (function() {

        /**
         * Properties of a SetKeyRequest.
         * @memberof Authentication
         * @interface ISetKeyRequest
         * @property {Array.<Authentication.ISetKey>|null} [keys] SetKeyRequest keys
         */

        /**
         * Constructs a new SetKeyRequest.
         * @memberof Authentication
         * @classdesc Represents a SetKeyRequest.
         * @implements ISetKeyRequest
         * @constructor
         * @param {Authentication.ISetKeyRequest=} [properties] Properties to set
         */
        function SetKeyRequest(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetKeyRequest keys.
         * @member {Array.<Authentication.ISetKey>} keys
         * @memberof Authentication.SetKeyRequest
         * @instance
         */
        SetKeyRequest.prototype.keys = $util.emptyArray;

        /**
         * Creates a new SetKeyRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest=} [properties] Properties to set
         * @returns {Authentication.SetKeyRequest} SetKeyRequest instance
         */
        SetKeyRequest.create = function create(properties) {
            return new SetKeyRequest(properties);
        };

        /**
         * Encodes the specified SetKeyRequest message. Does not implicitly {@link Authentication.SetKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest} message SetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (let i = 0; i < message.keys.length; ++i)
                    $root.Authentication.SetKey.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetKeyRequest message, length delimited. Does not implicitly {@link Authentication.SetKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest} message SetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SetKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.Authentication.SetKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetKeyRequest message.
         * @function verify
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (let i = 0; i < message.keys.length; ++i) {
                    let error = $root.Authentication.SetKey.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SetKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         */
        SetKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SetKeyRequest)
                return object;
            let message = new $root.Authentication.SetKeyRequest();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".Authentication.SetKeyRequest.keys: array expected");
                message.keys = [];
                for (let i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".Authentication.SetKeyRequest.keys: object expected");
                    message.keys[i] = $root.Authentication.SetKey.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.SetKeyRequest} message SetKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (let j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.Authentication.SetKey.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this SetKeyRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SetKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetKeyRequest;
    })();

    Authentication.AuthenticateViaEmail = (function() {

        /**
         * Properties of an AuthenticateViaEmail.
         * @memberof Authentication
         * @interface IAuthenticateViaEmail
         * @property {string|null} [email] AuthenticateViaEmail email
         * @property {boolean|null} [resend] AuthenticateViaEmail resend
         * @property {string|null} [locale] AuthenticateViaEmail locale
         */

        /**
         * Constructs a new AuthenticateViaEmail.
         * @memberof Authentication
         * @classdesc Represents an AuthenticateViaEmail.
         * @implements IAuthenticateViaEmail
         * @constructor
         * @param {Authentication.IAuthenticateViaEmail=} [properties] Properties to set
         */
        function AuthenticateViaEmail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthenticateViaEmail email.
         * @member {string} email
         * @memberof Authentication.AuthenticateViaEmail
         * @instance
         */
        AuthenticateViaEmail.prototype.email = "";

        /**
         * AuthenticateViaEmail resend.
         * @member {boolean} resend
         * @memberof Authentication.AuthenticateViaEmail
         * @instance
         */
        AuthenticateViaEmail.prototype.resend = false;

        /**
         * AuthenticateViaEmail locale.
         * @member {string} locale
         * @memberof Authentication.AuthenticateViaEmail
         * @instance
         */
        AuthenticateViaEmail.prototype.locale = "";

        /**
         * Creates a new AuthenticateViaEmail instance using the specified properties.
         * @function create
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Authentication.IAuthenticateViaEmail=} [properties] Properties to set
         * @returns {Authentication.AuthenticateViaEmail} AuthenticateViaEmail instance
         */
        AuthenticateViaEmail.create = function create(properties) {
            return new AuthenticateViaEmail(properties);
        };

        /**
         * Encodes the specified AuthenticateViaEmail message. Does not implicitly {@link Authentication.AuthenticateViaEmail.verify|verify} messages.
         * @function encode
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Authentication.IAuthenticateViaEmail} message AuthenticateViaEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticateViaEmail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.resend != null && message.hasOwnProperty("resend"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.resend);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            return writer;
        };

        /**
         * Encodes the specified AuthenticateViaEmail message, length delimited. Does not implicitly {@link Authentication.AuthenticateViaEmail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Authentication.IAuthenticateViaEmail} message AuthenticateViaEmail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthenticateViaEmail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthenticateViaEmail message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.AuthenticateViaEmail} AuthenticateViaEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticateViaEmail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.AuthenticateViaEmail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.resend = reader.bool();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthenticateViaEmail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.AuthenticateViaEmail} AuthenticateViaEmail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthenticateViaEmail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthenticateViaEmail message.
         * @function verify
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthenticateViaEmail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.resend != null && message.hasOwnProperty("resend"))
                if (typeof message.resend !== "boolean")
                    return "resend: boolean expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            return null;
        };

        /**
         * Creates an AuthenticateViaEmail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.AuthenticateViaEmail} AuthenticateViaEmail
         */
        AuthenticateViaEmail.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.AuthenticateViaEmail)
                return object;
            let message = new $root.Authentication.AuthenticateViaEmail();
            if (object.email != null)
                message.email = String(object.email);
            if (object.resend != null)
                message.resend = Boolean(object.resend);
            if (object.locale != null)
                message.locale = String(object.locale);
            return message;
        };

        /**
         * Creates a plain object from an AuthenticateViaEmail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.AuthenticateViaEmail
         * @static
         * @param {Authentication.AuthenticateViaEmail} message AuthenticateViaEmail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthenticateViaEmail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.resend = false;
                object.locale = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.resend != null && message.hasOwnProperty("resend"))
                object.resend = message.resend;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            return object;
        };

        /**
         * Converts this AuthenticateViaEmail to JSON.
         * @function toJSON
         * @memberof Authentication.AuthenticateViaEmail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthenticateViaEmail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthenticateViaEmail;
    })();

    Authentication.RegisterUserRequest = (function() {

        /**
         * Properties of a RegisterUserRequest.
         * @memberof Authentication
         * @interface IRegisterUserRequest
         * @property {string|null} [email] RegisterUserRequest email
         * @property {Authentication.Version|null} [version] RegisterUserRequest version
         * @property {Uint8Array|null} [authVerifier] RegisterUserRequest authVerifier
         * @property {Uint8Array|null} [encryptionParams] RegisterUserRequest encryptionParams
         * @property {Uint8Array|null} [publicKey] RegisterUserRequest publicKey
         * @property {Uint8Array|null} [encryptedPrivateKey] RegisterUserRequest encryptedPrivateKey
         * @property {string|null} [installReferrer] RegisterUserRequest installReferrer
         * @property {Uint8Array|null} [clientKey] RegisterUserRequest clientKey
         * @property {string|null} [deviceUid] RegisterUserRequest deviceUid
         * @property {number|null} [mccMNC] RegisterUserRequest mccMNC
         * @property {string|null} [mfg] RegisterUserRequest mfg
         * @property {string|null} [model] RegisterUserRequest model
         * @property {string|null} [brand] RegisterUserRequest brand
         * @property {string|null} [product] RegisterUserRequest product
         * @property {string|null} [pushToken] RegisterUserRequest pushToken
         * @property {string|null} [device] RegisterUserRequest device
         * @property {string|null} [carrier] RegisterUserRequest carrier
         * @property {boolean|null} [skipGroupAccept] RegisterUserRequest skipGroupAccept
         * @property {string|null} [locale] RegisterUserRequest locale
         * @property {string|null} [clientVersion] RegisterUserRequest clientVersion
         * @property {string|null} [ipAddress] RegisterUserRequest ipAddress
         * @property {boolean|null} [fromSP] RegisterUserRequest fromSP
         * @property {string|null} [verificationCode] RegisterUserRequest verificationCode
         * @property {Uint8Array|null} [encryptedDeviceToken] RegisterUserRequest encryptedDeviceToken
         */

        /**
         * Constructs a new RegisterUserRequest.
         * @memberof Authentication
         * @classdesc Represents a RegisterUserRequest.
         * @implements IRegisterUserRequest
         * @constructor
         * @param {Authentication.IRegisterUserRequest=} [properties] Properties to set
         */
        function RegisterUserRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterUserRequest email.
         * @member {string} email
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.email = "";

        /**
         * RegisterUserRequest version.
         * @member {Authentication.Version} version
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.version = 0;

        /**
         * RegisterUserRequest authVerifier.
         * @member {Uint8Array} authVerifier
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.authVerifier = $util.newBuffer([]);

        /**
         * RegisterUserRequest encryptionParams.
         * @member {Uint8Array} encryptionParams
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.encryptionParams = $util.newBuffer([]);

        /**
         * RegisterUserRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * RegisterUserRequest encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * RegisterUserRequest installReferrer.
         * @member {string} installReferrer
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.installReferrer = "";

        /**
         * RegisterUserRequest clientKey.
         * @member {Uint8Array} clientKey
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.clientKey = $util.newBuffer([]);

        /**
         * RegisterUserRequest deviceUid.
         * @member {string} deviceUid
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.deviceUid = "";

        /**
         * RegisterUserRequest mccMNC.
         * @member {number} mccMNC
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.mccMNC = 0;

        /**
         * RegisterUserRequest mfg.
         * @member {string} mfg
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.mfg = "";

        /**
         * RegisterUserRequest model.
         * @member {string} model
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.model = "";

        /**
         * RegisterUserRequest brand.
         * @member {string} brand
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.brand = "";

        /**
         * RegisterUserRequest product.
         * @member {string} product
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.product = "";

        /**
         * RegisterUserRequest pushToken.
         * @member {string} pushToken
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.pushToken = "";

        /**
         * RegisterUserRequest device.
         * @member {string} device
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.device = "";

        /**
         * RegisterUserRequest carrier.
         * @member {string} carrier
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.carrier = "";

        /**
         * RegisterUserRequest skipGroupAccept.
         * @member {boolean} skipGroupAccept
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.skipGroupAccept = false;

        /**
         * RegisterUserRequest locale.
         * @member {string} locale
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.locale = "";

        /**
         * RegisterUserRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.clientVersion = "";

        /**
         * RegisterUserRequest ipAddress.
         * @member {string} ipAddress
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.ipAddress = "";

        /**
         * RegisterUserRequest fromSP.
         * @member {boolean} fromSP
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.fromSP = false;

        /**
         * RegisterUserRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.verificationCode = "";

        /**
         * RegisterUserRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.RegisterUserRequest
         * @instance
         */
        RegisterUserRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new RegisterUserRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Authentication.IRegisterUserRequest=} [properties] Properties to set
         * @returns {Authentication.RegisterUserRequest} RegisterUserRequest instance
         */
        RegisterUserRequest.create = function create(properties) {
            return new RegisterUserRequest(properties);
        };

        /**
         * Encodes the specified RegisterUserRequest message. Does not implicitly {@link Authentication.RegisterUserRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Authentication.IRegisterUserRequest} message RegisterUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterUserRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.authVerifier);
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptionParams);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedPrivateKey);
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.installReferrer);
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.clientKey);
            if (message.deviceUid != null && message.hasOwnProperty("deviceUid"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.deviceUid);
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.mccMNC);
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.mfg);
            if (message.model != null && message.hasOwnProperty("model"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.model);
            if (message.brand != null && message.hasOwnProperty("brand"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.brand);
            if (message.product != null && message.hasOwnProperty("product"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.product);
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.pushToken);
            if (message.device != null && message.hasOwnProperty("device"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.device);
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.carrier);
            if (message.skipGroupAccept != null && message.hasOwnProperty("skipGroupAccept"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.skipGroupAccept);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.locale);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.clientVersion);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.ipAddress);
            if (message.fromSP != null && message.hasOwnProperty("fromSP"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.fromSP);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 23, wireType 2 =*/186).string(message.verificationCode);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 24, wireType 2 =*/194).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified RegisterUserRequest message, length delimited. Does not implicitly {@link Authentication.RegisterUserRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Authentication.IRegisterUserRequest} message RegisterUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterUserRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegisterUserRequest} RegisterUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterUserRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegisterUserRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                case 3:
                    message.authVerifier = reader.bytes();
                    break;
                case 4:
                    message.encryptionParams = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                case 6:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                case 7:
                    message.installReferrer = reader.string();
                    break;
                case 8:
                    message.clientKey = reader.bytes();
                    break;
                case 9:
                    message.deviceUid = reader.string();
                    break;
                case 10:
                    message.mccMNC = reader.int32();
                    break;
                case 11:
                    message.mfg = reader.string();
                    break;
                case 12:
                    message.model = reader.string();
                    break;
                case 13:
                    message.brand = reader.string();
                    break;
                case 14:
                    message.product = reader.string();
                    break;
                case 15:
                    message.pushToken = reader.string();
                    break;
                case 16:
                    message.device = reader.string();
                    break;
                case 17:
                    message.carrier = reader.string();
                    break;
                case 18:
                    message.skipGroupAccept = reader.bool();
                    break;
                case 19:
                    message.locale = reader.string();
                    break;
                case 20:
                    message.clientVersion = reader.string();
                    break;
                case 21:
                    message.ipAddress = reader.string();
                    break;
                case 22:
                    message.fromSP = reader.bool();
                    break;
                case 23:
                    message.verificationCode = reader.string();
                    break;
                case 24:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterUserRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegisterUserRequest} RegisterUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterUserRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterUserRequest message.
         * @function verify
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterUserRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                switch (message.version) {
                default:
                    return "version: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                if (!(message.authVerifier && typeof message.authVerifier.length === "number" || $util.isString(message.authVerifier)))
                    return "authVerifier: buffer expected";
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                if (!(message.encryptionParams && typeof message.encryptionParams.length === "number" || $util.isString(message.encryptionParams)))
                    return "encryptionParams: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                if (!$util.isString(message.installReferrer))
                    return "installReferrer: string expected";
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                if (!(message.clientKey && typeof message.clientKey.length === "number" || $util.isString(message.clientKey)))
                    return "clientKey: buffer expected";
            if (message.deviceUid != null && message.hasOwnProperty("deviceUid"))
                if (!$util.isString(message.deviceUid))
                    return "deviceUid: string expected";
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                if (!$util.isInteger(message.mccMNC))
                    return "mccMNC: integer expected";
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                if (!$util.isString(message.mfg))
                    return "mfg: string expected";
            if (message.model != null && message.hasOwnProperty("model"))
                if (!$util.isString(message.model))
                    return "model: string expected";
            if (message.brand != null && message.hasOwnProperty("brand"))
                if (!$util.isString(message.brand))
                    return "brand: string expected";
            if (message.product != null && message.hasOwnProperty("product"))
                if (!$util.isString(message.product))
                    return "product: string expected";
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                if (!$util.isString(message.pushToken))
                    return "pushToken: string expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                if (!$util.isString(message.carrier))
                    return "carrier: string expected";
            if (message.skipGroupAccept != null && message.hasOwnProperty("skipGroupAccept"))
                if (typeof message.skipGroupAccept !== "boolean")
                    return "skipGroupAccept: boolean expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.fromSP != null && message.hasOwnProperty("fromSP"))
                if (typeof message.fromSP !== "boolean")
                    return "fromSP: boolean expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a RegisterUserRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegisterUserRequest} RegisterUserRequest
         */
        RegisterUserRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegisterUserRequest)
                return object;
            let message = new $root.Authentication.RegisterUserRequest();
            if (object.email != null)
                message.email = String(object.email);
            switch (object.version) {
            case "invalid_version":
            case 0:
                message.version = 0;
                break;
            case "default_version":
            case 1:
                message.version = 1;
                break;
            case "second_version":
            case 2:
                message.version = 2;
                break;
            }
            if (object.authVerifier != null)
                if (typeof object.authVerifier === "string")
                    $util.base64.decode(object.authVerifier, message.authVerifier = $util.newBuffer($util.base64.length(object.authVerifier)), 0);
                else if (object.authVerifier.length)
                    message.authVerifier = object.authVerifier;
            if (object.encryptionParams != null)
                if (typeof object.encryptionParams === "string")
                    $util.base64.decode(object.encryptionParams, message.encryptionParams = $util.newBuffer($util.base64.length(object.encryptionParams)), 0);
                else if (object.encryptionParams.length)
                    message.encryptionParams = object.encryptionParams;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            if (object.installReferrer != null)
                message.installReferrer = String(object.installReferrer);
            if (object.clientKey != null)
                if (typeof object.clientKey === "string")
                    $util.base64.decode(object.clientKey, message.clientKey = $util.newBuffer($util.base64.length(object.clientKey)), 0);
                else if (object.clientKey.length)
                    message.clientKey = object.clientKey;
            if (object.deviceUid != null)
                message.deviceUid = String(object.deviceUid);
            if (object.mccMNC != null)
                message.mccMNC = object.mccMNC | 0;
            if (object.mfg != null)
                message.mfg = String(object.mfg);
            if (object.model != null)
                message.model = String(object.model);
            if (object.brand != null)
                message.brand = String(object.brand);
            if (object.product != null)
                message.product = String(object.product);
            if (object.pushToken != null)
                message.pushToken = String(object.pushToken);
            if (object.device != null)
                message.device = String(object.device);
            if (object.carrier != null)
                message.carrier = String(object.carrier);
            if (object.skipGroupAccept != null)
                message.skipGroupAccept = Boolean(object.skipGroupAccept);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.fromSP != null)
                message.fromSP = Boolean(object.fromSP);
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a RegisterUserRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegisterUserRequest
         * @static
         * @param {Authentication.RegisterUserRequest} message RegisterUserRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterUserRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.version = options.enums === String ? "invalid_version" : 0;
                if (options.bytes === String)
                    object.authVerifier = "";
                else {
                    object.authVerifier = [];
                    if (options.bytes !== Array)
                        object.authVerifier = $util.newBuffer(object.authVerifier);
                }
                if (options.bytes === String)
                    object.encryptionParams = "";
                else {
                    object.encryptionParams = [];
                    if (options.bytes !== Array)
                        object.encryptionParams = $util.newBuffer(object.encryptionParams);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
                object.installReferrer = "";
                if (options.bytes === String)
                    object.clientKey = "";
                else {
                    object.clientKey = [];
                    if (options.bytes !== Array)
                        object.clientKey = $util.newBuffer(object.clientKey);
                }
                object.deviceUid = "";
                object.mccMNC = 0;
                object.mfg = "";
                object.model = "";
                object.brand = "";
                object.product = "";
                object.pushToken = "";
                object.device = "";
                object.carrier = "";
                object.skipGroupAccept = false;
                object.locale = "";
                object.clientVersion = "";
                object.ipAddress = "";
                object.fromSP = false;
                object.verificationCode = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = options.enums === String ? $root.Authentication.Version[message.version] : message.version;
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                object.authVerifier = options.bytes === String ? $util.base64.encode(message.authVerifier, 0, message.authVerifier.length) : options.bytes === Array ? Array.prototype.slice.call(message.authVerifier) : message.authVerifier;
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                object.encryptionParams = options.bytes === String ? $util.base64.encode(message.encryptionParams, 0, message.encryptionParams.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptionParams) : message.encryptionParams;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                object.installReferrer = message.installReferrer;
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                object.clientKey = options.bytes === String ? $util.base64.encode(message.clientKey, 0, message.clientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientKey) : message.clientKey;
            if (message.deviceUid != null && message.hasOwnProperty("deviceUid"))
                object.deviceUid = message.deviceUid;
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                object.mccMNC = message.mccMNC;
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                object.mfg = message.mfg;
            if (message.model != null && message.hasOwnProperty("model"))
                object.model = message.model;
            if (message.brand != null && message.hasOwnProperty("brand"))
                object.brand = message.brand;
            if (message.product != null && message.hasOwnProperty("product"))
                object.product = message.product;
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                object.pushToken = message.pushToken;
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                object.carrier = message.carrier;
            if (message.skipGroupAccept != null && message.hasOwnProperty("skipGroupAccept"))
                object.skipGroupAccept = message.skipGroupAccept;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.fromSP != null && message.hasOwnProperty("fromSP"))
                object.fromSP = message.fromSP;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this RegisterUserRequest to JSON.
         * @function toJSON
         * @memberof Authentication.RegisterUserRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterUserRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterUserRequest;
    })();

    Authentication.RegisterUserResponse = (function() {

        /**
         * Properties of a RegisterUserResponse.
         * @memberof Authentication
         * @interface IRegisterUserResponse
         * @property {number|null} [emailId] RegisterUserResponse emailId
         * @property {number|null} [userId] RegisterUserResponse userId
         * @property {Uint8Array|null} [userUid] RegisterUserResponse userUid
         */

        /**
         * Constructs a new RegisterUserResponse.
         * @memberof Authentication
         * @classdesc Represents a RegisterUserResponse.
         * @implements IRegisterUserResponse
         * @constructor
         * @param {Authentication.IRegisterUserResponse=} [properties] Properties to set
         */
        function RegisterUserResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterUserResponse emailId.
         * @member {number} emailId
         * @memberof Authentication.RegisterUserResponse
         * @instance
         */
        RegisterUserResponse.prototype.emailId = 0;

        /**
         * RegisterUserResponse userId.
         * @member {number} userId
         * @memberof Authentication.RegisterUserResponse
         * @instance
         */
        RegisterUserResponse.prototype.userId = 0;

        /**
         * RegisterUserResponse userUid.
         * @member {Uint8Array} userUid
         * @memberof Authentication.RegisterUserResponse
         * @instance
         */
        RegisterUserResponse.prototype.userUid = $util.newBuffer([]);

        /**
         * Creates a new RegisterUserResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Authentication.IRegisterUserResponse=} [properties] Properties to set
         * @returns {Authentication.RegisterUserResponse} RegisterUserResponse instance
         */
        RegisterUserResponse.create = function create(properties) {
            return new RegisterUserResponse(properties);
        };

        /**
         * Encodes the specified RegisterUserResponse message. Does not implicitly {@link Authentication.RegisterUserResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Authentication.IRegisterUserResponse} message RegisterUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterUserResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailId != null && message.hasOwnProperty("emailId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.emailId);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            if (message.userUid != null && message.hasOwnProperty("userUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.userUid);
            return writer;
        };

        /**
         * Encodes the specified RegisterUserResponse message, length delimited. Does not implicitly {@link Authentication.RegisterUserResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Authentication.IRegisterUserResponse} message RegisterUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterUserResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegisterUserResponse} RegisterUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterUserResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegisterUserResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailId = reader.int32();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                case 3:
                    message.userUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterUserResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegisterUserResponse} RegisterUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterUserResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterUserResponse message.
         * @function verify
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterUserResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailId != null && message.hasOwnProperty("emailId"))
                if (!$util.isInteger(message.emailId))
                    return "emailId: integer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.userUid != null && message.hasOwnProperty("userUid"))
                if (!(message.userUid && typeof message.userUid.length === "number" || $util.isString(message.userUid)))
                    return "userUid: buffer expected";
            return null;
        };

        /**
         * Creates a RegisterUserResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegisterUserResponse} RegisterUserResponse
         */
        RegisterUserResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegisterUserResponse)
                return object;
            let message = new $root.Authentication.RegisterUserResponse();
            if (object.emailId != null)
                message.emailId = object.emailId | 0;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.userUid != null)
                if (typeof object.userUid === "string")
                    $util.base64.decode(object.userUid, message.userUid = $util.newBuffer($util.base64.length(object.userUid)), 0);
                else if (object.userUid.length)
                    message.userUid = object.userUid;
            return message;
        };

        /**
         * Creates a plain object from a RegisterUserResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegisterUserResponse
         * @static
         * @param {Authentication.RegisterUserResponse} message RegisterUserResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterUserResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.emailId = 0;
                object.userId = 0;
                if (options.bytes === String)
                    object.userUid = "";
                else {
                    object.userUid = [];
                    if (options.bytes !== Array)
                        object.userUid = $util.newBuffer(object.userUid);
                }
            }
            if (message.emailId != null && message.hasOwnProperty("emailId"))
                object.emailId = message.emailId;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.userUid != null && message.hasOwnProperty("userUid"))
                object.userUid = options.bytes === String ? $util.base64.encode(message.userUid, 0, message.userUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.userUid) : message.userUid;
            return object;
        };

        /**
         * Converts this RegisterUserResponse to JSON.
         * @function toJSON
         * @memberof Authentication.RegisterUserResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterUserResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterUserResponse;
    })();

    Authentication.DeviceVerification = (function() {

        /**
         * Properties of a DeviceVerification.
         * @memberof Authentication
         * @interface IDeviceVerification
         * @property {string|null} [email] DeviceVerification email
         * @property {string|null} [twoFactorChannel] DeviceVerification twoFactorChannel
         * @property {string|null} [clientVersion] DeviceVerification clientVersion
         * @property {string|null} [locale] DeviceVerification locale
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceVerification encryptedDeviceToken
         */

        /**
         * Constructs a new DeviceVerification.
         * @memberof Authentication
         * @classdesc Represents a DeviceVerification.
         * @implements IDeviceVerification
         * @constructor
         * @param {Authentication.IDeviceVerification=} [properties] Properties to set
         */
        function DeviceVerification(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceVerification email.
         * @member {string} email
         * @memberof Authentication.DeviceVerification
         * @instance
         */
        DeviceVerification.prototype.email = "";

        /**
         * DeviceVerification twoFactorChannel.
         * @member {string} twoFactorChannel
         * @memberof Authentication.DeviceVerification
         * @instance
         */
        DeviceVerification.prototype.twoFactorChannel = "";

        /**
         * DeviceVerification clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceVerification
         * @instance
         */
        DeviceVerification.prototype.clientVersion = "";

        /**
         * DeviceVerification locale.
         * @member {string} locale
         * @memberof Authentication.DeviceVerification
         * @instance
         */
        DeviceVerification.prototype.locale = "";

        /**
         * DeviceVerification encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceVerification
         * @instance
         */
        DeviceVerification.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new DeviceVerification instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Authentication.IDeviceVerification=} [properties] Properties to set
         * @returns {Authentication.DeviceVerification} DeviceVerification instance
         */
        DeviceVerification.create = function create(properties) {
            return new DeviceVerification(properties);
        };

        /**
         * Encodes the specified DeviceVerification message. Does not implicitly {@link Authentication.DeviceVerification.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Authentication.IDeviceVerification} message DeviceVerification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerification.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.twoFactorChannel);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.locale);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified DeviceVerification message, length delimited. Does not implicitly {@link Authentication.DeviceVerification.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Authentication.IDeviceVerification} message DeviceVerification message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerification.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceVerification message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceVerification} DeviceVerification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerification.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceVerification();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.twoFactorChannel = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.locale = reader.string();
                    break;
                case 5:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceVerification message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceVerification} DeviceVerification
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerification.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceVerification message.
         * @function verify
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceVerification.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                if (!$util.isString(message.twoFactorChannel))
                    return "twoFactorChannel: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a DeviceVerification message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceVerification} DeviceVerification
         */
        DeviceVerification.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceVerification)
                return object;
            let message = new $root.Authentication.DeviceVerification();
            if (object.email != null)
                message.email = String(object.email);
            if (object.twoFactorChannel != null)
                message.twoFactorChannel = String(object.twoFactorChannel);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a DeviceVerification message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceVerification
         * @static
         * @param {Authentication.DeviceVerification} message DeviceVerification
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceVerification.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.twoFactorChannel = "";
                object.clientVersion = "";
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                object.twoFactorChannel = message.twoFactorChannel;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this DeviceVerification to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceVerification
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceVerification.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceVerification;
    })();

    Authentication.DeviceApprovalRequest = (function() {

        /**
         * Properties of a DeviceApprovalRequest.
         * @memberof Authentication
         * @interface IDeviceApprovalRequest
         * @property {string|null} [email] DeviceApprovalRequest email
         * @property {string|null} [twoFactorChannel] DeviceApprovalRequest twoFactorChannel
         * @property {string|null} [clientVersion] DeviceApprovalRequest clientVersion
         * @property {string|null} [locale] DeviceApprovalRequest locale
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceApprovalRequest encryptedDeviceToken
         * @property {string|null} [totpCode] DeviceApprovalRequest totpCode
         * @property {string|null} [deviceIp] DeviceApprovalRequest deviceIp
         * @property {string|null} [deviceTokenExpireDays] DeviceApprovalRequest deviceTokenExpireDays
         */

        /**
         * Constructs a new DeviceApprovalRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceApprovalRequest.
         * @implements IDeviceApprovalRequest
         * @constructor
         * @param {Authentication.IDeviceApprovalRequest=} [properties] Properties to set
         */
        function DeviceApprovalRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalRequest email.
         * @member {string} email
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.email = "";

        /**
         * DeviceApprovalRequest twoFactorChannel.
         * @member {string} twoFactorChannel
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.twoFactorChannel = "";

        /**
         * DeviceApprovalRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.clientVersion = "";

        /**
         * DeviceApprovalRequest locale.
         * @member {string} locale
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.locale = "";

        /**
         * DeviceApprovalRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceApprovalRequest totpCode.
         * @member {string} totpCode
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.totpCode = "";

        /**
         * DeviceApprovalRequest deviceIp.
         * @member {string} deviceIp
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.deviceIp = "";

        /**
         * DeviceApprovalRequest deviceTokenExpireDays.
         * @member {string} deviceTokenExpireDays
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.deviceTokenExpireDays = "";

        /**
         * Creates a new DeviceApprovalRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest instance
         */
        DeviceApprovalRequest.create = function create(properties) {
            return new DeviceApprovalRequest(properties);
        };

        /**
         * Encodes the specified DeviceApprovalRequest message. Does not implicitly {@link Authentication.DeviceApprovalRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest} message DeviceApprovalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.twoFactorChannel);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.locale);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedDeviceToken);
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.totpCode);
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.deviceIp);
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.deviceTokenExpireDays);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalRequest message, length delimited. Does not implicitly {@link Authentication.DeviceApprovalRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest} message DeviceApprovalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceApprovalRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.twoFactorChannel = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.locale = reader.string();
                    break;
                case 5:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 6:
                    message.totpCode = reader.string();
                    break;
                case 7:
                    message.deviceIp = reader.string();
                    break;
                case 8:
                    message.deviceTokenExpireDays = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalRequest message.
         * @function verify
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                if (!$util.isString(message.twoFactorChannel))
                    return "twoFactorChannel: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                if (!$util.isString(message.totpCode))
                    return "totpCode: string expected";
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                if (!$util.isString(message.deviceIp))
                    return "deviceIp: string expected";
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                if (!$util.isString(message.deviceTokenExpireDays))
                    return "deviceTokenExpireDays: string expected";
            return null;
        };

        /**
         * Creates a DeviceApprovalRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         */
        DeviceApprovalRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceApprovalRequest)
                return object;
            let message = new $root.Authentication.DeviceApprovalRequest();
            if (object.email != null)
                message.email = String(object.email);
            if (object.twoFactorChannel != null)
                message.twoFactorChannel = String(object.twoFactorChannel);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.totpCode != null)
                message.totpCode = String(object.totpCode);
            if (object.deviceIp != null)
                message.deviceIp = String(object.deviceIp);
            if (object.deviceTokenExpireDays != null)
                message.deviceTokenExpireDays = String(object.deviceTokenExpireDays);
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.DeviceApprovalRequest} message DeviceApprovalRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.twoFactorChannel = "";
                object.clientVersion = "";
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.totpCode = "";
                object.deviceIp = "";
                object.deviceTokenExpireDays = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                object.twoFactorChannel = message.twoFactorChannel;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                object.totpCode = message.totpCode;
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                object.deviceIp = message.deviceIp;
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                object.deviceTokenExpireDays = message.deviceTokenExpireDays;
            return object;
        };

        /**
         * Converts this DeviceApprovalRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalRequest;
    })();

    Authentication.DeviceApprovalResponse = (function() {

        /**
         * Properties of a DeviceApprovalResponse.
         * @memberof Authentication
         * @interface IDeviceApprovalResponse
         * @property {Uint8Array|null} [encryptedTwoFactorToken] DeviceApprovalResponse encryptedTwoFactorToken
         */

        /**
         * Constructs a new DeviceApprovalResponse.
         * @memberof Authentication
         * @classdesc Represents a DeviceApprovalResponse.
         * @implements IDeviceApprovalResponse
         * @constructor
         * @param {Authentication.IDeviceApprovalResponse=} [properties] Properties to set
         */
        function DeviceApprovalResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalResponse encryptedTwoFactorToken.
         * @member {Uint8Array} encryptedTwoFactorToken
         * @memberof Authentication.DeviceApprovalResponse
         * @instance
         */
        DeviceApprovalResponse.prototype.encryptedTwoFactorToken = $util.newBuffer([]);

        /**
         * Creates a new DeviceApprovalResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse=} [properties] Properties to set
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse instance
         */
        DeviceApprovalResponse.create = function create(properties) {
            return new DeviceApprovalResponse(properties);
        };

        /**
         * Encodes the specified DeviceApprovalResponse message. Does not implicitly {@link Authentication.DeviceApprovalResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse} message DeviceApprovalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTwoFactorToken);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalResponse message, length delimited. Does not implicitly {@link Authentication.DeviceApprovalResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse} message DeviceApprovalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceApprovalResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTwoFactorToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalResponse message.
         * @function verify
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                if (!(message.encryptedTwoFactorToken && typeof message.encryptedTwoFactorToken.length === "number" || $util.isString(message.encryptedTwoFactorToken)))
                    return "encryptedTwoFactorToken: buffer expected";
            return null;
        };

        /**
         * Creates a DeviceApprovalResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         */
        DeviceApprovalResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceApprovalResponse)
                return object;
            let message = new $root.Authentication.DeviceApprovalResponse();
            if (object.encryptedTwoFactorToken != null)
                if (typeof object.encryptedTwoFactorToken === "string")
                    $util.base64.decode(object.encryptedTwoFactorToken, message.encryptedTwoFactorToken = $util.newBuffer($util.base64.length(object.encryptedTwoFactorToken)), 0);
                else if (object.encryptedTwoFactorToken.length)
                    message.encryptedTwoFactorToken = object.encryptedTwoFactorToken;
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.DeviceApprovalResponse} message DeviceApprovalResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedTwoFactorToken = "";
                else {
                    object.encryptedTwoFactorToken = [];
                    if (options.bytes !== Array)
                        object.encryptedTwoFactorToken = $util.newBuffer(object.encryptedTwoFactorToken);
                }
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                object.encryptedTwoFactorToken = options.bytes === String ? $util.base64.encode(message.encryptedTwoFactorToken, 0, message.encryptedTwoFactorToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTwoFactorToken) : message.encryptedTwoFactorToken;
            return object;
        };

        /**
         * Converts this DeviceApprovalResponse to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceApprovalResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalResponse;
    })();

    return Authentication;
})();

export const AccountSummary = $root.AccountSummary = (() => {

    /**
     * Namespace AccountSummary.
     * @exports AccountSummary
     * @namespace
     */
    const AccountSummary = {};

    AccountSummary.AccountSummaryElements = (function() {

        /**
         * Properties of an AccountSummaryElements.
         * @memberof AccountSummary
         * @interface IAccountSummaryElements
         * @property {string|null} [clientKey] AccountSummaryElements clientKey
         * @property {AccountSummary.IKeysInfo|null} [keysInfo] AccountSummaryElements keysInfo
         * @property {Array.<AccountSummary.ISyncLog>|null} [syncLogs] AccountSummaryElements syncLogs
         * @property {boolean|null} [isEnterpriseAdmin] AccountSummaryElements isEnterpriseAdmin
         * @property {AccountSummary.ILicense|null} [license] AccountSummaryElements license
         * @property {AccountSummary.ISettings|null} [settings] AccountSummaryElements settings
         * @property {AccountSummary.IGroups|null} [groups] AccountSummaryElements groups
         * @property {Array.<AccountSummary.IKeyValue>|null} [Enforcements] AccountSummaryElements Enforcements
         * @property {Array.<AccountSummary.IKeyValue>|null} [Images] AccountSummaryElements Images
         */

        /**
         * Constructs a new AccountSummaryElements.
         * @memberof AccountSummary
         * @classdesc Represents an AccountSummaryElements.
         * @implements IAccountSummaryElements
         * @constructor
         * @param {AccountSummary.IAccountSummaryElements=} [properties] Properties to set
         */
        function AccountSummaryElements(properties) {
            this.syncLogs = [];
            this.Enforcements = [];
            this.Images = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSummaryElements clientKey.
         * @member {string} clientKey
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.clientKey = "";

        /**
         * AccountSummaryElements keysInfo.
         * @member {AccountSummary.IKeysInfo|null|undefined} keysInfo
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.keysInfo = null;

        /**
         * AccountSummaryElements syncLogs.
         * @member {Array.<AccountSummary.ISyncLog>} syncLogs
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.syncLogs = $util.emptyArray;

        /**
         * AccountSummaryElements isEnterpriseAdmin.
         * @member {boolean} isEnterpriseAdmin
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.isEnterpriseAdmin = false;

        /**
         * AccountSummaryElements license.
         * @member {AccountSummary.ILicense|null|undefined} license
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.license = null;

        /**
         * AccountSummaryElements settings.
         * @member {AccountSummary.ISettings|null|undefined} settings
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.settings = null;

        /**
         * AccountSummaryElements groups.
         * @member {AccountSummary.IGroups|null|undefined} groups
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.groups = null;

        /**
         * AccountSummaryElements Enforcements.
         * @member {Array.<AccountSummary.IKeyValue>} Enforcements
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.Enforcements = $util.emptyArray;

        /**
         * AccountSummaryElements Images.
         * @member {Array.<AccountSummary.IKeyValue>} Images
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.Images = $util.emptyArray;

        /**
         * Creates a new AccountSummaryElements instance using the specified properties.
         * @function create
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements=} [properties] Properties to set
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements instance
         */
        AccountSummaryElements.create = function create(properties) {
            return new AccountSummaryElements(properties);
        };

        /**
         * Encodes the specified AccountSummaryElements message. Does not implicitly {@link AccountSummary.AccountSummaryElements.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements} message AccountSummaryElements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryElements.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientKey);
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo"))
                $root.AccountSummary.KeysInfo.encode(message.keysInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.syncLogs != null && message.syncLogs.length)
                for (let i = 0; i < message.syncLogs.length; ++i)
                    $root.AccountSummary.SyncLog.encode(message.syncLogs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isEnterpriseAdmin);
            if (message.license != null && message.hasOwnProperty("license"))
                $root.AccountSummary.License.encode(message.license, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.settings != null && message.hasOwnProperty("settings"))
                $root.AccountSummary.Settings.encode(message.settings, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.groups != null && message.hasOwnProperty("groups"))
                $root.AccountSummary.Groups.encode(message.groups, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.Enforcements != null && message.Enforcements.length)
                for (let i = 0; i < message.Enforcements.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.Enforcements[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.Images != null && message.Images.length)
                for (let i = 0; i < message.Images.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.Images[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountSummaryElements message, length delimited. Does not implicitly {@link AccountSummary.AccountSummaryElements.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements} message AccountSummaryElements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryElements.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSummaryElements message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryElements.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.AccountSummaryElements();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientKey = reader.string();
                    break;
                case 2:
                    message.keysInfo = $root.AccountSummary.KeysInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.syncLogs && message.syncLogs.length))
                        message.syncLogs = [];
                    message.syncLogs.push($root.AccountSummary.SyncLog.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.isEnterpriseAdmin = reader.bool();
                    break;
                case 5:
                    message.license = $root.AccountSummary.License.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.settings = $root.AccountSummary.Settings.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.groups = $root.AccountSummary.Groups.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.Enforcements && message.Enforcements.length))
                        message.Enforcements = [];
                    message.Enforcements.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.Images && message.Images.length))
                        message.Images = [];
                    message.Images.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSummaryElements message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryElements.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSummaryElements message.
         * @function verify
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSummaryElements.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                if (!$util.isString(message.clientKey))
                    return "clientKey: string expected";
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo")) {
                let error = $root.AccountSummary.KeysInfo.verify(message.keysInfo);
                if (error)
                    return "keysInfo." + error;
            }
            if (message.syncLogs != null && message.hasOwnProperty("syncLogs")) {
                if (!Array.isArray(message.syncLogs))
                    return "syncLogs: array expected";
                for (let i = 0; i < message.syncLogs.length; ++i) {
                    let error = $root.AccountSummary.SyncLog.verify(message.syncLogs[i]);
                    if (error)
                        return "syncLogs." + error;
                }
            }
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                if (typeof message.isEnterpriseAdmin !== "boolean")
                    return "isEnterpriseAdmin: boolean expected";
            if (message.license != null && message.hasOwnProperty("license")) {
                let error = $root.AccountSummary.License.verify(message.license);
                if (error)
                    return "license." + error;
            }
            if (message.settings != null && message.hasOwnProperty("settings")) {
                let error = $root.AccountSummary.Settings.verify(message.settings);
                if (error)
                    return "settings." + error;
            }
            if (message.groups != null && message.hasOwnProperty("groups")) {
                let error = $root.AccountSummary.Groups.verify(message.groups);
                if (error)
                    return "groups." + error;
            }
            if (message.Enforcements != null && message.hasOwnProperty("Enforcements")) {
                if (!Array.isArray(message.Enforcements))
                    return "Enforcements: array expected";
                for (let i = 0; i < message.Enforcements.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.Enforcements[i]);
                    if (error)
                        return "Enforcements." + error;
                }
            }
            if (message.Images != null && message.hasOwnProperty("Images")) {
                if (!Array.isArray(message.Images))
                    return "Images: array expected";
                for (let i = 0; i < message.Images.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.Images[i]);
                    if (error)
                        return "Images." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountSummaryElements message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         */
        AccountSummaryElements.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.AccountSummaryElements)
                return object;
            let message = new $root.AccountSummary.AccountSummaryElements();
            if (object.clientKey != null)
                message.clientKey = String(object.clientKey);
            if (object.keysInfo != null) {
                if (typeof object.keysInfo !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.keysInfo: object expected");
                message.keysInfo = $root.AccountSummary.KeysInfo.fromObject(object.keysInfo);
            }
            if (object.syncLogs) {
                if (!Array.isArray(object.syncLogs))
                    throw TypeError(".AccountSummary.AccountSummaryElements.syncLogs: array expected");
                message.syncLogs = [];
                for (let i = 0; i < object.syncLogs.length; ++i) {
                    if (typeof object.syncLogs[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.syncLogs: object expected");
                    message.syncLogs[i] = $root.AccountSummary.SyncLog.fromObject(object.syncLogs[i]);
                }
            }
            if (object.isEnterpriseAdmin != null)
                message.isEnterpriseAdmin = Boolean(object.isEnterpriseAdmin);
            if (object.license != null) {
                if (typeof object.license !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.license: object expected");
                message.license = $root.AccountSummary.License.fromObject(object.license);
            }
            if (object.settings != null) {
                if (typeof object.settings !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.settings: object expected");
                message.settings = $root.AccountSummary.Settings.fromObject(object.settings);
            }
            if (object.groups != null) {
                if (typeof object.groups !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.groups: object expected");
                message.groups = $root.AccountSummary.Groups.fromObject(object.groups);
            }
            if (object.Enforcements) {
                if (!Array.isArray(object.Enforcements))
                    throw TypeError(".AccountSummary.AccountSummaryElements.Enforcements: array expected");
                message.Enforcements = [];
                for (let i = 0; i < object.Enforcements.length; ++i) {
                    if (typeof object.Enforcements[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.Enforcements: object expected");
                    message.Enforcements[i] = $root.AccountSummary.KeyValue.fromObject(object.Enforcements[i]);
                }
            }
            if (object.Images) {
                if (!Array.isArray(object.Images))
                    throw TypeError(".AccountSummary.AccountSummaryElements.Images: array expected");
                message.Images = [];
                for (let i = 0; i < object.Images.length; ++i) {
                    if (typeof object.Images[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.Images: object expected");
                    message.Images[i] = $root.AccountSummary.KeyValue.fromObject(object.Images[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountSummaryElements message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.AccountSummaryElements} message AccountSummaryElements
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSummaryElements.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.syncLogs = [];
                object.Enforcements = [];
                object.Images = [];
            }
            if (options.defaults) {
                object.clientKey = "";
                object.keysInfo = null;
                object.isEnterpriseAdmin = false;
                object.license = null;
                object.settings = null;
                object.groups = null;
            }
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                object.clientKey = message.clientKey;
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo"))
                object.keysInfo = $root.AccountSummary.KeysInfo.toObject(message.keysInfo, options);
            if (message.syncLogs && message.syncLogs.length) {
                object.syncLogs = [];
                for (let j = 0; j < message.syncLogs.length; ++j)
                    object.syncLogs[j] = $root.AccountSummary.SyncLog.toObject(message.syncLogs[j], options);
            }
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                object.isEnterpriseAdmin = message.isEnterpriseAdmin;
            if (message.license != null && message.hasOwnProperty("license"))
                object.license = $root.AccountSummary.License.toObject(message.license, options);
            if (message.settings != null && message.hasOwnProperty("settings"))
                object.settings = $root.AccountSummary.Settings.toObject(message.settings, options);
            if (message.groups != null && message.hasOwnProperty("groups"))
                object.groups = $root.AccountSummary.Groups.toObject(message.groups, options);
            if (message.Enforcements && message.Enforcements.length) {
                object.Enforcements = [];
                for (let j = 0; j < message.Enforcements.length; ++j)
                    object.Enforcements[j] = $root.AccountSummary.KeyValue.toObject(message.Enforcements[j], options);
            }
            if (message.Images && message.Images.length) {
                object.Images = [];
                for (let j = 0; j < message.Images.length; ++j)
                    object.Images[j] = $root.AccountSummary.KeyValue.toObject(message.Images[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountSummaryElements to JSON.
         * @function toJSON
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSummaryElements.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountSummaryElements;
    })();

    AccountSummary.KeysInfo = (function() {

        /**
         * Properties of a KeysInfo.
         * @memberof AccountSummary
         * @interface IKeysInfo
         * @property {string|null} [encryptionParams] KeysInfo encryptionParams
         * @property {string|null} [encryptedPriveKeys] KeysInfo encryptedPriveKeys
         * @property {AccountSummary.IDataKey|null} [dataKey] KeysInfo dataKey
         */

        /**
         * Constructs a new KeysInfo.
         * @memberof AccountSummary
         * @classdesc Represents a KeysInfo.
         * @implements IKeysInfo
         * @constructor
         * @param {AccountSummary.IKeysInfo=} [properties] Properties to set
         */
        function KeysInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeysInfo encryptionParams.
         * @member {string} encryptionParams
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.encryptionParams = "";

        /**
         * KeysInfo encryptedPriveKeys.
         * @member {string} encryptedPriveKeys
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.encryptedPriveKeys = "";

        /**
         * KeysInfo dataKey.
         * @member {AccountSummary.IDataKey|null|undefined} dataKey
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.dataKey = null;

        /**
         * Creates a new KeysInfo instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo=} [properties] Properties to set
         * @returns {AccountSummary.KeysInfo} KeysInfo instance
         */
        KeysInfo.create = function create(properties) {
            return new KeysInfo(properties);
        };

        /**
         * Encodes the specified KeysInfo message. Does not implicitly {@link AccountSummary.KeysInfo.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo} message KeysInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeysInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.encryptionParams);
            if (message.encryptedPriveKeys != null && message.hasOwnProperty("encryptedPriveKeys"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.encryptedPriveKeys);
            if (message.dataKey != null && message.hasOwnProperty("dataKey"))
                $root.AccountSummary.DataKey.encode(message.dataKey, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified KeysInfo message, length delimited. Does not implicitly {@link AccountSummary.KeysInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo} message KeysInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeysInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeysInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeysInfo} KeysInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeysInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeysInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptionParams = reader.string();
                    break;
                case 2:
                    message.encryptedPriveKeys = reader.string();
                    break;
                case 3:
                    message.dataKey = $root.AccountSummary.DataKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeysInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeysInfo} KeysInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeysInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeysInfo message.
         * @function verify
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeysInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                if (!$util.isString(message.encryptionParams))
                    return "encryptionParams: string expected";
            if (message.encryptedPriveKeys != null && message.hasOwnProperty("encryptedPriveKeys"))
                if (!$util.isString(message.encryptedPriveKeys))
                    return "encryptedPriveKeys: string expected";
            if (message.dataKey != null && message.hasOwnProperty("dataKey")) {
                let error = $root.AccountSummary.DataKey.verify(message.dataKey);
                if (error)
                    return "dataKey." + error;
            }
            return null;
        };

        /**
         * Creates a KeysInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeysInfo} KeysInfo
         */
        KeysInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeysInfo)
                return object;
            let message = new $root.AccountSummary.KeysInfo();
            if (object.encryptionParams != null)
                message.encryptionParams = String(object.encryptionParams);
            if (object.encryptedPriveKeys != null)
                message.encryptedPriveKeys = String(object.encryptedPriveKeys);
            if (object.dataKey != null) {
                if (typeof object.dataKey !== "object")
                    throw TypeError(".AccountSummary.KeysInfo.dataKey: object expected");
                message.dataKey = $root.AccountSummary.DataKey.fromObject(object.dataKey);
            }
            return message;
        };

        /**
         * Creates a plain object from a KeysInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.KeysInfo} message KeysInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeysInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.encryptionParams = "";
                object.encryptedPriveKeys = "";
                object.dataKey = null;
            }
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                object.encryptionParams = message.encryptionParams;
            if (message.encryptedPriveKeys != null && message.hasOwnProperty("encryptedPriveKeys"))
                object.encryptedPriveKeys = message.encryptedPriveKeys;
            if (message.dataKey != null && message.hasOwnProperty("dataKey"))
                object.dataKey = $root.AccountSummary.DataKey.toObject(message.dataKey, options);
            return object;
        };

        /**
         * Converts this KeysInfo to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeysInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeysInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeysInfo;
    })();

    AccountSummary.DataKey = (function() {

        /**
         * Properties of a DataKey.
         * @memberof AccountSummary
         * @interface IDataKey
         * @property {number|null} [createdDate] DataKey createdDate
         * @property {string|null} [dataKey] DataKey dataKey
         */

        /**
         * Constructs a new DataKey.
         * @memberof AccountSummary
         * @classdesc Represents a DataKey.
         * @implements IDataKey
         * @constructor
         * @param {AccountSummary.IDataKey=} [properties] Properties to set
         */
        function DataKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DataKey createdDate.
         * @member {number} createdDate
         * @memberof AccountSummary.DataKey
         * @instance
         */
        DataKey.prototype.createdDate = 0;

        /**
         * DataKey dataKey.
         * @member {string} dataKey
         * @memberof AccountSummary.DataKey
         * @instance
         */
        DataKey.prototype.dataKey = "";

        /**
         * Creates a new DataKey instance using the specified properties.
         * @function create
         * @memberof AccountSummary.DataKey
         * @static
         * @param {AccountSummary.IDataKey=} [properties] Properties to set
         * @returns {AccountSummary.DataKey} DataKey instance
         */
        DataKey.create = function create(properties) {
            return new DataKey(properties);
        };

        /**
         * Encodes the specified DataKey message. Does not implicitly {@link AccountSummary.DataKey.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.DataKey
         * @static
         * @param {AccountSummary.IDataKey} message DataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.createdDate);
            if (message.dataKey != null && message.hasOwnProperty("dataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dataKey);
            return writer;
        };

        /**
         * Encodes the specified DataKey message, length delimited. Does not implicitly {@link AccountSummary.DataKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.DataKey
         * @static
         * @param {AccountSummary.IDataKey} message DataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DataKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DataKey message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.DataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.DataKey} DataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.DataKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.createdDate = reader.double();
                    break;
                case 2:
                    message.dataKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DataKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.DataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.DataKey} DataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DataKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DataKey message.
         * @function verify
         * @memberof AccountSummary.DataKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DataKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                if (typeof message.createdDate !== "number")
                    return "createdDate: number expected";
            if (message.dataKey != null && message.hasOwnProperty("dataKey"))
                if (!$util.isString(message.dataKey))
                    return "dataKey: string expected";
            return null;
        };

        /**
         * Creates a DataKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.DataKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.DataKey} DataKey
         */
        DataKey.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.DataKey)
                return object;
            let message = new $root.AccountSummary.DataKey();
            if (object.createdDate != null)
                message.createdDate = Number(object.createdDate);
            if (object.dataKey != null)
                message.dataKey = String(object.dataKey);
            return message;
        };

        /**
         * Creates a plain object from a DataKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.DataKey
         * @static
         * @param {AccountSummary.DataKey} message DataKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DataKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.createdDate = 0;
                object.dataKey = "";
            }
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                object.createdDate = options.json && !isFinite(message.createdDate) ? String(message.createdDate) : message.createdDate;
            if (message.dataKey != null && message.hasOwnProperty("dataKey"))
                object.dataKey = message.dataKey;
            return object;
        };

        /**
         * Converts this DataKey to JSON.
         * @function toJSON
         * @memberof AccountSummary.DataKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DataKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DataKey;
    })();

    AccountSummary.SyncLog = (function() {

        /**
         * Properties of a SyncLog.
         * @memberof AccountSummary
         * @interface ISyncLog
         * @property {string|null} [countryName] SyncLog countryName
         * @property {number|Long|null} [secondsAgo] SyncLog secondsAgo
         * @property {string|null} [deviceName] SyncLog deviceName
         * @property {string|null} [countryCode] SyncLog countryCode
         * @property {string|null} [deviceUID] SyncLog deviceUID
         * @property {string|null} [ipAddress] SyncLog ipAddress
         */

        /**
         * Constructs a new SyncLog.
         * @memberof AccountSummary
         * @classdesc Represents a SyncLog.
         * @implements ISyncLog
         * @constructor
         * @param {AccountSummary.ISyncLog=} [properties] Properties to set
         */
        function SyncLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncLog countryName.
         * @member {string} countryName
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.countryName = "";

        /**
         * SyncLog secondsAgo.
         * @member {number|Long} secondsAgo
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.secondsAgo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncLog deviceName.
         * @member {string} deviceName
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.deviceName = "";

        /**
         * SyncLog countryCode.
         * @member {string} countryCode
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.countryCode = "";

        /**
         * SyncLog deviceUID.
         * @member {string} deviceUID
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.deviceUID = "";

        /**
         * SyncLog ipAddress.
         * @member {string} ipAddress
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.ipAddress = "";

        /**
         * Creates a new SyncLog instance using the specified properties.
         * @function create
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog=} [properties] Properties to set
         * @returns {AccountSummary.SyncLog} SyncLog instance
         */
        SyncLog.create = function create(properties) {
            return new SyncLog(properties);
        };

        /**
         * Encodes the specified SyncLog message. Does not implicitly {@link AccountSummary.SyncLog.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog} message SyncLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.countryName);
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.secondsAgo);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceName);
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.countryCode);
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.deviceUID);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ipAddress);
            return writer;
        };

        /**
         * Encodes the specified SyncLog message, length delimited. Does not implicitly {@link AccountSummary.SyncLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog} message SyncLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncLog message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.SyncLog} SyncLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.SyncLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.countryName = reader.string();
                    break;
                case 2:
                    message.secondsAgo = reader.int64();
                    break;
                case 3:
                    message.deviceName = reader.string();
                    break;
                case 4:
                    message.countryCode = reader.string();
                    break;
                case 5:
                    message.deviceUID = reader.string();
                    break;
                case 6:
                    message.ipAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.SyncLog} SyncLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncLog message.
         * @function verify
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                if (!$util.isString(message.countryName))
                    return "countryName: string expected";
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                if (!$util.isInteger(message.secondsAgo) && !(message.secondsAgo && $util.isInteger(message.secondsAgo.low) && $util.isInteger(message.secondsAgo.high)))
                    return "secondsAgo: integer|Long expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isString(message.countryCode))
                    return "countryCode: string expected";
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                if (!$util.isString(message.deviceUID))
                    return "deviceUID: string expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            return null;
        };

        /**
         * Creates a SyncLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.SyncLog} SyncLog
         */
        SyncLog.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.SyncLog)
                return object;
            let message = new $root.AccountSummary.SyncLog();
            if (object.countryName != null)
                message.countryName = String(object.countryName);
            if (object.secondsAgo != null)
                if ($util.Long)
                    (message.secondsAgo = $util.Long.fromValue(object.secondsAgo)).unsigned = false;
                else if (typeof object.secondsAgo === "string")
                    message.secondsAgo = parseInt(object.secondsAgo, 10);
                else if (typeof object.secondsAgo === "number")
                    message.secondsAgo = object.secondsAgo;
                else if (typeof object.secondsAgo === "object")
                    message.secondsAgo = new $util.LongBits(object.secondsAgo.low >>> 0, object.secondsAgo.high >>> 0).toNumber();
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.countryCode != null)
                message.countryCode = String(object.countryCode);
            if (object.deviceUID != null)
                message.deviceUID = String(object.deviceUID);
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            return message;
        };

        /**
         * Creates a plain object from a SyncLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.SyncLog} message SyncLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.countryName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsAgo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsAgo = options.longs === String ? "0" : 0;
                object.deviceName = "";
                object.countryCode = "";
                object.deviceUID = "";
                object.ipAddress = "";
            }
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                object.countryName = message.countryName;
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                if (typeof message.secondsAgo === "number")
                    object.secondsAgo = options.longs === String ? String(message.secondsAgo) : message.secondsAgo;
                else
                    object.secondsAgo = options.longs === String ? $util.Long.prototype.toString.call(message.secondsAgo) : options.longs === Number ? new $util.LongBits(message.secondsAgo.low >>> 0, message.secondsAgo.high >>> 0).toNumber() : message.secondsAgo;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                object.deviceUID = message.deviceUID;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            return object;
        };

        /**
         * Converts this SyncLog to JSON.
         * @function toJSON
         * @memberof AccountSummary.SyncLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncLog;
    })();

    AccountSummary.License = (function() {

        /**
         * Properties of a License.
         * @memberof AccountSummary
         * @interface ILicense
         * @property {string|null} [subscriptionCode] License subscriptionCode
         * @property {number|null} [productTypeId] License productTypeId
         * @property {string|null} [productTypeName] License productTypeName
         * @property {string|null} [expirationDate] License expirationDate
         * @property {number|Long|null} [secondsUnitExpiration] License secondsUnitExpiration
         * @property {number|null} [maxDevices] License maxDevices
         * @property {number|null} [filePlanType] License filePlanType
         * @property {number|Long|null} [bytesUsed] License bytesUsed
         * @property {number|Long|null} [bytesTotal] License bytesTotal
         * @property {number|Long|null} [secondsUntilStorageExpiration] License secondsUntilStorageExpiration
         * @property {string|null} [storageExpirationDate] License storageExpirationDate
         * @property {boolean|null} [hasAutoRenewableAppstoreSubscription] License hasAutoRenewableAppstoreSubscription
         * @property {number|null} [accountType] License accountType
         * @property {number|null} [uploadsRemaining] License uploadsRemaining
         * @property {Array.<AccountSummary.IAddOn>|null} [addOns] License addOns
         */

        /**
         * Constructs a new License.
         * @memberof AccountSummary
         * @classdesc Represents a License.
         * @implements ILicense
         * @constructor
         * @param {AccountSummary.ILicense=} [properties] Properties to set
         */
        function License(properties) {
            this.addOns = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * License subscriptionCode.
         * @member {string} subscriptionCode
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.subscriptionCode = "";

        /**
         * License productTypeId.
         * @member {number} productTypeId
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.productTypeId = 0;

        /**
         * License productTypeName.
         * @member {string} productTypeName
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.productTypeName = "";

        /**
         * License expirationDate.
         * @member {string} expirationDate
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.expirationDate = "";

        /**
         * License secondsUnitExpiration.
         * @member {number|Long} secondsUnitExpiration
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.secondsUnitExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License maxDevices.
         * @member {number} maxDevices
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.maxDevices = 0;

        /**
         * License filePlanType.
         * @member {number} filePlanType
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.filePlanType = 0;

        /**
         * License bytesUsed.
         * @member {number|Long} bytesUsed
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.bytesUsed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License bytesTotal.
         * @member {number|Long} bytesTotal
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.bytesTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License secondsUntilStorageExpiration.
         * @member {number|Long} secondsUntilStorageExpiration
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.secondsUntilStorageExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License storageExpirationDate.
         * @member {string} storageExpirationDate
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.storageExpirationDate = "";

        /**
         * License hasAutoRenewableAppstoreSubscription.
         * @member {boolean} hasAutoRenewableAppstoreSubscription
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.hasAutoRenewableAppstoreSubscription = false;

        /**
         * License accountType.
         * @member {number} accountType
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.accountType = 0;

        /**
         * License uploadsRemaining.
         * @member {number} uploadsRemaining
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.uploadsRemaining = 0;

        /**
         * License addOns.
         * @member {Array.<AccountSummary.IAddOn>} addOns
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.addOns = $util.emptyArray;

        /**
         * Creates a new License instance using the specified properties.
         * @function create
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense=} [properties] Properties to set
         * @returns {AccountSummary.License} License instance
         */
        License.create = function create(properties) {
            return new License(properties);
        };

        /**
         * Encodes the specified License message. Does not implicitly {@link AccountSummary.License.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionCode);
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.productTypeId);
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.productTypeName);
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.expirationDate);
            if (message.secondsUnitExpiration != null && message.hasOwnProperty("secondsUnitExpiration"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.secondsUnitExpiration);
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxDevices);
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.filePlanType);
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.bytesUsed);
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.bytesTotal);
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.secondsUntilStorageExpiration);
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.storageExpirationDate);
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.hasAutoRenewableAppstoreSubscription);
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.accountType);
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.uploadsRemaining);
            if (message.addOns != null && message.addOns.length)
                for (let i = 0; i < message.addOns.length; ++i)
                    $root.AccountSummary.AddOn.encode(message.addOns[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified License message, length delimited. Does not implicitly {@link AccountSummary.License.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a License message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.License();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subscriptionCode = reader.string();
                    break;
                case 2:
                    message.productTypeId = reader.int32();
                    break;
                case 3:
                    message.productTypeName = reader.string();
                    break;
                case 4:
                    message.expirationDate = reader.string();
                    break;
                case 5:
                    message.secondsUnitExpiration = reader.int64();
                    break;
                case 6:
                    message.maxDevices = reader.int32();
                    break;
                case 7:
                    message.filePlanType = reader.int32();
                    break;
                case 8:
                    message.bytesUsed = reader.int64();
                    break;
                case 9:
                    message.bytesTotal = reader.int64();
                    break;
                case 10:
                    message.secondsUntilStorageExpiration = reader.int64();
                    break;
                case 11:
                    message.storageExpirationDate = reader.string();
                    break;
                case 12:
                    message.hasAutoRenewableAppstoreSubscription = reader.bool();
                    break;
                case 13:
                    message.accountType = reader.int32();
                    break;
                case 14:
                    message.uploadsRemaining = reader.int32();
                    break;
                case 15:
                    if (!(message.addOns && message.addOns.length))
                        message.addOns = [];
                    message.addOns.push($root.AccountSummary.AddOn.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a License message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a License message.
         * @function verify
         * @memberof AccountSummary.License
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        License.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                if (!$util.isString(message.subscriptionCode))
                    return "subscriptionCode: string expected";
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                if (!$util.isInteger(message.productTypeId))
                    return "productTypeId: integer expected";
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                if (!$util.isString(message.productTypeName))
                    return "productTypeName: string expected";
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (!$util.isString(message.expirationDate))
                    return "expirationDate: string expected";
            if (message.secondsUnitExpiration != null && message.hasOwnProperty("secondsUnitExpiration"))
                if (!$util.isInteger(message.secondsUnitExpiration) && !(message.secondsUnitExpiration && $util.isInteger(message.secondsUnitExpiration.low) && $util.isInteger(message.secondsUnitExpiration.high)))
                    return "secondsUnitExpiration: integer|Long expected";
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                if (!$util.isInteger(message.maxDevices))
                    return "maxDevices: integer expected";
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                if (!$util.isInteger(message.filePlanType))
                    return "filePlanType: integer expected";
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (!$util.isInteger(message.bytesUsed) && !(message.bytesUsed && $util.isInteger(message.bytesUsed.low) && $util.isInteger(message.bytesUsed.high)))
                    return "bytesUsed: integer|Long expected";
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                if (!$util.isInteger(message.bytesTotal) && !(message.bytesTotal && $util.isInteger(message.bytesTotal.low) && $util.isInteger(message.bytesTotal.high)))
                    return "bytesTotal: integer|Long expected";
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                if (!$util.isInteger(message.secondsUntilStorageExpiration) && !(message.secondsUntilStorageExpiration && $util.isInteger(message.secondsUntilStorageExpiration.low) && $util.isInteger(message.secondsUntilStorageExpiration.high)))
                    return "secondsUntilStorageExpiration: integer|Long expected";
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                if (!$util.isString(message.storageExpirationDate))
                    return "storageExpirationDate: string expected";
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                if (typeof message.hasAutoRenewableAppstoreSubscription !== "boolean")
                    return "hasAutoRenewableAppstoreSubscription: boolean expected";
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                if (!$util.isInteger(message.accountType))
                    return "accountType: integer expected";
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                if (!$util.isInteger(message.uploadsRemaining))
                    return "uploadsRemaining: integer expected";
            if (message.addOns != null && message.hasOwnProperty("addOns")) {
                if (!Array.isArray(message.addOns))
                    return "addOns: array expected";
                for (let i = 0; i < message.addOns.length; ++i) {
                    let error = $root.AccountSummary.AddOn.verify(message.addOns[i]);
                    if (error)
                        return "addOns." + error;
                }
            }
            return null;
        };

        /**
         * Creates a License message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.License
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.License} License
         */
        License.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.License)
                return object;
            let message = new $root.AccountSummary.License();
            if (object.subscriptionCode != null)
                message.subscriptionCode = String(object.subscriptionCode);
            if (object.productTypeId != null)
                message.productTypeId = object.productTypeId | 0;
            if (object.productTypeName != null)
                message.productTypeName = String(object.productTypeName);
            if (object.expirationDate != null)
                message.expirationDate = String(object.expirationDate);
            if (object.secondsUnitExpiration != null)
                if ($util.Long)
                    (message.secondsUnitExpiration = $util.Long.fromValue(object.secondsUnitExpiration)).unsigned = false;
                else if (typeof object.secondsUnitExpiration === "string")
                    message.secondsUnitExpiration = parseInt(object.secondsUnitExpiration, 10);
                else if (typeof object.secondsUnitExpiration === "number")
                    message.secondsUnitExpiration = object.secondsUnitExpiration;
                else if (typeof object.secondsUnitExpiration === "object")
                    message.secondsUnitExpiration = new $util.LongBits(object.secondsUnitExpiration.low >>> 0, object.secondsUnitExpiration.high >>> 0).toNumber();
            if (object.maxDevices != null)
                message.maxDevices = object.maxDevices | 0;
            if (object.filePlanType != null)
                message.filePlanType = object.filePlanType | 0;
            if (object.bytesUsed != null)
                if ($util.Long)
                    (message.bytesUsed = $util.Long.fromValue(object.bytesUsed)).unsigned = false;
                else if (typeof object.bytesUsed === "string")
                    message.bytesUsed = parseInt(object.bytesUsed, 10);
                else if (typeof object.bytesUsed === "number")
                    message.bytesUsed = object.bytesUsed;
                else if (typeof object.bytesUsed === "object")
                    message.bytesUsed = new $util.LongBits(object.bytesUsed.low >>> 0, object.bytesUsed.high >>> 0).toNumber();
            if (object.bytesTotal != null)
                if ($util.Long)
                    (message.bytesTotal = $util.Long.fromValue(object.bytesTotal)).unsigned = false;
                else if (typeof object.bytesTotal === "string")
                    message.bytesTotal = parseInt(object.bytesTotal, 10);
                else if (typeof object.bytesTotal === "number")
                    message.bytesTotal = object.bytesTotal;
                else if (typeof object.bytesTotal === "object")
                    message.bytesTotal = new $util.LongBits(object.bytesTotal.low >>> 0, object.bytesTotal.high >>> 0).toNumber();
            if (object.secondsUntilStorageExpiration != null)
                if ($util.Long)
                    (message.secondsUntilStorageExpiration = $util.Long.fromValue(object.secondsUntilStorageExpiration)).unsigned = false;
                else if (typeof object.secondsUntilStorageExpiration === "string")
                    message.secondsUntilStorageExpiration = parseInt(object.secondsUntilStorageExpiration, 10);
                else if (typeof object.secondsUntilStorageExpiration === "number")
                    message.secondsUntilStorageExpiration = object.secondsUntilStorageExpiration;
                else if (typeof object.secondsUntilStorageExpiration === "object")
                    message.secondsUntilStorageExpiration = new $util.LongBits(object.secondsUntilStorageExpiration.low >>> 0, object.secondsUntilStorageExpiration.high >>> 0).toNumber();
            if (object.storageExpirationDate != null)
                message.storageExpirationDate = String(object.storageExpirationDate);
            if (object.hasAutoRenewableAppstoreSubscription != null)
                message.hasAutoRenewableAppstoreSubscription = Boolean(object.hasAutoRenewableAppstoreSubscription);
            if (object.accountType != null)
                message.accountType = object.accountType | 0;
            if (object.uploadsRemaining != null)
                message.uploadsRemaining = object.uploadsRemaining | 0;
            if (object.addOns) {
                if (!Array.isArray(object.addOns))
                    throw TypeError(".AccountSummary.License.addOns: array expected");
                message.addOns = [];
                for (let i = 0; i < object.addOns.length; ++i) {
                    if (typeof object.addOns[i] !== "object")
                        throw TypeError(".AccountSummary.License.addOns: object expected");
                    message.addOns[i] = $root.AccountSummary.AddOn.fromObject(object.addOns[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a License message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.License} message License
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        License.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.addOns = [];
            if (options.defaults) {
                object.subscriptionCode = "";
                object.productTypeId = 0;
                object.productTypeName = "";
                object.expirationDate = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsUnitExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsUnitExpiration = options.longs === String ? "0" : 0;
                object.maxDevices = 0;
                object.filePlanType = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bytesUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesUsed = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bytesTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesTotal = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsUntilStorageExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsUntilStorageExpiration = options.longs === String ? "0" : 0;
                object.storageExpirationDate = "";
                object.hasAutoRenewableAppstoreSubscription = false;
                object.accountType = 0;
                object.uploadsRemaining = 0;
            }
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                object.subscriptionCode = message.subscriptionCode;
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                object.productTypeId = message.productTypeId;
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                object.productTypeName = message.productTypeName;
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                object.expirationDate = message.expirationDate;
            if (message.secondsUnitExpiration != null && message.hasOwnProperty("secondsUnitExpiration"))
                if (typeof message.secondsUnitExpiration === "number")
                    object.secondsUnitExpiration = options.longs === String ? String(message.secondsUnitExpiration) : message.secondsUnitExpiration;
                else
                    object.secondsUnitExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.secondsUnitExpiration) : options.longs === Number ? new $util.LongBits(message.secondsUnitExpiration.low >>> 0, message.secondsUnitExpiration.high >>> 0).toNumber() : message.secondsUnitExpiration;
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                object.maxDevices = message.maxDevices;
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                object.filePlanType = message.filePlanType;
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (typeof message.bytesUsed === "number")
                    object.bytesUsed = options.longs === String ? String(message.bytesUsed) : message.bytesUsed;
                else
                    object.bytesUsed = options.longs === String ? $util.Long.prototype.toString.call(message.bytesUsed) : options.longs === Number ? new $util.LongBits(message.bytesUsed.low >>> 0, message.bytesUsed.high >>> 0).toNumber() : message.bytesUsed;
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                if (typeof message.bytesTotal === "number")
                    object.bytesTotal = options.longs === String ? String(message.bytesTotal) : message.bytesTotal;
                else
                    object.bytesTotal = options.longs === String ? $util.Long.prototype.toString.call(message.bytesTotal) : options.longs === Number ? new $util.LongBits(message.bytesTotal.low >>> 0, message.bytesTotal.high >>> 0).toNumber() : message.bytesTotal;
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                if (typeof message.secondsUntilStorageExpiration === "number")
                    object.secondsUntilStorageExpiration = options.longs === String ? String(message.secondsUntilStorageExpiration) : message.secondsUntilStorageExpiration;
                else
                    object.secondsUntilStorageExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.secondsUntilStorageExpiration) : options.longs === Number ? new $util.LongBits(message.secondsUntilStorageExpiration.low >>> 0, message.secondsUntilStorageExpiration.high >>> 0).toNumber() : message.secondsUntilStorageExpiration;
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                object.storageExpirationDate = message.storageExpirationDate;
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                object.hasAutoRenewableAppstoreSubscription = message.hasAutoRenewableAppstoreSubscription;
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                object.accountType = message.accountType;
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                object.uploadsRemaining = message.uploadsRemaining;
            if (message.addOns && message.addOns.length) {
                object.addOns = [];
                for (let j = 0; j < message.addOns.length; ++j)
                    object.addOns[j] = $root.AccountSummary.AddOn.toObject(message.addOns[j], options);
            }
            return object;
        };

        /**
         * Converts this License to JSON.
         * @function toJSON
         * @memberof AccountSummary.License
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        License.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return License;
    })();

    AccountSummary.AddOn = (function() {

        /**
         * Properties of an AddOn.
         * @memberof AccountSummary
         * @interface IAddOn
         * @property {number|null} [licenseKeyId] AddOn licenseKeyId
         * @property {string|null} [name] AddOn name
         * @property {number|Long|null} [expirationDate] AddOn expirationDate
         * @property {number|Long|null} [createdDate] AddOn createdDate
         * @property {boolean|null} [isTrial] AddOn isTrial
         * @property {boolean|null} [enabled] AddOn enabled
         * @property {boolean|null} [scanned] AddOn scanned
         * @property {boolean|null} [featureDisable] AddOn featureDisable
         */

        /**
         * Constructs a new AddOn.
         * @memberof AccountSummary
         * @classdesc Represents an AddOn.
         * @implements IAddOn
         * @constructor
         * @param {AccountSummary.IAddOn=} [properties] Properties to set
         */
        function AddOn(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddOn licenseKeyId.
         * @member {number} licenseKeyId
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.licenseKeyId = 0;

        /**
         * AddOn name.
         * @member {string} name
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.name = "";

        /**
         * AddOn expirationDate.
         * @member {number|Long} expirationDate
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.expirationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AddOn createdDate.
         * @member {number|Long} createdDate
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.createdDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AddOn isTrial.
         * @member {boolean} isTrial
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.isTrial = false;

        /**
         * AddOn enabled.
         * @member {boolean} enabled
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.enabled = false;

        /**
         * AddOn scanned.
         * @member {boolean} scanned
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.scanned = false;

        /**
         * AddOn featureDisable.
         * @member {boolean} featureDisable
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.featureDisable = false;

        /**
         * Creates a new AddOn instance using the specified properties.
         * @function create
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn=} [properties] Properties to set
         * @returns {AccountSummary.AddOn} AddOn instance
         */
        AddOn.create = function create(properties) {
            return new AddOn(properties);
        };

        /**
         * Encodes the specified AddOn message. Does not implicitly {@link AccountSummary.AddOn.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn} message AddOn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.licenseKeyId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.expirationDate);
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.createdDate);
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isTrial);
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enabled);
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.scanned);
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.featureDisable);
            return writer;
        };

        /**
         * Encodes the specified AddOn message, length delimited. Does not implicitly {@link AccountSummary.AddOn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn} message AddOn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddOn message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.AddOn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.AddOn} AddOn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.AddOn();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.licenseKeyId = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.expirationDate = reader.int64();
                    break;
                case 4:
                    message.createdDate = reader.int64();
                    break;
                case 5:
                    message.isTrial = reader.bool();
                    break;
                case 6:
                    message.enabled = reader.bool();
                    break;
                case 7:
                    message.scanned = reader.bool();
                    break;
                case 8:
                    message.featureDisable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddOn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.AddOn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.AddOn} AddOn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddOn message.
         * @function verify
         * @memberof AccountSummary.AddOn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddOn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                if (!$util.isInteger(message.licenseKeyId))
                    return "licenseKeyId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (!$util.isInteger(message.expirationDate) && !(message.expirationDate && $util.isInteger(message.expirationDate.low) && $util.isInteger(message.expirationDate.high)))
                    return "expirationDate: integer|Long expected";
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                if (!$util.isInteger(message.createdDate) && !(message.createdDate && $util.isInteger(message.createdDate.low) && $util.isInteger(message.createdDate.high)))
                    return "createdDate: integer|Long expected";
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                if (typeof message.isTrial !== "boolean")
                    return "isTrial: boolean expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                if (typeof message.scanned !== "boolean")
                    return "scanned: boolean expected";
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                if (typeof message.featureDisable !== "boolean")
                    return "featureDisable: boolean expected";
            return null;
        };

        /**
         * Creates an AddOn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.AddOn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.AddOn} AddOn
         */
        AddOn.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.AddOn)
                return object;
            let message = new $root.AccountSummary.AddOn();
            if (object.licenseKeyId != null)
                message.licenseKeyId = object.licenseKeyId | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.expirationDate != null)
                if ($util.Long)
                    (message.expirationDate = $util.Long.fromValue(object.expirationDate)).unsigned = false;
                else if (typeof object.expirationDate === "string")
                    message.expirationDate = parseInt(object.expirationDate, 10);
                else if (typeof object.expirationDate === "number")
                    message.expirationDate = object.expirationDate;
                else if (typeof object.expirationDate === "object")
                    message.expirationDate = new $util.LongBits(object.expirationDate.low >>> 0, object.expirationDate.high >>> 0).toNumber();
            if (object.createdDate != null)
                if ($util.Long)
                    (message.createdDate = $util.Long.fromValue(object.createdDate)).unsigned = false;
                else if (typeof object.createdDate === "string")
                    message.createdDate = parseInt(object.createdDate, 10);
                else if (typeof object.createdDate === "number")
                    message.createdDate = object.createdDate;
                else if (typeof object.createdDate === "object")
                    message.createdDate = new $util.LongBits(object.createdDate.low >>> 0, object.createdDate.high >>> 0).toNumber();
            if (object.isTrial != null)
                message.isTrial = Boolean(object.isTrial);
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            if (object.scanned != null)
                message.scanned = Boolean(object.scanned);
            if (object.featureDisable != null)
                message.featureDisable = Boolean(object.featureDisable);
            return message;
        };

        /**
         * Creates a plain object from an AddOn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.AddOn} message AddOn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddOn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.licenseKeyId = 0;
                object.name = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expirationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expirationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdDate = options.longs === String ? "0" : 0;
                object.isTrial = false;
                object.enabled = false;
                object.scanned = false;
                object.featureDisable = false;
            }
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                object.licenseKeyId = message.licenseKeyId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (typeof message.expirationDate === "number")
                    object.expirationDate = options.longs === String ? String(message.expirationDate) : message.expirationDate;
                else
                    object.expirationDate = options.longs === String ? $util.Long.prototype.toString.call(message.expirationDate) : options.longs === Number ? new $util.LongBits(message.expirationDate.low >>> 0, message.expirationDate.high >>> 0).toNumber() : message.expirationDate;
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                if (typeof message.createdDate === "number")
                    object.createdDate = options.longs === String ? String(message.createdDate) : message.createdDate;
                else
                    object.createdDate = options.longs === String ? $util.Long.prototype.toString.call(message.createdDate) : options.longs === Number ? new $util.LongBits(message.createdDate.low >>> 0, message.createdDate.high >>> 0).toNumber() : message.createdDate;
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                object.isTrial = message.isTrial;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                object.scanned = message.scanned;
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                object.featureDisable = message.featureDisable;
            return object;
        };

        /**
         * Converts this AddOn to JSON.
         * @function toJSON
         * @memberof AccountSummary.AddOn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddOn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddOn;
    })();

    AccountSummary.Settings = (function() {

        /**
         * Properties of a Settings.
         * @memberof AccountSummary
         * @interface ISettings
         * @property {boolean|null} [audit] Settings audit
         * @property {number|Long|null} [mustPerfromAccountShareBy] Settings mustPerfromAccountShareBy
         * @property {Array.<AccountSummary.IMissingAccountShareKey>|null} [shareAccountTo] Settings shareAccountTo
         * @property {Array.<AccountSummary.IPasswordRule>|null} [rules] Settings rules
         * @property {string|null} [passwordRulesIntro] Settings passwordRulesIntro
         * @property {boolean|null} [twoFactorRequired] Settings twoFactorRequired
         * @property {number|null} [autoBackupDays] Settings autoBackupDays
         * @property {string|null} [theme] Settings theme
         * @property {string|null} [channel] Settings channel
         * @property {string|null} [channelValue] Settings channelValue
         * @property {boolean|null} [rsaConfigured] Settings rsaConfigured
         * @property {boolean|null} [emailVarified] Settings emailVarified
         * @property {number|null} [masterPasswordLastModified] Settings masterPasswordLastModified
         * @property {string|null} [accountFolderKey] Settings accountFolderKey
         * @property {Array.<AccountSummary.ISecurityKey>|null} [securityKeys] Settings securityKeys
         * @property {Array.<AccountSummary.IKeyValue>|null} [keyValues] Settings keyValues
         */

        /**
         * Constructs a new Settings.
         * @memberof AccountSummary
         * @classdesc Represents a Settings.
         * @implements ISettings
         * @constructor
         * @param {AccountSummary.ISettings=} [properties] Properties to set
         */
        function Settings(properties) {
            this.shareAccountTo = [];
            this.rules = [];
            this.securityKeys = [];
            this.keyValues = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Settings audit.
         * @member {boolean} audit
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.audit = false;

        /**
         * Settings mustPerfromAccountShareBy.
         * @member {number|Long} mustPerfromAccountShareBy
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.mustPerfromAccountShareBy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Settings shareAccountTo.
         * @member {Array.<AccountSummary.IMissingAccountShareKey>} shareAccountTo
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.shareAccountTo = $util.emptyArray;

        /**
         * Settings rules.
         * @member {Array.<AccountSummary.IPasswordRule>} rules
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.rules = $util.emptyArray;

        /**
         * Settings passwordRulesIntro.
         * @member {string} passwordRulesIntro
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.passwordRulesIntro = "";

        /**
         * Settings twoFactorRequired.
         * @member {boolean} twoFactorRequired
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.twoFactorRequired = false;

        /**
         * Settings autoBackupDays.
         * @member {number} autoBackupDays
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.autoBackupDays = 0;

        /**
         * Settings theme.
         * @member {string} theme
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.theme = "";

        /**
         * Settings channel.
         * @member {string} channel
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.channel = "";

        /**
         * Settings channelValue.
         * @member {string} channelValue
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.channelValue = "";

        /**
         * Settings rsaConfigured.
         * @member {boolean} rsaConfigured
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.rsaConfigured = false;

        /**
         * Settings emailVarified.
         * @member {boolean} emailVarified
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.emailVarified = false;

        /**
         * Settings masterPasswordLastModified.
         * @member {number} masterPasswordLastModified
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.masterPasswordLastModified = 0;

        /**
         * Settings accountFolderKey.
         * @member {string} accountFolderKey
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.accountFolderKey = "";

        /**
         * Settings securityKeys.
         * @member {Array.<AccountSummary.ISecurityKey>} securityKeys
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.securityKeys = $util.emptyArray;

        /**
         * Settings keyValues.
         * @member {Array.<AccountSummary.IKeyValue>} keyValues
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.keyValues = $util.emptyArray;

        /**
         * Creates a new Settings instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings=} [properties] Properties to set
         * @returns {AccountSummary.Settings} Settings instance
         */
        Settings.create = function create(properties) {
            return new Settings(properties);
        };

        /**
         * Encodes the specified Settings message. Does not implicitly {@link AccountSummary.Settings.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings} message Settings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Settings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audit != null && message.hasOwnProperty("audit"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.audit);
            if (message.mustPerfromAccountShareBy != null && message.hasOwnProperty("mustPerfromAccountShareBy"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.mustPerfromAccountShareBy);
            if (message.shareAccountTo != null && message.shareAccountTo.length)
                for (let i = 0; i < message.shareAccountTo.length; ++i)
                    $root.AccountSummary.MissingAccountShareKey.encode(message.shareAccountTo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.rules != null && message.rules.length)
                for (let i = 0; i < message.rules.length; ++i)
                    $root.AccountSummary.PasswordRule.encode(message.rules[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.passwordRulesIntro);
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.twoFactorRequired);
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.autoBackupDays);
            if (message.theme != null && message.hasOwnProperty("theme"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.theme);
            if (message.channel != null && message.hasOwnProperty("channel"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.channel);
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.channelValue);
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.rsaConfigured);
            if (message.emailVarified != null && message.hasOwnProperty("emailVarified"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.emailVarified);
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.masterPasswordLastModified);
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.accountFolderKey);
            if (message.securityKeys != null && message.securityKeys.length)
                for (let i = 0; i < message.securityKeys.length; ++i)
                    $root.AccountSummary.SecurityKey.encode(message.securityKeys[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.keyValues != null && message.keyValues.length)
                for (let i = 0; i < message.keyValues.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.keyValues[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Settings message, length delimited. Does not implicitly {@link AccountSummary.Settings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings} message Settings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Settings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Settings message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Settings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Settings} Settings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Settings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Settings();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audit = reader.bool();
                    break;
                case 2:
                    message.mustPerfromAccountShareBy = reader.int64();
                    break;
                case 3:
                    if (!(message.shareAccountTo && message.shareAccountTo.length))
                        message.shareAccountTo = [];
                    message.shareAccountTo.push($root.AccountSummary.MissingAccountShareKey.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.rules && message.rules.length))
                        message.rules = [];
                    message.rules.push($root.AccountSummary.PasswordRule.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.passwordRulesIntro = reader.string();
                    break;
                case 6:
                    message.twoFactorRequired = reader.bool();
                    break;
                case 7:
                    message.autoBackupDays = reader.int32();
                    break;
                case 8:
                    message.theme = reader.string();
                    break;
                case 9:
                    message.channel = reader.string();
                    break;
                case 10:
                    message.channelValue = reader.string();
                    break;
                case 11:
                    message.rsaConfigured = reader.bool();
                    break;
                case 12:
                    message.emailVarified = reader.bool();
                    break;
                case 13:
                    message.masterPasswordLastModified = reader.double();
                    break;
                case 14:
                    message.accountFolderKey = reader.string();
                    break;
                case 15:
                    if (!(message.securityKeys && message.securityKeys.length))
                        message.securityKeys = [];
                    message.securityKeys.push($root.AccountSummary.SecurityKey.decode(reader, reader.uint32()));
                    break;
                case 16:
                    if (!(message.keyValues && message.keyValues.length))
                        message.keyValues = [];
                    message.keyValues.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Settings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Settings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Settings} Settings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Settings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Settings message.
         * @function verify
         * @memberof AccountSummary.Settings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Settings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audit != null && message.hasOwnProperty("audit"))
                if (typeof message.audit !== "boolean")
                    return "audit: boolean expected";
            if (message.mustPerfromAccountShareBy != null && message.hasOwnProperty("mustPerfromAccountShareBy"))
                if (!$util.isInteger(message.mustPerfromAccountShareBy) && !(message.mustPerfromAccountShareBy && $util.isInteger(message.mustPerfromAccountShareBy.low) && $util.isInteger(message.mustPerfromAccountShareBy.high)))
                    return "mustPerfromAccountShareBy: integer|Long expected";
            if (message.shareAccountTo != null && message.hasOwnProperty("shareAccountTo")) {
                if (!Array.isArray(message.shareAccountTo))
                    return "shareAccountTo: array expected";
                for (let i = 0; i < message.shareAccountTo.length; ++i) {
                    let error = $root.AccountSummary.MissingAccountShareKey.verify(message.shareAccountTo[i]);
                    if (error)
                        return "shareAccountTo." + error;
                }
            }
            if (message.rules != null && message.hasOwnProperty("rules")) {
                if (!Array.isArray(message.rules))
                    return "rules: array expected";
                for (let i = 0; i < message.rules.length; ++i) {
                    let error = $root.AccountSummary.PasswordRule.verify(message.rules[i]);
                    if (error)
                        return "rules." + error;
                }
            }
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                if (!$util.isString(message.passwordRulesIntro))
                    return "passwordRulesIntro: string expected";
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                if (typeof message.twoFactorRequired !== "boolean")
                    return "twoFactorRequired: boolean expected";
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                if (!$util.isInteger(message.autoBackupDays))
                    return "autoBackupDays: integer expected";
            if (message.theme != null && message.hasOwnProperty("theme"))
                if (!$util.isString(message.theme))
                    return "theme: string expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isString(message.channel))
                    return "channel: string expected";
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                if (!$util.isString(message.channelValue))
                    return "channelValue: string expected";
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                if (typeof message.rsaConfigured !== "boolean")
                    return "rsaConfigured: boolean expected";
            if (message.emailVarified != null && message.hasOwnProperty("emailVarified"))
                if (typeof message.emailVarified !== "boolean")
                    return "emailVarified: boolean expected";
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                if (typeof message.masterPasswordLastModified !== "number")
                    return "masterPasswordLastModified: number expected";
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                if (!$util.isString(message.accountFolderKey))
                    return "accountFolderKey: string expected";
            if (message.securityKeys != null && message.hasOwnProperty("securityKeys")) {
                if (!Array.isArray(message.securityKeys))
                    return "securityKeys: array expected";
                for (let i = 0; i < message.securityKeys.length; ++i) {
                    let error = $root.AccountSummary.SecurityKey.verify(message.securityKeys[i]);
                    if (error)
                        return "securityKeys." + error;
                }
            }
            if (message.keyValues != null && message.hasOwnProperty("keyValues")) {
                if (!Array.isArray(message.keyValues))
                    return "keyValues: array expected";
                for (let i = 0; i < message.keyValues.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.keyValues[i]);
                    if (error)
                        return "keyValues." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Settings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Settings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Settings} Settings
         */
        Settings.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Settings)
                return object;
            let message = new $root.AccountSummary.Settings();
            if (object.audit != null)
                message.audit = Boolean(object.audit);
            if (object.mustPerfromAccountShareBy != null)
                if ($util.Long)
                    (message.mustPerfromAccountShareBy = $util.Long.fromValue(object.mustPerfromAccountShareBy)).unsigned = false;
                else if (typeof object.mustPerfromAccountShareBy === "string")
                    message.mustPerfromAccountShareBy = parseInt(object.mustPerfromAccountShareBy, 10);
                else if (typeof object.mustPerfromAccountShareBy === "number")
                    message.mustPerfromAccountShareBy = object.mustPerfromAccountShareBy;
                else if (typeof object.mustPerfromAccountShareBy === "object")
                    message.mustPerfromAccountShareBy = new $util.LongBits(object.mustPerfromAccountShareBy.low >>> 0, object.mustPerfromAccountShareBy.high >>> 0).toNumber();
            if (object.shareAccountTo) {
                if (!Array.isArray(object.shareAccountTo))
                    throw TypeError(".AccountSummary.Settings.shareAccountTo: array expected");
                message.shareAccountTo = [];
                for (let i = 0; i < object.shareAccountTo.length; ++i) {
                    if (typeof object.shareAccountTo[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.shareAccountTo: object expected");
                    message.shareAccountTo[i] = $root.AccountSummary.MissingAccountShareKey.fromObject(object.shareAccountTo[i]);
                }
            }
            if (object.rules) {
                if (!Array.isArray(object.rules))
                    throw TypeError(".AccountSummary.Settings.rules: array expected");
                message.rules = [];
                for (let i = 0; i < object.rules.length; ++i) {
                    if (typeof object.rules[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.rules: object expected");
                    message.rules[i] = $root.AccountSummary.PasswordRule.fromObject(object.rules[i]);
                }
            }
            if (object.passwordRulesIntro != null)
                message.passwordRulesIntro = String(object.passwordRulesIntro);
            if (object.twoFactorRequired != null)
                message.twoFactorRequired = Boolean(object.twoFactorRequired);
            if (object.autoBackupDays != null)
                message.autoBackupDays = object.autoBackupDays | 0;
            if (object.theme != null)
                message.theme = String(object.theme);
            if (object.channel != null)
                message.channel = String(object.channel);
            if (object.channelValue != null)
                message.channelValue = String(object.channelValue);
            if (object.rsaConfigured != null)
                message.rsaConfigured = Boolean(object.rsaConfigured);
            if (object.emailVarified != null)
                message.emailVarified = Boolean(object.emailVarified);
            if (object.masterPasswordLastModified != null)
                message.masterPasswordLastModified = Number(object.masterPasswordLastModified);
            if (object.accountFolderKey != null)
                message.accountFolderKey = String(object.accountFolderKey);
            if (object.securityKeys) {
                if (!Array.isArray(object.securityKeys))
                    throw TypeError(".AccountSummary.Settings.securityKeys: array expected");
                message.securityKeys = [];
                for (let i = 0; i < object.securityKeys.length; ++i) {
                    if (typeof object.securityKeys[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.securityKeys: object expected");
                    message.securityKeys[i] = $root.AccountSummary.SecurityKey.fromObject(object.securityKeys[i]);
                }
            }
            if (object.keyValues) {
                if (!Array.isArray(object.keyValues))
                    throw TypeError(".AccountSummary.Settings.keyValues: array expected");
                message.keyValues = [];
                for (let i = 0; i < object.keyValues.length; ++i) {
                    if (typeof object.keyValues[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.keyValues: object expected");
                    message.keyValues[i] = $root.AccountSummary.KeyValue.fromObject(object.keyValues[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Settings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.Settings} message Settings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Settings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.shareAccountTo = [];
                object.rules = [];
                object.securityKeys = [];
                object.keyValues = [];
            }
            if (options.defaults) {
                object.audit = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.mustPerfromAccountShareBy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mustPerfromAccountShareBy = options.longs === String ? "0" : 0;
                object.passwordRulesIntro = "";
                object.twoFactorRequired = false;
                object.autoBackupDays = 0;
                object.theme = "";
                object.channel = "";
                object.channelValue = "";
                object.rsaConfigured = false;
                object.emailVarified = false;
                object.masterPasswordLastModified = 0;
                object.accountFolderKey = "";
            }
            if (message.audit != null && message.hasOwnProperty("audit"))
                object.audit = message.audit;
            if (message.mustPerfromAccountShareBy != null && message.hasOwnProperty("mustPerfromAccountShareBy"))
                if (typeof message.mustPerfromAccountShareBy === "number")
                    object.mustPerfromAccountShareBy = options.longs === String ? String(message.mustPerfromAccountShareBy) : message.mustPerfromAccountShareBy;
                else
                    object.mustPerfromAccountShareBy = options.longs === String ? $util.Long.prototype.toString.call(message.mustPerfromAccountShareBy) : options.longs === Number ? new $util.LongBits(message.mustPerfromAccountShareBy.low >>> 0, message.mustPerfromAccountShareBy.high >>> 0).toNumber() : message.mustPerfromAccountShareBy;
            if (message.shareAccountTo && message.shareAccountTo.length) {
                object.shareAccountTo = [];
                for (let j = 0; j < message.shareAccountTo.length; ++j)
                    object.shareAccountTo[j] = $root.AccountSummary.MissingAccountShareKey.toObject(message.shareAccountTo[j], options);
            }
            if (message.rules && message.rules.length) {
                object.rules = [];
                for (let j = 0; j < message.rules.length; ++j)
                    object.rules[j] = $root.AccountSummary.PasswordRule.toObject(message.rules[j], options);
            }
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                object.passwordRulesIntro = message.passwordRulesIntro;
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                object.twoFactorRequired = message.twoFactorRequired;
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                object.autoBackupDays = message.autoBackupDays;
            if (message.theme != null && message.hasOwnProperty("theme"))
                object.theme = message.theme;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                object.channelValue = message.channelValue;
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                object.rsaConfigured = message.rsaConfigured;
            if (message.emailVarified != null && message.hasOwnProperty("emailVarified"))
                object.emailVarified = message.emailVarified;
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                object.masterPasswordLastModified = options.json && !isFinite(message.masterPasswordLastModified) ? String(message.masterPasswordLastModified) : message.masterPasswordLastModified;
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                object.accountFolderKey = message.accountFolderKey;
            if (message.securityKeys && message.securityKeys.length) {
                object.securityKeys = [];
                for (let j = 0; j < message.securityKeys.length; ++j)
                    object.securityKeys[j] = $root.AccountSummary.SecurityKey.toObject(message.securityKeys[j], options);
            }
            if (message.keyValues && message.keyValues.length) {
                object.keyValues = [];
                for (let j = 0; j < message.keyValues.length; ++j)
                    object.keyValues[j] = $root.AccountSummary.KeyValue.toObject(message.keyValues[j], options);
            }
            return object;
        };

        /**
         * Converts this Settings to JSON.
         * @function toJSON
         * @memberof AccountSummary.Settings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Settings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Settings;
    })();

    AccountSummary.KeyValue = (function() {

        /**
         * Properties of a KeyValue.
         * @memberof AccountSummary
         * @interface IKeyValue
         * @property {string|null} [key] KeyValue key
         * @property {string|null} [value] KeyValue value
         */

        /**
         * Constructs a new KeyValue.
         * @memberof AccountSummary
         * @classdesc Represents a KeyValue.
         * @implements IKeyValue
         * @constructor
         * @param {AccountSummary.IKeyValue=} [properties] Properties to set
         */
        function KeyValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValue key.
         * @member {string} key
         * @memberof AccountSummary.KeyValue
         * @instance
         */
        KeyValue.prototype.key = "";

        /**
         * KeyValue value.
         * @member {string} value
         * @memberof AccountSummary.KeyValue
         * @instance
         */
        KeyValue.prototype.value = "";

        /**
         * Creates a new KeyValue instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue=} [properties] Properties to set
         * @returns {AccountSummary.KeyValue} KeyValue instance
         */
        KeyValue.create = function create(properties) {
            return new KeyValue(properties);
        };

        /**
         * Encodes the specified KeyValue message. Does not implicitly {@link AccountSummary.KeyValue.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue} message KeyValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link AccountSummary.KeyValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue} message KeyValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyValue message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeyValue} KeyValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeyValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeyValue} KeyValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyValue message.
         * @function verify
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeyValue} KeyValue
         */
        KeyValue.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeyValue)
                return object;
            let message = new $root.AccountSummary.KeyValue();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.KeyValue} message KeyValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this KeyValue to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeyValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyValue;
    })();

    AccountSummary.MissingAccountShareKey = (function() {

        /**
         * Properties of a MissingAccountShareKey.
         * @memberof AccountSummary
         * @interface IMissingAccountShareKey
         * @property {number|Long|null} [roleId] MissingAccountShareKey roleId
         * @property {string|null} [publicKey] MissingAccountShareKey publicKey
         */

        /**
         * Constructs a new MissingAccountShareKey.
         * @memberof AccountSummary
         * @classdesc Represents a MissingAccountShareKey.
         * @implements IMissingAccountShareKey
         * @constructor
         * @param {AccountSummary.IMissingAccountShareKey=} [properties] Properties to set
         */
        function MissingAccountShareKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MissingAccountShareKey roleId.
         * @member {number|Long} roleId
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         */
        MissingAccountShareKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MissingAccountShareKey publicKey.
         * @member {string} publicKey
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         */
        MissingAccountShareKey.prototype.publicKey = "";

        /**
         * Creates a new MissingAccountShareKey instance using the specified properties.
         * @function create
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey=} [properties] Properties to set
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey instance
         */
        MissingAccountShareKey.create = function create(properties) {
            return new MissingAccountShareKey(properties);
        };

        /**
         * Encodes the specified MissingAccountShareKey message. Does not implicitly {@link AccountSummary.MissingAccountShareKey.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey} message MissingAccountShareKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAccountShareKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified MissingAccountShareKey message, length delimited. Does not implicitly {@link AccountSummary.MissingAccountShareKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey} message MissingAccountShareKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAccountShareKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissingAccountShareKey message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAccountShareKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.MissingAccountShareKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.publicKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissingAccountShareKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAccountShareKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissingAccountShareKey message.
         * @function verify
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissingAccountShareKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!$util.isString(message.publicKey))
                    return "publicKey: string expected";
            return null;
        };

        /**
         * Creates a MissingAccountShareKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         */
        MissingAccountShareKey.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.MissingAccountShareKey)
                return object;
            let message = new $root.AccountSummary.MissingAccountShareKey();
            if (object.roleId != null)
                if ($util.Long)
                    (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
                else if (typeof object.roleId === "string")
                    message.roleId = parseInt(object.roleId, 10);
                else if (typeof object.roleId === "number")
                    message.roleId = object.roleId;
                else if (typeof object.roleId === "object")
                    message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber();
            if (object.publicKey != null)
                message.publicKey = String(object.publicKey);
            return message;
        };

        /**
         * Creates a plain object from a MissingAccountShareKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.MissingAccountShareKey} message MissingAccountShareKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MissingAccountShareKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roleId = options.longs === String ? "0" : 0;
                object.publicKey = "";
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (typeof message.roleId === "number")
                    object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                else
                    object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber() : message.roleId;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = message.publicKey;
            return object;
        };

        /**
         * Converts this MissingAccountShareKey to JSON.
         * @function toJSON
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MissingAccountShareKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MissingAccountShareKey;
    })();

    AccountSummary.PasswordRule = (function() {

        /**
         * Properties of a PasswordRule.
         * @memberof AccountSummary
         * @interface IPasswordRule
         * @property {string|null} [roleType] PasswordRule roleType
         * @property {string|null} [pattern] PasswordRule pattern
         * @property {string|null} [ruleType] PasswordRule ruleType
         * @property {boolean|null} [match] PasswordRule match
         * @property {string|null} [minimum] PasswordRule minimum
         * @property {string|null} [description] PasswordRule description
         * @property {string|null} [value] PasswordRule value
         */

        /**
         * Constructs a new PasswordRule.
         * @memberof AccountSummary
         * @classdesc Represents a PasswordRule.
         * @implements IPasswordRule
         * @constructor
         * @param {AccountSummary.IPasswordRule=} [properties] Properties to set
         */
        function PasswordRule(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PasswordRule roleType.
         * @member {string} roleType
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.roleType = "";

        /**
         * PasswordRule pattern.
         * @member {string} pattern
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.pattern = "";

        /**
         * PasswordRule ruleType.
         * @member {string} ruleType
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.ruleType = "";

        /**
         * PasswordRule match.
         * @member {boolean} match
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.match = false;

        /**
         * PasswordRule minimum.
         * @member {string} minimum
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.minimum = "";

        /**
         * PasswordRule description.
         * @member {string} description
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.description = "";

        /**
         * PasswordRule value.
         * @member {string} value
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.value = "";

        /**
         * Creates a new PasswordRule instance using the specified properties.
         * @function create
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule=} [properties] Properties to set
         * @returns {AccountSummary.PasswordRule} PasswordRule instance
         */
        PasswordRule.create = function create(properties) {
            return new PasswordRule(properties);
        };

        /**
         * Encodes the specified PasswordRule message. Does not implicitly {@link AccountSummary.PasswordRule.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule} message PasswordRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasswordRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleType != null && message.hasOwnProperty("roleType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roleType);
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pattern);
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ruleType);
            if (message.match != null && message.hasOwnProperty("match"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.match);
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.minimum);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PasswordRule message, length delimited. Does not implicitly {@link AccountSummary.PasswordRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule} message PasswordRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasswordRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PasswordRule message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.PasswordRule} PasswordRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasswordRule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.PasswordRule();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleType = reader.string();
                    break;
                case 2:
                    message.pattern = reader.string();
                    break;
                case 3:
                    message.ruleType = reader.string();
                    break;
                case 4:
                    message.match = reader.bool();
                    break;
                case 5:
                    message.minimum = reader.string();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 7:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PasswordRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.PasswordRule} PasswordRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasswordRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PasswordRule message.
         * @function verify
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PasswordRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleType != null && message.hasOwnProperty("roleType"))
                if (!$util.isString(message.roleType))
                    return "roleType: string expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                if (!$util.isString(message.ruleType))
                    return "ruleType: string expected";
            if (message.match != null && message.hasOwnProperty("match"))
                if (typeof message.match !== "boolean")
                    return "match: boolean expected";
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                if (!$util.isString(message.minimum))
                    return "minimum: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PasswordRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.PasswordRule} PasswordRule
         */
        PasswordRule.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.PasswordRule)
                return object;
            let message = new $root.AccountSummary.PasswordRule();
            if (object.roleType != null)
                message.roleType = String(object.roleType);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.ruleType != null)
                message.ruleType = String(object.ruleType);
            if (object.match != null)
                message.match = Boolean(object.match);
            if (object.minimum != null)
                message.minimum = String(object.minimum);
            if (object.description != null)
                message.description = String(object.description);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PasswordRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.PasswordRule} message PasswordRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PasswordRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.roleType = "";
                object.pattern = "";
                object.ruleType = "";
                object.match = false;
                object.minimum = "";
                object.description = "";
                object.value = "";
            }
            if (message.roleType != null && message.hasOwnProperty("roleType"))
                object.roleType = message.roleType;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                object.ruleType = message.ruleType;
            if (message.match != null && message.hasOwnProperty("match"))
                object.match = message.match;
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                object.minimum = message.minimum;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PasswordRule to JSON.
         * @function toJSON
         * @memberof AccountSummary.PasswordRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PasswordRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PasswordRule;
    })();

    AccountSummary.SecurityKey = (function() {

        /**
         * Properties of a SecurityKey.
         * @memberof AccountSummary
         * @interface ISecurityKey
         * @property {number|Long|null} [deviceId] SecurityKey deviceId
         * @property {string|null} [deviceName] SecurityKey deviceName
         * @property {number|Long|null} [dateAdded] SecurityKey dateAdded
         * @property {boolean|null} [isValid] SecurityKey isValid
         * @property {AccountSummary.IDeviceRegistration|null} [deviceRegistration] SecurityKey deviceRegistration
         */

        /**
         * Constructs a new SecurityKey.
         * @memberof AccountSummary
         * @classdesc Represents a SecurityKey.
         * @implements ISecurityKey
         * @constructor
         * @param {AccountSummary.ISecurityKey=} [properties] Properties to set
         */
        function SecurityKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityKey deviceId.
         * @member {number|Long} deviceId
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityKey deviceName.
         * @member {string} deviceName
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceName = "";

        /**
         * SecurityKey dateAdded.
         * @member {number|Long} dateAdded
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.dateAdded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityKey isValid.
         * @member {boolean} isValid
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.isValid = false;

        /**
         * SecurityKey deviceRegistration.
         * @member {AccountSummary.IDeviceRegistration|null|undefined} deviceRegistration
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceRegistration = null;

        /**
         * Creates a new SecurityKey instance using the specified properties.
         * @function create
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey=} [properties] Properties to set
         * @returns {AccountSummary.SecurityKey} SecurityKey instance
         */
        SecurityKey.create = function create(properties) {
            return new SecurityKey(properties);
        };

        /**
         * Encodes the specified SecurityKey message. Does not implicitly {@link AccountSummary.SecurityKey.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey} message SecurityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.dateAdded);
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isValid);
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration"))
                $root.AccountSummary.DeviceRegistration.encode(message.deviceRegistration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityKey message, length delimited. Does not implicitly {@link AccountSummary.SecurityKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey} message SecurityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityKey message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.SecurityKey} SecurityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.SecurityKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                case 3:
                    message.dateAdded = reader.int64();
                    break;
                case 4:
                    message.isValid = reader.bool();
                    break;
                case 5:
                    message.deviceRegistration = $root.AccountSummary.DeviceRegistration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.SecurityKey} SecurityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityKey message.
         * @function verify
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                if (!$util.isInteger(message.dateAdded) && !(message.dateAdded && $util.isInteger(message.dateAdded.low) && $util.isInteger(message.dateAdded.high)))
                    return "dateAdded: integer|Long expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration")) {
                let error = $root.AccountSummary.DeviceRegistration.verify(message.deviceRegistration);
                if (error)
                    return "deviceRegistration." + error;
            }
            return null;
        };

        /**
         * Creates a SecurityKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.SecurityKey} SecurityKey
         */
        SecurityKey.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.SecurityKey)
                return object;
            let message = new $root.AccountSummary.SecurityKey();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.dateAdded != null)
                if ($util.Long)
                    (message.dateAdded = $util.Long.fromValue(object.dateAdded)).unsigned = false;
                else if (typeof object.dateAdded === "string")
                    message.dateAdded = parseInt(object.dateAdded, 10);
                else if (typeof object.dateAdded === "number")
                    message.dateAdded = object.dateAdded;
                else if (typeof object.dateAdded === "object")
                    message.dateAdded = new $util.LongBits(object.dateAdded.low >>> 0, object.dateAdded.high >>> 0).toNumber();
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            if (object.deviceRegistration != null) {
                if (typeof object.deviceRegistration !== "object")
                    throw TypeError(".AccountSummary.SecurityKey.deviceRegistration: object expected");
                message.deviceRegistration = $root.AccountSummary.DeviceRegistration.fromObject(object.deviceRegistration);
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.SecurityKey} message SecurityKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.deviceName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.dateAdded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dateAdded = options.longs === String ? "0" : 0;
                object.isValid = false;
                object.deviceRegistration = null;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                if (typeof message.dateAdded === "number")
                    object.dateAdded = options.longs === String ? String(message.dateAdded) : message.dateAdded;
                else
                    object.dateAdded = options.longs === String ? $util.Long.prototype.toString.call(message.dateAdded) : options.longs === Number ? new $util.LongBits(message.dateAdded.low >>> 0, message.dateAdded.high >>> 0).toNumber() : message.dateAdded;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration"))
                object.deviceRegistration = $root.AccountSummary.DeviceRegistration.toObject(message.deviceRegistration, options);
            return object;
        };

        /**
         * Converts this SecurityKey to JSON.
         * @function toJSON
         * @memberof AccountSummary.SecurityKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityKey;
    })();

    AccountSummary.DeviceRegistration = (function() {

        /**
         * Properties of a DeviceRegistration.
         * @memberof AccountSummary
         * @interface IDeviceRegistration
         * @property {string|null} [keyHandle] DeviceRegistration keyHandle
         * @property {string|null} [publicKey] DeviceRegistration publicKey
         * @property {string|null} [attestationCert] DeviceRegistration attestationCert
         * @property {number|Long|null} [counter] DeviceRegistration counter
         * @property {boolean|null} [compromised] DeviceRegistration compromised
         */

        /**
         * Constructs a new DeviceRegistration.
         * @memberof AccountSummary
         * @classdesc Represents a DeviceRegistration.
         * @implements IDeviceRegistration
         * @constructor
         * @param {AccountSummary.IDeviceRegistration=} [properties] Properties to set
         */
        function DeviceRegistration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRegistration keyHandle.
         * @member {string} keyHandle
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.keyHandle = "";

        /**
         * DeviceRegistration publicKey.
         * @member {string} publicKey
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.publicKey = "";

        /**
         * DeviceRegistration attestationCert.
         * @member {string} attestationCert
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.attestationCert = "";

        /**
         * DeviceRegistration counter.
         * @member {number|Long} counter
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.counter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceRegistration compromised.
         * @member {boolean} compromised
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.compromised = false;

        /**
         * Creates a new DeviceRegistration instance using the specified properties.
         * @function create
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration=} [properties] Properties to set
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration instance
         */
        DeviceRegistration.create = function create(properties) {
            return new DeviceRegistration(properties);
        };

        /**
         * Encodes the specified DeviceRegistration message. Does not implicitly {@link AccountSummary.DeviceRegistration.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration} message DeviceRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyHandle);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.publicKey);
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.attestationCert);
            if (message.counter != null && message.hasOwnProperty("counter"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.counter);
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.compromised);
            return writer;
        };

        /**
         * Encodes the specified DeviceRegistration message, length delimited. Does not implicitly {@link AccountSummary.DeviceRegistration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration} message DeviceRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRegistration message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.DeviceRegistration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyHandle = reader.string();
                    break;
                case 2:
                    message.publicKey = reader.string();
                    break;
                case 3:
                    message.attestationCert = reader.string();
                    break;
                case 4:
                    message.counter = reader.int64();
                    break;
                case 5:
                    message.compromised = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRegistration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRegistration message.
         * @function verify
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRegistration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                if (!$util.isString(message.keyHandle))
                    return "keyHandle: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!$util.isString(message.publicKey))
                    return "publicKey: string expected";
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                if (!$util.isString(message.attestationCert))
                    return "attestationCert: string expected";
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (!$util.isInteger(message.counter) && !(message.counter && $util.isInteger(message.counter.low) && $util.isInteger(message.counter.high)))
                    return "counter: integer|Long expected";
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                if (typeof message.compromised !== "boolean")
                    return "compromised: boolean expected";
            return null;
        };

        /**
         * Creates a DeviceRegistration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         */
        DeviceRegistration.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.DeviceRegistration)
                return object;
            let message = new $root.AccountSummary.DeviceRegistration();
            if (object.keyHandle != null)
                message.keyHandle = String(object.keyHandle);
            if (object.publicKey != null)
                message.publicKey = String(object.publicKey);
            if (object.attestationCert != null)
                message.attestationCert = String(object.attestationCert);
            if (object.counter != null)
                if ($util.Long)
                    (message.counter = $util.Long.fromValue(object.counter)).unsigned = false;
                else if (typeof object.counter === "string")
                    message.counter = parseInt(object.counter, 10);
                else if (typeof object.counter === "number")
                    message.counter = object.counter;
                else if (typeof object.counter === "object")
                    message.counter = new $util.LongBits(object.counter.low >>> 0, object.counter.high >>> 0).toNumber();
            if (object.compromised != null)
                message.compromised = Boolean(object.compromised);
            return message;
        };

        /**
         * Creates a plain object from a DeviceRegistration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.DeviceRegistration} message DeviceRegistration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRegistration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.keyHandle = "";
                object.publicKey = "";
                object.attestationCert = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.counter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.counter = options.longs === String ? "0" : 0;
                object.compromised = false;
            }
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                object.keyHandle = message.keyHandle;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = message.publicKey;
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                object.attestationCert = message.attestationCert;
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (typeof message.counter === "number")
                    object.counter = options.longs === String ? String(message.counter) : message.counter;
                else
                    object.counter = options.longs === String ? $util.Long.prototype.toString.call(message.counter) : options.longs === Number ? new $util.LongBits(message.counter.low >>> 0, message.counter.high >>> 0).toNumber() : message.counter;
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                object.compromised = message.compromised;
            return object;
        };

        /**
         * Converts this DeviceRegistration to JSON.
         * @function toJSON
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRegistration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRegistration;
    })();

    AccountSummary.Groups = (function() {

        /**
         * Properties of a Groups.
         * @memberof AccountSummary
         * @interface IGroups
         * @property {boolean|null} [admin] Groups admin
         * @property {string|null} [groupVerificationCode] Groups groupVerificationCode
         * @property {Array.<AccountSummary.IKeyValue>|null} [groupSettings] Groups groupSettings
         * @property {AccountSummary.IAdministrator|null} [administrator] Groups administrator
         */

        /**
         * Constructs a new Groups.
         * @memberof AccountSummary
         * @classdesc Represents a Groups.
         * @implements IGroups
         * @constructor
         * @param {AccountSummary.IGroups=} [properties] Properties to set
         */
        function Groups(properties) {
            this.groupSettings = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Groups admin.
         * @member {boolean} admin
         * @memberof AccountSummary.Groups
         * @instance
         */
        Groups.prototype.admin = false;

        /**
         * Groups groupVerificationCode.
         * @member {string} groupVerificationCode
         * @memberof AccountSummary.Groups
         * @instance
         */
        Groups.prototype.groupVerificationCode = "";

        /**
         * Groups groupSettings.
         * @member {Array.<AccountSummary.IKeyValue>} groupSettings
         * @memberof AccountSummary.Groups
         * @instance
         */
        Groups.prototype.groupSettings = $util.emptyArray;

        /**
         * Groups administrator.
         * @member {AccountSummary.IAdministrator|null|undefined} administrator
         * @memberof AccountSummary.Groups
         * @instance
         */
        Groups.prototype.administrator = null;

        /**
         * Creates a new Groups instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Groups
         * @static
         * @param {AccountSummary.IGroups=} [properties] Properties to set
         * @returns {AccountSummary.Groups} Groups instance
         */
        Groups.create = function create(properties) {
            return new Groups(properties);
        };

        /**
         * Encodes the specified Groups message. Does not implicitly {@link AccountSummary.Groups.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Groups
         * @static
         * @param {AccountSummary.IGroups} message Groups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Groups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.admin);
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupVerificationCode);
            if (message.groupSettings != null && message.groupSettings.length)
                for (let i = 0; i < message.groupSettings.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.groupSettings[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.administrator != null && message.hasOwnProperty("administrator"))
                $root.AccountSummary.Administrator.encode(message.administrator, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Groups message, length delimited. Does not implicitly {@link AccountSummary.Groups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Groups
         * @static
         * @param {AccountSummary.IGroups} message Groups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Groups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Groups message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Groups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Groups} Groups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Groups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Groups();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.admin = reader.bool();
                    break;
                case 2:
                    message.groupVerificationCode = reader.string();
                    break;
                case 3:
                    if (!(message.groupSettings && message.groupSettings.length))
                        message.groupSettings = [];
                    message.groupSettings.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.administrator = $root.AccountSummary.Administrator.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Groups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Groups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Groups} Groups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Groups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Groups message.
         * @function verify
         * @memberof AccountSummary.Groups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Groups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                if (!$util.isString(message.groupVerificationCode))
                    return "groupVerificationCode: string expected";
            if (message.groupSettings != null && message.hasOwnProperty("groupSettings")) {
                if (!Array.isArray(message.groupSettings))
                    return "groupSettings: array expected";
                for (let i = 0; i < message.groupSettings.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.groupSettings[i]);
                    if (error)
                        return "groupSettings." + error;
                }
            }
            if (message.administrator != null && message.hasOwnProperty("administrator")) {
                let error = $root.AccountSummary.Administrator.verify(message.administrator);
                if (error)
                    return "administrator." + error;
            }
            return null;
        };

        /**
         * Creates a Groups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Groups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Groups} Groups
         */
        Groups.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Groups)
                return object;
            let message = new $root.AccountSummary.Groups();
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            if (object.groupVerificationCode != null)
                message.groupVerificationCode = String(object.groupVerificationCode);
            if (object.groupSettings) {
                if (!Array.isArray(object.groupSettings))
                    throw TypeError(".AccountSummary.Groups.groupSettings: array expected");
                message.groupSettings = [];
                for (let i = 0; i < object.groupSettings.length; ++i) {
                    if (typeof object.groupSettings[i] !== "object")
                        throw TypeError(".AccountSummary.Groups.groupSettings: object expected");
                    message.groupSettings[i] = $root.AccountSummary.KeyValue.fromObject(object.groupSettings[i]);
                }
            }
            if (object.administrator != null) {
                if (typeof object.administrator !== "object")
                    throw TypeError(".AccountSummary.Groups.administrator: object expected");
                message.administrator = $root.AccountSummary.Administrator.fromObject(object.administrator);
            }
            return message;
        };

        /**
         * Creates a plain object from a Groups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Groups
         * @static
         * @param {AccountSummary.Groups} message Groups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Groups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.groupSettings = [];
            if (options.defaults) {
                object.admin = false;
                object.groupVerificationCode = "";
                object.administrator = null;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                object.groupVerificationCode = message.groupVerificationCode;
            if (message.groupSettings && message.groupSettings.length) {
                object.groupSettings = [];
                for (let j = 0; j < message.groupSettings.length; ++j)
                    object.groupSettings[j] = $root.AccountSummary.KeyValue.toObject(message.groupSettings[j], options);
            }
            if (message.administrator != null && message.hasOwnProperty("administrator"))
                object.administrator = $root.AccountSummary.Administrator.toObject(message.administrator, options);
            return object;
        };

        /**
         * Converts this Groups to JSON.
         * @function toJSON
         * @memberof AccountSummary.Groups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Groups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Groups;
    })();

    AccountSummary.Administrator = (function() {

        /**
         * Properties of an Administrator.
         * @memberof AccountSummary
         * @interface IAdministrator
         * @property {string|null} [firstName] Administrator firstName
         * @property {string|null} [lastName] Administrator lastName
         * @property {string|null} [email] Administrator email
         * @property {number|null} [currentNumberOfUsers] Administrator currentNumberOfUsers
         * @property {number|null} [numberOfUsers] Administrator numberOfUsers
         * @property {number|null} [numberOfDevices] Administrator numberOfDevices
         * @property {string|null} [subscriptionCode] Administrator subscriptionCode
         * @property {string|null} [exiprationDate] Administrator exiprationDate
         * @property {string|null} [purchaseDate] Administrator purchaseDate
         * @property {string|null} [total] Administrator total
         */

        /**
         * Constructs a new Administrator.
         * @memberof AccountSummary
         * @classdesc Represents an Administrator.
         * @implements IAdministrator
         * @constructor
         * @param {AccountSummary.IAdministrator=} [properties] Properties to set
         */
        function Administrator(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Administrator firstName.
         * @member {string} firstName
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.firstName = "";

        /**
         * Administrator lastName.
         * @member {string} lastName
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.lastName = "";

        /**
         * Administrator email.
         * @member {string} email
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.email = "";

        /**
         * Administrator currentNumberOfUsers.
         * @member {number} currentNumberOfUsers
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.currentNumberOfUsers = 0;

        /**
         * Administrator numberOfUsers.
         * @member {number} numberOfUsers
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.numberOfUsers = 0;

        /**
         * Administrator numberOfDevices.
         * @member {number} numberOfDevices
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.numberOfDevices = 0;

        /**
         * Administrator subscriptionCode.
         * @member {string} subscriptionCode
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.subscriptionCode = "";

        /**
         * Administrator exiprationDate.
         * @member {string} exiprationDate
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.exiprationDate = "";

        /**
         * Administrator purchaseDate.
         * @member {string} purchaseDate
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.purchaseDate = "";

        /**
         * Administrator total.
         * @member {string} total
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.total = "";

        /**
         * Creates a new Administrator instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator=} [properties] Properties to set
         * @returns {AccountSummary.Administrator} Administrator instance
         */
        Administrator.create = function create(properties) {
            return new Administrator(properties);
        };

        /**
         * Encodes the specified Administrator message. Does not implicitly {@link AccountSummary.Administrator.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator} message Administrator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Administrator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.firstName);
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.lastName);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.currentNumberOfUsers);
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numberOfUsers);
            if (message.numberOfDevices != null && message.hasOwnProperty("numberOfDevices"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.numberOfDevices);
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.subscriptionCode);
            if (message.exiprationDate != null && message.hasOwnProperty("exiprationDate"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.exiprationDate);
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.purchaseDate);
            if (message.total != null && message.hasOwnProperty("total"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.total);
            return writer;
        };

        /**
         * Encodes the specified Administrator message, length delimited. Does not implicitly {@link AccountSummary.Administrator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator} message Administrator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Administrator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Administrator message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Administrator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Administrator} Administrator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Administrator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Administrator();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.firstName = reader.string();
                    break;
                case 2:
                    message.lastName = reader.string();
                    break;
                case 3:
                    message.email = reader.string();
                    break;
                case 4:
                    message.currentNumberOfUsers = reader.int32();
                    break;
                case 5:
                    message.numberOfUsers = reader.int32();
                    break;
                case 6:
                    message.numberOfDevices = reader.int32();
                    break;
                case 7:
                    message.subscriptionCode = reader.string();
                    break;
                case 8:
                    message.exiprationDate = reader.string();
                    break;
                case 9:
                    message.purchaseDate = reader.string();
                    break;
                case 10:
                    message.total = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Administrator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Administrator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Administrator} Administrator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Administrator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Administrator message.
         * @function verify
         * @memberof AccountSummary.Administrator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Administrator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                if (!$util.isString(message.firstName))
                    return "firstName: string expected";
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                if (!$util.isString(message.lastName))
                    return "lastName: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                if (!$util.isInteger(message.currentNumberOfUsers))
                    return "currentNumberOfUsers: integer expected";
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                if (!$util.isInteger(message.numberOfUsers))
                    return "numberOfUsers: integer expected";
            if (message.numberOfDevices != null && message.hasOwnProperty("numberOfDevices"))
                if (!$util.isInteger(message.numberOfDevices))
                    return "numberOfDevices: integer expected";
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                if (!$util.isString(message.subscriptionCode))
                    return "subscriptionCode: string expected";
            if (message.exiprationDate != null && message.hasOwnProperty("exiprationDate"))
                if (!$util.isString(message.exiprationDate))
                    return "exiprationDate: string expected";
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                if (!$util.isString(message.purchaseDate))
                    return "purchaseDate: string expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isString(message.total))
                    return "total: string expected";
            return null;
        };

        /**
         * Creates an Administrator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Administrator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Administrator} Administrator
         */
        Administrator.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Administrator)
                return object;
            let message = new $root.AccountSummary.Administrator();
            if (object.firstName != null)
                message.firstName = String(object.firstName);
            if (object.lastName != null)
                message.lastName = String(object.lastName);
            if (object.email != null)
                message.email = String(object.email);
            if (object.currentNumberOfUsers != null)
                message.currentNumberOfUsers = object.currentNumberOfUsers | 0;
            if (object.numberOfUsers != null)
                message.numberOfUsers = object.numberOfUsers | 0;
            if (object.numberOfDevices != null)
                message.numberOfDevices = object.numberOfDevices | 0;
            if (object.subscriptionCode != null)
                message.subscriptionCode = String(object.subscriptionCode);
            if (object.exiprationDate != null)
                message.exiprationDate = String(object.exiprationDate);
            if (object.purchaseDate != null)
                message.purchaseDate = String(object.purchaseDate);
            if (object.total != null)
                message.total = String(object.total);
            return message;
        };

        /**
         * Creates a plain object from an Administrator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.Administrator} message Administrator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Administrator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.firstName = "";
                object.lastName = "";
                object.email = "";
                object.currentNumberOfUsers = 0;
                object.numberOfUsers = 0;
                object.numberOfDevices = 0;
                object.subscriptionCode = "";
                object.exiprationDate = "";
                object.purchaseDate = "";
                object.total = "";
            }
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                object.firstName = message.firstName;
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                object.lastName = message.lastName;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                object.currentNumberOfUsers = message.currentNumberOfUsers;
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                object.numberOfUsers = message.numberOfUsers;
            if (message.numberOfDevices != null && message.hasOwnProperty("numberOfDevices"))
                object.numberOfDevices = message.numberOfDevices;
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                object.subscriptionCode = message.subscriptionCode;
            if (message.exiprationDate != null && message.hasOwnProperty("exiprationDate"))
                object.exiprationDate = message.exiprationDate;
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                object.purchaseDate = message.purchaseDate;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            return object;
        };

        /**
         * Converts this Administrator to JSON.
         * @function toJSON
         * @memberof AccountSummary.Administrator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Administrator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Administrator;
    })();

    return AccountSummary;
})();

export const BITokenValidation = $root.BITokenValidation = (() => {

    /**
     * Namespace BITokenValidation.
     * @exports BITokenValidation
     * @namespace
     */
    const BITokenValidation = {};

    /**
     * SupportedLanguage enum.
     * @name BITokenValidation.SupportedLanguage
     * @enum {string}
     * @property {number} ENGLISH=0 ENGLISH value
     * @property {number} ARABIC=1 ARABIC value
     * @property {number} BRITISH=2 BRITISH value
     * @property {number} CHINESE=3 CHINESE value
     * @property {number} CHINESE_HONG_KONG=4 CHINESE_HONG_KONG value
     * @property {number} CHINESE_TAIWAN=5 CHINESE_TAIWAN value
     * @property {number} DUTCH=6 DUTCH value
     * @property {number} FRENCH=7 FRENCH value
     * @property {number} GERMAN=8 GERMAN value
     * @property {number} GREEK=9 GREEK value
     * @property {number} HEBREW=10 HEBREW value
     * @property {number} ITALIAN=11 ITALIAN value
     * @property {number} JAPANESE=12 JAPANESE value
     * @property {number} KOREAN=13 KOREAN value
     * @property {number} POLISH=14 POLISH value
     * @property {number} PORTUGUESE=15 PORTUGUESE value
     * @property {number} PORTUGUESE_BRAZIL=16 PORTUGUESE_BRAZIL value
     * @property {number} ROMANIAN=17 ROMANIAN value
     * @property {number} RUSSIAN=18 RUSSIAN value
     * @property {number} SLOVAK=19 SLOVAK value
     * @property {number} SPANISH=20 SPANISH value
     */
    BITokenValidation.SupportedLanguage = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENGLISH"] = 0;
        values[valuesById[1] = "ARABIC"] = 1;
        values[valuesById[2] = "BRITISH"] = 2;
        values[valuesById[3] = "CHINESE"] = 3;
        values[valuesById[4] = "CHINESE_HONG_KONG"] = 4;
        values[valuesById[5] = "CHINESE_TAIWAN"] = 5;
        values[valuesById[6] = "DUTCH"] = 6;
        values[valuesById[7] = "FRENCH"] = 7;
        values[valuesById[8] = "GERMAN"] = 8;
        values[valuesById[9] = "GREEK"] = 9;
        values[valuesById[10] = "HEBREW"] = 10;
        values[valuesById[11] = "ITALIAN"] = 11;
        values[valuesById[12] = "JAPANESE"] = 12;
        values[valuesById[13] = "KOREAN"] = 13;
        values[valuesById[14] = "POLISH"] = 14;
        values[valuesById[15] = "PORTUGUESE"] = 15;
        values[valuesById[16] = "PORTUGUESE_BRAZIL"] = 16;
        values[valuesById[17] = "ROMANIAN"] = 17;
        values[valuesById[18] = "RUSSIAN"] = 18;
        values[valuesById[19] = "SLOVAK"] = 19;
        values[valuesById[20] = "SPANISH"] = 20;
        return values;
    })();

    /**
     * SessionTokenType enum.
     * @name BITokenValidation.SessionTokenType
     * @enum {string}
     * @property {number} NO_RESTRICTION=0 NO_RESTRICTION value
     * @property {number} ACCOUNT_RECOVERY=1 ACCOUNT_RECOVERY value
     * @property {number} SHARE_ACCOUNT=2 SHARE_ACCOUNT value
     * @property {number} PURCHASE=3 PURCHASE value
     */
    BITokenValidation.SessionTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_RESTRICTION"] = 0;
        values[valuesById[1] = "ACCOUNT_RECOVERY"] = 1;
        values[valuesById[2] = "SHARE_ACCOUNT"] = 2;
        values[valuesById[3] = "PURCHASE"] = 3;
        return values;
    })();

    /**
     * LoginType enum.
     * @name BITokenValidation.LoginType
     * @enum {string}
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} SSO=1 SSO value
     * @property {number} BIO=2 BIO value
     * @property {number} ALTERNATE=3 ALTERNATE value
     * @property {number} OFFLINE=4 OFFLINE value
     */
    BITokenValidation.LoginType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "SSO"] = 1;
        values[valuesById[2] = "BIO"] = 2;
        values[valuesById[3] = "ALTERNATE"] = 3;
        values[valuesById[4] = "OFFLINE"] = 4;
        return values;
    })();

    BITokenValidation.BIApiRequest = (function() {

        /**
         * Properties of a BIApiRequest.
         * @memberof BITokenValidation
         * @interface IBIApiRequest
         * @property {Uint8Array|null} [encryptedTransmissionKey] BIApiRequest encryptedTransmissionKey
         * @property {number|null} [publicKeyId] BIApiRequest publicKeyId
         * @property {string|null} [locale] BIApiRequest locale
         * @property {Uint8Array|null} [encryptedPayload] BIApiRequest encryptedPayload
         * @property {string|null} [email] BIApiRequest email
         * @property {string|null} [clientVersion] BIApiRequest clientVersion
         * @property {string|null} [sessionToken] BIApiRequest sessionToken
         */

        /**
         * Constructs a new BIApiRequest.
         * @memberof BITokenValidation
         * @classdesc Represents a BIApiRequest.
         * @implements IBIApiRequest
         * @constructor
         * @param {BITokenValidation.IBIApiRequest=} [properties] Properties to set
         */
        function BIApiRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BIApiRequest encryptedTransmissionKey.
         * @member {Uint8Array} encryptedTransmissionKey
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.encryptedTransmissionKey = $util.newBuffer([]);

        /**
         * BIApiRequest publicKeyId.
         * @member {number} publicKeyId
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.publicKeyId = 0;

        /**
         * BIApiRequest locale.
         * @member {string} locale
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.locale = "";

        /**
         * BIApiRequest encryptedPayload.
         * @member {Uint8Array} encryptedPayload
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.encryptedPayload = $util.newBuffer([]);

        /**
         * BIApiRequest email.
         * @member {string} email
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.email = "";

        /**
         * BIApiRequest clientVersion.
         * @member {string} clientVersion
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.clientVersion = "";

        /**
         * BIApiRequest sessionToken.
         * @member {string} sessionToken
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         */
        BIApiRequest.prototype.sessionToken = "";

        /**
         * Creates a new BIApiRequest instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {BITokenValidation.IBIApiRequest=} [properties] Properties to set
         * @returns {BITokenValidation.BIApiRequest} BIApiRequest instance
         */
        BIApiRequest.create = function create(properties) {
            return new BIApiRequest(properties);
        };

        /**
         * Encodes the specified BIApiRequest message. Does not implicitly {@link BITokenValidation.BIApiRequest.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {BITokenValidation.IBIApiRequest} message BIApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTransmissionKey);
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.publicKeyId);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPayload);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.email);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientVersion);
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.sessionToken);
            return writer;
        };

        /**
         * Encodes the specified BIApiRequest message, length delimited. Does not implicitly {@link BITokenValidation.BIApiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {BITokenValidation.IBIApiRequest} message BIApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BIApiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.BIApiRequest} BIApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.BIApiRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTransmissionKey = reader.bytes();
                    break;
                case 2:
                    message.publicKeyId = reader.int32();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.encryptedPayload = reader.bytes();
                    break;
                case 5:
                    message.email = reader.string();
                    break;
                case 6:
                    message.clientVersion = reader.string();
                    break;
                case 7:
                    message.sessionToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BIApiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.BIApiRequest} BIApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BIApiRequest message.
         * @function verify
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BIApiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                if (!(message.encryptedTransmissionKey && typeof message.encryptedTransmissionKey.length === "number" || $util.isString(message.encryptedTransmissionKey)))
                    return "encryptedTransmissionKey: buffer expected";
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                if (!$util.isInteger(message.publicKeyId))
                    return "publicKeyId: integer expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                if (!(message.encryptedPayload && typeof message.encryptedPayload.length === "number" || $util.isString(message.encryptedPayload)))
                    return "encryptedPayload: buffer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                if (!$util.isString(message.sessionToken))
                    return "sessionToken: string expected";
            return null;
        };

        /**
         * Creates a BIApiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.BIApiRequest} BIApiRequest
         */
        BIApiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.BIApiRequest)
                return object;
            let message = new $root.BITokenValidation.BIApiRequest();
            if (object.encryptedTransmissionKey != null)
                if (typeof object.encryptedTransmissionKey === "string")
                    $util.base64.decode(object.encryptedTransmissionKey, message.encryptedTransmissionKey = $util.newBuffer($util.base64.length(object.encryptedTransmissionKey)), 0);
                else if (object.encryptedTransmissionKey.length)
                    message.encryptedTransmissionKey = object.encryptedTransmissionKey;
            if (object.publicKeyId != null)
                message.publicKeyId = object.publicKeyId | 0;
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedPayload != null)
                if (typeof object.encryptedPayload === "string")
                    $util.base64.decode(object.encryptedPayload, message.encryptedPayload = $util.newBuffer($util.base64.length(object.encryptedPayload)), 0);
                else if (object.encryptedPayload.length)
                    message.encryptedPayload = object.encryptedPayload;
            if (object.email != null)
                message.email = String(object.email);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.sessionToken != null)
                message.sessionToken = String(object.sessionToken);
            return message;
        };

        /**
         * Creates a plain object from a BIApiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.BIApiRequest
         * @static
         * @param {BITokenValidation.BIApiRequest} message BIApiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BIApiRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedTransmissionKey = "";
                else {
                    object.encryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTransmissionKey = $util.newBuffer(object.encryptedTransmissionKey);
                }
                object.publicKeyId = 0;
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedPayload = "";
                else {
                    object.encryptedPayload = [];
                    if (options.bytes !== Array)
                        object.encryptedPayload = $util.newBuffer(object.encryptedPayload);
                }
                object.email = "";
                object.clientVersion = "";
                object.sessionToken = "";
            }
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                object.encryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.encryptedTransmissionKey, 0, message.encryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTransmissionKey) : message.encryptedTransmissionKey;
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                object.publicKeyId = message.publicKeyId;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                object.encryptedPayload = options.bytes === String ? $util.base64.encode(message.encryptedPayload, 0, message.encryptedPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPayload) : message.encryptedPayload;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                object.sessionToken = message.sessionToken;
            return object;
        };

        /**
         * Converts this BIApiRequest to JSON.
         * @function toJSON
         * @memberof BITokenValidation.BIApiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BIApiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BIApiRequest;
    })();

    BITokenValidation.BIApiRequestPayload = (function() {

        /**
         * Properties of a BIApiRequestPayload.
         * @memberof BITokenValidation
         * @interface IBIApiRequestPayload
         * @property {Uint8Array|null} [payload] BIApiRequestPayload payload
         * @property {Uint8Array|null} [encryptedSessionToken] BIApiRequestPayload encryptedSessionToken
         * @property {Uint8Array|null} [timeToken] BIApiRequestPayload timeToken
         * @property {number|null} [apiVersion] BIApiRequestPayload apiVersion
         */

        /**
         * Constructs a new BIApiRequestPayload.
         * @memberof BITokenValidation
         * @classdesc Represents a BIApiRequestPayload.
         * @implements IBIApiRequestPayload
         * @constructor
         * @param {BITokenValidation.IBIApiRequestPayload=} [properties] Properties to set
         */
        function BIApiRequestPayload(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BIApiRequestPayload payload.
         * @member {Uint8Array} payload
         * @memberof BITokenValidation.BIApiRequestPayload
         * @instance
         */
        BIApiRequestPayload.prototype.payload = $util.newBuffer([]);

        /**
         * BIApiRequestPayload encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof BITokenValidation.BIApiRequestPayload
         * @instance
         */
        BIApiRequestPayload.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * BIApiRequestPayload timeToken.
         * @member {Uint8Array} timeToken
         * @memberof BITokenValidation.BIApiRequestPayload
         * @instance
         */
        BIApiRequestPayload.prototype.timeToken = $util.newBuffer([]);

        /**
         * BIApiRequestPayload apiVersion.
         * @member {number} apiVersion
         * @memberof BITokenValidation.BIApiRequestPayload
         * @instance
         */
        BIApiRequestPayload.prototype.apiVersion = 0;

        /**
         * Creates a new BIApiRequestPayload instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {BITokenValidation.IBIApiRequestPayload=} [properties] Properties to set
         * @returns {BITokenValidation.BIApiRequestPayload} BIApiRequestPayload instance
         */
        BIApiRequestPayload.create = function create(properties) {
            return new BIApiRequestPayload(properties);
        };

        /**
         * Encodes the specified BIApiRequestPayload message. Does not implicitly {@link BITokenValidation.BIApiRequestPayload.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {BITokenValidation.IBIApiRequestPayload} message BIApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiRequestPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedSessionToken);
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.timeToken);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.apiVersion);
            return writer;
        };

        /**
         * Encodes the specified BIApiRequestPayload message, length delimited. Does not implicitly {@link BITokenValidation.BIApiRequestPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {BITokenValidation.IBIApiRequestPayload} message BIApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiRequestPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BIApiRequestPayload message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.BIApiRequestPayload} BIApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiRequestPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.BIApiRequestPayload();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 3:
                    message.timeToken = reader.bytes();
                    break;
                case 4:
                    message.apiVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BIApiRequestPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.BIApiRequestPayload} BIApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiRequestPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BIApiRequestPayload message.
         * @function verify
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BIApiRequestPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                if (!(message.timeToken && typeof message.timeToken.length === "number" || $util.isString(message.timeToken)))
                    return "timeToken: buffer expected";
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                if (!$util.isInteger(message.apiVersion))
                    return "apiVersion: integer expected";
            return null;
        };

        /**
         * Creates a BIApiRequestPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.BIApiRequestPayload} BIApiRequestPayload
         */
        BIApiRequestPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.BIApiRequestPayload)
                return object;
            let message = new $root.BITokenValidation.BIApiRequestPayload();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.timeToken != null)
                if (typeof object.timeToken === "string")
                    $util.base64.decode(object.timeToken, message.timeToken = $util.newBuffer($util.base64.length(object.timeToken)), 0);
                else if (object.timeToken.length)
                    message.timeToken = object.timeToken;
            if (object.apiVersion != null)
                message.apiVersion = object.apiVersion | 0;
            return message;
        };

        /**
         * Creates a plain object from a BIApiRequestPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.BIApiRequestPayload
         * @static
         * @param {BITokenValidation.BIApiRequestPayload} message BIApiRequestPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BIApiRequestPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                if (options.bytes === String)
                    object.timeToken = "";
                else {
                    object.timeToken = [];
                    if (options.bytes !== Array)
                        object.timeToken = $util.newBuffer(object.timeToken);
                }
                object.apiVersion = 0;
            }
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                object.timeToken = options.bytes === String ? $util.base64.encode(message.timeToken, 0, message.timeToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.timeToken) : message.timeToken;
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = message.apiVersion;
            return object;
        };

        /**
         * Converts this BIApiRequestPayload to JSON.
         * @function toJSON
         * @memberof BITokenValidation.BIApiRequestPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BIApiRequestPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BIApiRequestPayload;
    })();

    BITokenValidation.Transform = (function() {

        /**
         * Properties of a Transform.
         * @memberof BITokenValidation
         * @interface ITransform
         * @property {Uint8Array|null} [key] Transform key
         * @property {Uint8Array|null} [encryptedDeviceToken] Transform encryptedDeviceToken
         */

        /**
         * Constructs a new Transform.
         * @memberof BITokenValidation
         * @classdesc Represents a Transform.
         * @implements ITransform
         * @constructor
         * @param {BITokenValidation.ITransform=} [properties] Properties to set
         */
        function Transform(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transform key.
         * @member {Uint8Array} key
         * @memberof BITokenValidation.Transform
         * @instance
         */
        Transform.prototype.key = $util.newBuffer([]);

        /**
         * Transform encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof BITokenValidation.Transform
         * @instance
         */
        Transform.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new Transform instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.Transform
         * @static
         * @param {BITokenValidation.ITransform=} [properties] Properties to set
         * @returns {BITokenValidation.Transform} Transform instance
         */
        Transform.create = function create(properties) {
            return new Transform(properties);
        };

        /**
         * Encodes the specified Transform message. Does not implicitly {@link BITokenValidation.Transform.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.Transform
         * @static
         * @param {BITokenValidation.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified Transform message, length delimited. Does not implicitly {@link BITokenValidation.Transform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.Transform
         * @static
         * @param {BITokenValidation.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transform message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.Transform();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transform message.
         * @function verify
         * @memberof BITokenValidation.Transform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a Transform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.Transform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.Transform} Transform
         */
        Transform.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.Transform)
                return object;
            let message = new $root.BITokenValidation.Transform();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a Transform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.Transform
         * @static
         * @param {BITokenValidation.Transform} message Transform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this Transform to JSON.
         * @function toJSON
         * @memberof BITokenValidation.Transform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transform;
    })();

    BITokenValidation.DeviceRequest = (function() {

        /**
         * Properties of a DeviceRequest.
         * @memberof BITokenValidation
         * @interface IDeviceRequest
         * @property {string|null} [clientVersion] DeviceRequest clientVersion
         * @property {string|null} [deviceName] DeviceRequest deviceName
         */

        /**
         * Constructs a new DeviceRequest.
         * @memberof BITokenValidation
         * @classdesc Represents a DeviceRequest.
         * @implements IDeviceRequest
         * @constructor
         * @param {BITokenValidation.IDeviceRequest=} [properties] Properties to set
         */
        function DeviceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRequest clientVersion.
         * @member {string} clientVersion
         * @memberof BITokenValidation.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.clientVersion = "";

        /**
         * DeviceRequest deviceName.
         * @member {string} deviceName
         * @memberof BITokenValidation.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.deviceName = "";

        /**
         * Creates a new DeviceRequest instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {BITokenValidation.IDeviceRequest=} [properties] Properties to set
         * @returns {BITokenValidation.DeviceRequest} DeviceRequest instance
         */
        DeviceRequest.create = function create(properties) {
            return new DeviceRequest(properties);
        };

        /**
         * Encodes the specified DeviceRequest message. Does not implicitly {@link BITokenValidation.DeviceRequest.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {BITokenValidation.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            return writer;
        };

        /**
         * Encodes the specified DeviceRequest message, length delimited. Does not implicitly {@link BITokenValidation.DeviceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {BITokenValidation.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.DeviceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRequest message.
         * @function verify
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            return null;
        };

        /**
         * Creates a DeviceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.DeviceRequest} DeviceRequest
         */
        DeviceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.DeviceRequest)
                return object;
            let message = new $root.BITokenValidation.DeviceRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            return message;
        };

        /**
         * Creates a plain object from a DeviceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.DeviceRequest
         * @static
         * @param {BITokenValidation.DeviceRequest} message DeviceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.deviceName = "";
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            return object;
        };

        /**
         * Converts this DeviceRequest to JSON.
         * @function toJSON
         * @memberof BITokenValidation.DeviceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRequest;
    })();

    BITokenValidation.AuthRequest = (function() {

        /**
         * Properties of an AuthRequest.
         * @memberof BITokenValidation
         * @interface IAuthRequest
         * @property {string|null} [clientVersion] AuthRequest clientVersion
         * @property {string|null} [username] AuthRequest username
         * @property {Uint8Array|null} [encryptedDeviceToken] AuthRequest encryptedDeviceToken
         */

        /**
         * Constructs a new AuthRequest.
         * @memberof BITokenValidation
         * @classdesc Represents an AuthRequest.
         * @implements IAuthRequest
         * @constructor
         * @param {BITokenValidation.IAuthRequest=} [properties] Properties to set
         */
        function AuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRequest clientVersion.
         * @member {string} clientVersion
         * @memberof BITokenValidation.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientVersion = "";

        /**
         * AuthRequest username.
         * @member {string} username
         * @memberof BITokenValidation.AuthRequest
         * @instance
         */
        AuthRequest.prototype.username = "";

        /**
         * AuthRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof BITokenValidation.AuthRequest
         * @instance
         */
        AuthRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new AuthRequest instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {BITokenValidation.IAuthRequest=} [properties] Properties to set
         * @returns {BITokenValidation.AuthRequest} AuthRequest instance
         */
        AuthRequest.create = function create(properties) {
            return new AuthRequest(properties);
        };

        /**
         * Encodes the specified AuthRequest message. Does not implicitly {@link BITokenValidation.AuthRequest.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {BITokenValidation.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified AuthRequest message, length delimited. Does not implicitly {@link BITokenValidation.AuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {BITokenValidation.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.AuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRequest message.
         * @function verify
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates an AuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.AuthRequest} AuthRequest
         */
        AuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.AuthRequest)
                return object;
            let message = new $root.BITokenValidation.AuthRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.username != null)
                message.username = String(object.username);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from an AuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.AuthRequest
         * @static
         * @param {BITokenValidation.AuthRequest} message AuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.username = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this AuthRequest to JSON.
         * @function toJSON
         * @memberof BITokenValidation.AuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthRequest;
    })();

    BITokenValidation.Salt = (function() {

        /**
         * Properties of a Salt.
         * @memberof BITokenValidation
         * @interface ISalt
         * @property {number|null} [iterations] Salt iterations
         * @property {Uint8Array|null} [salt] Salt salt
         * @property {number|null} [algorithm] Salt algorithm
         * @property {Uint8Array|null} [uid] Salt uid
         * @property {string|null} [name] Salt name
         */

        /**
         * Constructs a new Salt.
         * @memberof BITokenValidation
         * @classdesc Represents a Salt.
         * @implements ISalt
         * @constructor
         * @param {BITokenValidation.ISalt=} [properties] Properties to set
         */
        function Salt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Salt iterations.
         * @member {number} iterations
         * @memberof BITokenValidation.Salt
         * @instance
         */
        Salt.prototype.iterations = 0;

        /**
         * Salt salt.
         * @member {Uint8Array} salt
         * @memberof BITokenValidation.Salt
         * @instance
         */
        Salt.prototype.salt = $util.newBuffer([]);

        /**
         * Salt algorithm.
         * @member {number} algorithm
         * @memberof BITokenValidation.Salt
         * @instance
         */
        Salt.prototype.algorithm = 0;

        /**
         * Salt uid.
         * @member {Uint8Array} uid
         * @memberof BITokenValidation.Salt
         * @instance
         */
        Salt.prototype.uid = $util.newBuffer([]);

        /**
         * Salt name.
         * @member {string} name
         * @memberof BITokenValidation.Salt
         * @instance
         */
        Salt.prototype.name = "";

        /**
         * Creates a new Salt instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.Salt
         * @static
         * @param {BITokenValidation.ISalt=} [properties] Properties to set
         * @returns {BITokenValidation.Salt} Salt instance
         */
        Salt.create = function create(properties) {
            return new Salt(properties);
        };

        /**
         * Encodes the specified Salt message. Does not implicitly {@link BITokenValidation.Salt.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.Salt
         * @static
         * @param {BITokenValidation.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.iterations);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.algorithm);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.uid);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Salt message, length delimited. Does not implicitly {@link BITokenValidation.Salt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.Salt
         * @static
         * @param {BITokenValidation.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Salt message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.Salt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iterations = reader.int32();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.algorithm = reader.int32();
                    break;
                case 4:
                    message.uid = reader.bytes();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Salt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Salt message.
         * @function verify
         * @memberof BITokenValidation.Salt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Salt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Salt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.Salt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.Salt} Salt
         */
        Salt.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.Salt)
                return object;
            let message = new $root.BITokenValidation.Salt();
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Salt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.Salt
         * @static
         * @param {BITokenValidation.Salt} message Salt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Salt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.iterations = 0;
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.algorithm = 0;
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.name = "";
            }
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Salt to JSON.
         * @function toJSON
         * @memberof BITokenValidation.Salt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Salt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Salt;
    })();

    BITokenValidation.UserAuthRequest = (function() {

        /**
         * Properties of a UserAuthRequest.
         * @memberof BITokenValidation
         * @interface IUserAuthRequest
         * @property {Uint8Array|null} [uid] UserAuthRequest uid
         * @property {Uint8Array|null} [salt] UserAuthRequest salt
         * @property {number|null} [iterations] UserAuthRequest iterations
         * @property {Uint8Array|null} [encryptedClientKey] UserAuthRequest encryptedClientKey
         * @property {Uint8Array|null} [authHash] UserAuthRequest authHash
         * @property {Uint8Array|null} [encryptedDataKey] UserAuthRequest encryptedDataKey
         * @property {BITokenValidation.LoginType|null} [loginType] UserAuthRequest loginType
         * @property {string|null} [name] UserAuthRequest name
         * @property {number|null} [algorithm] UserAuthRequest algorithm
         */

        /**
         * Constructs a new UserAuthRequest.
         * @memberof BITokenValidation
         * @classdesc Represents a UserAuthRequest.
         * @implements IUserAuthRequest
         * @constructor
         * @param {BITokenValidation.IUserAuthRequest=} [properties] Properties to set
         */
        function UserAuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAuthRequest uid.
         * @member {Uint8Array} uid
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.uid = $util.newBuffer([]);

        /**
         * UserAuthRequest salt.
         * @member {Uint8Array} salt
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.salt = $util.newBuffer([]);

        /**
         * UserAuthRequest iterations.
         * @member {number} iterations
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.iterations = 0;

        /**
         * UserAuthRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * UserAuthRequest authHash.
         * @member {Uint8Array} authHash
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.authHash = $util.newBuffer([]);

        /**
         * UserAuthRequest encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * UserAuthRequest loginType.
         * @member {BITokenValidation.LoginType} loginType
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.loginType = 0;

        /**
         * UserAuthRequest name.
         * @member {string} name
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.name = "";

        /**
         * UserAuthRequest algorithm.
         * @member {number} algorithm
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.algorithm = 0;

        /**
         * Creates a new UserAuthRequest instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {BITokenValidation.IUserAuthRequest=} [properties] Properties to set
         * @returns {BITokenValidation.UserAuthRequest} UserAuthRequest instance
         */
        UserAuthRequest.create = function create(properties) {
            return new UserAuthRequest(properties);
        };

        /**
         * Encodes the specified UserAuthRequest message. Does not implicitly {@link BITokenValidation.UserAuthRequest.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {BITokenValidation.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.iterations);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedClientKey);
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.authHash);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedDataKey);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.loginType);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.algorithm);
            return writer;
        };

        /**
         * Encodes the specified UserAuthRequest message, length delimited. Does not implicitly {@link BITokenValidation.UserAuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {BITokenValidation.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.UserAuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.iterations = reader.int32();
                    break;
                case 4:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 5:
                    message.authHash = reader.bytes();
                    break;
                case 6:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 7:
                    message.loginType = reader.int32();
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 9:
                    message.algorithm = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserAuthRequest message.
         * @function verify
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserAuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                if (!(message.authHash && typeof message.authHash.length === "number" || $util.isString(message.authHash)))
                    return "authHash: buffer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            return null;
        };

        /**
         * Creates a UserAuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.UserAuthRequest} UserAuthRequest
         */
        UserAuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.UserAuthRequest)
                return object;
            let message = new $root.BITokenValidation.UserAuthRequest();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.authHash != null)
                if (typeof object.authHash === "string")
                    $util.base64.decode(object.authHash, message.authHash = $util.newBuffer($util.base64.length(object.authHash)), 0);
                else if (object.authHash.length)
                    message.authHash = object.authHash;
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserAuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.UserAuthRequest
         * @static
         * @param {BITokenValidation.UserAuthRequest} message UserAuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserAuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.iterations = 0;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.authHash = "";
                else {
                    object.authHash = [];
                    if (options.bytes !== Array)
                        object.authHash = $util.newBuffer(object.authHash);
                }
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
                object.loginType = options.enums === String ? "NORMAL" : 0;
                object.name = "";
                object.algorithm = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                object.authHash = options.bytes === String ? $util.base64.encode(message.authHash, 0, message.authHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.authHash) : message.authHash;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.BITokenValidation.LoginType[message.loginType] : message.loginType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            return object;
        };

        /**
         * Converts this UserAuthRequest to JSON.
         * @function toJSON
         * @memberof BITokenValidation.UserAuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserAuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserAuthRequest;
    })();

    BITokenValidation.BIApiDecryptedRequest = (function() {

        /**
         * Properties of a BIApiDecryptedRequest.
         * @memberof BITokenValidation
         * @interface IBIApiDecryptedRequest
         * @property {Uint8Array|null} [decryptedTransmissionKey] BIApiDecryptedRequest decryptedTransmissionKey
         * @property {BITokenValidation.IBIApiRequestPayload|null} [bIApiRequestPayload] BIApiDecryptedRequest bIApiRequestPayload
         * @property {BITokenValidation.SupportedLanguage|null} [supportedLanguage] BIApiDecryptedRequest supportedLanguage
         */

        /**
         * Constructs a new BIApiDecryptedRequest.
         * @memberof BITokenValidation
         * @classdesc Represents a BIApiDecryptedRequest.
         * @implements IBIApiDecryptedRequest
         * @constructor
         * @param {BITokenValidation.IBIApiDecryptedRequest=} [properties] Properties to set
         */
        function BIApiDecryptedRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BIApiDecryptedRequest decryptedTransmissionKey.
         * @member {Uint8Array} decryptedTransmissionKey
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @instance
         */
        BIApiDecryptedRequest.prototype.decryptedTransmissionKey = $util.newBuffer([]);

        /**
         * BIApiDecryptedRequest bIApiRequestPayload.
         * @member {BITokenValidation.IBIApiRequestPayload|null|undefined} bIApiRequestPayload
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @instance
         */
        BIApiDecryptedRequest.prototype.bIApiRequestPayload = null;

        /**
         * BIApiDecryptedRequest supportedLanguage.
         * @member {BITokenValidation.SupportedLanguage} supportedLanguage
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @instance
         */
        BIApiDecryptedRequest.prototype.supportedLanguage = 0;

        /**
         * Creates a new BIApiDecryptedRequest instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {BITokenValidation.IBIApiDecryptedRequest=} [properties] Properties to set
         * @returns {BITokenValidation.BIApiDecryptedRequest} BIApiDecryptedRequest instance
         */
        BIApiDecryptedRequest.create = function create(properties) {
            return new BIApiDecryptedRequest(properties);
        };

        /**
         * Encodes the specified BIApiDecryptedRequest message. Does not implicitly {@link BITokenValidation.BIApiDecryptedRequest.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {BITokenValidation.IBIApiDecryptedRequest} message BIApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiDecryptedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.decryptedTransmissionKey);
            if (message.bIApiRequestPayload != null && message.hasOwnProperty("bIApiRequestPayload"))
                $root.BITokenValidation.BIApiRequestPayload.encode(message.bIApiRequestPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            return writer;
        };

        /**
         * Encodes the specified BIApiDecryptedRequest message, length delimited. Does not implicitly {@link BITokenValidation.BIApiDecryptedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {BITokenValidation.IBIApiDecryptedRequest} message BIApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BIApiDecryptedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BIApiDecryptedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.BIApiDecryptedRequest} BIApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiDecryptedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.BIApiDecryptedRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.decryptedTransmissionKey = reader.bytes();
                    break;
                case 3:
                    message.bIApiRequestPayload = $root.BITokenValidation.BIApiRequestPayload.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BIApiDecryptedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.BIApiDecryptedRequest} BIApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BIApiDecryptedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BIApiDecryptedRequest message.
         * @function verify
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BIApiDecryptedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                if (!(message.decryptedTransmissionKey && typeof message.decryptedTransmissionKey.length === "number" || $util.isString(message.decryptedTransmissionKey)))
                    return "decryptedTransmissionKey: buffer expected";
            if (message.bIApiRequestPayload != null && message.hasOwnProperty("bIApiRequestPayload")) {
                let error = $root.BITokenValidation.BIApiRequestPayload.verify(message.bIApiRequestPayload);
                if (error)
                    return "bIApiRequestPayload." + error;
            }
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            return null;
        };

        /**
         * Creates a BIApiDecryptedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.BIApiDecryptedRequest} BIApiDecryptedRequest
         */
        BIApiDecryptedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.BIApiDecryptedRequest)
                return object;
            let message = new $root.BITokenValidation.BIApiDecryptedRequest();
            if (object.decryptedTransmissionKey != null)
                if (typeof object.decryptedTransmissionKey === "string")
                    $util.base64.decode(object.decryptedTransmissionKey, message.decryptedTransmissionKey = $util.newBuffer($util.base64.length(object.decryptedTransmissionKey)), 0);
                else if (object.decryptedTransmissionKey.length)
                    message.decryptedTransmissionKey = object.decryptedTransmissionKey;
            if (object.bIApiRequestPayload != null) {
                if (typeof object.bIApiRequestPayload !== "object")
                    throw TypeError(".BITokenValidation.BIApiDecryptedRequest.bIApiRequestPayload: object expected");
                message.bIApiRequestPayload = $root.BITokenValidation.BIApiRequestPayload.fromObject(object.bIApiRequestPayload);
            }
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BIApiDecryptedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @static
         * @param {BITokenValidation.BIApiDecryptedRequest} message BIApiDecryptedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BIApiDecryptedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.decryptedTransmissionKey = "";
                else {
                    object.decryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.decryptedTransmissionKey = $util.newBuffer(object.decryptedTransmissionKey);
                }
                object.bIApiRequestPayload = null;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
            }
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                object.decryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.decryptedTransmissionKey, 0, message.decryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.decryptedTransmissionKey) : message.decryptedTransmissionKey;
            if (message.bIApiRequestPayload != null && message.hasOwnProperty("bIApiRequestPayload"))
                object.bIApiRequestPayload = $root.BITokenValidation.BIApiRequestPayload.toObject(message.bIApiRequestPayload, options);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.BITokenValidation.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            return object;
        };

        /**
         * Converts this BIApiDecryptedRequest to JSON.
         * @function toJSON
         * @memberof BITokenValidation.BIApiDecryptedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BIApiDecryptedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BIApiDecryptedRequest;
    })();

    BITokenValidation.SessionToken = (function() {

        /**
         * Properties of a SessionToken.
         * @memberof BITokenValidation
         * @interface ISessionToken
         * @property {number|Long|null} [created] SessionToken created
         * @property {number|Long|null} [expiration] SessionToken expiration
         * @property {string|null} [ip] SessionToken ip
         * @property {Uint8Array|null} [sessionUid] SessionToken sessionUid
         * @property {BITokenValidation.IDeviceToken|null} [deviceToken] SessionToken deviceToken
         * @property {number|null} [fromUserId] SessionToken fromUserId
         * @property {number|null} [forUserId] SessionToken forUserId
         * @property {number|Long|null} [enterpriseUserId] SessionToken enterpriseUserId
         * @property {number|null} [clientVersionId] SessionToken clientVersionId
         * @property {BITokenValidation.SessionTokenType|null} [sessionTokenType] SessionToken sessionTokenType
         */

        /**
         * Constructs a new SessionToken.
         * @memberof BITokenValidation
         * @classdesc Represents a SessionToken.
         * @implements ISessionToken
         * @constructor
         * @param {BITokenValidation.ISessionToken=} [properties] Properties to set
         */
        function SessionToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionToken created.
         * @member {number|Long} created
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken expiration.
         * @member {number|Long} expiration
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken ip.
         * @member {string} ip
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.ip = "";

        /**
         * SessionToken sessionUid.
         * @member {Uint8Array} sessionUid
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.sessionUid = $util.newBuffer([]);

        /**
         * SessionToken deviceToken.
         * @member {BITokenValidation.IDeviceToken|null|undefined} deviceToken
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.deviceToken = null;

        /**
         * SessionToken fromUserId.
         * @member {number} fromUserId
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.fromUserId = 0;

        /**
         * SessionToken forUserId.
         * @member {number} forUserId
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.forUserId = 0;

        /**
         * SessionToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.clientVersionId = 0;

        /**
         * SessionToken sessionTokenType.
         * @member {BITokenValidation.SessionTokenType} sessionTokenType
         * @memberof BITokenValidation.SessionToken
         * @instance
         */
        SessionToken.prototype.sessionTokenType = 0;

        /**
         * Creates a new SessionToken instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {BITokenValidation.ISessionToken=} [properties] Properties to set
         * @returns {BITokenValidation.SessionToken} SessionToken instance
         */
        SessionToken.create = function create(properties) {
            return new SessionToken(properties);
        };

        /**
         * Encodes the specified SessionToken message. Does not implicitly {@link BITokenValidation.SessionToken.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {BITokenValidation.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.ip != null && message.hasOwnProperty("ip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ip);
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sessionUid);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.BITokenValidation.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fromUserId);
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.forUserId);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enterpriseUserId);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.clientVersionId);
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.sessionTokenType);
            return writer;
        };

        /**
         * Encodes the specified SessionToken message, length delimited. Does not implicitly {@link BITokenValidation.SessionToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {BITokenValidation.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.SessionToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.ip = reader.string();
                    break;
                case 4:
                    message.sessionUid = reader.bytes();
                    break;
                case 5:
                    message.deviceToken = $root.BITokenValidation.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.fromUserId = reader.int32();
                    break;
                case 7:
                    message.forUserId = reader.int32();
                    break;
                case 8:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 9:
                    message.clientVersionId = reader.int32();
                    break;
                case 10:
                    message.sessionTokenType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionToken message.
         * @function verify
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                if (!(message.sessionUid && typeof message.sessionUid.length === "number" || $util.isString(message.sessionUid)))
                    return "sessionUid: buffer expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.BITokenValidation.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                if (!$util.isInteger(message.fromUserId))
                    return "fromUserId: integer expected";
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                if (!$util.isInteger(message.forUserId))
                    return "forUserId: integer expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                switch (message.sessionTokenType) {
                default:
                    return "sessionTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a SessionToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.SessionToken} SessionToken
         */
        SessionToken.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.SessionToken)
                return object;
            let message = new $root.BITokenValidation.SessionToken();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.sessionUid != null)
                if (typeof object.sessionUid === "string")
                    $util.base64.decode(object.sessionUid, message.sessionUid = $util.newBuffer($util.base64.length(object.sessionUid)), 0);
                else if (object.sessionUid.length)
                    message.sessionUid = object.sessionUid;
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".BITokenValidation.SessionToken.deviceToken: object expected");
                message.deviceToken = $root.BITokenValidation.DeviceToken.fromObject(object.deviceToken);
            }
            if (object.fromUserId != null)
                message.fromUserId = object.fromUserId | 0;
            if (object.forUserId != null)
                message.forUserId = object.forUserId | 0;
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            switch (object.sessionTokenType) {
            case "NO_RESTRICTION":
            case 0:
                message.sessionTokenType = 0;
                break;
            case "ACCOUNT_RECOVERY":
            case 1:
                message.sessionTokenType = 1;
                break;
            case "SHARE_ACCOUNT":
            case 2:
                message.sessionTokenType = 2;
                break;
            case "PURCHASE":
            case 3:
                message.sessionTokenType = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SessionToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.SessionToken
         * @static
         * @param {BITokenValidation.SessionToken} message SessionToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.ip = "";
                if (options.bytes === String)
                    object.sessionUid = "";
                else {
                    object.sessionUid = [];
                    if (options.bytes !== Array)
                        object.sessionUid = $util.newBuffer(object.sessionUid);
                }
                object.deviceToken = null;
                object.fromUserId = 0;
                object.forUserId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.clientVersionId = 0;
                object.sessionTokenType = options.enums === String ? "NO_RESTRICTION" : 0;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                object.sessionUid = options.bytes === String ? $util.base64.encode(message.sessionUid, 0, message.sessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionUid) : message.sessionUid;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.BITokenValidation.DeviceToken.toObject(message.deviceToken, options);
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                object.fromUserId = message.fromUserId;
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                object.forUserId = message.forUserId;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                object.sessionTokenType = options.enums === String ? $root.BITokenValidation.SessionTokenType[message.sessionTokenType] : message.sessionTokenType;
            return object;
        };

        /**
         * Converts this SessionToken to JSON.
         * @function toJSON
         * @memberof BITokenValidation.SessionToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionToken;
    })();

    BITokenValidation.DeviceToken = (function() {

        /**
         * Properties of a DeviceToken.
         * @memberof BITokenValidation
         * @interface IDeviceToken
         * @property {number|Long|null} [deviceId] DeviceToken deviceId
         * @property {number|null} [region] DeviceToken region
         */

        /**
         * Constructs a new DeviceToken.
         * @memberof BITokenValidation
         * @classdesc Represents a DeviceToken.
         * @implements IDeviceToken
         * @constructor
         * @param {BITokenValidation.IDeviceToken=} [properties] Properties to set
         */
        function DeviceToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceToken deviceId.
         * @member {number|Long} deviceId
         * @memberof BITokenValidation.DeviceToken
         * @instance
         */
        DeviceToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceToken region.
         * @member {number} region
         * @memberof BITokenValidation.DeviceToken
         * @instance
         */
        DeviceToken.prototype.region = 0;

        /**
         * Creates a new DeviceToken instance using the specified properties.
         * @function create
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {BITokenValidation.IDeviceToken=} [properties] Properties to set
         * @returns {BITokenValidation.DeviceToken} DeviceToken instance
         */
        DeviceToken.create = function create(properties) {
            return new DeviceToken(properties);
        };

        /**
         * Encodes the specified DeviceToken message. Does not implicitly {@link BITokenValidation.DeviceToken.verify|verify} messages.
         * @function encode
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {BITokenValidation.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.region != null && message.hasOwnProperty("region"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.region);
            return writer;
        };

        /**
         * Encodes the specified DeviceToken message, length delimited. Does not implicitly {@link BITokenValidation.DeviceToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {BITokenValidation.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer.
         * @function decode
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BITokenValidation.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BITokenValidation.DeviceToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.region = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BITokenValidation.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceToken message.
         * @function verify
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isInteger(message.region))
                    return "region: integer expected";
            return null;
        };

        /**
         * Creates a DeviceToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BITokenValidation.DeviceToken} DeviceToken
         */
        DeviceToken.fromObject = function fromObject(object) {
            if (object instanceof $root.BITokenValidation.DeviceToken)
                return object;
            let message = new $root.BITokenValidation.DeviceToken();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.region != null)
                message.region = object.region | 0;
            return message;
        };

        /**
         * Creates a plain object from a DeviceToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BITokenValidation.DeviceToken
         * @static
         * @param {BITokenValidation.DeviceToken} message DeviceToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.region = 0;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            return object;
        };

        /**
         * Converts this DeviceToken to JSON.
         * @function toJSON
         * @memberof BITokenValidation.DeviceToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceToken;
    })();

    return BITokenValidation;
})();

export const BreachWatch = $root.BreachWatch = (() => {

    /**
     * Namespace BreachWatch.
     * @exports BreachWatch
     * @namespace
     */
    const BreachWatch = {};

    /**
     * BreachWatchInfoType enum.
     * @name BreachWatch.BreachWatchInfoType
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} ALTERNATE_PASSWORD=1 ALTERNATE_PASSWORD value
     */
    BreachWatch.BreachWatchInfoType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "ALTERNATE_PASSWORD"] = 1;
        return values;
    })();

    BreachWatch.BreachWatchRecordRequest = (function() {

        /**
         * Properties of a BreachWatchRecordRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchRecordRequest
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordRequest recordUid
         * @property {Uint8Array|null} [encryptedData] BreachWatchRecordRequest encryptedData
         * @property {BreachWatch.BreachWatchInfoType|null} [breachWatchInfoType] BreachWatchRecordRequest breachWatchInfoType
         * @property {boolean|null} [updateUserWhoScanned] BreachWatchRecordRequest updateUserWhoScanned
         */

        /**
         * Constructs a new BreachWatchRecordRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchRecordRequest.
         * @implements IBreachWatchRecordRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchRecordRequest=} [properties] Properties to set
         */
        function BreachWatchRecordRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest breachWatchInfoType.
         * @member {BreachWatch.BreachWatchInfoType} breachWatchInfoType
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.breachWatchInfoType = 0;

        /**
         * BreachWatchRecordRequest updateUserWhoScanned.
         * @member {boolean} updateUserWhoScanned
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.updateUserWhoScanned = false;

        /**
         * Creates a new BreachWatchRecordRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest instance
         */
        BreachWatchRecordRequest.create = function create(properties) {
            return new BreachWatchRecordRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message. Does not implicitly {@link BreachWatch.BreachWatchRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.breachWatchInfoType);
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateUserWhoScanned);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                case 3:
                    message.breachWatchInfoType = reader.int32();
                    break;
                case 4:
                    message.updateUserWhoScanned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                switch (message.breachWatchInfoType) {
                default:
                    return "breachWatchInfoType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                if (typeof message.updateUserWhoScanned !== "boolean")
                    return "updateUserWhoScanned: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         */
        BreachWatchRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchRecordRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchRecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            switch (object.breachWatchInfoType) {
            case "RECORD":
            case 0:
                message.breachWatchInfoType = 0;
                break;
            case "ALTERNATE_PASSWORD":
            case 1:
                message.breachWatchInfoType = 1;
                break;
            }
            if (object.updateUserWhoScanned != null)
                message.updateUserWhoScanned = Boolean(object.updateUserWhoScanned);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.BreachWatchRecordRequest} message BreachWatchRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
                object.breachWatchInfoType = options.enums === String ? "RECORD" : 0;
                object.updateUserWhoScanned = false;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                object.breachWatchInfoType = options.enums === String ? $root.BreachWatch.BreachWatchInfoType[message.breachWatchInfoType] : message.breachWatchInfoType;
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                object.updateUserWhoScanned = message.updateUserWhoScanned;
            return object;
        };

        /**
         * Converts this BreachWatchRecordRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordRequest;
    })();

    BreachWatch.BreachWatchUpdateRequest = (function() {

        /**
         * Properties of a BreachWatchUpdateRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchUpdateRequest
         * @property {Array.<BreachWatch.IBreachWatchRecordRequest>|null} [breachWatchRecordRequest] BreachWatchUpdateRequest breachWatchRecordRequest
         * @property {Uint8Array|null} [encryptedData] BreachWatchUpdateRequest encryptedData
         */

        /**
         * Constructs a new BreachWatchUpdateRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchUpdateRequest.
         * @implements IBreachWatchUpdateRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchUpdateRequest=} [properties] Properties to set
         */
        function BreachWatchUpdateRequest(properties) {
            this.breachWatchRecordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateRequest breachWatchRecordRequest.
         * @member {Array.<BreachWatch.IBreachWatchRecordRequest>} breachWatchRecordRequest
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.breachWatchRecordRequest = $util.emptyArray;

        /**
         * BreachWatchUpdateRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchUpdateRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest instance
         */
        BreachWatchUpdateRequest.create = function create(properties) {
            return new BreachWatchUpdateRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message. Does not implicitly {@link BreachWatch.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordRequest != null && message.breachWatchRecordRequest.length)
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i)
                    $root.BreachWatch.BreachWatchRecordRequest.encode(message.breachWatchRecordRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordRequest && message.breachWatchRecordRequest.length))
                        message.breachWatchRecordRequest = [];
                    message.breachWatchRecordRequest.push($root.BreachWatch.BreachWatchRecordRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordRequest != null && message.hasOwnProperty("breachWatchRecordRequest")) {
                if (!Array.isArray(message.breachWatchRecordRequest))
                    return "breachWatchRecordRequest: array expected";
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i) {
                    let error = $root.BreachWatch.BreachWatchRecordRequest.verify(message.breachWatchRecordRequest[i]);
                    if (error)
                        return "breachWatchRecordRequest." + error;
                }
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         */
        BreachWatchUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchUpdateRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchUpdateRequest();
            if (object.breachWatchRecordRequest) {
                if (!Array.isArray(object.breachWatchRecordRequest))
                    throw TypeError(".BreachWatch.BreachWatchUpdateRequest.breachWatchRecordRequest: array expected");
                message.breachWatchRecordRequest = [];
                for (let i = 0; i < object.breachWatchRecordRequest.length; ++i) {
                    if (typeof object.breachWatchRecordRequest[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchUpdateRequest.breachWatchRecordRequest: object expected");
                    message.breachWatchRecordRequest[i] = $root.BreachWatch.BreachWatchRecordRequest.fromObject(object.breachWatchRecordRequest[i]);
                }
            }
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.BreachWatchUpdateRequest} message BreachWatchUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordRequest = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
            if (message.breachWatchRecordRequest && message.breachWatchRecordRequest.length) {
                object.breachWatchRecordRequest = [];
                for (let j = 0; j < message.breachWatchRecordRequest.length; ++j)
                    object.breachWatchRecordRequest[j] = $root.BreachWatch.BreachWatchRecordRequest.toObject(message.breachWatchRecordRequest[j], options);
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            return object;
        };

        /**
         * Converts this BreachWatchUpdateRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateRequest;
    })();

    BreachWatch.BreachWatchRecordStatus = (function() {

        /**
         * Properties of a BreachWatchRecordStatus.
         * @memberof BreachWatch
         * @interface IBreachWatchRecordStatus
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordStatus recordUid
         * @property {string|null} [status] BreachWatchRecordStatus status
         * @property {string|null} [reason] BreachWatchRecordStatus reason
         */

        /**
         * Constructs a new BreachWatchRecordStatus.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchRecordStatus.
         * @implements IBreachWatchRecordStatus
         * @constructor
         * @param {BreachWatch.IBreachWatchRecordStatus=} [properties] Properties to set
         */
        function BreachWatchRecordStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordStatus recordUid.
         * @member {Uint8Array} recordUid
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordStatus status.
         * @member {string} status
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.status = "";

        /**
         * BreachWatchRecordStatus reason.
         * @member {string} reason
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.reason = "";

        /**
         * Creates a new BreachWatchRecordStatus instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus instance
         */
        BreachWatchRecordStatus.create = function create(properties) {
            return new BreachWatchRecordStatus(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordStatus message. Does not implicitly {@link BreachWatch.BreachWatchRecordStatus.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus} message BreachWatchRecordStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.status);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordStatus message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchRecordStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus} message BreachWatchRecordStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordStatus message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchRecordStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.status = reader.string();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordStatus message.
         * @function verify
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         */
        BreachWatchRecordStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchRecordStatus)
                return object;
            let message = new $root.BreachWatch.BreachWatchRecordStatus();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.status != null)
                message.status = String(object.status);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.BreachWatchRecordStatus} message BreachWatchRecordStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.status = "";
                object.reason = "";
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this BreachWatchRecordStatus to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordStatus;
    })();

    BreachWatch.BreachWatchUpdateResponse = (function() {

        /**
         * Properties of a BreachWatchUpdateResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchUpdateResponse
         * @property {Array.<BreachWatch.IBreachWatchRecordStatus>|null} [breachWatchRecordStatus] BreachWatchUpdateResponse breachWatchRecordStatus
         */

        /**
         * Constructs a new BreachWatchUpdateResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchUpdateResponse.
         * @implements IBreachWatchUpdateResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchUpdateResponse=} [properties] Properties to set
         */
        function BreachWatchUpdateResponse(properties) {
            this.breachWatchRecordStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateResponse breachWatchRecordStatus.
         * @member {Array.<BreachWatch.IBreachWatchRecordStatus>} breachWatchRecordStatus
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @instance
         */
        BreachWatchUpdateResponse.prototype.breachWatchRecordStatus = $util.emptyArray;

        /**
         * Creates a new BreachWatchUpdateResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse instance
         */
        BreachWatchUpdateResponse.create = function create(properties) {
            return new BreachWatchUpdateResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateResponse message. Does not implicitly {@link BreachWatch.BreachWatchUpdateResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse} message BreachWatchUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordStatus != null && message.breachWatchRecordStatus.length)
                for (let i = 0; i < message.breachWatchRecordStatus.length; ++i)
                    $root.BreachWatch.BreachWatchRecordStatus.encode(message.breachWatchRecordStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchUpdateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse} message BreachWatchUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchUpdateResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordStatus && message.breachWatchRecordStatus.length))
                        message.breachWatchRecordStatus = [];
                    message.breachWatchRecordStatus.push($root.BreachWatch.BreachWatchRecordStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordStatus != null && message.hasOwnProperty("breachWatchRecordStatus")) {
                if (!Array.isArray(message.breachWatchRecordStatus))
                    return "breachWatchRecordStatus: array expected";
                for (let i = 0; i < message.breachWatchRecordStatus.length; ++i) {
                    let error = $root.BreachWatch.BreachWatchRecordStatus.verify(message.breachWatchRecordStatus[i]);
                    if (error)
                        return "breachWatchRecordStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchUpdateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         */
        BreachWatchUpdateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchUpdateResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchUpdateResponse();
            if (object.breachWatchRecordStatus) {
                if (!Array.isArray(object.breachWatchRecordStatus))
                    throw TypeError(".BreachWatch.BreachWatchUpdateResponse.breachWatchRecordStatus: array expected");
                message.breachWatchRecordStatus = [];
                for (let i = 0; i < object.breachWatchRecordStatus.length; ++i) {
                    if (typeof object.breachWatchRecordStatus[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchUpdateResponse.breachWatchRecordStatus: object expected");
                    message.breachWatchRecordStatus[i] = $root.BreachWatch.BreachWatchRecordStatus.fromObject(object.breachWatchRecordStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.BreachWatchUpdateResponse} message BreachWatchUpdateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordStatus = [];
            if (message.breachWatchRecordStatus && message.breachWatchRecordStatus.length) {
                object.breachWatchRecordStatus = [];
                for (let j = 0; j < message.breachWatchRecordStatus.length; ++j)
                    object.breachWatchRecordStatus[j] = $root.BreachWatch.BreachWatchRecordStatus.toObject(message.breachWatchRecordStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchUpdateResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateResponse;
    })();

    BreachWatch.BreachWatchTokenRequest = (function() {

        /**
         * Properties of a BreachWatchTokenRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchTokenRequest
         * @property {Uint8Array|null} [breachWatchToken] BreachWatchTokenRequest breachWatchToken
         */

        /**
         * Constructs a new BreachWatchTokenRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchTokenRequest.
         * @implements IBreachWatchTokenRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchTokenRequest=} [properties] Properties to set
         */
        function BreachWatchTokenRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchTokenRequest breachWatchToken.
         * @member {Uint8Array} breachWatchToken
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @instance
         */
        BreachWatchTokenRequest.prototype.breachWatchToken = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchTokenRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest instance
         */
        BreachWatchTokenRequest.create = function create(properties) {
            return new BreachWatchTokenRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchTokenRequest message. Does not implicitly {@link BreachWatch.BreachWatchTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest} message BreachWatchTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.breachWatchToken);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchTokenRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest} message BreachWatchTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchTokenRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.breachWatchToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchTokenRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                if (!(message.breachWatchToken && typeof message.breachWatchToken.length === "number" || $util.isString(message.breachWatchToken)))
                    return "breachWatchToken: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         */
        BreachWatchTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchTokenRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchTokenRequest();
            if (object.breachWatchToken != null)
                if (typeof object.breachWatchToken === "string")
                    $util.base64.decode(object.breachWatchToken, message.breachWatchToken = $util.newBuffer($util.base64.length(object.breachWatchToken)), 0);
                else if (object.breachWatchToken.length)
                    message.breachWatchToken = object.breachWatchToken;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.BreachWatchTokenRequest} message BreachWatchTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.breachWatchToken = "";
                else {
                    object.breachWatchToken = [];
                    if (options.bytes !== Array)
                        object.breachWatchToken = $util.newBuffer(object.breachWatchToken);
                }
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                object.breachWatchToken = options.bytes === String ? $util.base64.encode(message.breachWatchToken, 0, message.breachWatchToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.breachWatchToken) : message.breachWatchToken;
            return object;
        };

        /**
         * Converts this BreachWatchTokenRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchTokenRequest;
    })();

    BreachWatch.BreachWatchTokenResponse = (function() {

        /**
         * Properties of a BreachWatchTokenResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchTokenResponse
         * @property {Uint8Array|null} [breachWatchToken] BreachWatchTokenResponse breachWatchToken
         * @property {boolean|null} [clientEncrypted] BreachWatchTokenResponse clientEncrypted
         */

        /**
         * Constructs a new BreachWatchTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchTokenResponse.
         * @implements IBreachWatchTokenResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchTokenResponse=} [properties] Properties to set
         */
        function BreachWatchTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchTokenResponse breachWatchToken.
         * @member {Uint8Array} breachWatchToken
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         */
        BreachWatchTokenResponse.prototype.breachWatchToken = $util.newBuffer([]);

        /**
         * BreachWatchTokenResponse clientEncrypted.
         * @member {boolean} clientEncrypted
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         */
        BreachWatchTokenResponse.prototype.clientEncrypted = false;

        /**
         * Creates a new BreachWatchTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse instance
         */
        BreachWatchTokenResponse.create = function create(properties) {
            return new BreachWatchTokenResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchTokenResponse message. Does not implicitly {@link BreachWatch.BreachWatchTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse} message BreachWatchTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.breachWatchToken);
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.clientEncrypted);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse} message BreachWatchTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.breachWatchToken = reader.bytes();
                    break;
                case 2:
                    message.clientEncrypted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchTokenResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                if (!(message.breachWatchToken && typeof message.breachWatchToken.length === "number" || $util.isString(message.breachWatchToken)))
                    return "breachWatchToken: buffer expected";
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                if (typeof message.clientEncrypted !== "boolean")
                    return "clientEncrypted: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         */
        BreachWatchTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchTokenResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchTokenResponse();
            if (object.breachWatchToken != null)
                if (typeof object.breachWatchToken === "string")
                    $util.base64.decode(object.breachWatchToken, message.breachWatchToken = $util.newBuffer($util.base64.length(object.breachWatchToken)), 0);
                else if (object.breachWatchToken.length)
                    message.breachWatchToken = object.breachWatchToken;
            if (object.clientEncrypted != null)
                message.clientEncrypted = Boolean(object.clientEncrypted);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.BreachWatchTokenResponse} message BreachWatchTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.breachWatchToken = "";
                else {
                    object.breachWatchToken = [];
                    if (options.bytes !== Array)
                        object.breachWatchToken = $util.newBuffer(object.breachWatchToken);
                }
                object.clientEncrypted = false;
            }
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                object.breachWatchToken = options.bytes === String ? $util.base64.encode(message.breachWatchToken, 0, message.breachWatchToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.breachWatchToken) : message.breachWatchToken;
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                object.clientEncrypted = message.clientEncrypted;
            return object;
        };

        /**
         * Converts this BreachWatchTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchTokenResponse;
    })();

    BreachWatch.AnonymizedTokenResponse = (function() {

        /**
         * Properties of an AnonymizedTokenResponse.
         * @memberof BreachWatch
         * @interface IAnonymizedTokenResponse
         * @property {Uint8Array|null} [domainToken] AnonymizedTokenResponse domainToken
         * @property {Uint8Array|null} [emailToken] AnonymizedTokenResponse emailToken
         * @property {Uint8Array|null} [passwordToken] AnonymizedTokenResponse passwordToken
         */

        /**
         * Constructs a new AnonymizedTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents an AnonymizedTokenResponse.
         * @implements IAnonymizedTokenResponse
         * @constructor
         * @param {BreachWatch.IAnonymizedTokenResponse=} [properties] Properties to set
         */
        function AnonymizedTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnonymizedTokenResponse domainToken.
         * @member {Uint8Array} domainToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.domainToken = $util.newBuffer([]);

        /**
         * AnonymizedTokenResponse emailToken.
         * @member {Uint8Array} emailToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.emailToken = $util.newBuffer([]);

        /**
         * AnonymizedTokenResponse passwordToken.
         * @member {Uint8Array} passwordToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.passwordToken = $util.newBuffer([]);

        /**
         * Creates a new AnonymizedTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse instance
         */
        AnonymizedTokenResponse.create = function create(properties) {
            return new AnonymizedTokenResponse(properties);
        };

        /**
         * Encodes the specified AnonymizedTokenResponse message. Does not implicitly {@link BreachWatch.AnonymizedTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse} message AnonymizedTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.domainToken);
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.emailToken);
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.passwordToken);
            return writer;
        };

        /**
         * Encodes the specified AnonymizedTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.AnonymizedTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse} message AnonymizedTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnonymizedTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.AnonymizedTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.domainToken = reader.bytes();
                    break;
                case 2:
                    message.emailToken = reader.bytes();
                    break;
                case 3:
                    message.passwordToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnonymizedTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnonymizedTokenResponse message.
         * @function verify
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnonymizedTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                if (!(message.domainToken && typeof message.domainToken.length === "number" || $util.isString(message.domainToken)))
                    return "domainToken: buffer expected";
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                if (!(message.emailToken && typeof message.emailToken.length === "number" || $util.isString(message.emailToken)))
                    return "emailToken: buffer expected";
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                if (!(message.passwordToken && typeof message.passwordToken.length === "number" || $util.isString(message.passwordToken)))
                    return "passwordToken: buffer expected";
            return null;
        };

        /**
         * Creates an AnonymizedTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         */
        AnonymizedTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.AnonymizedTokenResponse)
                return object;
            let message = new $root.BreachWatch.AnonymizedTokenResponse();
            if (object.domainToken != null)
                if (typeof object.domainToken === "string")
                    $util.base64.decode(object.domainToken, message.domainToken = $util.newBuffer($util.base64.length(object.domainToken)), 0);
                else if (object.domainToken.length)
                    message.domainToken = object.domainToken;
            if (object.emailToken != null)
                if (typeof object.emailToken === "string")
                    $util.base64.decode(object.emailToken, message.emailToken = $util.newBuffer($util.base64.length(object.emailToken)), 0);
                else if (object.emailToken.length)
                    message.emailToken = object.emailToken;
            if (object.passwordToken != null)
                if (typeof object.passwordToken === "string")
                    $util.base64.decode(object.passwordToken, message.passwordToken = $util.newBuffer($util.base64.length(object.passwordToken)), 0);
                else if (object.passwordToken.length)
                    message.passwordToken = object.passwordToken;
            return message;
        };

        /**
         * Creates a plain object from an AnonymizedTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.AnonymizedTokenResponse} message AnonymizedTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnonymizedTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.domainToken = "";
                else {
                    object.domainToken = [];
                    if (options.bytes !== Array)
                        object.domainToken = $util.newBuffer(object.domainToken);
                }
                if (options.bytes === String)
                    object.emailToken = "";
                else {
                    object.emailToken = [];
                    if (options.bytes !== Array)
                        object.emailToken = $util.newBuffer(object.emailToken);
                }
                if (options.bytes === String)
                    object.passwordToken = "";
                else {
                    object.passwordToken = [];
                    if (options.bytes !== Array)
                        object.passwordToken = $util.newBuffer(object.passwordToken);
                }
            }
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                object.domainToken = options.bytes === String ? $util.base64.encode(message.domainToken, 0, message.domainToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.domainToken) : message.domainToken;
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                object.emailToken = options.bytes === String ? $util.base64.encode(message.emailToken, 0, message.emailToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.emailToken) : message.emailToken;
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                object.passwordToken = options.bytes === String ? $util.base64.encode(message.passwordToken, 0, message.passwordToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.passwordToken) : message.passwordToken;
            return object;
        };

        /**
         * Converts this AnonymizedTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnonymizedTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnonymizedTokenResponse;
    })();

    BreachWatch.HashCheck = (function() {

        /**
         * Properties of a HashCheck.
         * @memberof BreachWatch
         * @interface IHashCheck
         * @property {Uint8Array|null} [hash1] HashCheck hash1
         * @property {Uint8Array|null} [euid] HashCheck euid
         */

        /**
         * Constructs a new HashCheck.
         * @memberof BreachWatch
         * @classdesc Represents a HashCheck.
         * @implements IHashCheck
         * @constructor
         * @param {BreachWatch.IHashCheck=} [properties] Properties to set
         */
        function HashCheck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashCheck hash1.
         * @member {Uint8Array} hash1
         * @memberof BreachWatch.HashCheck
         * @instance
         */
        HashCheck.prototype.hash1 = $util.newBuffer([]);

        /**
         * HashCheck euid.
         * @member {Uint8Array} euid
         * @memberof BreachWatch.HashCheck
         * @instance
         */
        HashCheck.prototype.euid = $util.newBuffer([]);

        /**
         * Creates a new HashCheck instance using the specified properties.
         * @function create
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck=} [properties] Properties to set
         * @returns {BreachWatch.HashCheck} HashCheck instance
         */
        HashCheck.create = function create(properties) {
            return new HashCheck(properties);
        };

        /**
         * Encodes the specified HashCheck message. Does not implicitly {@link BreachWatch.HashCheck.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck} message HashCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash1);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.euid);
            return writer;
        };

        /**
         * Encodes the specified HashCheck message, length delimited. Does not implicitly {@link BreachWatch.HashCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck} message HashCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashCheck message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.HashCheck} HashCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.HashCheck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash1 = reader.bytes();
                    break;
                case 2:
                    message.euid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.HashCheck} HashCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashCheck message.
         * @function verify
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                if (!(message.hash1 && typeof message.hash1.length === "number" || $util.isString(message.hash1)))
                    return "hash1: buffer expected";
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            return null;
        };

        /**
         * Creates a HashCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.HashCheck} HashCheck
         */
        HashCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.HashCheck)
                return object;
            let message = new $root.BreachWatch.HashCheck();
            if (object.hash1 != null)
                if (typeof object.hash1 === "string")
                    $util.base64.decode(object.hash1, message.hash1 = $util.newBuffer($util.base64.length(object.hash1)), 0);
                else if (object.hash1.length)
                    message.hash1 = object.hash1;
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            return message;
        };

        /**
         * Creates a plain object from a HashCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.HashCheck} message HashCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash1 = "";
                else {
                    object.hash1 = [];
                    if (options.bytes !== Array)
                        object.hash1 = $util.newBuffer(object.hash1);
                }
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
            }
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                object.hash1 = options.bytes === String ? $util.base64.encode(message.hash1, 0, message.hash1.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash1) : message.hash1;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            return object;
        };

        /**
         * Converts this HashCheck to JSON.
         * @function toJSON
         * @memberof BreachWatch.HashCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashCheck;
    })();

    BreachWatch.BreachWatchStatusRequest = (function() {

        /**
         * Properties of a BreachWatchStatusRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchStatusRequest
         * @property {Uint8Array|null} [anonymizedToken] BreachWatchStatusRequest anonymizedToken
         * @property {Array.<BreachWatch.IHashCheck>|null} [hashCheck] BreachWatchStatusRequest hashCheck
         * @property {Array.<Uint8Array>|null} [removedEuid] BreachWatchStatusRequest removedEuid
         */

        /**
         * Constructs a new BreachWatchStatusRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchStatusRequest.
         * @implements IBreachWatchStatusRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchStatusRequest=} [properties] Properties to set
         */
        function BreachWatchStatusRequest(properties) {
            this.hashCheck = [];
            this.removedEuid = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchStatusRequest anonymizedToken.
         * @member {Uint8Array} anonymizedToken
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.anonymizedToken = $util.newBuffer([]);

        /**
         * BreachWatchStatusRequest hashCheck.
         * @member {Array.<BreachWatch.IHashCheck>} hashCheck
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.hashCheck = $util.emptyArray;

        /**
         * BreachWatchStatusRequest removedEuid.
         * @member {Array.<Uint8Array>} removedEuid
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.removedEuid = $util.emptyArray;

        /**
         * Creates a new BreachWatchStatusRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest instance
         */
        BreachWatchStatusRequest.create = function create(properties) {
            return new BreachWatchStatusRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchStatusRequest message. Does not implicitly {@link BreachWatch.BreachWatchStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest} message BreachWatchStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anonymizedToken);
            if (message.hashCheck != null && message.hashCheck.length)
                for (let i = 0; i < message.hashCheck.length; ++i)
                    $root.BreachWatch.HashCheck.encode(message.hashCheck[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.removedEuid != null && message.removedEuid.length)
                for (let i = 0; i < message.removedEuid.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.removedEuid[i]);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchStatusRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest} message BreachWatchStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchStatusRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anonymizedToken = reader.bytes();
                    break;
                case 2:
                    if (!(message.hashCheck && message.hashCheck.length))
                        message.hashCheck = [];
                    message.hashCheck.push($root.BreachWatch.HashCheck.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.removedEuid && message.removedEuid.length))
                        message.removedEuid = [];
                    message.removedEuid.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchStatusRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                if (!(message.anonymizedToken && typeof message.anonymizedToken.length === "number" || $util.isString(message.anonymizedToken)))
                    return "anonymizedToken: buffer expected";
            if (message.hashCheck != null && message.hasOwnProperty("hashCheck")) {
                if (!Array.isArray(message.hashCheck))
                    return "hashCheck: array expected";
                for (let i = 0; i < message.hashCheck.length; ++i) {
                    let error = $root.BreachWatch.HashCheck.verify(message.hashCheck[i]);
                    if (error)
                        return "hashCheck." + error;
                }
            }
            if (message.removedEuid != null && message.hasOwnProperty("removedEuid")) {
                if (!Array.isArray(message.removedEuid))
                    return "removedEuid: array expected";
                for (let i = 0; i < message.removedEuid.length; ++i)
                    if (!(message.removedEuid[i] && typeof message.removedEuid[i].length === "number" || $util.isString(message.removedEuid[i])))
                        return "removedEuid: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a BreachWatchStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         */
        BreachWatchStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchStatusRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchStatusRequest();
            if (object.anonymizedToken != null)
                if (typeof object.anonymizedToken === "string")
                    $util.base64.decode(object.anonymizedToken, message.anonymizedToken = $util.newBuffer($util.base64.length(object.anonymizedToken)), 0);
                else if (object.anonymizedToken.length)
                    message.anonymizedToken = object.anonymizedToken;
            if (object.hashCheck) {
                if (!Array.isArray(object.hashCheck))
                    throw TypeError(".BreachWatch.BreachWatchStatusRequest.hashCheck: array expected");
                message.hashCheck = [];
                for (let i = 0; i < object.hashCheck.length; ++i) {
                    if (typeof object.hashCheck[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchStatusRequest.hashCheck: object expected");
                    message.hashCheck[i] = $root.BreachWatch.HashCheck.fromObject(object.hashCheck[i]);
                }
            }
            if (object.removedEuid) {
                if (!Array.isArray(object.removedEuid))
                    throw TypeError(".BreachWatch.BreachWatchStatusRequest.removedEuid: array expected");
                message.removedEuid = [];
                for (let i = 0; i < object.removedEuid.length; ++i)
                    if (typeof object.removedEuid[i] === "string")
                        $util.base64.decode(object.removedEuid[i], message.removedEuid[i] = $util.newBuffer($util.base64.length(object.removedEuid[i])), 0);
                    else if (object.removedEuid[i].length)
                        message.removedEuid[i] = object.removedEuid[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.BreachWatchStatusRequest} message BreachWatchStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.hashCheck = [];
                object.removedEuid = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.anonymizedToken = "";
                else {
                    object.anonymizedToken = [];
                    if (options.bytes !== Array)
                        object.anonymizedToken = $util.newBuffer(object.anonymizedToken);
                }
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                object.anonymizedToken = options.bytes === String ? $util.base64.encode(message.anonymizedToken, 0, message.anonymizedToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.anonymizedToken) : message.anonymizedToken;
            if (message.hashCheck && message.hashCheck.length) {
                object.hashCheck = [];
                for (let j = 0; j < message.hashCheck.length; ++j)
                    object.hashCheck[j] = $root.BreachWatch.HashCheck.toObject(message.hashCheck[j], options);
            }
            if (message.removedEuid && message.removedEuid.length) {
                object.removedEuid = [];
                for (let j = 0; j < message.removedEuid.length; ++j)
                    object.removedEuid[j] = options.bytes === String ? $util.base64.encode(message.removedEuid[j], 0, message.removedEuid[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.removedEuid[j]) : message.removedEuid[j];
            }
            return object;
        };

        /**
         * Converts this BreachWatchStatusRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchStatusRequest;
    })();

    BreachWatch.HashStatus = (function() {

        /**
         * Properties of a HashStatus.
         * @memberof BreachWatch
         * @interface IHashStatus
         * @property {Uint8Array|null} [hash1] HashStatus hash1
         * @property {Uint8Array|null} [euid] HashStatus euid
         * @property {boolean|null} [breachDetected] HashStatus breachDetected
         */

        /**
         * Constructs a new HashStatus.
         * @memberof BreachWatch
         * @classdesc Represents a HashStatus.
         * @implements IHashStatus
         * @constructor
         * @param {BreachWatch.IHashStatus=} [properties] Properties to set
         */
        function HashStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashStatus hash1.
         * @member {Uint8Array} hash1
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.hash1 = $util.newBuffer([]);

        /**
         * HashStatus euid.
         * @member {Uint8Array} euid
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.euid = $util.newBuffer([]);

        /**
         * HashStatus breachDetected.
         * @member {boolean} breachDetected
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.breachDetected = false;

        /**
         * Creates a new HashStatus instance using the specified properties.
         * @function create
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus=} [properties] Properties to set
         * @returns {BreachWatch.HashStatus} HashStatus instance
         */
        HashStatus.create = function create(properties) {
            return new HashStatus(properties);
        };

        /**
         * Encodes the specified HashStatus message. Does not implicitly {@link BreachWatch.HashStatus.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus} message HashStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash1);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.euid);
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.breachDetected);
            return writer;
        };

        /**
         * Encodes the specified HashStatus message, length delimited. Does not implicitly {@link BreachWatch.HashStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus} message HashStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashStatus message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.HashStatus} HashStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.HashStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash1 = reader.bytes();
                    break;
                case 2:
                    message.euid = reader.bytes();
                    break;
                case 3:
                    message.breachDetected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.HashStatus} HashStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashStatus message.
         * @function verify
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                if (!(message.hash1 && typeof message.hash1.length === "number" || $util.isString(message.hash1)))
                    return "hash1: buffer expected";
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                if (typeof message.breachDetected !== "boolean")
                    return "breachDetected: boolean expected";
            return null;
        };

        /**
         * Creates a HashStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.HashStatus} HashStatus
         */
        HashStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.HashStatus)
                return object;
            let message = new $root.BreachWatch.HashStatus();
            if (object.hash1 != null)
                if (typeof object.hash1 === "string")
                    $util.base64.decode(object.hash1, message.hash1 = $util.newBuffer($util.base64.length(object.hash1)), 0);
                else if (object.hash1.length)
                    message.hash1 = object.hash1;
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            if (object.breachDetected != null)
                message.breachDetected = Boolean(object.breachDetected);
            return message;
        };

        /**
         * Creates a plain object from a HashStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.HashStatus} message HashStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash1 = "";
                else {
                    object.hash1 = [];
                    if (options.bytes !== Array)
                        object.hash1 = $util.newBuffer(object.hash1);
                }
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
                object.breachDetected = false;
            }
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                object.hash1 = options.bytes === String ? $util.base64.encode(message.hash1, 0, message.hash1.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash1) : message.hash1;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                object.breachDetected = message.breachDetected;
            return object;
        };

        /**
         * Converts this HashStatus to JSON.
         * @function toJSON
         * @memberof BreachWatch.HashStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashStatus;
    })();

    BreachWatch.BreachWatchStatusResponse = (function() {

        /**
         * Properties of a BreachWatchStatusResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchStatusResponse
         * @property {Array.<BreachWatch.IHashStatus>|null} [hashStatus] BreachWatchStatusResponse hashStatus
         */

        /**
         * Constructs a new BreachWatchStatusResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchStatusResponse.
         * @implements IBreachWatchStatusResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchStatusResponse=} [properties] Properties to set
         */
        function BreachWatchStatusResponse(properties) {
            this.hashStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchStatusResponse hashStatus.
         * @member {Array.<BreachWatch.IHashStatus>} hashStatus
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @instance
         */
        BreachWatchStatusResponse.prototype.hashStatus = $util.emptyArray;

        /**
         * Creates a new BreachWatchStatusResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse instance
         */
        BreachWatchStatusResponse.create = function create(properties) {
            return new BreachWatchStatusResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchStatusResponse message. Does not implicitly {@link BreachWatch.BreachWatchStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse} message BreachWatchStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashStatus != null && message.hashStatus.length)
                for (let i = 0; i < message.hashStatus.length; ++i)
                    $root.BreachWatch.HashStatus.encode(message.hashStatus[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchStatusResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse} message BreachWatchStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchStatusResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.hashStatus && message.hashStatus.length))
                        message.hashStatus = [];
                    message.hashStatus.push($root.BreachWatch.HashStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchStatusResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashStatus != null && message.hasOwnProperty("hashStatus")) {
                if (!Array.isArray(message.hashStatus))
                    return "hashStatus: array expected";
                for (let i = 0; i < message.hashStatus.length; ++i) {
                    let error = $root.BreachWatch.HashStatus.verify(message.hashStatus[i]);
                    if (error)
                        return "hashStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         */
        BreachWatchStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchStatusResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchStatusResponse();
            if (object.hashStatus) {
                if (!Array.isArray(object.hashStatus))
                    throw TypeError(".BreachWatch.BreachWatchStatusResponse.hashStatus: array expected");
                message.hashStatus = [];
                for (let i = 0; i < object.hashStatus.length; ++i) {
                    if (typeof object.hashStatus[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchStatusResponse.hashStatus: object expected");
                    message.hashStatus[i] = $root.BreachWatch.HashStatus.fromObject(object.hashStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.BreachWatchStatusResponse} message BreachWatchStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchStatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hashStatus = [];
            if (message.hashStatus && message.hashStatus.length) {
                object.hashStatus = [];
                for (let j = 0; j < message.hashStatus.length; ++j)
                    object.hashStatus[j] = $root.BreachWatch.HashStatus.toObject(message.hashStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchStatusResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchStatusResponse;
    })();

    BreachWatch.EnterprisePublicKeyResponse = (function() {

        /**
         * Properties of an EnterprisePublicKeyResponse.
         * @memberof BreachWatch
         * @interface IEnterprisePublicKeyResponse
         * @property {Uint8Array|null} [enterprisePublicKey] EnterprisePublicKeyResponse enterprisePublicKey
         */

        /**
         * Constructs a new EnterprisePublicKeyResponse.
         * @memberof BreachWatch
         * @classdesc Represents an EnterprisePublicKeyResponse.
         * @implements IEnterprisePublicKeyResponse
         * @constructor
         * @param {BreachWatch.IEnterprisePublicKeyResponse=} [properties] Properties to set
         */
        function EnterprisePublicKeyResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePublicKeyResponse enterprisePublicKey.
         * @member {Uint8Array} enterprisePublicKey
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @instance
         */
        EnterprisePublicKeyResponse.prototype.enterprisePublicKey = $util.newBuffer([]);

        /**
         * Creates a new EnterprisePublicKeyResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse=} [properties] Properties to set
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse instance
         */
        EnterprisePublicKeyResponse.create = function create(properties) {
            return new EnterprisePublicKeyResponse(properties);
        };

        /**
         * Encodes the specified EnterprisePublicKeyResponse message. Does not implicitly {@link BreachWatch.EnterprisePublicKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse} message EnterprisePublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePublicKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePublicKey);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePublicKeyResponse message, length delimited. Does not implicitly {@link BreachWatch.EnterprisePublicKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse} message EnterprisePublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePublicKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePublicKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePublicKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.EnterprisePublicKeyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePublicKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePublicKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePublicKeyResponse message.
         * @function verify
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePublicKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                if (!(message.enterprisePublicKey && typeof message.enterprisePublicKey.length === "number" || $util.isString(message.enterprisePublicKey)))
                    return "enterprisePublicKey: buffer expected";
            return null;
        };

        /**
         * Creates an EnterprisePublicKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         */
        EnterprisePublicKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.EnterprisePublicKeyResponse)
                return object;
            let message = new $root.BreachWatch.EnterprisePublicKeyResponse();
            if (object.enterprisePublicKey != null)
                if (typeof object.enterprisePublicKey === "string")
                    $util.base64.decode(object.enterprisePublicKey, message.enterprisePublicKey = $util.newBuffer($util.base64.length(object.enterprisePublicKey)), 0);
                else if (object.enterprisePublicKey.length)
                    message.enterprisePublicKey = object.enterprisePublicKey;
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePublicKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.EnterprisePublicKeyResponse} message EnterprisePublicKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePublicKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.enterprisePublicKey = "";
                else {
                    object.enterprisePublicKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePublicKey = $util.newBuffer(object.enterprisePublicKey);
                }
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                object.enterprisePublicKey = options.bytes === String ? $util.base64.encode(message.enterprisePublicKey, 0, message.enterprisePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePublicKey) : message.enterprisePublicKey;
            return object;
        };

        /**
         * Converts this EnterprisePublicKeyResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePublicKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePublicKeyResponse;
    })();

    BreachWatch.FreeScanRequest = (function() {

        /**
         * Properties of a FreeScanRequest.
         * @memberof BreachWatch
         * @interface IFreeScanRequest
         * @property {Uint8Array|null} [hashedEmail] FreeScanRequest hashedEmail
         */

        /**
         * Constructs a new FreeScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a FreeScanRequest.
         * @implements IFreeScanRequest
         * @constructor
         * @param {BreachWatch.IFreeScanRequest=} [properties] Properties to set
         */
        function FreeScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreeScanRequest hashedEmail.
         * @member {Uint8Array} hashedEmail
         * @memberof BreachWatch.FreeScanRequest
         * @instance
         */
        FreeScanRequest.prototype.hashedEmail = $util.newBuffer([]);

        /**
         * Creates a new FreeScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest instance
         */
        FreeScanRequest.create = function create(properties) {
            return new FreeScanRequest(properties);
        };

        /**
         * Encodes the specified FreeScanRequest message. Does not implicitly {@link BreachWatch.FreeScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest} message FreeScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hashedEmail);
            return writer;
        };

        /**
         * Encodes the specified FreeScanRequest message, length delimited. Does not implicitly {@link BreachWatch.FreeScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest} message FreeScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreeScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreeScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashedEmail = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreeScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreeScanRequest message.
         * @function verify
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreeScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                if (!(message.hashedEmail && typeof message.hashedEmail.length === "number" || $util.isString(message.hashedEmail)))
                    return "hashedEmail: buffer expected";
            return null;
        };

        /**
         * Creates a FreeScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         */
        FreeScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreeScanRequest)
                return object;
            let message = new $root.BreachWatch.FreeScanRequest();
            if (object.hashedEmail != null)
                if (typeof object.hashedEmail === "string")
                    $util.base64.decode(object.hashedEmail, message.hashedEmail = $util.newBuffer($util.base64.length(object.hashedEmail)), 0);
                else if (object.hashedEmail.length)
                    message.hashedEmail = object.hashedEmail;
            return message;
        };

        /**
         * Creates a plain object from a FreeScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.FreeScanRequest} message FreeScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreeScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hashedEmail = "";
                else {
                    object.hashedEmail = [];
                    if (options.bytes !== Array)
                        object.hashedEmail = $util.newBuffer(object.hashedEmail);
                }
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                object.hashedEmail = options.bytes === String ? $util.base64.encode(message.hashedEmail, 0, message.hashedEmail.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashedEmail) : message.hashedEmail;
            return object;
        };

        /**
         * Converts this FreeScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreeScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreeScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreeScanRequest;
    })();

    BreachWatch.FreeScanResponse = (function() {

        /**
         * Properties of a FreeScanResponse.
         * @memberof BreachWatch
         * @interface IFreeScanResponse
         * @property {number|null} [emailBreaches] FreeScanResponse emailBreaches
         * @property {number|null} [passwordBreaches] FreeScanResponse passwordBreaches
         */

        /**
         * Constructs a new FreeScanResponse.
         * @memberof BreachWatch
         * @classdesc Represents a FreeScanResponse.
         * @implements IFreeScanResponse
         * @constructor
         * @param {BreachWatch.IFreeScanResponse=} [properties] Properties to set
         */
        function FreeScanResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreeScanResponse emailBreaches.
         * @member {number} emailBreaches
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         */
        FreeScanResponse.prototype.emailBreaches = 0;

        /**
         * FreeScanResponse passwordBreaches.
         * @member {number} passwordBreaches
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         */
        FreeScanResponse.prototype.passwordBreaches = 0;

        /**
         * Creates a new FreeScanResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse=} [properties] Properties to set
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse instance
         */
        FreeScanResponse.create = function create(properties) {
            return new FreeScanResponse(properties);
        };

        /**
         * Encodes the specified FreeScanResponse message. Does not implicitly {@link BreachWatch.FreeScanResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse} message FreeScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.emailBreaches);
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passwordBreaches);
            return writer;
        };

        /**
         * Encodes the specified FreeScanResponse message, length delimited. Does not implicitly {@link BreachWatch.FreeScanResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse} message FreeScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreeScanResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreeScanResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailBreaches = reader.int32();
                    break;
                case 2:
                    message.passwordBreaches = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreeScanResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreeScanResponse message.
         * @function verify
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreeScanResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                if (!$util.isInteger(message.emailBreaches))
                    return "emailBreaches: integer expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches))
                    return "passwordBreaches: integer expected";
            return null;
        };

        /**
         * Creates a FreeScanResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         */
        FreeScanResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreeScanResponse)
                return object;
            let message = new $root.BreachWatch.FreeScanResponse();
            if (object.emailBreaches != null)
                message.emailBreaches = object.emailBreaches | 0;
            if (object.passwordBreaches != null)
                message.passwordBreaches = object.passwordBreaches | 0;
            return message;
        };

        /**
         * Creates a plain object from a FreeScanResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.FreeScanResponse} message FreeScanResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreeScanResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.emailBreaches = 0;
                object.passwordBreaches = 0;
            }
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                object.emailBreaches = message.emailBreaches;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                object.passwordBreaches = message.passwordBreaches;
            return object;
        };

        /**
         * Converts this FreeScanResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreeScanResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreeScanResponse;
    })();

    BreachWatch.PaidUserRequest = (function() {

        /**
         * Properties of a PaidUserRequest.
         * @memberof BreachWatch
         * @interface IPaidUserRequest
         * @property {string|null} [email] PaidUserRequest email
         */

        /**
         * Constructs a new PaidUserRequest.
         * @memberof BreachWatch
         * @classdesc Represents a PaidUserRequest.
         * @implements IPaidUserRequest
         * @constructor
         * @param {BreachWatch.IPaidUserRequest=} [properties] Properties to set
         */
        function PaidUserRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaidUserRequest email.
         * @member {string} email
         * @memberof BreachWatch.PaidUserRequest
         * @instance
         */
        PaidUserRequest.prototype.email = "";

        /**
         * Creates a new PaidUserRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest=} [properties] Properties to set
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest instance
         */
        PaidUserRequest.create = function create(properties) {
            return new PaidUserRequest(properties);
        };

        /**
         * Encodes the specified PaidUserRequest message. Does not implicitly {@link BreachWatch.PaidUserRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest} message PaidUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PaidUserRequest message, length delimited. Does not implicitly {@link BreachWatch.PaidUserRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest} message PaidUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaidUserRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.PaidUserRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaidUserRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaidUserRequest message.
         * @function verify
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaidUserRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PaidUserRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         */
        PaidUserRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.PaidUserRequest)
                return object;
            let message = new $root.BreachWatch.PaidUserRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PaidUserRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.PaidUserRequest} message PaidUserRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaidUserRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PaidUserRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.PaidUserRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaidUserRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaidUserRequest;
    })();

    BreachWatch.PaidUserResponse = (function() {

        /**
         * Properties of a PaidUserResponse.
         * @memberof BreachWatch
         * @interface IPaidUserResponse
         * @property {boolean|null} [paidUser] PaidUserResponse paidUser
         */

        /**
         * Constructs a new PaidUserResponse.
         * @memberof BreachWatch
         * @classdesc Represents a PaidUserResponse.
         * @implements IPaidUserResponse
         * @constructor
         * @param {BreachWatch.IPaidUserResponse=} [properties] Properties to set
         */
        function PaidUserResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaidUserResponse paidUser.
         * @member {boolean} paidUser
         * @memberof BreachWatch.PaidUserResponse
         * @instance
         */
        PaidUserResponse.prototype.paidUser = false;

        /**
         * Creates a new PaidUserResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse=} [properties] Properties to set
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse instance
         */
        PaidUserResponse.create = function create(properties) {
            return new PaidUserResponse(properties);
        };

        /**
         * Encodes the specified PaidUserResponse message. Does not implicitly {@link BreachWatch.PaidUserResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse} message PaidUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.paidUser);
            return writer;
        };

        /**
         * Encodes the specified PaidUserResponse message, length delimited. Does not implicitly {@link BreachWatch.PaidUserResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse} message PaidUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaidUserResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.PaidUserResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paidUser = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaidUserResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaidUserResponse message.
         * @function verify
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaidUserResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                if (typeof message.paidUser !== "boolean")
                    return "paidUser: boolean expected";
            return null;
        };

        /**
         * Creates a PaidUserResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         */
        PaidUserResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.PaidUserResponse)
                return object;
            let message = new $root.BreachWatch.PaidUserResponse();
            if (object.paidUser != null)
                message.paidUser = Boolean(object.paidUser);
            return message;
        };

        /**
         * Creates a plain object from a PaidUserResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.PaidUserResponse} message PaidUserResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaidUserResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.paidUser = false;
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                object.paidUser = message.paidUser;
            return object;
        };

        /**
         * Converts this PaidUserResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.PaidUserResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaidUserResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaidUserResponse;
    })();

    BreachWatch.DetailedScanRequest = (function() {

        /**
         * Properties of a DetailedScanRequest.
         * @memberof BreachWatch
         * @interface IDetailedScanRequest
         * @property {string|null} [email] DetailedScanRequest email
         */

        /**
         * Constructs a new DetailedScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a DetailedScanRequest.
         * @implements IDetailedScanRequest
         * @constructor
         * @param {BreachWatch.IDetailedScanRequest=} [properties] Properties to set
         */
        function DetailedScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DetailedScanRequest email.
         * @member {string} email
         * @memberof BreachWatch.DetailedScanRequest
         * @instance
         */
        DetailedScanRequest.prototype.email = "";

        /**
         * Creates a new DetailedScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest instance
         */
        DetailedScanRequest.create = function create(properties) {
            return new DetailedScanRequest(properties);
        };

        /**
         * Encodes the specified DetailedScanRequest message. Does not implicitly {@link BreachWatch.DetailedScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest} message DetailedScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailedScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified DetailedScanRequest message, length delimited. Does not implicitly {@link BreachWatch.DetailedScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest} message DetailedScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailedScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DetailedScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailedScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.DetailedScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DetailedScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailedScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DetailedScanRequest message.
         * @function verify
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DetailedScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a DetailedScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         */
        DetailedScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.DetailedScanRequest)
                return object;
            let message = new $root.BreachWatch.DetailedScanRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a DetailedScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.DetailedScanRequest} message DetailedScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DetailedScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this DetailedScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.DetailedScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DetailedScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DetailedScanRequest;
    })();

    BreachWatch.UseOneTimeTokenRequest = (function() {

        /**
         * Properties of a UseOneTimeTokenRequest.
         * @memberof BreachWatch
         * @interface IUseOneTimeTokenRequest
         * @property {Uint8Array|null} [token] UseOneTimeTokenRequest token
         */

        /**
         * Constructs a new UseOneTimeTokenRequest.
         * @memberof BreachWatch
         * @classdesc Represents a UseOneTimeTokenRequest.
         * @implements IUseOneTimeTokenRequest
         * @constructor
         * @param {BreachWatch.IUseOneTimeTokenRequest=} [properties] Properties to set
         */
        function UseOneTimeTokenRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UseOneTimeTokenRequest token.
         * @member {Uint8Array} token
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @instance
         */
        UseOneTimeTokenRequest.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new UseOneTimeTokenRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest=} [properties] Properties to set
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest instance
         */
        UseOneTimeTokenRequest.create = function create(properties) {
            return new UseOneTimeTokenRequest(properties);
        };

        /**
         * Encodes the specified UseOneTimeTokenRequest message. Does not implicitly {@link BreachWatch.UseOneTimeTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest} message UseOneTimeTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified UseOneTimeTokenRequest message, length delimited. Does not implicitly {@link BreachWatch.UseOneTimeTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest} message UseOneTimeTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UseOneTimeTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.UseOneTimeTokenRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UseOneTimeTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UseOneTimeTokenRequest message.
         * @function verify
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UseOneTimeTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a UseOneTimeTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         */
        UseOneTimeTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.UseOneTimeTokenRequest)
                return object;
            let message = new $root.BreachWatch.UseOneTimeTokenRequest();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a UseOneTimeTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.UseOneTimeTokenRequest} message UseOneTimeTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UseOneTimeTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this UseOneTimeTokenRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UseOneTimeTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UseOneTimeTokenRequest;
    })();

    BreachWatch.BreachEvent = (function() {

        /**
         * Properties of a BreachEvent.
         * @memberof BreachWatch
         * @interface IBreachEvent
         * @property {string|null} [site] BreachEvent site
         * @property {string|null} [email] BreachEvent email
         * @property {boolean|null} [passwordInBreach] BreachEvent passwordInBreach
         * @property {string|null} [date] BreachEvent date
         * @property {string|null} [description] BreachEvent description
         */

        /**
         * Constructs a new BreachEvent.
         * @memberof BreachWatch
         * @classdesc Represents a BreachEvent.
         * @implements IBreachEvent
         * @constructor
         * @param {BreachWatch.IBreachEvent=} [properties] Properties to set
         */
        function BreachEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachEvent site.
         * @member {string} site
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.site = "";

        /**
         * BreachEvent email.
         * @member {string} email
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.email = "";

        /**
         * BreachEvent passwordInBreach.
         * @member {boolean} passwordInBreach
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.passwordInBreach = false;

        /**
         * BreachEvent date.
         * @member {string} date
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.date = "";

        /**
         * BreachEvent description.
         * @member {string} description
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.description = "";

        /**
         * Creates a new BreachEvent instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent=} [properties] Properties to set
         * @returns {BreachWatch.BreachEvent} BreachEvent instance
         */
        BreachEvent.create = function create(properties) {
            return new BreachEvent(properties);
        };

        /**
         * Encodes the specified BreachEvent message. Does not implicitly {@link BreachWatch.BreachEvent.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent} message BreachEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.site != null && message.hasOwnProperty("site"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.site);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.passwordInBreach);
            if (message.date != null && message.hasOwnProperty("date"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.date);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified BreachEvent message, length delimited. Does not implicitly {@link BreachWatch.BreachEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent} message BreachEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachEvent message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachEvent} BreachEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.site = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.passwordInBreach = reader.bool();
                    break;
                case 4:
                    message.date = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachEvent} BreachEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachEvent message.
         * @function verify
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.site != null && message.hasOwnProperty("site"))
                if (!$util.isString(message.site))
                    return "site: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                if (typeof message.passwordInBreach !== "boolean")
                    return "passwordInBreach: boolean expected";
            if (message.date != null && message.hasOwnProperty("date"))
                if (!$util.isString(message.date))
                    return "date: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a BreachEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachEvent} BreachEvent
         */
        BreachEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachEvent)
                return object;
            let message = new $root.BreachWatch.BreachEvent();
            if (object.site != null)
                message.site = String(object.site);
            if (object.email != null)
                message.email = String(object.email);
            if (object.passwordInBreach != null)
                message.passwordInBreach = Boolean(object.passwordInBreach);
            if (object.date != null)
                message.date = String(object.date);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a BreachEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.BreachEvent} message BreachEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.site = "";
                object.email = "";
                object.passwordInBreach = false;
                object.date = "";
                object.description = "";
            }
            if (message.site != null && message.hasOwnProperty("site"))
                object.site = message.site;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                object.passwordInBreach = message.passwordInBreach;
            if (message.date != null && message.hasOwnProperty("date"))
                object.date = message.date;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this BreachEvent to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachEvent;
    })();

    BreachWatch.UseOneTimeTokenResponse = (function() {

        /**
         * Properties of a UseOneTimeTokenResponse.
         * @memberof BreachWatch
         * @interface IUseOneTimeTokenResponse
         * @property {number|null} [emailBreaches] UseOneTimeTokenResponse emailBreaches
         * @property {number|null} [passwordBreaches] UseOneTimeTokenResponse passwordBreaches
         * @property {Array.<BreachWatch.IBreachEvent>|null} [breachEvents] UseOneTimeTokenResponse breachEvents
         * @property {string|null} [email] UseOneTimeTokenResponse email
         */

        /**
         * Constructs a new UseOneTimeTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents a UseOneTimeTokenResponse.
         * @implements IUseOneTimeTokenResponse
         * @constructor
         * @param {BreachWatch.IUseOneTimeTokenResponse=} [properties] Properties to set
         */
        function UseOneTimeTokenResponse(properties) {
            this.breachEvents = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UseOneTimeTokenResponse emailBreaches.
         * @member {number} emailBreaches
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.emailBreaches = 0;

        /**
         * UseOneTimeTokenResponse passwordBreaches.
         * @member {number} passwordBreaches
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.passwordBreaches = 0;

        /**
         * UseOneTimeTokenResponse breachEvents.
         * @member {Array.<BreachWatch.IBreachEvent>} breachEvents
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.breachEvents = $util.emptyArray;

        /**
         * UseOneTimeTokenResponse email.
         * @member {string} email
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.email = "";

        /**
         * Creates a new UseOneTimeTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse instance
         */
        UseOneTimeTokenResponse.create = function create(properties) {
            return new UseOneTimeTokenResponse(properties);
        };

        /**
         * Encodes the specified UseOneTimeTokenResponse message. Does not implicitly {@link BreachWatch.UseOneTimeTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse} message UseOneTimeTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.emailBreaches);
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passwordBreaches);
            if (message.breachEvents != null && message.breachEvents.length)
                for (let i = 0; i < message.breachEvents.length; ++i)
                    $root.BreachWatch.BreachEvent.encode(message.breachEvents[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified UseOneTimeTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.UseOneTimeTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse} message UseOneTimeTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UseOneTimeTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.UseOneTimeTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailBreaches = reader.int32();
                    break;
                case 2:
                    message.passwordBreaches = reader.int32();
                    break;
                case 3:
                    if (!(message.breachEvents && message.breachEvents.length))
                        message.breachEvents = [];
                    message.breachEvents.push($root.BreachWatch.BreachEvent.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UseOneTimeTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UseOneTimeTokenResponse message.
         * @function verify
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UseOneTimeTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                if (!$util.isInteger(message.emailBreaches))
                    return "emailBreaches: integer expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches))
                    return "passwordBreaches: integer expected";
            if (message.breachEvents != null && message.hasOwnProperty("breachEvents")) {
                if (!Array.isArray(message.breachEvents))
                    return "breachEvents: array expected";
                for (let i = 0; i < message.breachEvents.length; ++i) {
                    let error = $root.BreachWatch.BreachEvent.verify(message.breachEvents[i]);
                    if (error)
                        return "breachEvents." + error;
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a UseOneTimeTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         */
        UseOneTimeTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.UseOneTimeTokenResponse)
                return object;
            let message = new $root.BreachWatch.UseOneTimeTokenResponse();
            if (object.emailBreaches != null)
                message.emailBreaches = object.emailBreaches | 0;
            if (object.passwordBreaches != null)
                message.passwordBreaches = object.passwordBreaches | 0;
            if (object.breachEvents) {
                if (!Array.isArray(object.breachEvents))
                    throw TypeError(".BreachWatch.UseOneTimeTokenResponse.breachEvents: array expected");
                message.breachEvents = [];
                for (let i = 0; i < object.breachEvents.length; ++i) {
                    if (typeof object.breachEvents[i] !== "object")
                        throw TypeError(".BreachWatch.UseOneTimeTokenResponse.breachEvents: object expected");
                    message.breachEvents[i] = $root.BreachWatch.BreachEvent.fromObject(object.breachEvents[i]);
                }
            }
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a UseOneTimeTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.UseOneTimeTokenResponse} message UseOneTimeTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UseOneTimeTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachEvents = [];
            if (options.defaults) {
                object.emailBreaches = 0;
                object.passwordBreaches = 0;
                object.email = "";
            }
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                object.emailBreaches = message.emailBreaches;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                object.passwordBreaches = message.passwordBreaches;
            if (message.breachEvents && message.breachEvents.length) {
                object.breachEvents = [];
                for (let j = 0; j < message.breachEvents.length; ++j)
                    object.breachEvents[j] = $root.BreachWatch.BreachEvent.toObject(message.breachEvents[j], options);
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this UseOneTimeTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UseOneTimeTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UseOneTimeTokenResponse;
    })();

    BreachWatch.OneTimeUseToken = (function() {

        /**
         * Properties of an OneTimeUseToken.
         * @memberof BreachWatch
         * @interface IOneTimeUseToken
         * @property {string|null} [email] OneTimeUseToken email
         * @property {string|null} [pad] OneTimeUseToken pad
         */

        /**
         * Constructs a new OneTimeUseToken.
         * @memberof BreachWatch
         * @classdesc Represents an OneTimeUseToken.
         * @implements IOneTimeUseToken
         * @constructor
         * @param {BreachWatch.IOneTimeUseToken=} [properties] Properties to set
         */
        function OneTimeUseToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneTimeUseToken email.
         * @member {string} email
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         */
        OneTimeUseToken.prototype.email = "";

        /**
         * OneTimeUseToken pad.
         * @member {string} pad
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         */
        OneTimeUseToken.prototype.pad = "";

        /**
         * Creates a new OneTimeUseToken instance using the specified properties.
         * @function create
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken=} [properties] Properties to set
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken instance
         */
        OneTimeUseToken.create = function create(properties) {
            return new OneTimeUseToken(properties);
        };

        /**
         * Encodes the specified OneTimeUseToken message. Does not implicitly {@link BreachWatch.OneTimeUseToken.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken} message OneTimeUseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneTimeUseToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.pad != null && message.hasOwnProperty("pad"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pad);
            return writer;
        };

        /**
         * Encodes the specified OneTimeUseToken message, length delimited. Does not implicitly {@link BreachWatch.OneTimeUseToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken} message OneTimeUseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneTimeUseToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneTimeUseToken message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneTimeUseToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.OneTimeUseToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.pad = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OneTimeUseToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneTimeUseToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneTimeUseToken message.
         * @function verify
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneTimeUseToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.pad != null && message.hasOwnProperty("pad"))
                if (!$util.isString(message.pad))
                    return "pad: string expected";
            return null;
        };

        /**
         * Creates an OneTimeUseToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         */
        OneTimeUseToken.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.OneTimeUseToken)
                return object;
            let message = new $root.BreachWatch.OneTimeUseToken();
            if (object.email != null)
                message.email = String(object.email);
            if (object.pad != null)
                message.pad = String(object.pad);
            return message;
        };

        /**
         * Creates a plain object from an OneTimeUseToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.OneTimeUseToken} message OneTimeUseToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneTimeUseToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.pad = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.pad != null && message.hasOwnProperty("pad"))
                object.pad = message.pad;
            return object;
        };

        /**
         * Converts this OneTimeUseToken to JSON.
         * @function toJSON
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneTimeUseToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneTimeUseToken;
    })();

    BreachWatch.FreePasswordScanRequest = (function() {

        /**
         * Properties of a FreePasswordScanRequest.
         * @memberof BreachWatch
         * @interface IFreePasswordScanRequest
         * @property {Uint8Array|null} [hashedPassword] FreePasswordScanRequest hashedPassword
         */

        /**
         * Constructs a new FreePasswordScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a FreePasswordScanRequest.
         * @implements IFreePasswordScanRequest
         * @constructor
         * @param {BreachWatch.IFreePasswordScanRequest=} [properties] Properties to set
         */
        function FreePasswordScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreePasswordScanRequest hashedPassword.
         * @member {Uint8Array} hashedPassword
         * @memberof BreachWatch.FreePasswordScanRequest
         * @instance
         */
        FreePasswordScanRequest.prototype.hashedPassword = $util.newBuffer([]);

        /**
         * Creates a new FreePasswordScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest instance
         */
        FreePasswordScanRequest.create = function create(properties) {
            return new FreePasswordScanRequest(properties);
        };

        /**
         * Encodes the specified FreePasswordScanRequest message. Does not implicitly {@link BreachWatch.FreePasswordScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest} message FreePasswordScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hashedPassword);
            return writer;
        };

        /**
         * Encodes the specified FreePasswordScanRequest message, length delimited. Does not implicitly {@link BreachWatch.FreePasswordScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest} message FreePasswordScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreePasswordScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreePasswordScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashedPassword = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreePasswordScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreePasswordScanRequest message.
         * @function verify
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreePasswordScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                if (!(message.hashedPassword && typeof message.hashedPassword.length === "number" || $util.isString(message.hashedPassword)))
                    return "hashedPassword: buffer expected";
            return null;
        };

        /**
         * Creates a FreePasswordScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         */
        FreePasswordScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreePasswordScanRequest)
                return object;
            let message = new $root.BreachWatch.FreePasswordScanRequest();
            if (object.hashedPassword != null)
                if (typeof object.hashedPassword === "string")
                    $util.base64.decode(object.hashedPassword, message.hashedPassword = $util.newBuffer($util.base64.length(object.hashedPassword)), 0);
                else if (object.hashedPassword.length)
                    message.hashedPassword = object.hashedPassword;
            return message;
        };

        /**
         * Creates a plain object from a FreePasswordScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.FreePasswordScanRequest} message FreePasswordScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreePasswordScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hashedPassword = "";
                else {
                    object.hashedPassword = [];
                    if (options.bytes !== Array)
                        object.hashedPassword = $util.newBuffer(object.hashedPassword);
                }
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                object.hashedPassword = options.bytes === String ? $util.base64.encode(message.hashedPassword, 0, message.hashedPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashedPassword) : message.hashedPassword;
            return object;
        };

        /**
         * Converts this FreePasswordScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreePasswordScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreePasswordScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreePasswordScanRequest;
    })();

    BreachWatch.FreePasswordScanResponse = (function() {

        /**
         * Properties of a FreePasswordScanResponse.
         * @memberof BreachWatch
         * @interface IFreePasswordScanResponse
         * @property {number|Long|null} [passwordBreaches] FreePasswordScanResponse passwordBreaches
         */

        /**
         * Constructs a new FreePasswordScanResponse.
         * @memberof BreachWatch
         * @classdesc Represents a FreePasswordScanResponse.
         * @implements IFreePasswordScanResponse
         * @constructor
         * @param {BreachWatch.IFreePasswordScanResponse=} [properties] Properties to set
         */
        function FreePasswordScanResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreePasswordScanResponse passwordBreaches.
         * @member {number|Long} passwordBreaches
         * @memberof BreachWatch.FreePasswordScanResponse
         * @instance
         */
        FreePasswordScanResponse.prototype.passwordBreaches = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FreePasswordScanResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse=} [properties] Properties to set
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse instance
         */
        FreePasswordScanResponse.create = function create(properties) {
            return new FreePasswordScanResponse(properties);
        };

        /**
         * Encodes the specified FreePasswordScanResponse message. Does not implicitly {@link BreachWatch.FreePasswordScanResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse} message FreePasswordScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.passwordBreaches);
            return writer;
        };

        /**
         * Encodes the specified FreePasswordScanResponse message, length delimited. Does not implicitly {@link BreachWatch.FreePasswordScanResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse} message FreePasswordScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreePasswordScanResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreePasswordScanResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.passwordBreaches = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreePasswordScanResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreePasswordScanResponse message.
         * @function verify
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreePasswordScanResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches) && !(message.passwordBreaches && $util.isInteger(message.passwordBreaches.low) && $util.isInteger(message.passwordBreaches.high)))
                    return "passwordBreaches: integer|Long expected";
            return null;
        };

        /**
         * Creates a FreePasswordScanResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         */
        FreePasswordScanResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreePasswordScanResponse)
                return object;
            let message = new $root.BreachWatch.FreePasswordScanResponse();
            if (object.passwordBreaches != null)
                if ($util.Long)
                    (message.passwordBreaches = $util.Long.fromValue(object.passwordBreaches)).unsigned = false;
                else if (typeof object.passwordBreaches === "string")
                    message.passwordBreaches = parseInt(object.passwordBreaches, 10);
                else if (typeof object.passwordBreaches === "number")
                    message.passwordBreaches = object.passwordBreaches;
                else if (typeof object.passwordBreaches === "object")
                    message.passwordBreaches = new $util.LongBits(object.passwordBreaches.low >>> 0, object.passwordBreaches.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FreePasswordScanResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.FreePasswordScanResponse} message FreePasswordScanResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreePasswordScanResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.passwordBreaches = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.passwordBreaches = options.longs === String ? "0" : 0;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (typeof message.passwordBreaches === "number")
                    object.passwordBreaches = options.longs === String ? String(message.passwordBreaches) : message.passwordBreaches;
                else
                    object.passwordBreaches = options.longs === String ? $util.Long.prototype.toString.call(message.passwordBreaches) : options.longs === Number ? new $util.LongBits(message.passwordBreaches.low >>> 0, message.passwordBreaches.high >>> 0).toNumber() : message.passwordBreaches;
            return object;
        };

        /**
         * Converts this FreePasswordScanResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreePasswordScanResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreePasswordScanResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreePasswordScanResponse;
    })();

    return BreachWatch;
})();

export const Tokens = $root.Tokens = (() => {

    /**
     * Namespace Tokens.
     * @exports Tokens
     * @namespace
     */
    const Tokens = {};

    Tokens.BreachWatchUpdateRequest = (function() {

        /**
         * Properties of a BreachWatchUpdateRequest.
         * @memberof Tokens
         * @interface IBreachWatchUpdateRequest
         * @property {Array.<Tokens.IBreachWatchRecordRequest>|null} [breachWatchRecordRequest] BreachWatchUpdateRequest breachWatchRecordRequest
         * @property {Uint8Array|null} [encryptedData] BreachWatchUpdateRequest encryptedData
         */

        /**
         * Constructs a new BreachWatchUpdateRequest.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchUpdateRequest.
         * @implements IBreachWatchUpdateRequest
         * @constructor
         * @param {Tokens.IBreachWatchUpdateRequest=} [properties] Properties to set
         */
        function BreachWatchUpdateRequest(properties) {
            this.breachWatchRecordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateRequest breachWatchRecordRequest.
         * @member {Array.<Tokens.IBreachWatchRecordRequest>} breachWatchRecordRequest
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.breachWatchRecordRequest = $util.emptyArray;

        /**
         * BreachWatchUpdateRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest=} [properties] Properties to set
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest instance
         */
        BreachWatchUpdateRequest.create = function create(properties) {
            return new BreachWatchUpdateRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message. Does not implicitly {@link Tokens.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordRequest != null && message.breachWatchRecordRequest.length)
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i)
                    $root.Tokens.BreachWatchRecordRequest.encode(message.breachWatchRecordRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message, length delimited. Does not implicitly {@link Tokens.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordRequest && message.breachWatchRecordRequest.length))
                        message.breachWatchRecordRequest = [];
                    message.breachWatchRecordRequest.push($root.Tokens.BreachWatchRecordRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateRequest message.
         * @function verify
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordRequest != null && message.hasOwnProperty("breachWatchRecordRequest")) {
                if (!Array.isArray(message.breachWatchRecordRequest))
                    return "breachWatchRecordRequest: array expected";
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i) {
                    let error = $root.Tokens.BreachWatchRecordRequest.verify(message.breachWatchRecordRequest[i]);
                    if (error)
                        return "breachWatchRecordRequest." + error;
                }
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         */
        BreachWatchUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchUpdateRequest)
                return object;
            let message = new $root.Tokens.BreachWatchUpdateRequest();
            if (object.breachWatchRecordRequest) {
                if (!Array.isArray(object.breachWatchRecordRequest))
                    throw TypeError(".Tokens.BreachWatchUpdateRequest.breachWatchRecordRequest: array expected");
                message.breachWatchRecordRequest = [];
                for (let i = 0; i < object.breachWatchRecordRequest.length; ++i) {
                    if (typeof object.breachWatchRecordRequest[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchUpdateRequest.breachWatchRecordRequest: object expected");
                    message.breachWatchRecordRequest[i] = $root.Tokens.BreachWatchRecordRequest.fromObject(object.breachWatchRecordRequest[i]);
                }
            }
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.BreachWatchUpdateRequest} message BreachWatchUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordRequest = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
            if (message.breachWatchRecordRequest && message.breachWatchRecordRequest.length) {
                object.breachWatchRecordRequest = [];
                for (let j = 0; j < message.breachWatchRecordRequest.length; ++j)
                    object.breachWatchRecordRequest[j] = $root.Tokens.BreachWatchRecordRequest.toObject(message.breachWatchRecordRequest[j], options);
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            return object;
        };

        /**
         * Converts this BreachWatchUpdateRequest to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateRequest;
    })();

    Tokens.BreachWatchRecordRequest = (function() {

        /**
         * Properties of a BreachWatchRecordRequest.
         * @memberof Tokens
         * @interface IBreachWatchRecordRequest
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordRequest recordUid
         * @property {Uint8Array|null} [encryptedData] BreachWatchRecordRequest encryptedData
         * @property {Tokens.BreachWatchInfoType|null} [breachWatchInfoType] BreachWatchRecordRequest breachWatchInfoType
         * @property {boolean|null} [updateUserWhoScanned] BreachWatchRecordRequest updateUserWhoScanned
         */

        /**
         * Constructs a new BreachWatchRecordRequest.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchRecordRequest.
         * @implements IBreachWatchRecordRequest
         * @constructor
         * @param {Tokens.IBreachWatchRecordRequest=} [properties] Properties to set
         */
        function BreachWatchRecordRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest breachWatchInfoType.
         * @member {Tokens.BreachWatchInfoType} breachWatchInfoType
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.breachWatchInfoType = 0;

        /**
         * BreachWatchRecordRequest updateUserWhoScanned.
         * @member {boolean} updateUserWhoScanned
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.updateUserWhoScanned = false;

        /**
         * Creates a new BreachWatchRecordRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest=} [properties] Properties to set
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest instance
         */
        BreachWatchRecordRequest.create = function create(properties) {
            return new BreachWatchRecordRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message. Does not implicitly {@link Tokens.BreachWatchRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.breachWatchInfoType);
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateUserWhoScanned);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message, length delimited. Does not implicitly {@link Tokens.BreachWatchRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                case 3:
                    message.breachWatchInfoType = reader.int32();
                    break;
                case 4:
                    message.updateUserWhoScanned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordRequest message.
         * @function verify
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                switch (message.breachWatchInfoType) {
                default:
                    return "breachWatchInfoType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                if (typeof message.updateUserWhoScanned !== "boolean")
                    return "updateUserWhoScanned: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         */
        BreachWatchRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchRecordRequest)
                return object;
            let message = new $root.Tokens.BreachWatchRecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            switch (object.breachWatchInfoType) {
            case "RECORD":
            case 0:
                message.breachWatchInfoType = 0;
                break;
            case "ALTERNATE_PASSWORD":
            case 1:
                message.breachWatchInfoType = 1;
                break;
            }
            if (object.updateUserWhoScanned != null)
                message.updateUserWhoScanned = Boolean(object.updateUserWhoScanned);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.BreachWatchRecordRequest} message BreachWatchRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
                object.breachWatchInfoType = options.enums === String ? "RECORD" : 0;
                object.updateUserWhoScanned = false;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                object.breachWatchInfoType = options.enums === String ? $root.Tokens.BreachWatchInfoType[message.breachWatchInfoType] : message.breachWatchInfoType;
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                object.updateUserWhoScanned = message.updateUserWhoScanned;
            return object;
        };

        /**
         * Converts this BreachWatchRecordRequest to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordRequest;
    })();

    /**
     * BreachWatchInfoType enum.
     * @name Tokens.BreachWatchInfoType
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} ALTERNATE_PASSWORD=1 ALTERNATE_PASSWORD value
     */
    Tokens.BreachWatchInfoType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "ALTERNATE_PASSWORD"] = 1;
        return values;
    })();

    Tokens.BreachWatchData = (function() {

        /**
         * Properties of a BreachWatchData.
         * @memberof Tokens
         * @interface IBreachWatchData
         * @property {Array.<Tokens.IBWPassword>|null} [passwords] BreachWatchData passwords
         * @property {Array.<Tokens.IBWPassword>|null} [emails] BreachWatchData emails
         * @property {Array.<Tokens.IBWPassword>|null} [domains] BreachWatchData domains
         */

        /**
         * Constructs a new BreachWatchData.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchData.
         * @implements IBreachWatchData
         * @constructor
         * @param {Tokens.IBreachWatchData=} [properties] Properties to set
         */
        function BreachWatchData(properties) {
            this.passwords = [];
            this.emails = [];
            this.domains = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchData passwords.
         * @member {Array.<Tokens.IBWPassword>} passwords
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.passwords = $util.emptyArray;

        /**
         * BreachWatchData emails.
         * @member {Array.<Tokens.IBWPassword>} emails
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.emails = $util.emptyArray;

        /**
         * BreachWatchData domains.
         * @member {Array.<Tokens.IBWPassword>} domains
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.domains = $util.emptyArray;

        /**
         * Creates a new BreachWatchData instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData=} [properties] Properties to set
         * @returns {Tokens.BreachWatchData} BreachWatchData instance
         */
        BreachWatchData.create = function create(properties) {
            return new BreachWatchData(properties);
        };

        /**
         * Encodes the specified BreachWatchData message. Does not implicitly {@link Tokens.BreachWatchData.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData} message BreachWatchData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passwords != null && message.passwords.length)
                for (let i = 0; i < message.passwords.length; ++i)
                    $root.Tokens.BWPassword.encode(message.passwords[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.emails != null && message.emails.length)
                for (let i = 0; i < message.emails.length; ++i)
                    $root.Tokens.BWPassword.encode(message.emails[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.domains != null && message.domains.length)
                for (let i = 0; i < message.domains.length; ++i)
                    $root.Tokens.BWPassword.encode(message.domains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchData message, length delimited. Does not implicitly {@link Tokens.BreachWatchData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData} message BreachWatchData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchData message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchData} BreachWatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.passwords && message.passwords.length))
                        message.passwords = [];
                    message.passwords.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.emails && message.emails.length))
                        message.emails = [];
                    message.emails.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.domains && message.domains.length))
                        message.domains = [];
                    message.domains.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchData} BreachWatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchData message.
         * @function verify
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passwords != null && message.hasOwnProperty("passwords")) {
                if (!Array.isArray(message.passwords))
                    return "passwords: array expected";
                for (let i = 0; i < message.passwords.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.passwords[i]);
                    if (error)
                        return "passwords." + error;
                }
            }
            if (message.emails != null && message.hasOwnProperty("emails")) {
                if (!Array.isArray(message.emails))
                    return "emails: array expected";
                for (let i = 0; i < message.emails.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.emails[i]);
                    if (error)
                        return "emails." + error;
                }
            }
            if (message.domains != null && message.hasOwnProperty("domains")) {
                if (!Array.isArray(message.domains))
                    return "domains: array expected";
                for (let i = 0; i < message.domains.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.domains[i]);
                    if (error)
                        return "domains." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchData} BreachWatchData
         */
        BreachWatchData.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchData)
                return object;
            let message = new $root.Tokens.BreachWatchData();
            if (object.passwords) {
                if (!Array.isArray(object.passwords))
                    throw TypeError(".Tokens.BreachWatchData.passwords: array expected");
                message.passwords = [];
                for (let i = 0; i < object.passwords.length; ++i) {
                    if (typeof object.passwords[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.passwords: object expected");
                    message.passwords[i] = $root.Tokens.BWPassword.fromObject(object.passwords[i]);
                }
            }
            if (object.emails) {
                if (!Array.isArray(object.emails))
                    throw TypeError(".Tokens.BreachWatchData.emails: array expected");
                message.emails = [];
                for (let i = 0; i < object.emails.length; ++i) {
                    if (typeof object.emails[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.emails: object expected");
                    message.emails[i] = $root.Tokens.BWPassword.fromObject(object.emails[i]);
                }
            }
            if (object.domains) {
                if (!Array.isArray(object.domains))
                    throw TypeError(".Tokens.BreachWatchData.domains: array expected");
                message.domains = [];
                for (let i = 0; i < object.domains.length; ++i) {
                    if (typeof object.domains[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.domains: object expected");
                    message.domains[i] = $root.Tokens.BWPassword.fromObject(object.domains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.BreachWatchData} message BreachWatchData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.passwords = [];
                object.emails = [];
                object.domains = [];
            }
            if (message.passwords && message.passwords.length) {
                object.passwords = [];
                for (let j = 0; j < message.passwords.length; ++j)
                    object.passwords[j] = $root.Tokens.BWPassword.toObject(message.passwords[j], options);
            }
            if (message.emails && message.emails.length) {
                object.emails = [];
                for (let j = 0; j < message.emails.length; ++j)
                    object.emails[j] = $root.Tokens.BWPassword.toObject(message.emails[j], options);
            }
            if (message.domains && message.domains.length) {
                object.domains = [];
                for (let j = 0; j < message.domains.length; ++j)
                    object.domains[j] = $root.Tokens.BWPassword.toObject(message.domains[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchData to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchData;
    })();

    Tokens.BWPassword = (function() {

        /**
         * Properties of a BWPassword.
         * @memberof Tokens
         * @interface IBWPassword
         * @property {string|null} [value] BWPassword value
         * @property {number|Long|null} [resolved] BWPassword resolved
         * @property {Tokens.BWStatus|null} [status] BWPassword status
         * @property {Uint8Array|null} [euid] BWPassword euid
         */

        /**
         * Constructs a new BWPassword.
         * @memberof Tokens
         * @classdesc Represents a BWPassword.
         * @implements IBWPassword
         * @constructor
         * @param {Tokens.IBWPassword=} [properties] Properties to set
         */
        function BWPassword(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BWPassword value.
         * @member {string} value
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.value = "";

        /**
         * BWPassword resolved.
         * @member {number|Long} resolved
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.resolved = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BWPassword status.
         * @member {Tokens.BWStatus} status
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.status = 0;

        /**
         * BWPassword euid.
         * @member {Uint8Array} euid
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.euid = $util.newBuffer([]);

        /**
         * Creates a new BWPassword instance using the specified properties.
         * @function create
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword=} [properties] Properties to set
         * @returns {Tokens.BWPassword} BWPassword instance
         */
        BWPassword.create = function create(properties) {
            return new BWPassword(properties);
        };

        /**
         * Encodes the specified BWPassword message. Does not implicitly {@link Tokens.BWPassword.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword} message BWPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BWPassword.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.resolved);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.euid);
            return writer;
        };

        /**
         * Encodes the specified BWPassword message, length delimited. Does not implicitly {@link Tokens.BWPassword.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword} message BWPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BWPassword.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BWPassword message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BWPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BWPassword} BWPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BWPassword.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BWPassword();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.resolved = reader.uint64();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.euid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BWPassword message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BWPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BWPassword} BWPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BWPassword.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BWPassword message.
         * @function verify
         * @memberof Tokens.BWPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BWPassword.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (!$util.isInteger(message.resolved) && !(message.resolved && $util.isInteger(message.resolved.low) && $util.isInteger(message.resolved.high)))
                    return "resolved: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            return null;
        };

        /**
         * Creates a BWPassword message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BWPassword
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BWPassword} BWPassword
         */
        BWPassword.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BWPassword)
                return object;
            let message = new $root.Tokens.BWPassword();
            if (object.value != null)
                message.value = String(object.value);
            if (object.resolved != null)
                if ($util.Long)
                    (message.resolved = $util.Long.fromValue(object.resolved)).unsigned = true;
                else if (typeof object.resolved === "string")
                    message.resolved = parseInt(object.resolved, 10);
                else if (typeof object.resolved === "number")
                    message.resolved = object.resolved;
                else if (typeof object.resolved === "object")
                    message.resolved = new $util.LongBits(object.resolved.low >>> 0, object.resolved.high >>> 0).toNumber(true);
            switch (object.status) {
            case "GOOD":
            case 0:
                message.status = 0;
                break;
            case "CHANGED":
            case 1:
                message.status = 1;
                break;
            case "WEAK":
            case 2:
                message.status = 2;
                break;
            case "BREACHED":
            case 3:
                message.status = 3;
                break;
            case "IGNORE":
            case 4:
                message.status = 4;
                break;
            }
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            return message;
        };

        /**
         * Creates a plain object from a BWPassword message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.BWPassword} message BWPassword
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BWPassword.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.resolved = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resolved = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "GOOD" : 0;
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (typeof message.resolved === "number")
                    object.resolved = options.longs === String ? String(message.resolved) : message.resolved;
                else
                    object.resolved = options.longs === String ? $util.Long.prototype.toString.call(message.resolved) : options.longs === Number ? new $util.LongBits(message.resolved.low >>> 0, message.resolved.high >>> 0).toNumber(true) : message.resolved;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Tokens.BWStatus[message.status] : message.status;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            return object;
        };

        /**
         * Converts this BWPassword to JSON.
         * @function toJSON
         * @memberof Tokens.BWPassword
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BWPassword.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BWPassword;
    })();

    /**
     * BWStatus enum.
     * @name Tokens.BWStatus
     * @enum {string}
     * @property {number} GOOD=0 GOOD value
     * @property {number} CHANGED=1 CHANGED value
     * @property {number} WEAK=2 WEAK value
     * @property {number} BREACHED=3 BREACHED value
     * @property {number} IGNORE=4 IGNORE value
     */
    Tokens.BWStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GOOD"] = 0;
        values[valuesById[1] = "CHANGED"] = 1;
        values[valuesById[2] = "WEAK"] = 2;
        values[valuesById[3] = "BREACHED"] = 3;
        values[valuesById[4] = "IGNORE"] = 4;
        return values;
    })();

    Tokens.DeviceToken = (function() {

        /**
         * Properties of a DeviceToken.
         * @memberof Tokens
         * @interface IDeviceToken
         * @property {number|Long|null} [deviceId] DeviceToken deviceId
         * @property {number|null} [region] DeviceToken region
         */

        /**
         * Constructs a new DeviceToken.
         * @memberof Tokens
         * @classdesc Represents a DeviceToken.
         * @implements IDeviceToken
         * @constructor
         * @param {Tokens.IDeviceToken=} [properties] Properties to set
         */
        function DeviceToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.DeviceToken
         * @instance
         */
        DeviceToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceToken region.
         * @member {number} region
         * @memberof Tokens.DeviceToken
         * @instance
         */
        DeviceToken.prototype.region = 0;

        /**
         * Creates a new DeviceToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken=} [properties] Properties to set
         * @returns {Tokens.DeviceToken} DeviceToken instance
         */
        DeviceToken.create = function create(properties) {
            return new DeviceToken(properties);
        };

        /**
         * Encodes the specified DeviceToken message. Does not implicitly {@link Tokens.DeviceToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.region != null && message.hasOwnProperty("region"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.region);
            return writer;
        };

        /**
         * Encodes the specified DeviceToken message, length delimited. Does not implicitly {@link Tokens.DeviceToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeviceToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.region = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceToken message.
         * @function verify
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isInteger(message.region))
                    return "region: integer expected";
            return null;
        };

        /**
         * Creates a DeviceToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeviceToken} DeviceToken
         */
        DeviceToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeviceToken)
                return object;
            let message = new $root.Tokens.DeviceToken();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.region != null)
                message.region = object.region | 0;
            return message;
        };

        /**
         * Creates a plain object from a DeviceToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.DeviceToken} message DeviceToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.region = 0;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            return object;
        };

        /**
         * Converts this DeviceToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeviceToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceToken;
    })();

    Tokens.DeviceApprovalToken = (function() {

        /**
         * Properties of a DeviceApprovalToken.
         * @memberof Tokens
         * @interface IDeviceApprovalToken
         * @property {number|Long|null} [creation] DeviceApprovalToken creation
         * @property {number|Long|null} [expiration] DeviceApprovalToken expiration
         * @property {Tokens.IDeviceToken|null} [deviceToken] DeviceApprovalToken deviceToken
         * @property {string|null} [locale] DeviceApprovalToken locale
         */

        /**
         * Constructs a new DeviceApprovalToken.
         * @memberof Tokens
         * @classdesc Represents a DeviceApprovalToken.
         * @implements IDeviceApprovalToken
         * @constructor
         * @param {Tokens.IDeviceApprovalToken=} [properties] Properties to set
         */
        function DeviceApprovalToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceApprovalToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceApprovalToken deviceToken.
         * @member {Tokens.IDeviceToken|null|undefined} deviceToken
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.deviceToken = null;

        /**
         * DeviceApprovalToken locale.
         * @member {string} locale
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.locale = "";

        /**
         * Creates a new DeviceApprovalToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken=} [properties] Properties to set
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken instance
         */
        DeviceApprovalToken.create = function create(properties) {
            return new DeviceApprovalToken(properties);
        };

        /**
         * Encodes the specified DeviceApprovalToken message. Does not implicitly {@link Tokens.DeviceApprovalToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken} message DeviceApprovalToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.creation);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.Tokens.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.locale);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalToken message, length delimited. Does not implicitly {@link Tokens.DeviceApprovalToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken} message DeviceApprovalToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeviceApprovalToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.creation = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.deviceToken = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalToken message.
         * @function verify
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.Tokens.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            return null;
        };

        /**
         * Creates a DeviceApprovalToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         */
        DeviceApprovalToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeviceApprovalToken)
                return object;
            let message = new $root.Tokens.DeviceApprovalToken();
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".Tokens.DeviceApprovalToken.deviceToken: object expected");
                message.deviceToken = $root.Tokens.DeviceToken.fromObject(object.deviceToken);
            }
            if (object.locale != null)
                message.locale = String(object.locale);
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.DeviceApprovalToken} message DeviceApprovalToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.deviceToken = null;
                object.locale = "";
            }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.Tokens.DeviceToken.toObject(message.deviceToken, options);
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            return object;
        };

        /**
         * Converts this DeviceApprovalToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalToken;
    })();

    Tokens.TwoFactorToken = (function() {

        /**
         * Properties of a TwoFactorToken.
         * @memberof Tokens
         * @interface ITwoFactorToken
         * @property {number|Long|null} [creation] TwoFactorToken creation
         * @property {number|Long|null} [expiration] TwoFactorToken expiration
         * @property {Tokens.IDeviceToken|null} [deviceToken] TwoFactorToken deviceToken
         * @property {string|null} [deviceIp] TwoFactorToken deviceIp
         */

        /**
         * Constructs a new TwoFactorToken.
         * @memberof Tokens
         * @classdesc Represents a TwoFactorToken.
         * @implements ITwoFactorToken
         * @constructor
         * @param {Tokens.ITwoFactorToken=} [properties] Properties to set
         */
        function TwoFactorToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TwoFactorToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TwoFactorToken deviceToken.
         * @member {Tokens.IDeviceToken|null|undefined} deviceToken
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.deviceToken = null;

        /**
         * TwoFactorToken deviceIp.
         * @member {string} deviceIp
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.deviceIp = "";

        /**
         * Creates a new TwoFactorToken instance using the specified properties.
         * @function create
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken=} [properties] Properties to set
         * @returns {Tokens.TwoFactorToken} TwoFactorToken instance
         */
        TwoFactorToken.create = function create(properties) {
            return new TwoFactorToken(properties);
        };

        /**
         * Encodes the specified TwoFactorToken message. Does not implicitly {@link Tokens.TwoFactorToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken} message TwoFactorToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.creation);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.Tokens.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceIp);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorToken message, length delimited. Does not implicitly {@link Tokens.TwoFactorToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken} message TwoFactorToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.TwoFactorToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.creation = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.deviceToken = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.deviceIp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorToken message.
         * @function verify
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.Tokens.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                if (!$util.isString(message.deviceIp))
                    return "deviceIp: string expected";
            return null;
        };

        /**
         * Creates a TwoFactorToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         */
        TwoFactorToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.TwoFactorToken)
                return object;
            let message = new $root.Tokens.TwoFactorToken();
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".Tokens.TwoFactorToken.deviceToken: object expected");
                message.deviceToken = $root.Tokens.DeviceToken.fromObject(object.deviceToken);
            }
            if (object.deviceIp != null)
                message.deviceIp = String(object.deviceIp);
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.TwoFactorToken} message TwoFactorToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.deviceToken = null;
                object.deviceIp = "";
            }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.Tokens.DeviceToken.toObject(message.deviceToken, options);
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                object.deviceIp = message.deviceIp;
            return object;
        };

        /**
         * Converts this TwoFactorToken to JSON.
         * @function toJSON
         * @memberof Tokens.TwoFactorToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorToken;
    })();

    Tokens.BreachWatchToken = (function() {

        /**
         * Properties of a BreachWatchToken.
         * @memberof Tokens
         * @interface IBreachWatchToken
         * @property {number|null} [userId] BreachWatchToken userId
         * @property {Uint8Array|null} [domainUid] BreachWatchToken domainUid
         * @property {Uint8Array|null} [emailUid] BreachWatchToken emailUid
         * @property {Uint8Array|null} [passwordUid] BreachWatchToken passwordUid
         */

        /**
         * Constructs a new BreachWatchToken.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchToken.
         * @implements IBreachWatchToken
         * @constructor
         * @param {Tokens.IBreachWatchToken=} [properties] Properties to set
         */
        function BreachWatchToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchToken userId.
         * @member {number} userId
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.userId = 0;

        /**
         * BreachWatchToken domainUid.
         * @member {Uint8Array} domainUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.domainUid = $util.newBuffer([]);

        /**
         * BreachWatchToken emailUid.
         * @member {Uint8Array} emailUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.emailUid = $util.newBuffer([]);

        /**
         * BreachWatchToken passwordUid.
         * @member {Uint8Array} passwordUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.passwordUid = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchToken instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken=} [properties] Properties to set
         * @returns {Tokens.BreachWatchToken} BreachWatchToken instance
         */
        BreachWatchToken.create = function create(properties) {
            return new BreachWatchToken(properties);
        };

        /**
         * Encodes the specified BreachWatchToken message. Does not implicitly {@link Tokens.BreachWatchToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken} message BreachWatchToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.domainUid);
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.emailUid);
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.passwordUid);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchToken message, length delimited. Does not implicitly {@link Tokens.BreachWatchToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken} message BreachWatchToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.domainUid = reader.bytes();
                    break;
                case 3:
                    message.emailUid = reader.bytes();
                    break;
                case 4:
                    message.passwordUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchToken message.
         * @function verify
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                if (!(message.domainUid && typeof message.domainUid.length === "number" || $util.isString(message.domainUid)))
                    return "domainUid: buffer expected";
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                if (!(message.emailUid && typeof message.emailUid.length === "number" || $util.isString(message.emailUid)))
                    return "emailUid: buffer expected";
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                if (!(message.passwordUid && typeof message.passwordUid.length === "number" || $util.isString(message.passwordUid)))
                    return "passwordUid: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         */
        BreachWatchToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchToken)
                return object;
            let message = new $root.Tokens.BreachWatchToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.domainUid != null)
                if (typeof object.domainUid === "string")
                    $util.base64.decode(object.domainUid, message.domainUid = $util.newBuffer($util.base64.length(object.domainUid)), 0);
                else if (object.domainUid.length)
                    message.domainUid = object.domainUid;
            if (object.emailUid != null)
                if (typeof object.emailUid === "string")
                    $util.base64.decode(object.emailUid, message.emailUid = $util.newBuffer($util.base64.length(object.emailUid)), 0);
                else if (object.emailUid.length)
                    message.emailUid = object.emailUid;
            if (object.passwordUid != null)
                if (typeof object.passwordUid === "string")
                    $util.base64.decode(object.passwordUid, message.passwordUid = $util.newBuffer($util.base64.length(object.passwordUid)), 0);
                else if (object.passwordUid.length)
                    message.passwordUid = object.passwordUid;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.BreachWatchToken} message BreachWatchToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                if (options.bytes === String)
                    object.domainUid = "";
                else {
                    object.domainUid = [];
                    if (options.bytes !== Array)
                        object.domainUid = $util.newBuffer(object.domainUid);
                }
                if (options.bytes === String)
                    object.emailUid = "";
                else {
                    object.emailUid = [];
                    if (options.bytes !== Array)
                        object.emailUid = $util.newBuffer(object.emailUid);
                }
                if (options.bytes === String)
                    object.passwordUid = "";
                else {
                    object.passwordUid = [];
                    if (options.bytes !== Array)
                        object.passwordUid = $util.newBuffer(object.passwordUid);
                }
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                object.domainUid = options.bytes === String ? $util.base64.encode(message.domainUid, 0, message.domainUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.domainUid) : message.domainUid;
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                object.emailUid = options.bytes === String ? $util.base64.encode(message.emailUid, 0, message.emailUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.emailUid) : message.emailUid;
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                object.passwordUid = options.bytes === String ? $util.base64.encode(message.passwordUid, 0, message.passwordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.passwordUid) : message.passwordUid;
            return object;
        };

        /**
         * Converts this BreachWatchToken to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchToken;
    })();

    /**
     * AnonymizedTokenType enum.
     * @name Tokens.AnonymizedTokenType
     * @enum {string}
     * @property {number} DAT=0 DAT value
     * @property {number} EAT=1 EAT value
     * @property {number} PAT=2 PAT value
     */
    Tokens.AnonymizedTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DAT"] = 0;
        values[valuesById[1] = "EAT"] = 1;
        values[valuesById[2] = "PAT"] = 2;
        return values;
    })();

    Tokens.AnonymizedToken = (function() {

        /**
         * Properties of an AnonymizedToken.
         * @memberof Tokens
         * @interface IAnonymizedToken
         * @property {number|Long|null} [created] AnonymizedToken created
         * @property {number|Long|null} [expiration] AnonymizedToken expiration
         * @property {Uint8Array|null} [uid] AnonymizedToken uid
         * @property {Tokens.AnonymizedTokenType|null} [anonymizedTokenType] AnonymizedToken anonymizedTokenType
         */

        /**
         * Constructs a new AnonymizedToken.
         * @memberof Tokens
         * @classdesc Represents an AnonymizedToken.
         * @implements IAnonymizedToken
         * @constructor
         * @param {Tokens.IAnonymizedToken=} [properties] Properties to set
         */
        function AnonymizedToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnonymizedToken created.
         * @member {number|Long} created
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnonymizedToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnonymizedToken uid.
         * @member {Uint8Array} uid
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.uid = $util.newBuffer([]);

        /**
         * AnonymizedToken anonymizedTokenType.
         * @member {Tokens.AnonymizedTokenType} anonymizedTokenType
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.anonymizedTokenType = 0;

        /**
         * Creates a new AnonymizedToken instance using the specified properties.
         * @function create
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken=} [properties] Properties to set
         * @returns {Tokens.AnonymizedToken} AnonymizedToken instance
         */
        AnonymizedToken.create = function create(properties) {
            return new AnonymizedToken(properties);
        };

        /**
         * Encodes the specified AnonymizedToken message. Does not implicitly {@link Tokens.AnonymizedToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken} message AnonymizedToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.uid);
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.anonymizedTokenType);
            return writer;
        };

        /**
         * Encodes the specified AnonymizedToken message, length delimited. Does not implicitly {@link Tokens.AnonymizedToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken} message AnonymizedToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnonymizedToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.AnonymizedToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.uid = reader.bytes();
                    break;
                case 4:
                    message.anonymizedTokenType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnonymizedToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnonymizedToken message.
         * @function verify
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnonymizedToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                switch (message.anonymizedTokenType) {
                default:
                    return "anonymizedTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an AnonymizedToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         */
        AnonymizedToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.AnonymizedToken)
                return object;
            let message = new $root.Tokens.AnonymizedToken();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            switch (object.anonymizedTokenType) {
            case "DAT":
            case 0:
                message.anonymizedTokenType = 0;
                break;
            case "EAT":
            case 1:
                message.anonymizedTokenType = 1;
                break;
            case "PAT":
            case 2:
                message.anonymizedTokenType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AnonymizedToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.AnonymizedToken} message AnonymizedToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnonymizedToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.anonymizedTokenType = options.enums === String ? "DAT" : 0;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                object.anonymizedTokenType = options.enums === String ? $root.Tokens.AnonymizedTokenType[message.anonymizedTokenType] : message.anonymizedTokenType;
            return object;
        };

        /**
         * Converts this AnonymizedToken to JSON.
         * @function toJSON
         * @memberof Tokens.AnonymizedToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnonymizedToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnonymizedToken;
    })();

    Tokens.LicenseToken = (function() {

        /**
         * Properties of a LicenseToken.
         * @memberof Tokens
         * @interface ILicenseToken
         * @property {number|Long|null} [expiration] LicenseToken expiration
         * @property {Authentication.LicenseStatus|null} [licenseStatus] LicenseToken licenseStatus
         */

        /**
         * Constructs a new LicenseToken.
         * @memberof Tokens
         * @classdesc Represents a LicenseToken.
         * @implements ILicenseToken
         * @constructor
         * @param {Tokens.ILicenseToken=} [properties] Properties to set
         */
        function LicenseToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LicenseToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.LicenseToken
         * @instance
         */
        LicenseToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LicenseToken licenseStatus.
         * @member {Authentication.LicenseStatus} licenseStatus
         * @memberof Tokens.LicenseToken
         * @instance
         */
        LicenseToken.prototype.licenseStatus = 0;

        /**
         * Creates a new LicenseToken instance using the specified properties.
         * @function create
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken=} [properties] Properties to set
         * @returns {Tokens.LicenseToken} LicenseToken instance
         */
        LicenseToken.create = function create(properties) {
            return new LicenseToken(properties);
        };

        /**
         * Encodes the specified LicenseToken message. Does not implicitly {@link Tokens.LicenseToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken} message LicenseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LicenseToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.licenseStatus);
            return writer;
        };

        /**
         * Encodes the specified LicenseToken message, length delimited. Does not implicitly {@link Tokens.LicenseToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken} message LicenseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LicenseToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LicenseToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.LicenseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.LicenseToken} LicenseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LicenseToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.LicenseToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.licenseStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LicenseToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.LicenseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.LicenseToken} LicenseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LicenseToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LicenseToken message.
         * @function verify
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LicenseToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                switch (message.licenseStatus) {
                default:
                    return "licenseStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a LicenseToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.LicenseToken} LicenseToken
         */
        LicenseToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.LicenseToken)
                return object;
            let message = new $root.Tokens.LicenseToken();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            switch (object.licenseStatus) {
            case "OTHER":
            case 0:
                message.licenseStatus = 0;
                break;
            case "ACTIVE":
            case 1:
                message.licenseStatus = 1;
                break;
            case "EXPIRED":
            case 2:
                message.licenseStatus = 2;
                break;
            case "DISABLED":
            case 3:
                message.licenseStatus = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LicenseToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.LicenseToken} message LicenseToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LicenseToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.licenseStatus = options.enums === String ? "OTHER" : 0;
            }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                object.licenseStatus = options.enums === String ? $root.Authentication.LicenseStatus[message.licenseStatus] : message.licenseStatus;
            return object;
        };

        /**
         * Converts this LicenseToken to JSON.
         * @function toJSON
         * @memberof Tokens.LicenseToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LicenseToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LicenseToken;
    })();

    /**
     * AccessType enum.
     * @name Tokens.AccessType
     * @enum {string}
     * @property {number} VAULT_RW=0 VAULT_RW value
     * @property {number} VAULT_RO=1 VAULT_RO value
     * @property {number} ADMIN=2 ADMIN value
     */
    Tokens.AccessType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VAULT_RW"] = 0;
        values[valuesById[1] = "VAULT_RO"] = 1;
        values[valuesById[2] = "ADMIN"] = 2;
        return values;
    })();

    Tokens.SessionToken = (function() {

        /**
         * Properties of a SessionToken.
         * @memberof Tokens
         * @interface ISessionToken
         * @property {number|Long|null} [created] SessionToken created
         * @property {number|Long|null} [expiration] SessionToken expiration
         * @property {string|null} [ip] SessionToken ip
         * @property {Uint8Array|null} [sessionUid] SessionToken sessionUid
         * @property {Tokens.IDeviceToken|null} [deviceToken] SessionToken deviceToken
         * @property {number|null} [fromUserId] SessionToken fromUserId
         * @property {number|null} [forUserId] SessionToken forUserId
         * @property {number|Long|null} [enterpriseUserId] SessionToken enterpriseUserId
         * @property {Tokens.ILicenseToken|null} [vault] SessionToken vault
         * @property {Tokens.ILicenseToken|null} [chat] SessionToken chat
         * @property {Tokens.ILicenseToken|null} [storage] SessionToken storage
         * @property {Tokens.ILicenseToken|null} [breachWatch] SessionToken breachWatch
         * @property {Authentication.AccountType|null} [accountType] SessionToken accountType
         * @property {number|null} [clientVersionId] SessionToken clientVersionId
         * @property {Authentication.SessionTokenType|null} [sessionTokenType] SessionToken sessionTokenType
         * @property {number|null} [mcEnterpriseId] SessionToken mcEnterpriseId
         * @property {boolean|null} [offlineDisallowed] SessionToken offlineDisallowed
         */

        /**
         * Constructs a new SessionToken.
         * @memberof Tokens
         * @classdesc Represents a SessionToken.
         * @implements ISessionToken
         * @constructor
         * @param {Tokens.ISessionToken=} [properties] Properties to set
         */
        function SessionToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionToken created.
         * @member {number|Long} created
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken ip.
         * @member {string} ip
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.ip = "";

        /**
         * SessionToken sessionUid.
         * @member {Uint8Array} sessionUid
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.sessionUid = $util.newBuffer([]);

        /**
         * SessionToken deviceToken.
         * @member {Tokens.IDeviceToken|null|undefined} deviceToken
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.deviceToken = null;

        /**
         * SessionToken fromUserId.
         * @member {number} fromUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.fromUserId = 0;

        /**
         * SessionToken forUserId.
         * @member {number} forUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.forUserId = 0;

        /**
         * SessionToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken vault.
         * @member {Tokens.ILicenseToken|null|undefined} vault
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.vault = null;

        /**
         * SessionToken chat.
         * @member {Tokens.ILicenseToken|null|undefined} chat
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.chat = null;

        /**
         * SessionToken storage.
         * @member {Tokens.ILicenseToken|null|undefined} storage
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.storage = null;

        /**
         * SessionToken breachWatch.
         * @member {Tokens.ILicenseToken|null|undefined} breachWatch
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.breachWatch = null;

        /**
         * SessionToken accountType.
         * @member {Authentication.AccountType} accountType
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.accountType = 0;

        /**
         * SessionToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.clientVersionId = 0;

        /**
         * SessionToken sessionTokenType.
         * @member {Authentication.SessionTokenType} sessionTokenType
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.sessionTokenType = 0;

        /**
         * SessionToken mcEnterpriseId.
         * @member {number} mcEnterpriseId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.mcEnterpriseId = 0;

        /**
         * SessionToken offlineDisallowed.
         * @member {boolean} offlineDisallowed
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.offlineDisallowed = false;

        /**
         * Creates a new SessionToken instance using the specified properties.
         * @function create
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken=} [properties] Properties to set
         * @returns {Tokens.SessionToken} SessionToken instance
         */
        SessionToken.create = function create(properties) {
            return new SessionToken(properties);
        };

        /**
         * Encodes the specified SessionToken message. Does not implicitly {@link Tokens.SessionToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.ip != null && message.hasOwnProperty("ip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ip);
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sessionUid);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.Tokens.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fromUserId);
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.forUserId);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enterpriseUserId);
            if (message.vault != null && message.hasOwnProperty("vault"))
                $root.Tokens.LicenseToken.encode(message.vault, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.chat != null && message.hasOwnProperty("chat"))
                $root.Tokens.LicenseToken.encode(message.chat, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.storage != null && message.hasOwnProperty("storage"))
                $root.Tokens.LicenseToken.encode(message.storage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.accountType);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.clientVersionId);
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.sessionTokenType);
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch"))
                $root.Tokens.LicenseToken.encode(message.breachWatch, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.mcEnterpriseId);
            if (message.offlineDisallowed != null && message.hasOwnProperty("offlineDisallowed"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.offlineDisallowed);
            return writer;
        };

        /**
         * Encodes the specified SessionToken message, length delimited. Does not implicitly {@link Tokens.SessionToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.SessionToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.ip = reader.string();
                    break;
                case 4:
                    message.sessionUid = reader.bytes();
                    break;
                case 5:
                    message.deviceToken = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.fromUserId = reader.int32();
                    break;
                case 7:
                    message.forUserId = reader.int32();
                    break;
                case 8:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 9:
                    message.vault = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.chat = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.storage = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.breachWatch = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.accountType = reader.int32();
                    break;
                case 13:
                    message.clientVersionId = reader.int32();
                    break;
                case 14:
                    message.sessionTokenType = reader.int32();
                    break;
                case 16:
                    message.mcEnterpriseId = reader.int32();
                    break;
                case 17:
                    message.offlineDisallowed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionToken message.
         * @function verify
         * @memberof Tokens.SessionToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                if (!(message.sessionUid && typeof message.sessionUid.length === "number" || $util.isString(message.sessionUid)))
                    return "sessionUid: buffer expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.Tokens.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                if (!$util.isInteger(message.fromUserId))
                    return "fromUserId: integer expected";
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                if (!$util.isInteger(message.forUserId))
                    return "forUserId: integer expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.vault != null && message.hasOwnProperty("vault")) {
                let error = $root.Tokens.LicenseToken.verify(message.vault);
                if (error)
                    return "vault." + error;
            }
            if (message.chat != null && message.hasOwnProperty("chat")) {
                let error = $root.Tokens.LicenseToken.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            if (message.storage != null && message.hasOwnProperty("storage")) {
                let error = $root.Tokens.LicenseToken.verify(message.storage);
                if (error)
                    return "storage." + error;
            }
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch")) {
                let error = $root.Tokens.LicenseToken.verify(message.breachWatch);
                if (error)
                    return "breachWatch." + error;
            }
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                switch (message.accountType) {
                default:
                    return "accountType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                switch (message.sessionTokenType) {
                default:
                    return "sessionTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                if (!$util.isInteger(message.mcEnterpriseId))
                    return "mcEnterpriseId: integer expected";
            if (message.offlineDisallowed != null && message.hasOwnProperty("offlineDisallowed"))
                if (typeof message.offlineDisallowed !== "boolean")
                    return "offlineDisallowed: boolean expected";
            return null;
        };

        /**
         * Creates a SessionToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.SessionToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.SessionToken} SessionToken
         */
        SessionToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.SessionToken)
                return object;
            let message = new $root.Tokens.SessionToken();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.ip != null)
                message.ip = String(object.ip);
            if (object.sessionUid != null)
                if (typeof object.sessionUid === "string")
                    $util.base64.decode(object.sessionUid, message.sessionUid = $util.newBuffer($util.base64.length(object.sessionUid)), 0);
                else if (object.sessionUid.length)
                    message.sessionUid = object.sessionUid;
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".Tokens.SessionToken.deviceToken: object expected");
                message.deviceToken = $root.Tokens.DeviceToken.fromObject(object.deviceToken);
            }
            if (object.fromUserId != null)
                message.fromUserId = object.fromUserId | 0;
            if (object.forUserId != null)
                message.forUserId = object.forUserId | 0;
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.vault != null) {
                if (typeof object.vault !== "object")
                    throw TypeError(".Tokens.SessionToken.vault: object expected");
                message.vault = $root.Tokens.LicenseToken.fromObject(object.vault);
            }
            if (object.chat != null) {
                if (typeof object.chat !== "object")
                    throw TypeError(".Tokens.SessionToken.chat: object expected");
                message.chat = $root.Tokens.LicenseToken.fromObject(object.chat);
            }
            if (object.storage != null) {
                if (typeof object.storage !== "object")
                    throw TypeError(".Tokens.SessionToken.storage: object expected");
                message.storage = $root.Tokens.LicenseToken.fromObject(object.storage);
            }
            if (object.breachWatch != null) {
                if (typeof object.breachWatch !== "object")
                    throw TypeError(".Tokens.SessionToken.breachWatch: object expected");
                message.breachWatch = $root.Tokens.LicenseToken.fromObject(object.breachWatch);
            }
            switch (object.accountType) {
            case "CONSUMER":
            case 0:
                message.accountType = 0;
                break;
            case "FAMILY":
            case 1:
                message.accountType = 1;
                break;
            case "ENTERPRISE":
            case 2:
                message.accountType = 2;
                break;
            }
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            switch (object.sessionTokenType) {
            case "NO_RESTRICTION":
            case 0:
                message.sessionTokenType = 0;
                break;
            case "ACCOUNT_RECOVERY":
            case 1:
                message.sessionTokenType = 1;
                break;
            case "SHARE_ACCOUNT":
            case 2:
                message.sessionTokenType = 2;
                break;
            case "PURCHASE":
            case 3:
                message.sessionTokenType = 3;
                break;
            case "RESTRICT":
            case 4:
                message.sessionTokenType = 4;
                break;
            case "ACCEPT_INVITE":
            case 5:
                message.sessionTokenType = 5;
                break;
            }
            if (object.mcEnterpriseId != null)
                message.mcEnterpriseId = object.mcEnterpriseId | 0;
            if (object.offlineDisallowed != null)
                message.offlineDisallowed = Boolean(object.offlineDisallowed);
            return message;
        };

        /**
         * Creates a plain object from a SessionToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.SessionToken} message SessionToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.ip = "";
                if (options.bytes === String)
                    object.sessionUid = "";
                else {
                    object.sessionUid = [];
                    if (options.bytes !== Array)
                        object.sessionUid = $util.newBuffer(object.sessionUid);
                }
                object.deviceToken = null;
                object.fromUserId = 0;
                object.forUserId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.vault = null;
                object.chat = null;
                object.storage = null;
                object.accountType = options.enums === String ? "CONSUMER" : 0;
                object.clientVersionId = 0;
                object.sessionTokenType = options.enums === String ? "NO_RESTRICTION" : 0;
                object.breachWatch = null;
                object.mcEnterpriseId = 0;
                object.offlineDisallowed = false;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.ip != null && message.hasOwnProperty("ip"))
                object.ip = message.ip;
            if (message.sessionUid != null && message.hasOwnProperty("sessionUid"))
                object.sessionUid = options.bytes === String ? $util.base64.encode(message.sessionUid, 0, message.sessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.sessionUid) : message.sessionUid;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.Tokens.DeviceToken.toObject(message.deviceToken, options);
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                object.fromUserId = message.fromUserId;
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                object.forUserId = message.forUserId;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.vault != null && message.hasOwnProperty("vault"))
                object.vault = $root.Tokens.LicenseToken.toObject(message.vault, options);
            if (message.chat != null && message.hasOwnProperty("chat"))
                object.chat = $root.Tokens.LicenseToken.toObject(message.chat, options);
            if (message.storage != null && message.hasOwnProperty("storage"))
                object.storage = $root.Tokens.LicenseToken.toObject(message.storage, options);
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                object.accountType = options.enums === String ? $root.Authentication.AccountType[message.accountType] : message.accountType;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                object.sessionTokenType = options.enums === String ? $root.Authentication.SessionTokenType[message.sessionTokenType] : message.sessionTokenType;
            if (message.breachWatch != null && message.hasOwnProperty("breachWatch"))
                object.breachWatch = $root.Tokens.LicenseToken.toObject(message.breachWatch, options);
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                object.mcEnterpriseId = message.mcEnterpriseId;
            if (message.offlineDisallowed != null && message.hasOwnProperty("offlineDisallowed"))
                object.offlineDisallowed = message.offlineDisallowed;
            return object;
        };

        /**
         * Converts this SessionToken to JSON.
         * @function toJSON
         * @memberof Tokens.SessionToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionToken;
    })();

    Tokens.CheckOutTokenResponse = (function() {

        /**
         * Properties of a CheckOutTokenResponse.
         * @memberof Tokens
         * @interface ICheckOutTokenResponse
         * @property {string|null} [checkOutToken] CheckOutTokenResponse checkOutToken
         */

        /**
         * Constructs a new CheckOutTokenResponse.
         * @memberof Tokens
         * @classdesc Represents a CheckOutTokenResponse.
         * @implements ICheckOutTokenResponse
         * @constructor
         * @param {Tokens.ICheckOutTokenResponse=} [properties] Properties to set
         */
        function CheckOutTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckOutTokenResponse checkOutToken.
         * @member {string} checkOutToken
         * @memberof Tokens.CheckOutTokenResponse
         * @instance
         */
        CheckOutTokenResponse.prototype.checkOutToken = "";

        /**
         * Creates a new CheckOutTokenResponse instance using the specified properties.
         * @function create
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse=} [properties] Properties to set
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse instance
         */
        CheckOutTokenResponse.create = function create(properties) {
            return new CheckOutTokenResponse(properties);
        };

        /**
         * Encodes the specified CheckOutTokenResponse message. Does not implicitly {@link Tokens.CheckOutTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse} message CheckOutTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckOutTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.checkOutToken);
            return writer;
        };

        /**
         * Encodes the specified CheckOutTokenResponse message, length delimited. Does not implicitly {@link Tokens.CheckOutTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse} message CheckOutTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckOutTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckOutTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckOutTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.CheckOutTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.checkOutToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckOutTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckOutTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckOutTokenResponse message.
         * @function verify
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckOutTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                if (!$util.isString(message.checkOutToken))
                    return "checkOutToken: string expected";
            return null;
        };

        /**
         * Creates a CheckOutTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         */
        CheckOutTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.CheckOutTokenResponse)
                return object;
            let message = new $root.Tokens.CheckOutTokenResponse();
            if (object.checkOutToken != null)
                message.checkOutToken = String(object.checkOutToken);
            return message;
        };

        /**
         * Creates a plain object from a CheckOutTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.CheckOutTokenResponse} message CheckOutTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckOutTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.checkOutToken = "";
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                object.checkOutToken = message.checkOutToken;
            return object;
        };

        /**
         * Converts this CheckOutTokenResponse to JSON.
         * @function toJSON
         * @memberof Tokens.CheckOutTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckOutTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CheckOutTokenResponse;
    })();

    Tokens.ImporterToken = (function() {

        /**
         * Properties of an ImporterToken.
         * @memberof Tokens
         * @interface IImporterToken
         * @property {number|null} [importId] ImporterToken importId
         * @property {number|null} [userId] ImporterToken userId
         * @property {string|null} [region] ImporterToken region
         */

        /**
         * Constructs a new ImporterToken.
         * @memberof Tokens
         * @classdesc Represents an ImporterToken.
         * @implements IImporterToken
         * @constructor
         * @param {Tokens.IImporterToken=} [properties] Properties to set
         */
        function ImporterToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImporterToken importId.
         * @member {number} importId
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.importId = 0;

        /**
         * ImporterToken userId.
         * @member {number} userId
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.userId = 0;

        /**
         * ImporterToken region.
         * @member {string} region
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.region = "";

        /**
         * Creates a new ImporterToken instance using the specified properties.
         * @function create
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken=} [properties] Properties to set
         * @returns {Tokens.ImporterToken} ImporterToken instance
         */
        ImporterToken.create = function create(properties) {
            return new ImporterToken(properties);
        };

        /**
         * Encodes the specified ImporterToken message. Does not implicitly {@link Tokens.ImporterToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken} message ImporterToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImporterToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.importId != null && message.hasOwnProperty("importId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.importId);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            if (message.region != null && message.hasOwnProperty("region"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.region);
            return writer;
        };

        /**
         * Encodes the specified ImporterToken message, length delimited. Does not implicitly {@link Tokens.ImporterToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken} message ImporterToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImporterToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImporterToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ImporterToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ImporterToken} ImporterToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImporterToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ImporterToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.importId = reader.int32();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                case 3:
                    message.region = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImporterToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ImporterToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ImporterToken} ImporterToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImporterToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImporterToken message.
         * @function verify
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImporterToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.importId != null && message.hasOwnProperty("importId"))
                if (!$util.isInteger(message.importId))
                    return "importId: integer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isString(message.region))
                    return "region: string expected";
            return null;
        };

        /**
         * Creates an ImporterToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ImporterToken} ImporterToken
         */
        ImporterToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ImporterToken)
                return object;
            let message = new $root.Tokens.ImporterToken();
            if (object.importId != null)
                message.importId = object.importId | 0;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.region != null)
                message.region = String(object.region);
            return message;
        };

        /**
         * Creates a plain object from an ImporterToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.ImporterToken} message ImporterToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImporterToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.importId = 0;
                object.userId = 0;
                object.region = "";
            }
            if (message.importId != null && message.hasOwnProperty("importId"))
                object.importId = message.importId;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            return object;
        };

        /**
         * Converts this ImporterToken to JSON.
         * @function toJSON
         * @memberof Tokens.ImporterToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImporterToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImporterToken;
    })();

    Tokens.ApiDecryptedRequest = (function() {

        /**
         * Properties of an ApiDecryptedRequest.
         * @memberof Tokens
         * @interface IApiDecryptedRequest
         * @property {Uint8Array|null} [decryptedTransmissionKey] ApiDecryptedRequest decryptedTransmissionKey
         * @property {Authentication.IApiRequestPayload|null} [apiRequestPayload] ApiDecryptedRequest apiRequestPayload
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] ApiDecryptedRequest supportedLanguage
         * @property {string|null} [recaptcha] ApiDecryptedRequest recaptcha
         * @property {string|null} [userAgent] ApiDecryptedRequest userAgent
         */

        /**
         * Constructs a new ApiDecryptedRequest.
         * @memberof Tokens
         * @classdesc Represents an ApiDecryptedRequest.
         * @implements IApiDecryptedRequest
         * @constructor
         * @param {Tokens.IApiDecryptedRequest=} [properties] Properties to set
         */
        function ApiDecryptedRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiDecryptedRequest decryptedTransmissionKey.
         * @member {Uint8Array} decryptedTransmissionKey
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.decryptedTransmissionKey = $util.newBuffer([]);

        /**
         * ApiDecryptedRequest apiRequestPayload.
         * @member {Authentication.IApiRequestPayload|null|undefined} apiRequestPayload
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.apiRequestPayload = null;

        /**
         * ApiDecryptedRequest supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.supportedLanguage = 0;

        /**
         * ApiDecryptedRequest recaptcha.
         * @member {string} recaptcha
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.recaptcha = "";

        /**
         * ApiDecryptedRequest userAgent.
         * @member {string} userAgent
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.userAgent = "";

        /**
         * Creates a new ApiDecryptedRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest=} [properties] Properties to set
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest instance
         */
        ApiDecryptedRequest.create = function create(properties) {
            return new ApiDecryptedRequest(properties);
        };

        /**
         * Encodes the specified ApiDecryptedRequest message. Does not implicitly {@link Tokens.ApiDecryptedRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest} message ApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiDecryptedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.decryptedTransmissionKey);
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload"))
                $root.Authentication.ApiRequestPayload.encode(message.apiRequestPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.recaptcha);
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.userAgent);
            return writer;
        };

        /**
         * Encodes the specified ApiDecryptedRequest message, length delimited. Does not implicitly {@link Tokens.ApiDecryptedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest} message ApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiDecryptedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiDecryptedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiDecryptedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ApiDecryptedRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.decryptedTransmissionKey = reader.bytes();
                    break;
                case 3:
                    message.apiRequestPayload = $root.Authentication.ApiRequestPayload.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                case 5:
                    message.recaptcha = reader.string();
                    break;
                case 6:
                    message.userAgent = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiDecryptedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiDecryptedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiDecryptedRequest message.
         * @function verify
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiDecryptedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                if (!(message.decryptedTransmissionKey && typeof message.decryptedTransmissionKey.length === "number" || $util.isString(message.decryptedTransmissionKey)))
                    return "decryptedTransmissionKey: buffer expected";
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload")) {
                let error = $root.Authentication.ApiRequestPayload.verify(message.apiRequestPayload);
                if (error)
                    return "apiRequestPayload." + error;
            }
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                if (!$util.isString(message.recaptcha))
                    return "recaptcha: string expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            return null;
        };

        /**
         * Creates an ApiDecryptedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         */
        ApiDecryptedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ApiDecryptedRequest)
                return object;
            let message = new $root.Tokens.ApiDecryptedRequest();
            if (object.decryptedTransmissionKey != null)
                if (typeof object.decryptedTransmissionKey === "string")
                    $util.base64.decode(object.decryptedTransmissionKey, message.decryptedTransmissionKey = $util.newBuffer($util.base64.length(object.decryptedTransmissionKey)), 0);
                else if (object.decryptedTransmissionKey.length)
                    message.decryptedTransmissionKey = object.decryptedTransmissionKey;
            if (object.apiRequestPayload != null) {
                if (typeof object.apiRequestPayload !== "object")
                    throw TypeError(".Tokens.ApiDecryptedRequest.apiRequestPayload: object expected");
                message.apiRequestPayload = $root.Authentication.ApiRequestPayload.fromObject(object.apiRequestPayload);
            }
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.recaptcha != null)
                message.recaptcha = String(object.recaptcha);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            return message;
        };

        /**
         * Creates a plain object from an ApiDecryptedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.ApiDecryptedRequest} message ApiDecryptedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiDecryptedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.decryptedTransmissionKey = "";
                else {
                    object.decryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.decryptedTransmissionKey = $util.newBuffer(object.decryptedTransmissionKey);
                }
                object.apiRequestPayload = null;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.recaptcha = "";
                object.userAgent = "";
            }
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                object.decryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.decryptedTransmissionKey, 0, message.decryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.decryptedTransmissionKey) : message.decryptedTransmissionKey;
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload"))
                object.apiRequestPayload = $root.Authentication.ApiRequestPayload.toObject(message.apiRequestPayload, options);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                object.recaptcha = message.recaptcha;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            return object;
        };

        /**
         * Converts this ApiDecryptedRequest to JSON.
         * @function toJSON
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiDecryptedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiDecryptedRequest;
    })();

    Tokens.ChangeEmailToken = (function() {

        /**
         * Properties of a ChangeEmailToken.
         * @memberof Tokens
         * @interface IChangeEmailToken
         * @property {number|null} [userId] ChangeEmailToken userId
         * @property {string|null} [newEmail] ChangeEmailToken newEmail
         * @property {string|null} [locale] ChangeEmailToken locale
         * @property {number|Long|null} [enterpriseUserId] ChangeEmailToken enterpriseUserId
         * @property {number|Long|null} [expiration] ChangeEmailToken expiration
         */

        /**
         * Constructs a new ChangeEmailToken.
         * @memberof Tokens
         * @classdesc Represents a ChangeEmailToken.
         * @implements IChangeEmailToken
         * @constructor
         * @param {Tokens.IChangeEmailToken=} [properties] Properties to set
         */
        function ChangeEmailToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailToken userId.
         * @member {number} userId
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.userId = 0;

        /**
         * ChangeEmailToken newEmail.
         * @member {string} newEmail
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.newEmail = "";

        /**
         * ChangeEmailToken locale.
         * @member {string} locale
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.locale = "";

        /**
         * ChangeEmailToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChangeEmailToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChangeEmailToken instance using the specified properties.
         * @function create
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken=} [properties] Properties to set
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken instance
         */
        ChangeEmailToken.create = function create(properties) {
            return new ChangeEmailToken(properties);
        };

        /**
         * Encodes the specified ChangeEmailToken message. Does not implicitly {@link Tokens.ChangeEmailToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken} message ChangeEmailToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newEmail);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.enterpriseUserId);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiration);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailToken message, length delimited. Does not implicitly {@link Tokens.ChangeEmailToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken} message ChangeEmailToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ChangeEmailToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.newEmail = reader.string();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 5:
                    message.expiration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailToken message.
         * @function verify
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                if (!$util.isString(message.newEmail))
                    return "newEmail: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChangeEmailToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         */
        ChangeEmailToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ChangeEmailToken)
                return object;
            let message = new $root.Tokens.ChangeEmailToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.newEmail != null)
                message.newEmail = String(object.newEmail);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.ChangeEmailToken} message ChangeEmailToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.newEmail = "";
                object.locale = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                object.newEmail = message.newEmail;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            return object;
        };

        /**
         * Converts this ChangeEmailToken to JSON.
         * @function toJSON
         * @memberof Tokens.ChangeEmailToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailToken;
    })();

    Tokens.EmailVerificationToken = (function() {

        /**
         * Properties of an EmailVerificationToken.
         * @memberof Tokens
         * @interface IEmailVerificationToken
         * @property {number|null} [userId] EmailVerificationToken userId
         * @property {string|null} [email] EmailVerificationToken email
         * @property {string|null} [locale] EmailVerificationToken locale
         * @property {number|Long|null} [enterpriseUserId] EmailVerificationToken enterpriseUserId
         * @property {number|Long|null} [expiration] EmailVerificationToken expiration
         */

        /**
         * Constructs a new EmailVerificationToken.
         * @memberof Tokens
         * @classdesc Represents an EmailVerificationToken.
         * @implements IEmailVerificationToken
         * @constructor
         * @param {Tokens.IEmailVerificationToken=} [properties] Properties to set
         */
        function EmailVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmailVerificationToken userId.
         * @member {number} userId
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.userId = 0;

        /**
         * EmailVerificationToken email.
         * @member {string} email
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.email = "";

        /**
         * EmailVerificationToken locale.
         * @member {string} locale
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.locale = "";

        /**
         * EmailVerificationToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EmailVerificationToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EmailVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken=} [properties] Properties to set
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken instance
         */
        EmailVerificationToken.create = function create(properties) {
            return new EmailVerificationToken(properties);
        };

        /**
         * Encodes the specified EmailVerificationToken message. Does not implicitly {@link Tokens.EmailVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken} message EmailVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.enterpriseUserId);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiration);
            return writer;
        };

        /**
         * Encodes the specified EmailVerificationToken message, length delimited. Does not implicitly {@link Tokens.EmailVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken} message EmailVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmailVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.EmailVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 5:
                    message.expiration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmailVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmailVerificationToken message.
         * @function verify
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmailVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            return null;
        };

        /**
         * Creates an EmailVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         */
        EmailVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.EmailVerificationToken)
                return object;
            let message = new $root.Tokens.EmailVerificationToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.email != null)
                message.email = String(object.email);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EmailVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.EmailVerificationToken} message EmailVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmailVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.email = "";
                object.locale = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            return object;
        };

        /**
         * Converts this EmailVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.EmailVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmailVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmailVerificationToken;
    })();

    Tokens.IpAddressVerificationToken = (function() {

        /**
         * Properties of an IpAddressVerificationToken.
         * @memberof Tokens
         * @interface IIpAddressVerificationToken
         * @property {number|null} [userId] IpAddressVerificationToken userId
         * @property {string|null} [email] IpAddressVerificationToken email
         * @property {number|Long|null} [ssoServiceProviderId] IpAddressVerificationToken ssoServiceProviderId
         * @property {string|null} [ipAddress] IpAddressVerificationToken ipAddress
         * @property {string|null} [locale] IpAddressVerificationToken locale
         * @property {number|Long|null} [expiration] IpAddressVerificationToken expiration
         */

        /**
         * Constructs a new IpAddressVerificationToken.
         * @memberof Tokens
         * @classdesc Represents an IpAddressVerificationToken.
         * @implements IIpAddressVerificationToken
         * @constructor
         * @param {Tokens.IIpAddressVerificationToken=} [properties] Properties to set
         */
        function IpAddressVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IpAddressVerificationToken userId.
         * @member {number} userId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.userId = 0;

        /**
         * IpAddressVerificationToken email.
         * @member {string} email
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.email = "";

        /**
         * IpAddressVerificationToken ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpAddressVerificationToken ipAddress.
         * @member {string} ipAddress
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.ipAddress = "";

        /**
         * IpAddressVerificationToken locale.
         * @member {string} locale
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.locale = "";

        /**
         * IpAddressVerificationToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IpAddressVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken=} [properties] Properties to set
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken instance
         */
        IpAddressVerificationToken.create = function create(properties) {
            return new IpAddressVerificationToken(properties);
        };

        /**
         * Encodes the specified IpAddressVerificationToken message. Does not implicitly {@link Tokens.IpAddressVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken} message IpAddressVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpAddressVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ssoServiceProviderId);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ipAddress);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.locale);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expiration);
            return writer;
        };

        /**
         * Encodes the specified IpAddressVerificationToken message, length delimited. Does not implicitly {@link Tokens.IpAddressVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken} message IpAddressVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpAddressVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IpAddressVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpAddressVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.IpAddressVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.ssoServiceProviderId = reader.int64();
                    break;
                case 4:
                    message.ipAddress = reader.string();
                    break;
                case 5:
                    message.locale = reader.string();
                    break;
                case 6:
                    message.expiration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IpAddressVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpAddressVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IpAddressVerificationToken message.
         * @function verify
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IpAddressVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            return null;
        };

        /**
         * Creates an IpAddressVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         */
        IpAddressVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.IpAddressVerificationToken)
                return object;
            let message = new $root.Tokens.IpAddressVerificationToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.email != null)
                message.email = String(object.email);
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = false;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber();
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IpAddressVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IpAddressVerificationToken} message IpAddressVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IpAddressVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.email = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                object.ipAddress = "";
                object.locale = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber() : message.ssoServiceProviderId;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            return object;
        };

        /**
         * Converts this IpAddressVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IpAddressVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IpAddressVerificationToken;
    })();

    Tokens.EnterprisePersonalAccountToken = (function() {

        /**
         * Properties of an EnterprisePersonalAccountToken.
         * @memberof Tokens
         * @interface IEnterprisePersonalAccountToken
         * @property {number|Long|null} [enterpriseUserId] EnterprisePersonalAccountToken enterpriseUserId
         * @property {string|null} [email] EnterprisePersonalAccountToken email
         * @property {string|null} [locale] EnterprisePersonalAccountToken locale
         * @property {number|Long|null} [duration] EnterprisePersonalAccountToken duration
         * @property {string|null} [referralName] EnterprisePersonalAccountToken referralName
         * @property {number|Long|null} [expiration] EnterprisePersonalAccountToken expiration
         */

        /**
         * Constructs a new EnterprisePersonalAccountToken.
         * @memberof Tokens
         * @classdesc Represents an EnterprisePersonalAccountToken.
         * @implements IEnterprisePersonalAccountToken
         * @constructor
         * @param {Tokens.IEnterprisePersonalAccountToken=} [properties] Properties to set
         */
        function EnterprisePersonalAccountToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePersonalAccountToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterprisePersonalAccountToken email.
         * @member {string} email
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.email = "";

        /**
         * EnterprisePersonalAccountToken locale.
         * @member {string} locale
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.locale = "";

        /**
         * EnterprisePersonalAccountToken duration.
         * @member {number|Long} duration
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterprisePersonalAccountToken referralName.
         * @member {string} referralName
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.referralName = "";

        /**
         * EnterprisePersonalAccountToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EnterprisePersonalAccountToken instance using the specified properties.
         * @function create
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken=} [properties] Properties to set
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken instance
         */
        EnterprisePersonalAccountToken.create = function create(properties) {
            return new EnterprisePersonalAccountToken(properties);
        };

        /**
         * Encodes the specified EnterprisePersonalAccountToken message. Does not implicitly {@link Tokens.EnterprisePersonalAccountToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken} message EnterprisePersonalAccountToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccountToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.duration);
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.referralName);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expiration);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePersonalAccountToken message, length delimited. Does not implicitly {@link Tokens.EnterprisePersonalAccountToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken} message EnterprisePersonalAccountToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccountToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePersonalAccountToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccountToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.EnterprisePersonalAccountToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.duration = reader.int64();
                    break;
                case 5:
                    message.referralName = reader.string();
                    break;
                case 6:
                    message.expiration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePersonalAccountToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccountToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePersonalAccountToken message.
         * @function verify
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePersonalAccountToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
                    return "duration: integer|Long expected";
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                if (!$util.isString(message.referralName))
                    return "referralName: string expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            return null;
        };

        /**
         * Creates an EnterprisePersonalAccountToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         */
        EnterprisePersonalAccountToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.EnterprisePersonalAccountToken)
                return object;
            let message = new $root.Tokens.EnterprisePersonalAccountToken();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.email != null)
                message.email = String(object.email);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.duration != null)
                if ($util.Long)
                    (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
                else if (typeof object.duration === "string")
                    message.duration = parseInt(object.duration, 10);
                else if (typeof object.duration === "number")
                    message.duration = object.duration;
                else if (typeof object.duration === "object")
                    message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
            if (object.referralName != null)
                message.referralName = String(object.referralName);
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePersonalAccountToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.EnterprisePersonalAccountToken} message EnterprisePersonalAccountToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePersonalAccountToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.email = "";
                object.locale = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.duration = options.longs === String ? "0" : 0;
                object.referralName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration === "number")
                    object.duration = options.longs === String ? String(message.duration) : message.duration;
                else
                    object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                object.referralName = message.referralName;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            return object;
        };

        /**
         * Converts this EnterprisePersonalAccountToken to JSON.
         * @function toJSON
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePersonalAccountToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePersonalAccountToken;
    })();

    return Tokens;
})();

export const Enterprise = $root.Enterprise = (() => {

    /**
     * Namespace Enterprise.
     * @exports Enterprise
     * @namespace
     */
    const Enterprise = {};

    Enterprise.EnterpriseKeyPairRequest = (function() {

        /**
         * Properties of an EnterpriseKeyPairRequest.
         * @memberof Enterprise
         * @interface IEnterpriseKeyPairRequest
         * @property {Uint8Array|null} [enterprisePublicKey] EnterpriseKeyPairRequest enterprisePublicKey
         * @property {Uint8Array|null} [encryptedEnterprisePrivateKey] EnterpriseKeyPairRequest encryptedEnterprisePrivateKey
         */

        /**
         * Constructs a new EnterpriseKeyPairRequest.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseKeyPairRequest.
         * @implements IEnterpriseKeyPairRequest
         * @constructor
         * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
         */
        function EnterpriseKeyPairRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseKeyPairRequest enterprisePublicKey.
         * @member {Uint8Array} enterprisePublicKey
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         */
        EnterpriseKeyPairRequest.prototype.enterprisePublicKey = $util.newBuffer([]);

        /**
         * EnterpriseKeyPairRequest encryptedEnterprisePrivateKey.
         * @member {Uint8Array} encryptedEnterprisePrivateKey
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         */
        EnterpriseKeyPairRequest.prototype.encryptedEnterprisePrivateKey = $util.newBuffer([]);

        /**
         * Creates a new EnterpriseKeyPairRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest instance
         */
        EnterpriseKeyPairRequest.create = function create(properties) {
            return new EnterpriseKeyPairRequest(properties);
        };

        /**
         * Encodes the specified EnterpriseKeyPairRequest message. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseKeyPairRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePublicKey);
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedEnterprisePrivateKey);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseKeyPairRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseKeyPairRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseKeyPairRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseKeyPairRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePublicKey = reader.bytes();
                    break;
                case 2:
                    message.encryptedEnterprisePrivateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseKeyPairRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseKeyPairRequest message.
         * @function verify
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseKeyPairRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                if (!(message.enterprisePublicKey && typeof message.enterprisePublicKey.length === "number" || $util.isString(message.enterprisePublicKey)))
                    return "enterprisePublicKey: buffer expected";
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                if (!(message.encryptedEnterprisePrivateKey && typeof message.encryptedEnterprisePrivateKey.length === "number" || $util.isString(message.encryptedEnterprisePrivateKey)))
                    return "encryptedEnterprisePrivateKey: buffer expected";
            return null;
        };

        /**
         * Creates an EnterpriseKeyPairRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         */
        EnterpriseKeyPairRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseKeyPairRequest)
                return object;
            let message = new $root.Enterprise.EnterpriseKeyPairRequest();
            if (object.enterprisePublicKey != null)
                if (typeof object.enterprisePublicKey === "string")
                    $util.base64.decode(object.enterprisePublicKey, message.enterprisePublicKey = $util.newBuffer($util.base64.length(object.enterprisePublicKey)), 0);
                else if (object.enterprisePublicKey.length)
                    message.enterprisePublicKey = object.enterprisePublicKey;
            if (object.encryptedEnterprisePrivateKey != null)
                if (typeof object.encryptedEnterprisePrivateKey === "string")
                    $util.base64.decode(object.encryptedEnterprisePrivateKey, message.encryptedEnterprisePrivateKey = $util.newBuffer($util.base64.length(object.encryptedEnterprisePrivateKey)), 0);
                else if (object.encryptedEnterprisePrivateKey.length)
                    message.encryptedEnterprisePrivateKey = object.encryptedEnterprisePrivateKey;
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseKeyPairRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.EnterpriseKeyPairRequest} message EnterpriseKeyPairRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseKeyPairRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.enterprisePublicKey = "";
                else {
                    object.enterprisePublicKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePublicKey = $util.newBuffer(object.enterprisePublicKey);
                }
                if (options.bytes === String)
                    object.encryptedEnterprisePrivateKey = "";
                else {
                    object.encryptedEnterprisePrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedEnterprisePrivateKey = $util.newBuffer(object.encryptedEnterprisePrivateKey);
                }
            }
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                object.enterprisePublicKey = options.bytes === String ? $util.base64.encode(message.enterprisePublicKey, 0, message.enterprisePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePublicKey) : message.enterprisePublicKey;
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                object.encryptedEnterprisePrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedEnterprisePrivateKey, 0, message.encryptedEnterprisePrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedEnterprisePrivateKey) : message.encryptedEnterprisePrivateKey;
            return object;
        };

        /**
         * Converts this EnterpriseKeyPairRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseKeyPairRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseKeyPairRequest;
    })();

    Enterprise.GetTeamMemberRequest = (function() {

        /**
         * Properties of a GetTeamMemberRequest.
         * @memberof Enterprise
         * @interface IGetTeamMemberRequest
         * @property {Uint8Array|null} [teamUid] GetTeamMemberRequest teamUid
         */

        /**
         * Constructs a new GetTeamMemberRequest.
         * @memberof Enterprise
         * @classdesc Represents a GetTeamMemberRequest.
         * @implements IGetTeamMemberRequest
         * @constructor
         * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
         */
        function GetTeamMemberRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTeamMemberRequest teamUid.
         * @member {Uint8Array} teamUid
         * @memberof Enterprise.GetTeamMemberRequest
         * @instance
         */
        GetTeamMemberRequest.prototype.teamUid = $util.newBuffer([]);

        /**
         * Creates a new GetTeamMemberRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest instance
         */
        GetTeamMemberRequest.create = function create(properties) {
            return new GetTeamMemberRequest(properties);
        };

        /**
         * Encodes the specified GetTeamMemberRequest message. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teamUid);
            return writer;
        };

        /**
         * Encodes the specified GetTeamMemberRequest message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTeamMemberRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.GetTeamMemberRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTeamMemberRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTeamMemberRequest message.
         * @function verify
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTeamMemberRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                if (!(message.teamUid && typeof message.teamUid.length === "number" || $util.isString(message.teamUid)))
                    return "teamUid: buffer expected";
            return null;
        };

        /**
         * Creates a GetTeamMemberRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         */
        GetTeamMemberRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.GetTeamMemberRequest)
                return object;
            let message = new $root.Enterprise.GetTeamMemberRequest();
            if (object.teamUid != null)
                if (typeof object.teamUid === "string")
                    $util.base64.decode(object.teamUid, message.teamUid = $util.newBuffer($util.base64.length(object.teamUid)), 0);
                else if (object.teamUid.length)
                    message.teamUid = object.teamUid;
            return message;
        };

        /**
         * Creates a plain object from a GetTeamMemberRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.GetTeamMemberRequest} message GetTeamMemberRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTeamMemberRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.teamUid = "";
                else {
                    object.teamUid = [];
                    if (options.bytes !== Array)
                        object.teamUid = $util.newBuffer(object.teamUid);
                }
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                object.teamUid = options.bytes === String ? $util.base64.encode(message.teamUid, 0, message.teamUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.teamUid) : message.teamUid;
            return object;
        };

        /**
         * Converts this GetTeamMemberRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.GetTeamMemberRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTeamMemberRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTeamMemberRequest;
    })();

    Enterprise.EnterpriseUser = (function() {

        /**
         * Properties of an EnterpriseUser.
         * @memberof Enterprise
         * @interface IEnterpriseUser
         * @property {number|Long|null} [enterpriseUserId] EnterpriseUser enterpriseUserId
         * @property {string|null} [email] EnterpriseUser email
         * @property {string|null} [enterpriseUsername] EnterpriseUser enterpriseUsername
         */

        /**
         * Constructs a new EnterpriseUser.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseUser.
         * @implements IEnterpriseUser
         * @constructor
         * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
         */
        function EnterpriseUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUser enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterpriseUser email.
         * @member {string} email
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.email = "";

        /**
         * EnterpriseUser enterpriseUsername.
         * @member {string} enterpriseUsername
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.enterpriseUsername = "";

        /**
         * Creates a new EnterpriseUser instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser instance
         */
        EnterpriseUser.create = function create(properties) {
            return new EnterpriseUser(properties);
        };

        /**
         * Encodes the specified EnterpriseUser message. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.enterpriseUsername);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUser message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUser message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.enterpriseUsername = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUser message.
         * @function verify
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                if (!$util.isString(message.enterpriseUsername))
                    return "enterpriseUsername: string expected";
            return null;
        };

        /**
         * Creates an EnterpriseUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         */
        EnterpriseUser.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseUser)
                return object;
            let message = new $root.Enterprise.EnterpriseUser();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.email != null)
                message.email = String(object.email);
            if (object.enterpriseUsername != null)
                message.enterpriseUsername = String(object.enterpriseUsername);
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.EnterpriseUser} message EnterpriseUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.email = "";
                object.enterpriseUsername = "";
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                object.enterpriseUsername = message.enterpriseUsername;
            return object;
        };

        /**
         * Converts this EnterpriseUser to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUser;
    })();

    Enterprise.GetTeamMemberResponse = (function() {

        /**
         * Properties of a GetTeamMemberResponse.
         * @memberof Enterprise
         * @interface IGetTeamMemberResponse
         * @property {Array.<Enterprise.IEnterpriseUser>|null} [enterpriseUser] GetTeamMemberResponse enterpriseUser
         */

        /**
         * Constructs a new GetTeamMemberResponse.
         * @memberof Enterprise
         * @classdesc Represents a GetTeamMemberResponse.
         * @implements IGetTeamMemberResponse
         * @constructor
         * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
         */
        function GetTeamMemberResponse(properties) {
            this.enterpriseUser = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTeamMemberResponse enterpriseUser.
         * @member {Array.<Enterprise.IEnterpriseUser>} enterpriseUser
         * @memberof Enterprise.GetTeamMemberResponse
         * @instance
         */
        GetTeamMemberResponse.prototype.enterpriseUser = $util.emptyArray;

        /**
         * Creates a new GetTeamMemberResponse instance using the specified properties.
         * @function create
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse instance
         */
        GetTeamMemberResponse.create = function create(properties) {
            return new GetTeamMemberResponse(properties);
        };

        /**
         * Encodes the specified GetTeamMemberResponse message. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUser != null && message.enterpriseUser.length)
                for (let i = 0; i < message.enterpriseUser.length; ++i)
                    $root.Enterprise.EnterpriseUser.encode(message.enterpriseUser[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTeamMemberResponse message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTeamMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.GetTeamMemberResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.enterpriseUser && message.enterpriseUser.length))
                        message.enterpriseUser = [];
                    message.enterpriseUser.push($root.Enterprise.EnterpriseUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTeamMemberResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTeamMemberResponse message.
         * @function verify
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTeamMemberResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUser != null && message.hasOwnProperty("enterpriseUser")) {
                if (!Array.isArray(message.enterpriseUser))
                    return "enterpriseUser: array expected";
                for (let i = 0; i < message.enterpriseUser.length; ++i) {
                    let error = $root.Enterprise.EnterpriseUser.verify(message.enterpriseUser[i]);
                    if (error)
                        return "enterpriseUser." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetTeamMemberResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         */
        GetTeamMemberResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.GetTeamMemberResponse)
                return object;
            let message = new $root.Enterprise.GetTeamMemberResponse();
            if (object.enterpriseUser) {
                if (!Array.isArray(object.enterpriseUser))
                    throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: array expected");
                message.enterpriseUser = [];
                for (let i = 0; i < object.enterpriseUser.length; ++i) {
                    if (typeof object.enterpriseUser[i] !== "object")
                        throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: object expected");
                    message.enterpriseUser[i] = $root.Enterprise.EnterpriseUser.fromObject(object.enterpriseUser[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTeamMemberResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.GetTeamMemberResponse} message GetTeamMemberResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTeamMemberResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.enterpriseUser = [];
            if (message.enterpriseUser && message.enterpriseUser.length) {
                object.enterpriseUser = [];
                for (let j = 0; j < message.enterpriseUser.length; ++j)
                    object.enterpriseUser[j] = $root.Enterprise.EnterpriseUser.toObject(message.enterpriseUser[j], options);
            }
            return object;
        };

        /**
         * Converts this GetTeamMemberResponse to JSON.
         * @function toJSON
         * @memberof Enterprise.GetTeamMemberResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTeamMemberResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTeamMemberResponse;
    })();

    Enterprise.EnterprisePersonalAccount = (function() {

        /**
         * Properties of an EnterprisePersonalAccount.
         * @memberof Enterprise
         * @interface IEnterprisePersonalAccount
         * @property {string|null} [email] EnterprisePersonalAccount email
         * @property {Uint8Array|null} [OBSOLETE_FIELD] EnterprisePersonalAccount OBSOLETE_FIELD
         */

        /**
         * Constructs a new EnterprisePersonalAccount.
         * @memberof Enterprise
         * @classdesc Represents an EnterprisePersonalAccount.
         * @implements IEnterprisePersonalAccount
         * @constructor
         * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
         */
        function EnterprisePersonalAccount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePersonalAccount email.
         * @member {string} email
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         */
        EnterprisePersonalAccount.prototype.email = "";

        /**
         * EnterprisePersonalAccount OBSOLETE_FIELD.
         * @member {Uint8Array} OBSOLETE_FIELD
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         */
        EnterprisePersonalAccount.prototype.OBSOLETE_FIELD = $util.newBuffer([]);

        /**
         * Creates a new EnterprisePersonalAccount instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount instance
         */
        EnterprisePersonalAccount.create = function create(properties) {
            return new EnterprisePersonalAccount(properties);
        };

        /**
         * Encodes the specified EnterprisePersonalAccount message. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.OBSOLETE_FIELD);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePersonalAccount message, length delimited. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePersonalAccount message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterprisePersonalAccount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.OBSOLETE_FIELD = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePersonalAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePersonalAccount message.
         * @function verify
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePersonalAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                if (!(message.OBSOLETE_FIELD && typeof message.OBSOLETE_FIELD.length === "number" || $util.isString(message.OBSOLETE_FIELD)))
                    return "OBSOLETE_FIELD: buffer expected";
            return null;
        };

        /**
         * Creates an EnterprisePersonalAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         */
        EnterprisePersonalAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterprisePersonalAccount)
                return object;
            let message = new $root.Enterprise.EnterprisePersonalAccount();
            if (object.email != null)
                message.email = String(object.email);
            if (object.OBSOLETE_FIELD != null)
                if (typeof object.OBSOLETE_FIELD === "string")
                    $util.base64.decode(object.OBSOLETE_FIELD, message.OBSOLETE_FIELD = $util.newBuffer($util.base64.length(object.OBSOLETE_FIELD)), 0);
                else if (object.OBSOLETE_FIELD.length)
                    message.OBSOLETE_FIELD = object.OBSOLETE_FIELD;
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePersonalAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.EnterprisePersonalAccount} message EnterprisePersonalAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePersonalAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                if (options.bytes === String)
                    object.OBSOLETE_FIELD = "";
                else {
                    object.OBSOLETE_FIELD = [];
                    if (options.bytes !== Array)
                        object.OBSOLETE_FIELD = $util.newBuffer(object.OBSOLETE_FIELD);
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                object.OBSOLETE_FIELD = options.bytes === String ? $util.base64.encode(message.OBSOLETE_FIELD, 0, message.OBSOLETE_FIELD.length) : options.bytes === Array ? Array.prototype.slice.call(message.OBSOLETE_FIELD) : message.OBSOLETE_FIELD;
            return object;
        };

        /**
         * Converts this EnterprisePersonalAccount to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePersonalAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePersonalAccount;
    })();

    Enterprise.EncryptedTeamKeyRequest = (function() {

        /**
         * Properties of an EncryptedTeamKeyRequest.
         * @memberof Enterprise
         * @interface IEncryptedTeamKeyRequest
         * @property {Uint8Array|null} [teamUid] EncryptedTeamKeyRequest teamUid
         * @property {Uint8Array|null} [encryptedTeamKey] EncryptedTeamKeyRequest encryptedTeamKey
         */

        /**
         * Constructs a new EncryptedTeamKeyRequest.
         * @memberof Enterprise
         * @classdesc Represents an EncryptedTeamKeyRequest.
         * @implements IEncryptedTeamKeyRequest
         * @constructor
         * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
         */
        function EncryptedTeamKeyRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EncryptedTeamKeyRequest teamUid.
         * @member {Uint8Array} teamUid
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         */
        EncryptedTeamKeyRequest.prototype.teamUid = $util.newBuffer([]);

        /**
         * EncryptedTeamKeyRequest encryptedTeamKey.
         * @member {Uint8Array} encryptedTeamKey
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         */
        EncryptedTeamKeyRequest.prototype.encryptedTeamKey = $util.newBuffer([]);

        /**
         * Creates a new EncryptedTeamKeyRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest instance
         */
        EncryptedTeamKeyRequest.create = function create(properties) {
            return new EncryptedTeamKeyRequest(properties);
        };

        /**
         * Encodes the specified EncryptedTeamKeyRequest message. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedTeamKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teamUid);
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedTeamKey);
            return writer;
        };

        /**
         * Encodes the specified EncryptedTeamKeyRequest message, length delimited. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedTeamKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedTeamKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EncryptedTeamKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedTeamKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedTeamKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EncryptedTeamKeyRequest message.
         * @function verify
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EncryptedTeamKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                if (!(message.teamUid && typeof message.teamUid.length === "number" || $util.isString(message.teamUid)))
                    return "teamUid: buffer expected";
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                if (!(message.encryptedTeamKey && typeof message.encryptedTeamKey.length === "number" || $util.isString(message.encryptedTeamKey)))
                    return "encryptedTeamKey: buffer expected";
            return null;
        };

        /**
         * Creates an EncryptedTeamKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         */
        EncryptedTeamKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EncryptedTeamKeyRequest)
                return object;
            let message = new $root.Enterprise.EncryptedTeamKeyRequest();
            if (object.teamUid != null)
                if (typeof object.teamUid === "string")
                    $util.base64.decode(object.teamUid, message.teamUid = $util.newBuffer($util.base64.length(object.teamUid)), 0);
                else if (object.teamUid.length)
                    message.teamUid = object.teamUid;
            if (object.encryptedTeamKey != null)
                if (typeof object.encryptedTeamKey === "string")
                    $util.base64.decode(object.encryptedTeamKey, message.encryptedTeamKey = $util.newBuffer($util.base64.length(object.encryptedTeamKey)), 0);
                else if (object.encryptedTeamKey.length)
                    message.encryptedTeamKey = object.encryptedTeamKey;
            return message;
        };

        /**
         * Creates a plain object from an EncryptedTeamKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.EncryptedTeamKeyRequest} message EncryptedTeamKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EncryptedTeamKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.teamUid = "";
                else {
                    object.teamUid = [];
                    if (options.bytes !== Array)
                        object.teamUid = $util.newBuffer(object.teamUid);
                }
                if (options.bytes === String)
                    object.encryptedTeamKey = "";
                else {
                    object.encryptedTeamKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTeamKey = $util.newBuffer(object.encryptedTeamKey);
                }
            }
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                object.teamUid = options.bytes === String ? $util.base64.encode(message.teamUid, 0, message.teamUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.teamUid) : message.teamUid;
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                object.encryptedTeamKey = options.bytes === String ? $util.base64.encode(message.encryptedTeamKey, 0, message.encryptedTeamKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTeamKey) : message.encryptedTeamKey;
            return object;
        };

        /**
         * Converts this EncryptedTeamKeyRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EncryptedTeamKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EncryptedTeamKeyRequest;
    })();

    Enterprise.ReEncryptedData = (function() {

        /**
         * Properties of a ReEncryptedData.
         * @memberof Enterprise
         * @interface IReEncryptedData
         * @property {number|Long|null} [id] ReEncryptedData id
         * @property {string|null} [data] ReEncryptedData data
         */

        /**
         * Constructs a new ReEncryptedData.
         * @memberof Enterprise
         * @classdesc Represents a ReEncryptedData.
         * @implements IReEncryptedData
         * @constructor
         * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
         */
        function ReEncryptedData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReEncryptedData id.
         * @member {number|Long} id
         * @memberof Enterprise.ReEncryptedData
         * @instance
         */
        ReEncryptedData.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReEncryptedData data.
         * @member {string} data
         * @memberof Enterprise.ReEncryptedData
         * @instance
         */
        ReEncryptedData.prototype.data = "";

        /**
         * Creates a new ReEncryptedData instance using the specified properties.
         * @function create
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData instance
         */
        ReEncryptedData.create = function create(properties) {
            return new ReEncryptedData(properties);
        };

        /**
         * Encodes the specified ReEncryptedData message. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified ReEncryptedData message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReEncryptedData message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ReEncryptedData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReEncryptedData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReEncryptedData message.
         * @function verify
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReEncryptedData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        /**
         * Creates a ReEncryptedData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         */
        ReEncryptedData.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ReEncryptedData)
                return object;
            let message = new $root.Enterprise.ReEncryptedData();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from a ReEncryptedData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.ReEncryptedData} message ReEncryptedData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReEncryptedData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.data = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this ReEncryptedData to JSON.
         * @function toJSON
         * @memberof Enterprise.ReEncryptedData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReEncryptedData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReEncryptedData;
    })();

    Enterprise.NodeToManagedCompanyRequest = (function() {

        /**
         * Properties of a NodeToManagedCompanyRequest.
         * @memberof Enterprise
         * @interface INodeToManagedCompanyRequest
         * @property {number|null} [companyId] NodeToManagedCompanyRequest companyId
         * @property {Array.<Enterprise.IReEncryptedData>|null} [nodes] NodeToManagedCompanyRequest nodes
         * @property {Array.<Enterprise.IReEncryptedData>|null} [roles] NodeToManagedCompanyRequest roles
         * @property {Array.<Enterprise.IReEncryptedData>|null} [users] NodeToManagedCompanyRequest users
         */

        /**
         * Constructs a new NodeToManagedCompanyRequest.
         * @memberof Enterprise
         * @classdesc Represents a NodeToManagedCompanyRequest.
         * @implements INodeToManagedCompanyRequest
         * @constructor
         * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
         */
        function NodeToManagedCompanyRequest(properties) {
            this.nodes = [];
            this.roles = [];
            this.users = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeToManagedCompanyRequest companyId.
         * @member {number} companyId
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.companyId = 0;

        /**
         * NodeToManagedCompanyRequest nodes.
         * @member {Array.<Enterprise.IReEncryptedData>} nodes
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.nodes = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest roles.
         * @member {Array.<Enterprise.IReEncryptedData>} roles
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.roles = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest users.
         * @member {Array.<Enterprise.IReEncryptedData>} users
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.users = $util.emptyArray;

        /**
         * Creates a new NodeToManagedCompanyRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest instance
         */
        NodeToManagedCompanyRequest.create = function create(properties) {
            return new NodeToManagedCompanyRequest(properties);
        };

        /**
         * Encodes the specified NodeToManagedCompanyRequest message. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeToManagedCompanyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.companyId);
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.nodes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.roles != null && message.roles.length)
                for (let i = 0; i < message.roles.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.roles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.users != null && message.users.length)
                for (let i = 0; i < message.users.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.users[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeToManagedCompanyRequest message, length delimited. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeToManagedCompanyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeToManagedCompanyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.NodeToManagedCompanyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.companyId = reader.int32();
                    break;
                case 2:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.roles && message.roles.length))
                        message.roles = [];
                    message.roles.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.users && message.users.length))
                        message.users = [];
                    message.users.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeToManagedCompanyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeToManagedCompanyRequest message.
         * @function verify
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeToManagedCompanyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                if (!$util.isInteger(message.companyId))
                    return "companyId: integer expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (let i = 0; i < message.nodes.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (let i = 0; i < message.roles.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (let i = 0; i < message.users.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeToManagedCompanyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         */
        NodeToManagedCompanyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.NodeToManagedCompanyRequest)
                return object;
            let message = new $root.Enterprise.NodeToManagedCompanyRequest();
            if (object.companyId != null)
                message.companyId = object.companyId | 0;
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: array expected");
                message.nodes = [];
                for (let i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: object expected");
                    message.nodes[i] = $root.Enterprise.ReEncryptedData.fromObject(object.nodes[i]);
                }
            }
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: array expected");
                message.roles = [];
                for (let i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: object expected");
                    message.roles[i] = $root.Enterprise.ReEncryptedData.fromObject(object.roles[i]);
                }
            }
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: array expected");
                message.users = [];
                for (let i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: object expected");
                    message.users[i] = $root.Enterprise.ReEncryptedData.fromObject(object.users[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeToManagedCompanyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.NodeToManagedCompanyRequest} message NodeToManagedCompanyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeToManagedCompanyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodes = [];
                object.roles = [];
                object.users = [];
            }
            if (options.defaults)
                object.companyId = 0;
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                object.companyId = message.companyId;
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (let j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.Enterprise.ReEncryptedData.toObject(message.nodes[j], options);
            }
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (let j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.Enterprise.ReEncryptedData.toObject(message.roles[j], options);
            }
            if (message.users && message.users.length) {
                object.users = [];
                for (let j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.Enterprise.ReEncryptedData.toObject(message.users[j], options);
            }
            return object;
        };

        /**
         * Converts this NodeToManagedCompanyRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeToManagedCompanyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeToManagedCompanyRequest;
    })();

    return Enterprise;
})();

export const Folder = $root.Folder = (() => {

    /**
     * Namespace Folder.
     * @exports Folder
     * @namespace
     */
    const Folder = {};

    /**
     * RecordType enum.
     * @name Folder.RecordType
     * @enum {string}
     * @property {number} password=0 password value
     */
    Folder.RecordType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "password"] = 0;
        return values;
    })();

    /**
     * FolderType enum.
     * @name Folder.FolderType
     * @enum {string}
     * @property {number} default_folder=0 default_folder value
     * @property {number} user_folder=1 user_folder value
     * @property {number} shared_folder=2 shared_folder value
     * @property {number} shared_folder_folder=3 shared_folder_folder value
     */
    Folder.FolderType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "default_folder"] = 0;
        values[valuesById[1] = "user_folder"] = 1;
        values[valuesById[2] = "shared_folder"] = 2;
        values[valuesById[3] = "shared_folder_folder"] = 3;
        return values;
    })();

    /**
     * EncryptedKeyType enum.
     * @name Folder.EncryptedKeyType
     * @enum {string}
     * @property {number} no_key=0 no_key value
     * @property {number} encrypted_by_data_key=1 encrypted_by_data_key value
     * @property {number} encrypted_by_public_key=2 encrypted_by_public_key value
     */
    Folder.EncryptedKeyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "no_key"] = 0;
        values[valuesById[1] = "encrypted_by_data_key"] = 1;
        values[valuesById[2] = "encrypted_by_public_key"] = 2;
        return values;
    })();

    Folder.EncryptedDataKey = (function() {

        /**
         * Properties of an EncryptedDataKey.
         * @memberof Folder
         * @interface IEncryptedDataKey
         * @property {Uint8Array|null} [encryptedKey] EncryptedDataKey encryptedKey
         * @property {Folder.EncryptedKeyType|null} [encryptedKeyType] EncryptedDataKey encryptedKeyType
         */

        /**
         * Constructs a new EncryptedDataKey.
         * @memberof Folder
         * @classdesc Represents an EncryptedDataKey.
         * @implements IEncryptedDataKey
         * @constructor
         * @param {Folder.IEncryptedDataKey=} [properties] Properties to set
         */
        function EncryptedDataKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EncryptedDataKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof Folder.EncryptedDataKey
         * @instance
         */
        EncryptedDataKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * EncryptedDataKey encryptedKeyType.
         * @member {Folder.EncryptedKeyType} encryptedKeyType
         * @memberof Folder.EncryptedDataKey
         * @instance
         */
        EncryptedDataKey.prototype.encryptedKeyType = 0;

        /**
         * Creates a new EncryptedDataKey instance using the specified properties.
         * @function create
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey=} [properties] Properties to set
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey instance
         */
        EncryptedDataKey.create = function create(properties) {
            return new EncryptedDataKey(properties);
        };

        /**
         * Encodes the specified EncryptedDataKey message. Does not implicitly {@link Folder.EncryptedDataKey.verify|verify} messages.
         * @function encode
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey} message EncryptedDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedDataKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedKey);
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encryptedKeyType);
            return writer;
        };

        /**
         * Encodes the specified EncryptedDataKey message, length delimited. Does not implicitly {@link Folder.EncryptedDataKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey} message EncryptedDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedDataKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EncryptedDataKey message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedDataKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.EncryptedDataKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedKey = reader.bytes();
                    break;
                case 2:
                    message.encryptedKeyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EncryptedDataKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedDataKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EncryptedDataKey message.
         * @function verify
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EncryptedDataKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                switch (message.encryptedKeyType) {
                default:
                    return "encryptedKeyType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an EncryptedDataKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         */
        EncryptedDataKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.EncryptedDataKey)
                return object;
            let message = new $root.Folder.EncryptedDataKey();
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            switch (object.encryptedKeyType) {
            case "no_key":
            case 0:
                message.encryptedKeyType = 0;
                break;
            case "encrypted_by_data_key":
            case 1:
                message.encryptedKeyType = 1;
                break;
            case "encrypted_by_public_key":
            case 2:
                message.encryptedKeyType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an EncryptedDataKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.EncryptedDataKey} message EncryptedDataKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EncryptedDataKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
                object.encryptedKeyType = options.enums === String ? "no_key" : 0;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                object.encryptedKeyType = options.enums === String ? $root.Folder.EncryptedKeyType[message.encryptedKeyType] : message.encryptedKeyType;
            return object;
        };

        /**
         * Converts this EncryptedDataKey to JSON.
         * @function toJSON
         * @memberof Folder.EncryptedDataKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EncryptedDataKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EncryptedDataKey;
    })();

    Folder.SharedFolderRecordData = (function() {

        /**
         * Properties of a SharedFolderRecordData.
         * @memberof Folder
         * @interface ISharedFolderRecordData
         * @property {Uint8Array|null} [folderUid] SharedFolderRecordData folderUid
         * @property {Uint8Array|null} [recordUid] SharedFolderRecordData recordUid
         * @property {number|null} [userId] SharedFolderRecordData userId
         * @property {Array.<Folder.IEncryptedDataKey>|null} [encryptedDataKey] SharedFolderRecordData encryptedDataKey
         */

        /**
         * Constructs a new SharedFolderRecordData.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordData.
         * @implements ISharedFolderRecordData
         * @constructor
         * @param {Folder.ISharedFolderRecordData=} [properties] Properties to set
         */
        function SharedFolderRecordData(properties) {
            this.encryptedDataKey = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordData folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.folderUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordData recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.recordUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordData userId.
         * @member {number} userId
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.userId = 0;

        /**
         * SharedFolderRecordData encryptedDataKey.
         * @member {Array.<Folder.IEncryptedDataKey>} encryptedDataKey
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.encryptedDataKey = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordData instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData instance
         */
        SharedFolderRecordData.create = function create(properties) {
            return new SharedFolderRecordData(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordData message. Does not implicitly {@link Folder.SharedFolderRecordData.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData} message SharedFolderRecordData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordUid);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userId);
            if (message.encryptedDataKey != null && message.encryptedDataKey.length)
                for (let i = 0; i < message.encryptedDataKey.length; ++i)
                    $root.Folder.EncryptedDataKey.encode(message.encryptedDataKey[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordData message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData} message SharedFolderRecordData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordData message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.recordUid = reader.bytes();
                    break;
                case 3:
                    message.userId = reader.int32();
                    break;
                case 4:
                    if (!(message.encryptedDataKey && message.encryptedDataKey.length))
                        message.encryptedDataKey = [];
                    message.encryptedDataKey.push($root.Folder.EncryptedDataKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordData message.
         * @function verify
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey")) {
                if (!Array.isArray(message.encryptedDataKey))
                    return "encryptedDataKey: array expected";
                for (let i = 0; i < message.encryptedDataKey.length; ++i) {
                    let error = $root.Folder.EncryptedDataKey.verify(message.encryptedDataKey[i]);
                    if (error)
                        return "encryptedDataKey." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         */
        SharedFolderRecordData.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordData)
                return object;
            let message = new $root.Folder.SharedFolderRecordData();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.encryptedDataKey) {
                if (!Array.isArray(object.encryptedDataKey))
                    throw TypeError(".Folder.SharedFolderRecordData.encryptedDataKey: array expected");
                message.encryptedDataKey = [];
                for (let i = 0; i < object.encryptedDataKey.length; ++i) {
                    if (typeof object.encryptedDataKey[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordData.encryptedDataKey: object expected");
                    message.encryptedDataKey[i] = $root.Folder.EncryptedDataKey.fromObject(object.encryptedDataKey[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.SharedFolderRecordData} message SharedFolderRecordData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.encryptedDataKey = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.userId = 0;
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.encryptedDataKey && message.encryptedDataKey.length) {
                object.encryptedDataKey = [];
                for (let j = 0; j < message.encryptedDataKey.length; ++j)
                    object.encryptedDataKey[j] = $root.Folder.EncryptedDataKey.toObject(message.encryptedDataKey[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordData to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordData;
    })();

    Folder.SharedFolderRecordDataList = (function() {

        /**
         * Properties of a SharedFolderRecordDataList.
         * @memberof Folder
         * @interface ISharedFolderRecordDataList
         * @property {Array.<Folder.ISharedFolderRecordData>|null} [sharedFolderRecordData] SharedFolderRecordDataList sharedFolderRecordData
         */

        /**
         * Constructs a new SharedFolderRecordDataList.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordDataList.
         * @implements ISharedFolderRecordDataList
         * @constructor
         * @param {Folder.ISharedFolderRecordDataList=} [properties] Properties to set
         */
        function SharedFolderRecordDataList(properties) {
            this.sharedFolderRecordData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordDataList sharedFolderRecordData.
         * @member {Array.<Folder.ISharedFolderRecordData>} sharedFolderRecordData
         * @memberof Folder.SharedFolderRecordDataList
         * @instance
         */
        SharedFolderRecordDataList.prototype.sharedFolderRecordData = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordDataList instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList instance
         */
        SharedFolderRecordDataList.create = function create(properties) {
            return new SharedFolderRecordDataList(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordDataList message. Does not implicitly {@link Folder.SharedFolderRecordDataList.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList} message SharedFolderRecordDataList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordDataList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderRecordData != null && message.sharedFolderRecordData.length)
                for (let i = 0; i < message.sharedFolderRecordData.length; ++i)
                    $root.Folder.SharedFolderRecordData.encode(message.sharedFolderRecordData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordDataList message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordDataList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList} message SharedFolderRecordDataList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordDataList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordDataList message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordDataList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordDataList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharedFolderRecordData && message.sharedFolderRecordData.length))
                        message.sharedFolderRecordData = [];
                    message.sharedFolderRecordData.push($root.Folder.SharedFolderRecordData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordDataList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordDataList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordDataList message.
         * @function verify
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordDataList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderRecordData != null && message.hasOwnProperty("sharedFolderRecordData")) {
                if (!Array.isArray(message.sharedFolderRecordData))
                    return "sharedFolderRecordData: array expected";
                for (let i = 0; i < message.sharedFolderRecordData.length; ++i) {
                    let error = $root.Folder.SharedFolderRecordData.verify(message.sharedFolderRecordData[i]);
                    if (error)
                        return "sharedFolderRecordData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordDataList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         */
        SharedFolderRecordDataList.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordDataList)
                return object;
            let message = new $root.Folder.SharedFolderRecordDataList();
            if (object.sharedFolderRecordData) {
                if (!Array.isArray(object.sharedFolderRecordData))
                    throw TypeError(".Folder.SharedFolderRecordDataList.sharedFolderRecordData: array expected");
                message.sharedFolderRecordData = [];
                for (let i = 0; i < object.sharedFolderRecordData.length; ++i) {
                    if (typeof object.sharedFolderRecordData[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordDataList.sharedFolderRecordData: object expected");
                    message.sharedFolderRecordData[i] = $root.Folder.SharedFolderRecordData.fromObject(object.sharedFolderRecordData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordDataList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.SharedFolderRecordDataList} message SharedFolderRecordDataList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordDataList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sharedFolderRecordData = [];
            if (message.sharedFolderRecordData && message.sharedFolderRecordData.length) {
                object.sharedFolderRecordData = [];
                for (let j = 0; j < message.sharedFolderRecordData.length; ++j)
                    object.sharedFolderRecordData[j] = $root.Folder.SharedFolderRecordData.toObject(message.sharedFolderRecordData[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordDataList to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordDataList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordDataList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordDataList;
    })();

    Folder.SharedFolderRecordFix = (function() {

        /**
         * Properties of a SharedFolderRecordFix.
         * @memberof Folder
         * @interface ISharedFolderRecordFix
         * @property {Uint8Array|null} [folderUid] SharedFolderRecordFix folderUid
         * @property {Uint8Array|null} [recordUid] SharedFolderRecordFix recordUid
         * @property {Uint8Array|null} [encryptedRecordFolderKey] SharedFolderRecordFix encryptedRecordFolderKey
         */

        /**
         * Constructs a new SharedFolderRecordFix.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordFix.
         * @implements ISharedFolderRecordFix
         * @constructor
         * @param {Folder.ISharedFolderRecordFix=} [properties] Properties to set
         */
        function SharedFolderRecordFix(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordFix folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.folderUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordFix recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.recordUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordFix encryptedRecordFolderKey.
         * @member {Uint8Array} encryptedRecordFolderKey
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.encryptedRecordFolderKey = $util.newBuffer([]);

        /**
         * Creates a new SharedFolderRecordFix instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix instance
         */
        SharedFolderRecordFix.create = function create(properties) {
            return new SharedFolderRecordFix(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordFix message. Does not implicitly {@link Folder.SharedFolderRecordFix.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix} message SharedFolderRecordFix message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFix.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordUid);
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedRecordFolderKey);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordFix message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordFix.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix} message SharedFolderRecordFix message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFix.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordFix message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFix.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordFix();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.recordUid = reader.bytes();
                    break;
                case 3:
                    message.encryptedRecordFolderKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordFix message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFix.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordFix message.
         * @function verify
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordFix.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                if (!(message.encryptedRecordFolderKey && typeof message.encryptedRecordFolderKey.length === "number" || $util.isString(message.encryptedRecordFolderKey)))
                    return "encryptedRecordFolderKey: buffer expected";
            return null;
        };

        /**
         * Creates a SharedFolderRecordFix message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         */
        SharedFolderRecordFix.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordFix)
                return object;
            let message = new $root.Folder.SharedFolderRecordFix();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedRecordFolderKey != null)
                if (typeof object.encryptedRecordFolderKey === "string")
                    $util.base64.decode(object.encryptedRecordFolderKey, message.encryptedRecordFolderKey = $util.newBuffer($util.base64.length(object.encryptedRecordFolderKey)), 0);
                else if (object.encryptedRecordFolderKey.length)
                    message.encryptedRecordFolderKey = object.encryptedRecordFolderKey;
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordFix message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.SharedFolderRecordFix} message SharedFolderRecordFix
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordFix.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedRecordFolderKey = "";
                else {
                    object.encryptedRecordFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordFolderKey = $util.newBuffer(object.encryptedRecordFolderKey);
                }
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                object.encryptedRecordFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordFolderKey, 0, message.encryptedRecordFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordFolderKey) : message.encryptedRecordFolderKey;
            return object;
        };

        /**
         * Converts this SharedFolderRecordFix to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordFix.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordFix;
    })();

    Folder.SharedFolderRecordFixList = (function() {

        /**
         * Properties of a SharedFolderRecordFixList.
         * @memberof Folder
         * @interface ISharedFolderRecordFixList
         * @property {Array.<Folder.ISharedFolderRecordFix>|null} [sharedFolderRecordFix] SharedFolderRecordFixList sharedFolderRecordFix
         */

        /**
         * Constructs a new SharedFolderRecordFixList.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordFixList.
         * @implements ISharedFolderRecordFixList
         * @constructor
         * @param {Folder.ISharedFolderRecordFixList=} [properties] Properties to set
         */
        function SharedFolderRecordFixList(properties) {
            this.sharedFolderRecordFix = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordFixList sharedFolderRecordFix.
         * @member {Array.<Folder.ISharedFolderRecordFix>} sharedFolderRecordFix
         * @memberof Folder.SharedFolderRecordFixList
         * @instance
         */
        SharedFolderRecordFixList.prototype.sharedFolderRecordFix = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordFixList instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList instance
         */
        SharedFolderRecordFixList.create = function create(properties) {
            return new SharedFolderRecordFixList(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordFixList message. Does not implicitly {@link Folder.SharedFolderRecordFixList.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList} message SharedFolderRecordFixList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFixList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderRecordFix != null && message.sharedFolderRecordFix.length)
                for (let i = 0; i < message.sharedFolderRecordFix.length; ++i)
                    $root.Folder.SharedFolderRecordFix.encode(message.sharedFolderRecordFix[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordFixList message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordFixList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList} message SharedFolderRecordFixList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFixList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordFixList message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFixList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordFixList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharedFolderRecordFix && message.sharedFolderRecordFix.length))
                        message.sharedFolderRecordFix = [];
                    message.sharedFolderRecordFix.push($root.Folder.SharedFolderRecordFix.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordFixList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFixList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordFixList message.
         * @function verify
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordFixList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderRecordFix != null && message.hasOwnProperty("sharedFolderRecordFix")) {
                if (!Array.isArray(message.sharedFolderRecordFix))
                    return "sharedFolderRecordFix: array expected";
                for (let i = 0; i < message.sharedFolderRecordFix.length; ++i) {
                    let error = $root.Folder.SharedFolderRecordFix.verify(message.sharedFolderRecordFix[i]);
                    if (error)
                        return "sharedFolderRecordFix." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordFixList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         */
        SharedFolderRecordFixList.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordFixList)
                return object;
            let message = new $root.Folder.SharedFolderRecordFixList();
            if (object.sharedFolderRecordFix) {
                if (!Array.isArray(object.sharedFolderRecordFix))
                    throw TypeError(".Folder.SharedFolderRecordFixList.sharedFolderRecordFix: array expected");
                message.sharedFolderRecordFix = [];
                for (let i = 0; i < object.sharedFolderRecordFix.length; ++i) {
                    if (typeof object.sharedFolderRecordFix[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordFixList.sharedFolderRecordFix: object expected");
                    message.sharedFolderRecordFix[i] = $root.Folder.SharedFolderRecordFix.fromObject(object.sharedFolderRecordFix[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordFixList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.SharedFolderRecordFixList} message SharedFolderRecordFixList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordFixList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sharedFolderRecordFix = [];
            if (message.sharedFolderRecordFix && message.sharedFolderRecordFix.length) {
                object.sharedFolderRecordFix = [];
                for (let j = 0; j < message.sharedFolderRecordFix.length; ++j)
                    object.sharedFolderRecordFix[j] = $root.Folder.SharedFolderRecordFix.toObject(message.sharedFolderRecordFix[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordFixList to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordFixList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordFixList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordFixList;
    })();

    Folder.RecordRequest = (function() {

        /**
         * Properties of a RecordRequest.
         * @memberof Folder
         * @interface IRecordRequest
         * @property {Uint8Array|null} [recordUid] RecordRequest recordUid
         * @property {Folder.RecordType|null} [recordType] RecordRequest recordType
         * @property {Uint8Array|null} [recordData] RecordRequest recordData
         * @property {Uint8Array|null} [encryptedRecordKey] RecordRequest encryptedRecordKey
         * @property {Folder.FolderType|null} [folderType] RecordRequest folderType
         * @property {number|Long|null} [howLongAgo] RecordRequest howLongAgo
         * @property {Uint8Array|null} [folderUid] RecordRequest folderUid
         * @property {Uint8Array|null} [encryptedRecordFolderKey] RecordRequest encryptedRecordFolderKey
         * @property {Uint8Array|null} [extra] RecordRequest extra
         * @property {Uint8Array|null} [nonSharedData] RecordRequest nonSharedData
         * @property {Array.<number|Long>|null} [fileIds] RecordRequest fileIds
         */

        /**
         * Constructs a new RecordRequest.
         * @memberof Folder
         * @classdesc Represents a RecordRequest.
         * @implements IRecordRequest
         * @constructor
         * @param {Folder.IRecordRequest=} [properties] Properties to set
         */
        function RecordRequest(properties) {
            this.fileIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordRequest recordType.
         * @member {Folder.RecordType} recordType
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordType = 0;

        /**
         * RecordRequest recordData.
         * @member {Uint8Array} recordData
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordData = $util.newBuffer([]);

        /**
         * RecordRequest encryptedRecordKey.
         * @member {Uint8Array} encryptedRecordKey
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.encryptedRecordKey = $util.newBuffer([]);

        /**
         * RecordRequest folderType.
         * @member {Folder.FolderType} folderType
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.folderType = 0;

        /**
         * RecordRequest howLongAgo.
         * @member {number|Long} howLongAgo
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.howLongAgo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordRequest folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.folderUid = $util.newBuffer([]);

        /**
         * RecordRequest encryptedRecordFolderKey.
         * @member {Uint8Array} encryptedRecordFolderKey
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.encryptedRecordFolderKey = $util.newBuffer([]);

        /**
         * RecordRequest extra.
         * @member {Uint8Array} extra
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.extra = $util.newBuffer([]);

        /**
         * RecordRequest nonSharedData.
         * @member {Uint8Array} nonSharedData
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.nonSharedData = $util.newBuffer([]);

        /**
         * RecordRequest fileIds.
         * @member {Array.<number|Long>} fileIds
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.fileIds = $util.emptyArray;

        /**
         * Creates a new RecordRequest instance using the specified properties.
         * @function create
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest=} [properties] Properties to set
         * @returns {Folder.RecordRequest} RecordRequest instance
         */
        RecordRequest.create = function create(properties) {
            return new RecordRequest(properties);
        };

        /**
         * Encodes the specified RecordRequest message. Does not implicitly {@link Folder.RecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest} message RecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.recordType);
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.recordData);
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedRecordKey);
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.folderType);
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.howLongAgo);
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.folderUid);
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encryptedRecordFolderKey);
            if (message.extra != null && message.hasOwnProperty("extra"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.extra);
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.nonSharedData);
            if (message.fileIds != null && message.fileIds.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (let i = 0; i < message.fileIds.length; ++i)
                    writer.int64(message.fileIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RecordRequest message, length delimited. Does not implicitly {@link Folder.RecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest} message RecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.RecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.RecordRequest} RecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.RecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordType = reader.int32();
                    break;
                case 3:
                    message.recordData = reader.bytes();
                    break;
                case 4:
                    message.encryptedRecordKey = reader.bytes();
                    break;
                case 5:
                    message.folderType = reader.int32();
                    break;
                case 6:
                    message.howLongAgo = reader.int64();
                    break;
                case 7:
                    message.folderUid = reader.bytes();
                    break;
                case 8:
                    message.encryptedRecordFolderKey = reader.bytes();
                    break;
                case 9:
                    message.extra = reader.bytes();
                    break;
                case 10:
                    message.nonSharedData = reader.bytes();
                    break;
                case 11:
                    if (!(message.fileIds && message.fileIds.length))
                        message.fileIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fileIds.push(reader.int64());
                    } else
                        message.fileIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.RecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.RecordRequest} RecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordRequest message.
         * @function verify
         * @memberof Folder.RecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                switch (message.recordType) {
                default:
                    return "recordType: enum value expected";
                case 0:
                    break;
                }
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                if (!(message.recordData && typeof message.recordData.length === "number" || $util.isString(message.recordData)))
                    return "recordData: buffer expected";
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                if (!(message.encryptedRecordKey && typeof message.encryptedRecordKey.length === "number" || $util.isString(message.encryptedRecordKey)))
                    return "encryptedRecordKey: buffer expected";
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                switch (message.folderType) {
                default:
                    return "folderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                if (!$util.isInteger(message.howLongAgo) && !(message.howLongAgo && $util.isInteger(message.howLongAgo.low) && $util.isInteger(message.howLongAgo.high)))
                    return "howLongAgo: integer|Long expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                if (!(message.encryptedRecordFolderKey && typeof message.encryptedRecordFolderKey.length === "number" || $util.isString(message.encryptedRecordFolderKey)))
                    return "encryptedRecordFolderKey: buffer expected";
            if (message.extra != null && message.hasOwnProperty("extra"))
                if (!(message.extra && typeof message.extra.length === "number" || $util.isString(message.extra)))
                    return "extra: buffer expected";
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                if (!(message.nonSharedData && typeof message.nonSharedData.length === "number" || $util.isString(message.nonSharedData)))
                    return "nonSharedData: buffer expected";
            if (message.fileIds != null && message.hasOwnProperty("fileIds")) {
                if (!Array.isArray(message.fileIds))
                    return "fileIds: array expected";
                for (let i = 0; i < message.fileIds.length; ++i)
                    if (!$util.isInteger(message.fileIds[i]) && !(message.fileIds[i] && $util.isInteger(message.fileIds[i].low) && $util.isInteger(message.fileIds[i].high)))
                        return "fileIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a RecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.RecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.RecordRequest} RecordRequest
         */
        RecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.RecordRequest)
                return object;
            let message = new $root.Folder.RecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            switch (object.recordType) {
            case "password":
            case 0:
                message.recordType = 0;
                break;
            }
            if (object.recordData != null)
                if (typeof object.recordData === "string")
                    $util.base64.decode(object.recordData, message.recordData = $util.newBuffer($util.base64.length(object.recordData)), 0);
                else if (object.recordData.length)
                    message.recordData = object.recordData;
            if (object.encryptedRecordKey != null)
                if (typeof object.encryptedRecordKey === "string")
                    $util.base64.decode(object.encryptedRecordKey, message.encryptedRecordKey = $util.newBuffer($util.base64.length(object.encryptedRecordKey)), 0);
                else if (object.encryptedRecordKey.length)
                    message.encryptedRecordKey = object.encryptedRecordKey;
            switch (object.folderType) {
            case "default_folder":
            case 0:
                message.folderType = 0;
                break;
            case "user_folder":
            case 1:
                message.folderType = 1;
                break;
            case "shared_folder":
            case 2:
                message.folderType = 2;
                break;
            case "shared_folder_folder":
            case 3:
                message.folderType = 3;
                break;
            }
            if (object.howLongAgo != null)
                if ($util.Long)
                    (message.howLongAgo = $util.Long.fromValue(object.howLongAgo)).unsigned = false;
                else if (typeof object.howLongAgo === "string")
                    message.howLongAgo = parseInt(object.howLongAgo, 10);
                else if (typeof object.howLongAgo === "number")
                    message.howLongAgo = object.howLongAgo;
                else if (typeof object.howLongAgo === "object")
                    message.howLongAgo = new $util.LongBits(object.howLongAgo.low >>> 0, object.howLongAgo.high >>> 0).toNumber();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.encryptedRecordFolderKey != null)
                if (typeof object.encryptedRecordFolderKey === "string")
                    $util.base64.decode(object.encryptedRecordFolderKey, message.encryptedRecordFolderKey = $util.newBuffer($util.base64.length(object.encryptedRecordFolderKey)), 0);
                else if (object.encryptedRecordFolderKey.length)
                    message.encryptedRecordFolderKey = object.encryptedRecordFolderKey;
            if (object.extra != null)
                if (typeof object.extra === "string")
                    $util.base64.decode(object.extra, message.extra = $util.newBuffer($util.base64.length(object.extra)), 0);
                else if (object.extra.length)
                    message.extra = object.extra;
            if (object.nonSharedData != null)
                if (typeof object.nonSharedData === "string")
                    $util.base64.decode(object.nonSharedData, message.nonSharedData = $util.newBuffer($util.base64.length(object.nonSharedData)), 0);
                else if (object.nonSharedData.length)
                    message.nonSharedData = object.nonSharedData;
            if (object.fileIds) {
                if (!Array.isArray(object.fileIds))
                    throw TypeError(".Folder.RecordRequest.fileIds: array expected");
                message.fileIds = [];
                for (let i = 0; i < object.fileIds.length; ++i)
                    if ($util.Long)
                        (message.fileIds[i] = $util.Long.fromValue(object.fileIds[i])).unsigned = false;
                    else if (typeof object.fileIds[i] === "string")
                        message.fileIds[i] = parseInt(object.fileIds[i], 10);
                    else if (typeof object.fileIds[i] === "number")
                        message.fileIds[i] = object.fileIds[i];
                    else if (typeof object.fileIds[i] === "object")
                        message.fileIds[i] = new $util.LongBits(object.fileIds[i].low >>> 0, object.fileIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.RecordRequest} message RecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fileIds = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.recordType = options.enums === String ? "password" : 0;
                if (options.bytes === String)
                    object.recordData = "";
                else {
                    object.recordData = [];
                    if (options.bytes !== Array)
                        object.recordData = $util.newBuffer(object.recordData);
                }
                if (options.bytes === String)
                    object.encryptedRecordKey = "";
                else {
                    object.encryptedRecordKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordKey = $util.newBuffer(object.encryptedRecordKey);
                }
                object.folderType = options.enums === String ? "default_folder" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.howLongAgo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.howLongAgo = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.encryptedRecordFolderKey = "";
                else {
                    object.encryptedRecordFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordFolderKey = $util.newBuffer(object.encryptedRecordFolderKey);
                }
                if (options.bytes === String)
                    object.extra = "";
                else {
                    object.extra = [];
                    if (options.bytes !== Array)
                        object.extra = $util.newBuffer(object.extra);
                }
                if (options.bytes === String)
                    object.nonSharedData = "";
                else {
                    object.nonSharedData = [];
                    if (options.bytes !== Array)
                        object.nonSharedData = $util.newBuffer(object.nonSharedData);
                }
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                object.recordType = options.enums === String ? $root.Folder.RecordType[message.recordType] : message.recordType;
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                object.recordData = options.bytes === String ? $util.base64.encode(message.recordData, 0, message.recordData.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordData) : message.recordData;
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                object.encryptedRecordKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordKey, 0, message.encryptedRecordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordKey) : message.encryptedRecordKey;
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                object.folderType = options.enums === String ? $root.Folder.FolderType[message.folderType] : message.folderType;
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                if (typeof message.howLongAgo === "number")
                    object.howLongAgo = options.longs === String ? String(message.howLongAgo) : message.howLongAgo;
                else
                    object.howLongAgo = options.longs === String ? $util.Long.prototype.toString.call(message.howLongAgo) : options.longs === Number ? new $util.LongBits(message.howLongAgo.low >>> 0, message.howLongAgo.high >>> 0).toNumber() : message.howLongAgo;
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                object.encryptedRecordFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordFolderKey, 0, message.encryptedRecordFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordFolderKey) : message.encryptedRecordFolderKey;
            if (message.extra != null && message.hasOwnProperty("extra"))
                object.extra = options.bytes === String ? $util.base64.encode(message.extra, 0, message.extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.extra) : message.extra;
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                object.nonSharedData = options.bytes === String ? $util.base64.encode(message.nonSharedData, 0, message.nonSharedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonSharedData) : message.nonSharedData;
            if (message.fileIds && message.fileIds.length) {
                object.fileIds = [];
                for (let j = 0; j < message.fileIds.length; ++j)
                    if (typeof message.fileIds[j] === "number")
                        object.fileIds[j] = options.longs === String ? String(message.fileIds[j]) : message.fileIds[j];
                    else
                        object.fileIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.fileIds[j]) : options.longs === Number ? new $util.LongBits(message.fileIds[j].low >>> 0, message.fileIds[j].high >>> 0).toNumber() : message.fileIds[j];
            }
            return object;
        };

        /**
         * Converts this RecordRequest to JSON.
         * @function toJSON
         * @memberof Folder.RecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordRequest;
    })();

    Folder.RecordResponse = (function() {

        /**
         * Properties of a RecordResponse.
         * @memberof Folder
         * @interface IRecordResponse
         * @property {Uint8Array|null} [recordUid] RecordResponse recordUid
         * @property {number|Long|null} [revision] RecordResponse revision
         * @property {string|null} [status] RecordResponse status
         */

        /**
         * Constructs a new RecordResponse.
         * @memberof Folder
         * @classdesc Represents a RecordResponse.
         * @implements IRecordResponse
         * @constructor
         * @param {Folder.IRecordResponse=} [properties] Properties to set
         */
        function RecordResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordResponse recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordResponse revision.
         * @member {number|Long} revision
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordResponse status.
         * @member {string} status
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.status = "";

        /**
         * Creates a new RecordResponse instance using the specified properties.
         * @function create
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse=} [properties] Properties to set
         * @returns {Folder.RecordResponse} RecordResponse instance
         */
        RecordResponse.create = function create(properties) {
            return new RecordResponse(properties);
        };

        /**
         * Encodes the specified RecordResponse message. Does not implicitly {@link Folder.RecordResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse} message RecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.revision);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            return writer;
        };

        /**
         * Encodes the specified RecordResponse message, length delimited. Does not implicitly {@link Folder.RecordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse} message RecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.RecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.RecordResponse} RecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.RecordResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.revision = reader.int64();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.RecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.RecordResponse} RecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordResponse message.
         * @function verify
         * @memberof Folder.RecordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            return null;
        };

        /**
         * Creates a RecordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.RecordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.RecordResponse} RecordResponse
         */
        RecordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.RecordResponse)
                return object;
            let message = new $root.Folder.RecordResponse();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.status != null)
                message.status = String(object.status);
            return message;
        };

        /**
         * Creates a plain object from a RecordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.RecordResponse} message RecordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.status = "";
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this RecordResponse to JSON.
         * @function toJSON
         * @memberof Folder.RecordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordResponse;
    })();

    Folder.SharedFolderFields = (function() {

        /**
         * Properties of a SharedFolderFields.
         * @memberof Folder
         * @interface ISharedFolderFields
         * @property {Uint8Array|null} [encryptedFolderName] SharedFolderFields encryptedFolderName
         * @property {boolean|null} [manageUsers] SharedFolderFields manageUsers
         * @property {boolean|null} [manageRecords] SharedFolderFields manageRecords
         * @property {boolean|null} [canEdit] SharedFolderFields canEdit
         * @property {boolean|null} [canShare] SharedFolderFields canShare
         */

        /**
         * Constructs a new SharedFolderFields.
         * @memberof Folder
         * @classdesc Represents a SharedFolderFields.
         * @implements ISharedFolderFields
         * @constructor
         * @param {Folder.ISharedFolderFields=} [properties] Properties to set
         */
        function SharedFolderFields(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderFields encryptedFolderName.
         * @member {Uint8Array} encryptedFolderName
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.encryptedFolderName = $util.newBuffer([]);

        /**
         * SharedFolderFields manageUsers.
         * @member {boolean} manageUsers
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.manageUsers = false;

        /**
         * SharedFolderFields manageRecords.
         * @member {boolean} manageRecords
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.manageRecords = false;

        /**
         * SharedFolderFields canEdit.
         * @member {boolean} canEdit
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.canEdit = false;

        /**
         * SharedFolderFields canShare.
         * @member {boolean} canShare
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.canShare = false;

        /**
         * Creates a new SharedFolderFields instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields=} [properties] Properties to set
         * @returns {Folder.SharedFolderFields} SharedFolderFields instance
         */
        SharedFolderFields.create = function create(properties) {
            return new SharedFolderFields(properties);
        };

        /**
         * Encodes the specified SharedFolderFields message. Does not implicitly {@link Folder.SharedFolderFields.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields} message SharedFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedFolderName);
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.manageUsers);
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manageRecords);
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.canEdit);
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canShare);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderFields message, length delimited. Does not implicitly {@link Folder.SharedFolderFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields} message SharedFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderFields message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderFields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedFolderName = reader.bytes();
                    break;
                case 2:
                    message.manageUsers = reader.bool();
                    break;
                case 3:
                    message.manageRecords = reader.bool();
                    break;
                case 4:
                    message.canEdit = reader.bool();
                    break;
                case 5:
                    message.canShare = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderFields message.
         * @function verify
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                if (!(message.encryptedFolderName && typeof message.encryptedFolderName.length === "number" || $util.isString(message.encryptedFolderName)))
                    return "encryptedFolderName: buffer expected";
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                if (typeof message.manageUsers !== "boolean")
                    return "manageUsers: boolean expected";
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                if (typeof message.manageRecords !== "boolean")
                    return "manageRecords: boolean expected";
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                if (typeof message.canEdit !== "boolean")
                    return "canEdit: boolean expected";
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                if (typeof message.canShare !== "boolean")
                    return "canShare: boolean expected";
            return null;
        };

        /**
         * Creates a SharedFolderFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         */
        SharedFolderFields.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderFields)
                return object;
            let message = new $root.Folder.SharedFolderFields();
            if (object.encryptedFolderName != null)
                if (typeof object.encryptedFolderName === "string")
                    $util.base64.decode(object.encryptedFolderName, message.encryptedFolderName = $util.newBuffer($util.base64.length(object.encryptedFolderName)), 0);
                else if (object.encryptedFolderName.length)
                    message.encryptedFolderName = object.encryptedFolderName;
            if (object.manageUsers != null)
                message.manageUsers = Boolean(object.manageUsers);
            if (object.manageRecords != null)
                message.manageRecords = Boolean(object.manageRecords);
            if (object.canEdit != null)
                message.canEdit = Boolean(object.canEdit);
            if (object.canShare != null)
                message.canShare = Boolean(object.canShare);
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.SharedFolderFields} message SharedFolderFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedFolderName = "";
                else {
                    object.encryptedFolderName = [];
                    if (options.bytes !== Array)
                        object.encryptedFolderName = $util.newBuffer(object.encryptedFolderName);
                }
                object.manageUsers = false;
                object.manageRecords = false;
                object.canEdit = false;
                object.canShare = false;
            }
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                object.encryptedFolderName = options.bytes === String ? $util.base64.encode(message.encryptedFolderName, 0, message.encryptedFolderName.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedFolderName) : message.encryptedFolderName;
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                object.manageUsers = message.manageUsers;
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                object.manageRecords = message.manageRecords;
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                object.canEdit = message.canEdit;
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                object.canShare = message.canShare;
            return object;
        };

        /**
         * Converts this SharedFolderFields to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderFields;
    })();

    Folder.SharedFolderFolderFields = (function() {

        /**
         * Properties of a SharedFolderFolderFields.
         * @memberof Folder
         * @interface ISharedFolderFolderFields
         * @property {Uint8Array|null} [sharedFolderUid] SharedFolderFolderFields sharedFolderUid
         */

        /**
         * Constructs a new SharedFolderFolderFields.
         * @memberof Folder
         * @classdesc Represents a SharedFolderFolderFields.
         * @implements ISharedFolderFolderFields
         * @constructor
         * @param {Folder.ISharedFolderFolderFields=} [properties] Properties to set
         */
        function SharedFolderFolderFields(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderFolderFields sharedFolderUid.
         * @member {Uint8Array} sharedFolderUid
         * @memberof Folder.SharedFolderFolderFields
         * @instance
         */
        SharedFolderFolderFields.prototype.sharedFolderUid = $util.newBuffer([]);

        /**
         * Creates a new SharedFolderFolderFields instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields=} [properties] Properties to set
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields instance
         */
        SharedFolderFolderFields.create = function create(properties) {
            return new SharedFolderFolderFields(properties);
        };

        /**
         * Encodes the specified SharedFolderFolderFields message. Does not implicitly {@link Folder.SharedFolderFolderFields.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields} message SharedFolderFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFolderFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sharedFolderUid);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderFolderFields message, length delimited. Does not implicitly {@link Folder.SharedFolderFolderFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields} message SharedFolderFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFolderFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderFolderFields message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFolderFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderFolderFields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sharedFolderUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderFolderFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFolderFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderFolderFields message.
         * @function verify
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderFolderFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                if (!(message.sharedFolderUid && typeof message.sharedFolderUid.length === "number" || $util.isString(message.sharedFolderUid)))
                    return "sharedFolderUid: buffer expected";
            return null;
        };

        /**
         * Creates a SharedFolderFolderFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         */
        SharedFolderFolderFields.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderFolderFields)
                return object;
            let message = new $root.Folder.SharedFolderFolderFields();
            if (object.sharedFolderUid != null)
                if (typeof object.sharedFolderUid === "string")
                    $util.base64.decode(object.sharedFolderUid, message.sharedFolderUid = $util.newBuffer($util.base64.length(object.sharedFolderUid)), 0);
                else if (object.sharedFolderUid.length)
                    message.sharedFolderUid = object.sharedFolderUid;
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderFolderFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.SharedFolderFolderFields} message SharedFolderFolderFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderFolderFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.sharedFolderUid = "";
                else {
                    object.sharedFolderUid = [];
                    if (options.bytes !== Array)
                        object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
                }
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                object.sharedFolderUid = options.bytes === String ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharedFolderUid) : message.sharedFolderUid;
            return object;
        };

        /**
         * Converts this SharedFolderFolderFields to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderFolderFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderFolderFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderFolderFields;
    })();

    Folder.FolderRequest = (function() {

        /**
         * Properties of a FolderRequest.
         * @memberof Folder
         * @interface IFolderRequest
         * @property {Uint8Array|null} [folderUid] FolderRequest folderUid
         * @property {Folder.FolderType|null} [folderType] FolderRequest folderType
         * @property {Uint8Array|null} [parentFolderUid] FolderRequest parentFolderUid
         * @property {Uint8Array|null} [folderData] FolderRequest folderData
         * @property {Uint8Array|null} [encryptedFolderKey] FolderRequest encryptedFolderKey
         * @property {Folder.ISharedFolderFields|null} [sharedFolderFields] FolderRequest sharedFolderFields
         * @property {Folder.ISharedFolderFolderFields|null} [sharedFolderFolderFields] FolderRequest sharedFolderFolderFields
         */

        /**
         * Constructs a new FolderRequest.
         * @memberof Folder
         * @classdesc Represents a FolderRequest.
         * @implements IFolderRequest
         * @constructor
         * @param {Folder.IFolderRequest=} [properties] Properties to set
         */
        function FolderRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FolderRequest folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderUid = $util.newBuffer([]);

        /**
         * FolderRequest folderType.
         * @member {Folder.FolderType} folderType
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderType = 0;

        /**
         * FolderRequest parentFolderUid.
         * @member {Uint8Array} parentFolderUid
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.parentFolderUid = $util.newBuffer([]);

        /**
         * FolderRequest folderData.
         * @member {Uint8Array} folderData
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderData = $util.newBuffer([]);

        /**
         * FolderRequest encryptedFolderKey.
         * @member {Uint8Array} encryptedFolderKey
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.encryptedFolderKey = $util.newBuffer([]);

        /**
         * FolderRequest sharedFolderFields.
         * @member {Folder.ISharedFolderFields|null|undefined} sharedFolderFields
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.sharedFolderFields = null;

        /**
         * FolderRequest sharedFolderFolderFields.
         * @member {Folder.ISharedFolderFolderFields|null|undefined} sharedFolderFolderFields
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.sharedFolderFolderFields = null;

        /**
         * Creates a new FolderRequest instance using the specified properties.
         * @function create
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest=} [properties] Properties to set
         * @returns {Folder.FolderRequest} FolderRequest instance
         */
        FolderRequest.create = function create(properties) {
            return new FolderRequest(properties);
        };

        /**
         * Encodes the specified FolderRequest message. Does not implicitly {@link Folder.FolderRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest} message FolderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.folderType);
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentFolderUid);
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.folderData);
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedFolderKey);
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields"))
                $root.Folder.SharedFolderFields.encode(message.sharedFolderFields, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields"))
                $root.Folder.SharedFolderFolderFields.encode(message.sharedFolderFolderFields, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FolderRequest message, length delimited. Does not implicitly {@link Folder.FolderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest} message FolderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FolderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.FolderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.FolderRequest} FolderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.FolderRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.folderType = reader.int32();
                    break;
                case 3:
                    message.parentFolderUid = reader.bytes();
                    break;
                case 4:
                    message.folderData = reader.bytes();
                    break;
                case 5:
                    message.encryptedFolderKey = reader.bytes();
                    break;
                case 6:
                    message.sharedFolderFields = $root.Folder.SharedFolderFields.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FolderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.FolderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.FolderRequest} FolderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FolderRequest message.
         * @function verify
         * @memberof Folder.FolderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FolderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                switch (message.folderType) {
                default:
                    return "folderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                if (!(message.parentFolderUid && typeof message.parentFolderUid.length === "number" || $util.isString(message.parentFolderUid)))
                    return "parentFolderUid: buffer expected";
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                if (!(message.folderData && typeof message.folderData.length === "number" || $util.isString(message.folderData)))
                    return "folderData: buffer expected";
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                if (!(message.encryptedFolderKey && typeof message.encryptedFolderKey.length === "number" || $util.isString(message.encryptedFolderKey)))
                    return "encryptedFolderKey: buffer expected";
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields")) {
                let error = $root.Folder.SharedFolderFields.verify(message.sharedFolderFields);
                if (error)
                    return "sharedFolderFields." + error;
            }
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields")) {
                let error = $root.Folder.SharedFolderFolderFields.verify(message.sharedFolderFolderFields);
                if (error)
                    return "sharedFolderFolderFields." + error;
            }
            return null;
        };

        /**
         * Creates a FolderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.FolderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.FolderRequest} FolderRequest
         */
        FolderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.FolderRequest)
                return object;
            let message = new $root.Folder.FolderRequest();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            switch (object.folderType) {
            case "default_folder":
            case 0:
                message.folderType = 0;
                break;
            case "user_folder":
            case 1:
                message.folderType = 1;
                break;
            case "shared_folder":
            case 2:
                message.folderType = 2;
                break;
            case "shared_folder_folder":
            case 3:
                message.folderType = 3;
                break;
            }
            if (object.parentFolderUid != null)
                if (typeof object.parentFolderUid === "string")
                    $util.base64.decode(object.parentFolderUid, message.parentFolderUid = $util.newBuffer($util.base64.length(object.parentFolderUid)), 0);
                else if (object.parentFolderUid.length)
                    message.parentFolderUid = object.parentFolderUid;
            if (object.folderData != null)
                if (typeof object.folderData === "string")
                    $util.base64.decode(object.folderData, message.folderData = $util.newBuffer($util.base64.length(object.folderData)), 0);
                else if (object.folderData.length)
                    message.folderData = object.folderData;
            if (object.encryptedFolderKey != null)
                if (typeof object.encryptedFolderKey === "string")
                    $util.base64.decode(object.encryptedFolderKey, message.encryptedFolderKey = $util.newBuffer($util.base64.length(object.encryptedFolderKey)), 0);
                else if (object.encryptedFolderKey.length)
                    message.encryptedFolderKey = object.encryptedFolderKey;
            if (object.sharedFolderFields != null) {
                if (typeof object.sharedFolderFields !== "object")
                    throw TypeError(".Folder.FolderRequest.sharedFolderFields: object expected");
                message.sharedFolderFields = $root.Folder.SharedFolderFields.fromObject(object.sharedFolderFields);
            }
            if (object.sharedFolderFolderFields != null) {
                if (typeof object.sharedFolderFolderFields !== "object")
                    throw TypeError(".Folder.FolderRequest.sharedFolderFolderFields: object expected");
                message.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.fromObject(object.sharedFolderFolderFields);
            }
            return message;
        };

        /**
         * Creates a plain object from a FolderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.FolderRequest} message FolderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FolderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                object.folderType = options.enums === String ? "default_folder" : 0;
                if (options.bytes === String)
                    object.parentFolderUid = "";
                else {
                    object.parentFolderUid = [];
                    if (options.bytes !== Array)
                        object.parentFolderUid = $util.newBuffer(object.parentFolderUid);
                }
                if (options.bytes === String)
                    object.folderData = "";
                else {
                    object.folderData = [];
                    if (options.bytes !== Array)
                        object.folderData = $util.newBuffer(object.folderData);
                }
                if (options.bytes === String)
                    object.encryptedFolderKey = "";
                else {
                    object.encryptedFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedFolderKey = $util.newBuffer(object.encryptedFolderKey);
                }
                object.sharedFolderFields = null;
                object.sharedFolderFolderFields = null;
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                object.folderType = options.enums === String ? $root.Folder.FolderType[message.folderType] : message.folderType;
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                object.parentFolderUid = options.bytes === String ? $util.base64.encode(message.parentFolderUid, 0, message.parentFolderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentFolderUid) : message.parentFolderUid;
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                object.folderData = options.bytes === String ? $util.base64.encode(message.folderData, 0, message.folderData.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderData) : message.folderData;
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                object.encryptedFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedFolderKey, 0, message.encryptedFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedFolderKey) : message.encryptedFolderKey;
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields"))
                object.sharedFolderFields = $root.Folder.SharedFolderFields.toObject(message.sharedFolderFields, options);
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields"))
                object.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.toObject(message.sharedFolderFolderFields, options);
            return object;
        };

        /**
         * Converts this FolderRequest to JSON.
         * @function toJSON
         * @memberof Folder.FolderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FolderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FolderRequest;
    })();

    Folder.FolderResponse = (function() {

        /**
         * Properties of a FolderResponse.
         * @memberof Folder
         * @interface IFolderResponse
         * @property {Uint8Array|null} [folderUid] FolderResponse folderUid
         * @property {number|Long|null} [revision] FolderResponse revision
         * @property {string|null} [status] FolderResponse status
         */

        /**
         * Constructs a new FolderResponse.
         * @memberof Folder
         * @classdesc Represents a FolderResponse.
         * @implements IFolderResponse
         * @constructor
         * @param {Folder.IFolderResponse=} [properties] Properties to set
         */
        function FolderResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FolderResponse folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.folderUid = $util.newBuffer([]);

        /**
         * FolderResponse revision.
         * @member {number|Long} revision
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FolderResponse status.
         * @member {string} status
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.status = "";

        /**
         * Creates a new FolderResponse instance using the specified properties.
         * @function create
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse=} [properties] Properties to set
         * @returns {Folder.FolderResponse} FolderResponse instance
         */
        FolderResponse.create = function create(properties) {
            return new FolderResponse(properties);
        };

        /**
         * Encodes the specified FolderResponse message. Does not implicitly {@link Folder.FolderResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse} message FolderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.revision);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            return writer;
        };

        /**
         * Encodes the specified FolderResponse message, length delimited. Does not implicitly {@link Folder.FolderResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse} message FolderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FolderResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.FolderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.FolderResponse} FolderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.FolderResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.revision = reader.int64();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FolderResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.FolderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.FolderResponse} FolderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FolderResponse message.
         * @function verify
         * @memberof Folder.FolderResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FolderResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            return null;
        };

        /**
         * Creates a FolderResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.FolderResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.FolderResponse} FolderResponse
         */
        FolderResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.FolderResponse)
                return object;
            let message = new $root.Folder.FolderResponse();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.status != null)
                message.status = String(object.status);
            return message;
        };

        /**
         * Creates a plain object from a FolderResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.FolderResponse} message FolderResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FolderResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.status = "";
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this FolderResponse to JSON.
         * @function toJSON
         * @memberof Folder.FolderResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FolderResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FolderResponse;
    })();

    Folder.ImportFolderRecordRequest = (function() {

        /**
         * Properties of an ImportFolderRecordRequest.
         * @memberof Folder
         * @interface IImportFolderRecordRequest
         * @property {Array.<Folder.IFolderRequest>|null} [folderRequest] ImportFolderRecordRequest folderRequest
         * @property {Array.<Folder.IRecordRequest>|null} [recordRequest] ImportFolderRecordRequest recordRequest
         */

        /**
         * Constructs a new ImportFolderRecordRequest.
         * @memberof Folder
         * @classdesc Represents an ImportFolderRecordRequest.
         * @implements IImportFolderRecordRequest
         * @constructor
         * @param {Folder.IImportFolderRecordRequest=} [properties] Properties to set
         */
        function ImportFolderRecordRequest(properties) {
            this.folderRequest = [];
            this.recordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportFolderRecordRequest folderRequest.
         * @member {Array.<Folder.IFolderRequest>} folderRequest
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         */
        ImportFolderRecordRequest.prototype.folderRequest = $util.emptyArray;

        /**
         * ImportFolderRecordRequest recordRequest.
         * @member {Array.<Folder.IRecordRequest>} recordRequest
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         */
        ImportFolderRecordRequest.prototype.recordRequest = $util.emptyArray;

        /**
         * Creates a new ImportFolderRecordRequest instance using the specified properties.
         * @function create
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest=} [properties] Properties to set
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest instance
         */
        ImportFolderRecordRequest.create = function create(properties) {
            return new ImportFolderRecordRequest(properties);
        };

        /**
         * Encodes the specified ImportFolderRecordRequest message. Does not implicitly {@link Folder.ImportFolderRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest} message ImportFolderRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderRequest != null && message.folderRequest.length)
                for (let i = 0; i < message.folderRequest.length; ++i)
                    $root.Folder.FolderRequest.encode(message.folderRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.recordRequest != null && message.recordRequest.length)
                for (let i = 0; i < message.recordRequest.length; ++i)
                    $root.Folder.RecordRequest.encode(message.recordRequest[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportFolderRecordRequest message, length delimited. Does not implicitly {@link Folder.ImportFolderRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest} message ImportFolderRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportFolderRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.ImportFolderRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.folderRequest && message.folderRequest.length))
                        message.folderRequest = [];
                    message.folderRequest.push($root.Folder.FolderRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.recordRequest && message.recordRequest.length))
                        message.recordRequest = [];
                    message.recordRequest.push($root.Folder.RecordRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportFolderRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportFolderRecordRequest message.
         * @function verify
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportFolderRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderRequest != null && message.hasOwnProperty("folderRequest")) {
                if (!Array.isArray(message.folderRequest))
                    return "folderRequest: array expected";
                for (let i = 0; i < message.folderRequest.length; ++i) {
                    let error = $root.Folder.FolderRequest.verify(message.folderRequest[i]);
                    if (error)
                        return "folderRequest." + error;
                }
            }
            if (message.recordRequest != null && message.hasOwnProperty("recordRequest")) {
                if (!Array.isArray(message.recordRequest))
                    return "recordRequest: array expected";
                for (let i = 0; i < message.recordRequest.length; ++i) {
                    let error = $root.Folder.RecordRequest.verify(message.recordRequest[i]);
                    if (error)
                        return "recordRequest." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportFolderRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         */
        ImportFolderRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.ImportFolderRecordRequest)
                return object;
            let message = new $root.Folder.ImportFolderRecordRequest();
            if (object.folderRequest) {
                if (!Array.isArray(object.folderRequest))
                    throw TypeError(".Folder.ImportFolderRecordRequest.folderRequest: array expected");
                message.folderRequest = [];
                for (let i = 0; i < object.folderRequest.length; ++i) {
                    if (typeof object.folderRequest[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordRequest.folderRequest: object expected");
                    message.folderRequest[i] = $root.Folder.FolderRequest.fromObject(object.folderRequest[i]);
                }
            }
            if (object.recordRequest) {
                if (!Array.isArray(object.recordRequest))
                    throw TypeError(".Folder.ImportFolderRecordRequest.recordRequest: array expected");
                message.recordRequest = [];
                for (let i = 0; i < object.recordRequest.length; ++i) {
                    if (typeof object.recordRequest[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordRequest.recordRequest: object expected");
                    message.recordRequest[i] = $root.Folder.RecordRequest.fromObject(object.recordRequest[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportFolderRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.ImportFolderRecordRequest} message ImportFolderRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportFolderRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.folderRequest = [];
                object.recordRequest = [];
            }
            if (message.folderRequest && message.folderRequest.length) {
                object.folderRequest = [];
                for (let j = 0; j < message.folderRequest.length; ++j)
                    object.folderRequest[j] = $root.Folder.FolderRequest.toObject(message.folderRequest[j], options);
            }
            if (message.recordRequest && message.recordRequest.length) {
                object.recordRequest = [];
                for (let j = 0; j < message.recordRequest.length; ++j)
                    object.recordRequest[j] = $root.Folder.RecordRequest.toObject(message.recordRequest[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportFolderRecordRequest to JSON.
         * @function toJSON
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportFolderRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportFolderRecordRequest;
    })();

    Folder.ImportFolderRecordResponse = (function() {

        /**
         * Properties of an ImportFolderRecordResponse.
         * @memberof Folder
         * @interface IImportFolderRecordResponse
         * @property {Array.<Folder.IFolderResponse>|null} [folderResponse] ImportFolderRecordResponse folderResponse
         * @property {Array.<Folder.IRecordResponse>|null} [recordResponse] ImportFolderRecordResponse recordResponse
         */

        /**
         * Constructs a new ImportFolderRecordResponse.
         * @memberof Folder
         * @classdesc Represents an ImportFolderRecordResponse.
         * @implements IImportFolderRecordResponse
         * @constructor
         * @param {Folder.IImportFolderRecordResponse=} [properties] Properties to set
         */
        function ImportFolderRecordResponse(properties) {
            this.folderResponse = [];
            this.recordResponse = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportFolderRecordResponse folderResponse.
         * @member {Array.<Folder.IFolderResponse>} folderResponse
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         */
        ImportFolderRecordResponse.prototype.folderResponse = $util.emptyArray;

        /**
         * ImportFolderRecordResponse recordResponse.
         * @member {Array.<Folder.IRecordResponse>} recordResponse
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         */
        ImportFolderRecordResponse.prototype.recordResponse = $util.emptyArray;

        /**
         * Creates a new ImportFolderRecordResponse instance using the specified properties.
         * @function create
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse=} [properties] Properties to set
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse instance
         */
        ImportFolderRecordResponse.create = function create(properties) {
            return new ImportFolderRecordResponse(properties);
        };

        /**
         * Encodes the specified ImportFolderRecordResponse message. Does not implicitly {@link Folder.ImportFolderRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse} message ImportFolderRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderResponse != null && message.folderResponse.length)
                for (let i = 0; i < message.folderResponse.length; ++i)
                    $root.Folder.FolderResponse.encode(message.folderResponse[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.recordResponse != null && message.recordResponse.length)
                for (let i = 0; i < message.recordResponse.length; ++i)
                    $root.Folder.RecordResponse.encode(message.recordResponse[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportFolderRecordResponse message, length delimited. Does not implicitly {@link Folder.ImportFolderRecordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse} message ImportFolderRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportFolderRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.ImportFolderRecordResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.folderResponse && message.folderResponse.length))
                        message.folderResponse = [];
                    message.folderResponse.push($root.Folder.FolderResponse.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.recordResponse && message.recordResponse.length))
                        message.recordResponse = [];
                    message.recordResponse.push($root.Folder.RecordResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportFolderRecordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportFolderRecordResponse message.
         * @function verify
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportFolderRecordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderResponse != null && message.hasOwnProperty("folderResponse")) {
                if (!Array.isArray(message.folderResponse))
                    return "folderResponse: array expected";
                for (let i = 0; i < message.folderResponse.length; ++i) {
                    let error = $root.Folder.FolderResponse.verify(message.folderResponse[i]);
                    if (error)
                        return "folderResponse." + error;
                }
            }
            if (message.recordResponse != null && message.hasOwnProperty("recordResponse")) {
                if (!Array.isArray(message.recordResponse))
                    return "recordResponse: array expected";
                for (let i = 0; i < message.recordResponse.length; ++i) {
                    let error = $root.Folder.RecordResponse.verify(message.recordResponse[i]);
                    if (error)
                        return "recordResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportFolderRecordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         */
        ImportFolderRecordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.ImportFolderRecordResponse)
                return object;
            let message = new $root.Folder.ImportFolderRecordResponse();
            if (object.folderResponse) {
                if (!Array.isArray(object.folderResponse))
                    throw TypeError(".Folder.ImportFolderRecordResponse.folderResponse: array expected");
                message.folderResponse = [];
                for (let i = 0; i < object.folderResponse.length; ++i) {
                    if (typeof object.folderResponse[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordResponse.folderResponse: object expected");
                    message.folderResponse[i] = $root.Folder.FolderResponse.fromObject(object.folderResponse[i]);
                }
            }
            if (object.recordResponse) {
                if (!Array.isArray(object.recordResponse))
                    throw TypeError(".Folder.ImportFolderRecordResponse.recordResponse: array expected");
                message.recordResponse = [];
                for (let i = 0; i < object.recordResponse.length; ++i) {
                    if (typeof object.recordResponse[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordResponse.recordResponse: object expected");
                    message.recordResponse[i] = $root.Folder.RecordResponse.fromObject(object.recordResponse[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportFolderRecordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.ImportFolderRecordResponse} message ImportFolderRecordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportFolderRecordResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.folderResponse = [];
                object.recordResponse = [];
            }
            if (message.folderResponse && message.folderResponse.length) {
                object.folderResponse = [];
                for (let j = 0; j < message.folderResponse.length; ++j)
                    object.folderResponse[j] = $root.Folder.FolderResponse.toObject(message.folderResponse[j], options);
            }
            if (message.recordResponse && message.recordResponse.length) {
                object.recordResponse = [];
                for (let j = 0; j < message.recordResponse.length; ++j)
                    object.recordResponse[j] = $root.Folder.RecordResponse.toObject(message.recordResponse[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportFolderRecordResponse to JSON.
         * @function toJSON
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportFolderRecordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportFolderRecordResponse;
    })();

    return Folder;
})();

export const Upsell = $root.Upsell = (() => {

    /**
     * Namespace Upsell.
     * @exports Upsell
     * @namespace
     */
    const Upsell = {};

    Upsell.UpsellRequest = (function() {

        /**
         * Properties of an UpsellRequest.
         * @memberof Upsell
         * @interface IUpsellRequest
         * @property {string|null} [email] UpsellRequest email
         * @property {string|null} [locale] UpsellRequest locale
         * @property {string|null} [clientVersion] UpsellRequest clientVersion
         * @property {string|null} [sessionToken] UpsellRequest sessionToken
         */

        /**
         * Constructs a new UpsellRequest.
         * @memberof Upsell
         * @classdesc Represents an UpsellRequest.
         * @implements IUpsellRequest
         * @constructor
         * @param {Upsell.IUpsellRequest=} [properties] Properties to set
         */
        function UpsellRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellRequest email.
         * @member {string} email
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.email = "";

        /**
         * UpsellRequest locale.
         * @member {string} locale
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.locale = "";

        /**
         * UpsellRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.clientVersion = "";

        /**
         * UpsellRequest sessionToken.
         * @member {string} sessionToken
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.sessionToken = "";

        /**
         * Creates a new UpsellRequest instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest=} [properties] Properties to set
         * @returns {Upsell.UpsellRequest} UpsellRequest instance
         */
        UpsellRequest.create = function create(properties) {
            return new UpsellRequest(properties);
        };

        /**
         * Encodes the specified UpsellRequest message. Does not implicitly {@link Upsell.UpsellRequest.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest} message UpsellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.locale);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sessionToken);
            return writer;
        };

        /**
         * Encodes the specified UpsellRequest message, length delimited. Does not implicitly {@link Upsell.UpsellRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest} message UpsellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellRequest} UpsellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.locale = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.sessionToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellRequest} UpsellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellRequest message.
         * @function verify
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                if (!$util.isString(message.sessionToken))
                    return "sessionToken: string expected";
            return null;
        };

        /**
         * Creates an UpsellRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellRequest} UpsellRequest
         */
        UpsellRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellRequest)
                return object;
            let message = new $root.Upsell.UpsellRequest();
            if (object.email != null)
                message.email = String(object.email);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.sessionToken != null)
                message.sessionToken = String(object.sessionToken);
            return message;
        };

        /**
         * Creates a plain object from an UpsellRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.UpsellRequest} message UpsellRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.locale = "";
                object.clientVersion = "";
                object.sessionToken = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                object.sessionToken = message.sessionToken;
            return object;
        };

        /**
         * Converts this UpsellRequest to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellRequest;
    })();

    Upsell.UpsellResponse = (function() {

        /**
         * Properties of an UpsellResponse.
         * @memberof Upsell
         * @interface IUpsellResponse
         * @property {Array.<Upsell.IUpsellBanner>|null} [UpsellBanner] UpsellResponse UpsellBanner
         */

        /**
         * Constructs a new UpsellResponse.
         * @memberof Upsell
         * @classdesc Represents an UpsellResponse.
         * @implements IUpsellResponse
         * @constructor
         * @param {Upsell.IUpsellResponse=} [properties] Properties to set
         */
        function UpsellResponse(properties) {
            this.UpsellBanner = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellResponse UpsellBanner.
         * @member {Array.<Upsell.IUpsellBanner>} UpsellBanner
         * @memberof Upsell.UpsellResponse
         * @instance
         */
        UpsellResponse.prototype.UpsellBanner = $util.emptyArray;

        /**
         * Creates a new UpsellResponse instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse=} [properties] Properties to set
         * @returns {Upsell.UpsellResponse} UpsellResponse instance
         */
        UpsellResponse.create = function create(properties) {
            return new UpsellResponse(properties);
        };

        /**
         * Encodes the specified UpsellResponse message. Does not implicitly {@link Upsell.UpsellResponse.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse} message UpsellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.UpsellBanner != null && message.UpsellBanner.length)
                for (let i = 0; i < message.UpsellBanner.length; ++i)
                    $root.Upsell.UpsellBanner.encode(message.UpsellBanner[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpsellResponse message, length delimited. Does not implicitly {@link Upsell.UpsellResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse} message UpsellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellResponse} UpsellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.UpsellBanner && message.UpsellBanner.length))
                        message.UpsellBanner = [];
                    message.UpsellBanner.push($root.Upsell.UpsellBanner.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellResponse} UpsellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellResponse message.
         * @function verify
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.UpsellBanner != null && message.hasOwnProperty("UpsellBanner")) {
                if (!Array.isArray(message.UpsellBanner))
                    return "UpsellBanner: array expected";
                for (let i = 0; i < message.UpsellBanner.length; ++i) {
                    let error = $root.Upsell.UpsellBanner.verify(message.UpsellBanner[i]);
                    if (error)
                        return "UpsellBanner." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UpsellResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellResponse} UpsellResponse
         */
        UpsellResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellResponse)
                return object;
            let message = new $root.Upsell.UpsellResponse();
            if (object.UpsellBanner) {
                if (!Array.isArray(object.UpsellBanner))
                    throw TypeError(".Upsell.UpsellResponse.UpsellBanner: array expected");
                message.UpsellBanner = [];
                for (let i = 0; i < object.UpsellBanner.length; ++i) {
                    if (typeof object.UpsellBanner[i] !== "object")
                        throw TypeError(".Upsell.UpsellResponse.UpsellBanner: object expected");
                    message.UpsellBanner[i] = $root.Upsell.UpsellBanner.fromObject(object.UpsellBanner[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UpsellResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.UpsellResponse} message UpsellResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.UpsellBanner = [];
            if (message.UpsellBanner && message.UpsellBanner.length) {
                object.UpsellBanner = [];
                for (let j = 0; j < message.UpsellBanner.length; ++j)
                    object.UpsellBanner[j] = $root.Upsell.UpsellBanner.toObject(message.UpsellBanner[j], options);
            }
            return object;
        };

        /**
         * Converts this UpsellResponse to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellResponse;
    })();

    Upsell.UpsellBanner = (function() {

        /**
         * Properties of an UpsellBanner.
         * @memberof Upsell
         * @interface IUpsellBanner
         * @property {number|null} [bannerId] UpsellBanner bannerId
         * @property {string|null} [bannerOkAction] UpsellBanner bannerOkAction
         * @property {string|null} [bannerOkButton] UpsellBanner bannerOkButton
         * @property {string|null} [bannerCancelAction] UpsellBanner bannerCancelAction
         * @property {string|null} [bannerCancelButton] UpsellBanner bannerCancelButton
         * @property {string|null} [bannerMessage] UpsellBanner bannerMessage
         * @property {string|null} [locale] UpsellBanner locale
         */

        /**
         * Constructs a new UpsellBanner.
         * @memberof Upsell
         * @classdesc Represents an UpsellBanner.
         * @implements IUpsellBanner
         * @constructor
         * @param {Upsell.IUpsellBanner=} [properties] Properties to set
         */
        function UpsellBanner(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellBanner bannerId.
         * @member {number} bannerId
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerId = 0;

        /**
         * UpsellBanner bannerOkAction.
         * @member {string} bannerOkAction
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerOkAction = "";

        /**
         * UpsellBanner bannerOkButton.
         * @member {string} bannerOkButton
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerOkButton = "";

        /**
         * UpsellBanner bannerCancelAction.
         * @member {string} bannerCancelAction
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerCancelAction = "";

        /**
         * UpsellBanner bannerCancelButton.
         * @member {string} bannerCancelButton
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerCancelButton = "";

        /**
         * UpsellBanner bannerMessage.
         * @member {string} bannerMessage
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerMessage = "";

        /**
         * UpsellBanner locale.
         * @member {string} locale
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.locale = "";

        /**
         * Creates a new UpsellBanner instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner=} [properties] Properties to set
         * @returns {Upsell.UpsellBanner} UpsellBanner instance
         */
        UpsellBanner.create = function create(properties) {
            return new UpsellBanner(properties);
        };

        /**
         * Encodes the specified UpsellBanner message. Does not implicitly {@link Upsell.UpsellBanner.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner} message UpsellBanner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellBanner.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bannerId);
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.bannerOkAction);
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.bannerOkButton);
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.bannerCancelAction);
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.bannerCancelButton);
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.bannerMessage);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.locale);
            return writer;
        };

        /**
         * Encodes the specified UpsellBanner message, length delimited. Does not implicitly {@link Upsell.UpsellBanner.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner} message UpsellBanner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellBanner.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellBanner message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellBanner} UpsellBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellBanner.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellBanner();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bannerId = reader.int32();
                    break;
                case 2:
                    message.bannerOkAction = reader.string();
                    break;
                case 3:
                    message.bannerOkButton = reader.string();
                    break;
                case 4:
                    message.bannerCancelAction = reader.string();
                    break;
                case 5:
                    message.bannerCancelButton = reader.string();
                    break;
                case 6:
                    message.bannerMessage = reader.string();
                    break;
                case 7:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellBanner message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellBanner} UpsellBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellBanner.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellBanner message.
         * @function verify
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellBanner.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                if (!$util.isInteger(message.bannerId))
                    return "bannerId: integer expected";
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                if (!$util.isString(message.bannerOkAction))
                    return "bannerOkAction: string expected";
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                if (!$util.isString(message.bannerOkButton))
                    return "bannerOkButton: string expected";
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                if (!$util.isString(message.bannerCancelAction))
                    return "bannerCancelAction: string expected";
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                if (!$util.isString(message.bannerCancelButton))
                    return "bannerCancelButton: string expected";
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                if (!$util.isString(message.bannerMessage))
                    return "bannerMessage: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            return null;
        };

        /**
         * Creates an UpsellBanner message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellBanner} UpsellBanner
         */
        UpsellBanner.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellBanner)
                return object;
            let message = new $root.Upsell.UpsellBanner();
            if (object.bannerId != null)
                message.bannerId = object.bannerId | 0;
            if (object.bannerOkAction != null)
                message.bannerOkAction = String(object.bannerOkAction);
            if (object.bannerOkButton != null)
                message.bannerOkButton = String(object.bannerOkButton);
            if (object.bannerCancelAction != null)
                message.bannerCancelAction = String(object.bannerCancelAction);
            if (object.bannerCancelButton != null)
                message.bannerCancelButton = String(object.bannerCancelButton);
            if (object.bannerMessage != null)
                message.bannerMessage = String(object.bannerMessage);
            if (object.locale != null)
                message.locale = String(object.locale);
            return message;
        };

        /**
         * Creates a plain object from an UpsellBanner message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.UpsellBanner} message UpsellBanner
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellBanner.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.bannerId = 0;
                object.bannerOkAction = "";
                object.bannerOkButton = "";
                object.bannerCancelAction = "";
                object.bannerCancelButton = "";
                object.bannerMessage = "";
                object.locale = "";
            }
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                object.bannerId = message.bannerId;
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                object.bannerOkAction = message.bannerOkAction;
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                object.bannerOkButton = message.bannerOkButton;
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                object.bannerCancelAction = message.bannerCancelAction;
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                object.bannerCancelButton = message.bannerCancelButton;
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                object.bannerMessage = message.bannerMessage;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            return object;
        };

        /**
         * Converts this UpsellBanner to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellBanner
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellBanner.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellBanner;
    })();

    /**
     * ClientType enum.
     * @name Upsell.ClientType
     * @enum {string}
     * @property {number} DEFAULT_CLIENT_TYPE=0 DEFAULT_CLIENT_TYPE value
     * @property {number} ALL=1 ALL value
     * @property {number} ANDROID=2 ANDROID value
     * @property {number} IOS=3 IOS value
     * @property {number} MICROSOFT=4 MICROSOFT value
     * @property {number} WEBAPP=5 WEBAPP value
     */
    Upsell.ClientType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_CLIENT_TYPE"] = 0;
        values[valuesById[1] = "ALL"] = 1;
        values[valuesById[2] = "ANDROID"] = 2;
        values[valuesById[3] = "IOS"] = 3;
        values[valuesById[4] = "MICROSOFT"] = 4;
        values[valuesById[5] = "WEBAPP"] = 5;
        return values;
    })();

    /**
     * ClientVersion enum.
     * @name Upsell.ClientVersion
     * @enum {string}
     * @property {number} DEFAULT_VERSION=0 DEFAULT_VERSION value
     * @property {number} SUPPORTS_ALL=1 SUPPORTS_ALL value
     * @property {number} BASEVERSION=14 BASEVERSION value
     * @property {number} ABOVERANGE=15 ABOVERANGE value
     */
    Upsell.ClientVersion = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_VERSION"] = 0;
        values[valuesById[1] = "SUPPORTS_ALL"] = 1;
        values[valuesById[14] = "BASEVERSION"] = 14;
        values[valuesById[15] = "ABOVERANGE"] = 15;
        return values;
    })();

    return Upsell;
})();

export { $root as default };
