/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const Authentication = $root.Authentication = (() => {

    /**
     * Namespace Authentication.
     * @exports Authentication
     * @namespace
     */
    const Authentication = {};

    /**
     * SupportedLanguage enum.
     * @name Authentication.SupportedLanguage
     * @enum {string}
     * @property {number} ENGLISH=0 ENGLISH value
     * @property {number} ARABIC=1 ARABIC value
     * @property {number} BRITISH=2 BRITISH value
     * @property {number} CHINESE=3 CHINESE value
     * @property {number} CHINESE_HONG_KONG=4 CHINESE_HONG_KONG value
     * @property {number} CHINESE_TAIWAN=5 CHINESE_TAIWAN value
     * @property {number} DUTCH=6 DUTCH value
     * @property {number} FRENCH=7 FRENCH value
     * @property {number} GERMAN=8 GERMAN value
     * @property {number} GREEK=9 GREEK value
     * @property {number} HEBREW=10 HEBREW value
     * @property {number} ITALIAN=11 ITALIAN value
     * @property {number} JAPANESE=12 JAPANESE value
     * @property {number} KOREAN=13 KOREAN value
     * @property {number} POLISH=14 POLISH value
     * @property {number} PORTUGUESE=15 PORTUGUESE value
     * @property {number} PORTUGUESE_BRAZIL=16 PORTUGUESE_BRAZIL value
     * @property {number} ROMANIAN=17 ROMANIAN value
     * @property {number} RUSSIAN=18 RUSSIAN value
     * @property {number} SLOVAK=19 SLOVAK value
     * @property {number} SPANISH=20 SPANISH value
     */
    Authentication.SupportedLanguage = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENGLISH"] = 0;
        values[valuesById[1] = "ARABIC"] = 1;
        values[valuesById[2] = "BRITISH"] = 2;
        values[valuesById[3] = "CHINESE"] = 3;
        values[valuesById[4] = "CHINESE_HONG_KONG"] = 4;
        values[valuesById[5] = "CHINESE_TAIWAN"] = 5;
        values[valuesById[6] = "DUTCH"] = 6;
        values[valuesById[7] = "FRENCH"] = 7;
        values[valuesById[8] = "GERMAN"] = 8;
        values[valuesById[9] = "GREEK"] = 9;
        values[valuesById[10] = "HEBREW"] = 10;
        values[valuesById[11] = "ITALIAN"] = 11;
        values[valuesById[12] = "JAPANESE"] = 12;
        values[valuesById[13] = "KOREAN"] = 13;
        values[valuesById[14] = "POLISH"] = 14;
        values[valuesById[15] = "PORTUGUESE"] = 15;
        values[valuesById[16] = "PORTUGUESE_BRAZIL"] = 16;
        values[valuesById[17] = "ROMANIAN"] = 17;
        values[valuesById[18] = "RUSSIAN"] = 18;
        values[valuesById[19] = "SLOVAK"] = 19;
        values[valuesById[20] = "SPANISH"] = 20;
        return values;
    })();

    /**
     * LoginType enum.
     * @name Authentication.LoginType
     * @enum {string}
     * @property {number} NORMAL=0 NORMAL value
     * @property {number} SSO=1 SSO value
     * @property {number} BIO=2 BIO value
     * @property {number} ALTERNATE=3 ALTERNATE value
     * @property {number} OFFLINE=4 OFFLINE value
     */
    Authentication.LoginType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NORMAL"] = 0;
        values[valuesById[1] = "SSO"] = 1;
        values[valuesById[2] = "BIO"] = 2;
        values[valuesById[3] = "ALTERNATE"] = 3;
        values[valuesById[4] = "OFFLINE"] = 4;
        return values;
    })();

    /**
     * DeviceStatus enum.
     * @name Authentication.DeviceStatus
     * @enum {string}
     * @property {number} DEVICE_NEEDS_APPROVAL=0 DEVICE_NEEDS_APPROVAL value
     * @property {number} DEVICE_OK=1 DEVICE_OK value
     * @property {number} DEVICE_DISABLED_BY_USER=2 DEVICE_DISABLED_BY_USER value
     * @property {number} DEVICE_LOCKED_BY_ADMIN=3 DEVICE_LOCKED_BY_ADMIN value
     */
    Authentication.DeviceStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEVICE_NEEDS_APPROVAL"] = 0;
        values[valuesById[1] = "DEVICE_OK"] = 1;
        values[valuesById[2] = "DEVICE_DISABLED_BY_USER"] = 2;
        values[valuesById[3] = "DEVICE_LOCKED_BY_ADMIN"] = 3;
        return values;
    })();

    /**
     * LicenseStatus enum.
     * @name Authentication.LicenseStatus
     * @enum {string}
     * @property {number} OTHER=0 OTHER value
     * @property {number} ACTIVE=1 ACTIVE value
     * @property {number} EXPIRED=2 EXPIRED value
     * @property {number} DISABLED=3 DISABLED value
     */
    Authentication.LicenseStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "OTHER"] = 0;
        values[valuesById[1] = "ACTIVE"] = 1;
        values[valuesById[2] = "EXPIRED"] = 2;
        values[valuesById[3] = "DISABLED"] = 3;
        return values;
    })();

    /**
     * AccountType enum.
     * @name Authentication.AccountType
     * @enum {string}
     * @property {number} CONSUMER=0 CONSUMER value
     * @property {number} FAMILY=1 FAMILY value
     * @property {number} ENTERPRISE=2 ENTERPRISE value
     */
    Authentication.AccountType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CONSUMER"] = 0;
        values[valuesById[1] = "FAMILY"] = 1;
        values[valuesById[2] = "ENTERPRISE"] = 2;
        return values;
    })();

    /**
     * SessionTokenType enum.
     * @name Authentication.SessionTokenType
     * @enum {string}
     * @property {number} NO_RESTRICTION=0 NO_RESTRICTION value
     * @property {number} ACCOUNT_RECOVERY=1 ACCOUNT_RECOVERY value
     * @property {number} SHARE_ACCOUNT=2 SHARE_ACCOUNT value
     * @property {number} PURCHASE=3 PURCHASE value
     * @property {number} RESTRICT=4 RESTRICT value
     * @property {number} ACCEPT_INVITE=5 ACCEPT_INVITE value
     * @property {number} SUPPORT_SERVER=6 SUPPORT_SERVER value
     * @property {number} ENTERPRISE_CREATION=7 ENTERPRISE_CREATION value
     * @property {number} EXPIRED_BUT_ALLOWED_TO_SYNC=8 EXPIRED_BUT_ALLOWED_TO_SYNC value
     */
    Authentication.SessionTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_RESTRICTION"] = 0;
        values[valuesById[1] = "ACCOUNT_RECOVERY"] = 1;
        values[valuesById[2] = "SHARE_ACCOUNT"] = 2;
        values[valuesById[3] = "PURCHASE"] = 3;
        values[valuesById[4] = "RESTRICT"] = 4;
        values[valuesById[5] = "ACCEPT_INVITE"] = 5;
        values[valuesById[6] = "SUPPORT_SERVER"] = 6;
        values[valuesById[7] = "ENTERPRISE_CREATION"] = 7;
        values[valuesById[8] = "EXPIRED_BUT_ALLOWED_TO_SYNC"] = 8;
        return values;
    })();

    /**
     * Version enum.
     * @name Authentication.Version
     * @enum {string}
     * @property {number} invalid_version=0 invalid_version value
     * @property {number} default_version=1 default_version value
     * @property {number} second_version=2 second_version value
     */
    Authentication.Version = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "invalid_version"] = 0;
        values[valuesById[1] = "default_version"] = 1;
        values[valuesById[2] = "second_version"] = 2;
        return values;
    })();

    /**
     * MasterPasswordReentryActionType enum.
     * @name Authentication.MasterPasswordReentryActionType
     * @enum {string}
     * @property {number} UNMASK=0 UNMASK value
     * @property {number} COPY=1 COPY value
     */
    Authentication.MasterPasswordReentryActionType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNMASK"] = 0;
        values[valuesById[1] = "COPY"] = 1;
        return values;
    })();

    Authentication.ApiRequest = (function() {

        /**
         * Properties of an ApiRequest.
         * @memberof Authentication
         * @interface IApiRequest
         * @property {Uint8Array|null} [encryptedTransmissionKey] ApiRequest encryptedTransmissionKey
         * @property {number|null} [publicKeyId] ApiRequest publicKeyId
         * @property {string|null} [locale] ApiRequest locale
         * @property {Uint8Array|null} [encryptedPayload] ApiRequest encryptedPayload
         * @property {number|null} [encryptionType] ApiRequest encryptionType
         * @property {string|null} [recaptcha] ApiRequest recaptcha
         * @property {string|null} [subEnvironment] ApiRequest subEnvironment
         */

        /**
         * Constructs a new ApiRequest.
         * @memberof Authentication
         * @classdesc Represents an ApiRequest.
         * @implements IApiRequest
         * @constructor
         * @param {Authentication.IApiRequest=} [properties] Properties to set
         */
        function ApiRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiRequest encryptedTransmissionKey.
         * @member {Uint8Array} encryptedTransmissionKey
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptedTransmissionKey = $util.newBuffer([]);

        /**
         * ApiRequest publicKeyId.
         * @member {number} publicKeyId
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.publicKeyId = 0;

        /**
         * ApiRequest locale.
         * @member {string} locale
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.locale = "";

        /**
         * ApiRequest encryptedPayload.
         * @member {Uint8Array} encryptedPayload
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptedPayload = $util.newBuffer([]);

        /**
         * ApiRequest encryptionType.
         * @member {number} encryptionType
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.encryptionType = 0;

        /**
         * ApiRequest recaptcha.
         * @member {string} recaptcha
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.recaptcha = "";

        /**
         * ApiRequest subEnvironment.
         * @member {string} subEnvironment
         * @memberof Authentication.ApiRequest
         * @instance
         */
        ApiRequest.prototype.subEnvironment = "";

        /**
         * Creates a new ApiRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest=} [properties] Properties to set
         * @returns {Authentication.ApiRequest} ApiRequest instance
         */
        ApiRequest.create = function create(properties) {
            return new ApiRequest(properties);
        };

        /**
         * Encodes the specified ApiRequest message. Does not implicitly {@link Authentication.ApiRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest} message ApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTransmissionKey);
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.publicKeyId);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPayload);
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.encryptionType);
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.recaptcha);
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.subEnvironment);
            return writer;
        };

        /**
         * Encodes the specified ApiRequest message, length delimited. Does not implicitly {@link Authentication.ApiRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.IApiRequest} message ApiRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApiRequest} ApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApiRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTransmissionKey = reader.bytes();
                    break;
                case 2:
                    message.publicKeyId = reader.int32();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                case 4:
                    message.encryptedPayload = reader.bytes();
                    break;
                case 5:
                    message.encryptionType = reader.int32();
                    break;
                case 6:
                    message.recaptcha = reader.string();
                    break;
                case 7:
                    message.subEnvironment = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApiRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApiRequest} ApiRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiRequest message.
         * @function verify
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                if (!(message.encryptedTransmissionKey && typeof message.encryptedTransmissionKey.length === "number" || $util.isString(message.encryptedTransmissionKey)))
                    return "encryptedTransmissionKey: buffer expected";
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                if (!$util.isInteger(message.publicKeyId))
                    return "publicKeyId: integer expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                if (!(message.encryptedPayload && typeof message.encryptedPayload.length === "number" || $util.isString(message.encryptedPayload)))
                    return "encryptedPayload: buffer expected";
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                if (!$util.isInteger(message.encryptionType))
                    return "encryptionType: integer expected";
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                if (!$util.isString(message.recaptcha))
                    return "recaptcha: string expected";
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                if (!$util.isString(message.subEnvironment))
                    return "subEnvironment: string expected";
            return null;
        };

        /**
         * Creates an ApiRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApiRequest} ApiRequest
         */
        ApiRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApiRequest)
                return object;
            let message = new $root.Authentication.ApiRequest();
            if (object.encryptedTransmissionKey != null)
                if (typeof object.encryptedTransmissionKey === "string")
                    $util.base64.decode(object.encryptedTransmissionKey, message.encryptedTransmissionKey = $util.newBuffer($util.base64.length(object.encryptedTransmissionKey)), 0);
                else if (object.encryptedTransmissionKey.length)
                    message.encryptedTransmissionKey = object.encryptedTransmissionKey;
            if (object.publicKeyId != null)
                message.publicKeyId = object.publicKeyId | 0;
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedPayload != null)
                if (typeof object.encryptedPayload === "string")
                    $util.base64.decode(object.encryptedPayload, message.encryptedPayload = $util.newBuffer($util.base64.length(object.encryptedPayload)), 0);
                else if (object.encryptedPayload.length)
                    message.encryptedPayload = object.encryptedPayload;
            if (object.encryptionType != null)
                message.encryptionType = object.encryptionType | 0;
            if (object.recaptcha != null)
                message.recaptcha = String(object.recaptcha);
            if (object.subEnvironment != null)
                message.subEnvironment = String(object.subEnvironment);
            return message;
        };

        /**
         * Creates a plain object from an ApiRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApiRequest
         * @static
         * @param {Authentication.ApiRequest} message ApiRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedTransmissionKey = "";
                else {
                    object.encryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTransmissionKey = $util.newBuffer(object.encryptedTransmissionKey);
                }
                object.publicKeyId = 0;
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedPayload = "";
                else {
                    object.encryptedPayload = [];
                    if (options.bytes !== Array)
                        object.encryptedPayload = $util.newBuffer(object.encryptedPayload);
                }
                object.encryptionType = 0;
                object.recaptcha = "";
                object.subEnvironment = "";
            }
            if (message.encryptedTransmissionKey != null && message.hasOwnProperty("encryptedTransmissionKey"))
                object.encryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.encryptedTransmissionKey, 0, message.encryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTransmissionKey) : message.encryptedTransmissionKey;
            if (message.publicKeyId != null && message.hasOwnProperty("publicKeyId"))
                object.publicKeyId = message.publicKeyId;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedPayload != null && message.hasOwnProperty("encryptedPayload"))
                object.encryptedPayload = options.bytes === String ? $util.base64.encode(message.encryptedPayload, 0, message.encryptedPayload.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPayload) : message.encryptedPayload;
            if (message.encryptionType != null && message.hasOwnProperty("encryptionType"))
                object.encryptionType = message.encryptionType;
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                object.recaptcha = message.recaptcha;
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                object.subEnvironment = message.subEnvironment;
            return object;
        };

        /**
         * Converts this ApiRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ApiRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiRequest;
    })();

    Authentication.ApiRequestPayload = (function() {

        /**
         * Properties of an ApiRequestPayload.
         * @memberof Authentication
         * @interface IApiRequestPayload
         * @property {Uint8Array|null} [payload] ApiRequestPayload payload
         * @property {Uint8Array|null} [encryptedSessionToken] ApiRequestPayload encryptedSessionToken
         * @property {Uint8Array|null} [timeToken] ApiRequestPayload timeToken
         * @property {number|null} [apiVersion] ApiRequestPayload apiVersion
         */

        /**
         * Constructs a new ApiRequestPayload.
         * @memberof Authentication
         * @classdesc Represents an ApiRequestPayload.
         * @implements IApiRequestPayload
         * @constructor
         * @param {Authentication.IApiRequestPayload=} [properties] Properties to set
         */
        function ApiRequestPayload(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiRequestPayload payload.
         * @member {Uint8Array} payload
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.payload = $util.newBuffer([]);

        /**
         * ApiRequestPayload encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * ApiRequestPayload timeToken.
         * @member {Uint8Array} timeToken
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.timeToken = $util.newBuffer([]);

        /**
         * ApiRequestPayload apiVersion.
         * @member {number} apiVersion
         * @memberof Authentication.ApiRequestPayload
         * @instance
         */
        ApiRequestPayload.prototype.apiVersion = 0;

        /**
         * Creates a new ApiRequestPayload instance using the specified properties.
         * @function create
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload=} [properties] Properties to set
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload instance
         */
        ApiRequestPayload.create = function create(properties) {
            return new ApiRequestPayload(properties);
        };

        /**
         * Encodes the specified ApiRequestPayload message. Does not implicitly {@link Authentication.ApiRequestPayload.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload} message ApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestPayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payload);
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedSessionToken);
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.timeToken);
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.apiVersion);
            return writer;
        };

        /**
         * Encodes the specified ApiRequestPayload message, length delimited. Does not implicitly {@link Authentication.ApiRequestPayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.IApiRequestPayload} message ApiRequestPayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestPayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiRequestPayload message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestPayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApiRequestPayload();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 3:
                    message.timeToken = reader.bytes();
                    break;
                case 4:
                    message.apiVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiRequestPayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestPayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiRequestPayload message.
         * @function verify
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiRequestPayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                if (!(message.timeToken && typeof message.timeToken.length === "number" || $util.isString(message.timeToken)))
                    return "timeToken: buffer expected";
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                if (!$util.isInteger(message.apiVersion))
                    return "apiVersion: integer expected";
            return null;
        };

        /**
         * Creates an ApiRequestPayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApiRequestPayload} ApiRequestPayload
         */
        ApiRequestPayload.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApiRequestPayload)
                return object;
            let message = new $root.Authentication.ApiRequestPayload();
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.timeToken != null)
                if (typeof object.timeToken === "string")
                    $util.base64.decode(object.timeToken, message.timeToken = $util.newBuffer($util.base64.length(object.timeToken)), 0);
                else if (object.timeToken.length)
                    message.timeToken = object.timeToken;
            if (object.apiVersion != null)
                message.apiVersion = object.apiVersion | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApiRequestPayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApiRequestPayload
         * @static
         * @param {Authentication.ApiRequestPayload} message ApiRequestPayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiRequestPayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                if (options.bytes === String)
                    object.timeToken = "";
                else {
                    object.timeToken = [];
                    if (options.bytes !== Array)
                        object.timeToken = $util.newBuffer(object.timeToken);
                }
                object.apiVersion = 0;
            }
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.timeToken != null && message.hasOwnProperty("timeToken"))
                object.timeToken = options.bytes === String ? $util.base64.encode(message.timeToken, 0, message.timeToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.timeToken) : message.timeToken;
            if (message.apiVersion != null && message.hasOwnProperty("apiVersion"))
                object.apiVersion = message.apiVersion;
            return object;
        };

        /**
         * Converts this ApiRequestPayload to JSON.
         * @function toJSON
         * @memberof Authentication.ApiRequestPayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiRequestPayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiRequestPayload;
    })();

    Authentication.Transform = (function() {

        /**
         * Properties of a Transform.
         * @memberof Authentication
         * @interface ITransform
         * @property {Uint8Array|null} [key] Transform key
         * @property {Uint8Array|null} [encryptedDeviceToken] Transform encryptedDeviceToken
         */

        /**
         * Constructs a new Transform.
         * @memberof Authentication
         * @classdesc Represents a Transform.
         * @implements ITransform
         * @constructor
         * @param {Authentication.ITransform=} [properties] Properties to set
         */
        function Transform(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transform key.
         * @member {Uint8Array} key
         * @memberof Authentication.Transform
         * @instance
         */
        Transform.prototype.key = $util.newBuffer([]);

        /**
         * Transform encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.Transform
         * @instance
         */
        Transform.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new Transform instance using the specified properties.
         * @function create
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform=} [properties] Properties to set
         * @returns {Authentication.Transform} Transform instance
         */
        Transform.create = function create(properties) {
            return new Transform(properties);
        };

        /**
         * Encodes the specified Transform message. Does not implicitly {@link Authentication.Transform.verify|verify} messages.
         * @function encode
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified Transform message, length delimited. Does not implicitly {@link Authentication.Transform.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.ITransform} message Transform message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transform.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transform message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.Transform();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transform message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.Transform
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.Transform} Transform
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transform.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transform message.
         * @function verify
         * @memberof Authentication.Transform
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transform.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a Transform message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.Transform
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.Transform} Transform
         */
        Transform.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.Transform)
                return object;
            let message = new $root.Authentication.Transform();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a Transform message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.Transform
         * @static
         * @param {Authentication.Transform} message Transform
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transform.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this Transform to JSON.
         * @function toJSON
         * @memberof Authentication.Transform
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transform.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transform;
    })();

    Authentication.DeviceRequest = (function() {

        /**
         * Properties of a DeviceRequest.
         * @memberof Authentication
         * @interface IDeviceRequest
         * @property {string|null} [clientVersion] DeviceRequest clientVersion
         * @property {string|null} [deviceName] DeviceRequest deviceName
         */

        /**
         * Constructs a new DeviceRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceRequest.
         * @implements IDeviceRequest
         * @constructor
         * @param {Authentication.IDeviceRequest=} [properties] Properties to set
         */
        function DeviceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.clientVersion = "";

        /**
         * DeviceRequest deviceName.
         * @member {string} deviceName
         * @memberof Authentication.DeviceRequest
         * @instance
         */
        DeviceRequest.prototype.deviceName = "";

        /**
         * Creates a new DeviceRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceRequest} DeviceRequest instance
         */
        DeviceRequest.create = function create(properties) {
            return new DeviceRequest(properties);
        };

        /**
         * Encodes the specified DeviceRequest message. Does not implicitly {@link Authentication.DeviceRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            return writer;
        };

        /**
         * Encodes the specified DeviceRequest message, length delimited. Does not implicitly {@link Authentication.DeviceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.IDeviceRequest} message DeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceRequest} DeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRequest message.
         * @function verify
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            return null;
        };

        /**
         * Creates a DeviceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceRequest} DeviceRequest
         */
        DeviceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceRequest)
                return object;
            let message = new $root.Authentication.DeviceRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            return message;
        };

        /**
         * Creates a plain object from a DeviceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceRequest
         * @static
         * @param {Authentication.DeviceRequest} message DeviceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.deviceName = "";
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            return object;
        };

        /**
         * Converts this DeviceRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRequest;
    })();

    Authentication.AuthRequest = (function() {

        /**
         * Properties of an AuthRequest.
         * @memberof Authentication
         * @interface IAuthRequest
         * @property {string|null} [clientVersion] AuthRequest clientVersion
         * @property {string|null} [username] AuthRequest username
         * @property {Uint8Array|null} [encryptedDeviceToken] AuthRequest encryptedDeviceToken
         */

        /**
         * Constructs a new AuthRequest.
         * @memberof Authentication
         * @classdesc Represents an AuthRequest.
         * @implements IAuthRequest
         * @constructor
         * @param {Authentication.IAuthRequest=} [properties] Properties to set
         */
        function AuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AuthRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.clientVersion = "";

        /**
         * AuthRequest username.
         * @member {string} username
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.username = "";

        /**
         * AuthRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.AuthRequest
         * @instance
         */
        AuthRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new AuthRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest=} [properties] Properties to set
         * @returns {Authentication.AuthRequest} AuthRequest instance
         */
        AuthRequest.create = function create(properties) {
            return new AuthRequest(properties);
        };

        /**
         * Encodes the specified AuthRequest message. Does not implicitly {@link Authentication.AuthRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified AuthRequest message, length delimited. Does not implicitly {@link Authentication.AuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.IAuthRequest} message AuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.AuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.AuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.AuthRequest} AuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AuthRequest message.
         * @function verify
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates an AuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.AuthRequest} AuthRequest
         */
        AuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.AuthRequest)
                return object;
            let message = new $root.Authentication.AuthRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.username != null)
                message.username = String(object.username);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from an AuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.AuthRequest
         * @static
         * @param {Authentication.AuthRequest} message AuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.username = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this AuthRequest to JSON.
         * @function toJSON
         * @memberof Authentication.AuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AuthRequest;
    })();

    Authentication.NewUserMinimumParams = (function() {

        /**
         * Properties of a NewUserMinimumParams.
         * @memberof Authentication
         * @interface INewUserMinimumParams
         * @property {number|null} [minimumIterations] NewUserMinimumParams minimumIterations
         * @property {Array.<string>|null} [passwordMatchRegex] NewUserMinimumParams passwordMatchRegex
         * @property {Array.<string>|null} [passwordMatchDescription] NewUserMinimumParams passwordMatchDescription
         * @property {boolean|null} [isEnterpriseDomain] NewUserMinimumParams isEnterpriseDomain
         */

        /**
         * Constructs a new NewUserMinimumParams.
         * @memberof Authentication
         * @classdesc Represents a NewUserMinimumParams.
         * @implements INewUserMinimumParams
         * @constructor
         * @param {Authentication.INewUserMinimumParams=} [properties] Properties to set
         */
        function NewUserMinimumParams(properties) {
            this.passwordMatchRegex = [];
            this.passwordMatchDescription = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewUserMinimumParams minimumIterations.
         * @member {number} minimumIterations
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.minimumIterations = 0;

        /**
         * NewUserMinimumParams passwordMatchRegex.
         * @member {Array.<string>} passwordMatchRegex
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.passwordMatchRegex = $util.emptyArray;

        /**
         * NewUserMinimumParams passwordMatchDescription.
         * @member {Array.<string>} passwordMatchDescription
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.passwordMatchDescription = $util.emptyArray;

        /**
         * NewUserMinimumParams isEnterpriseDomain.
         * @member {boolean} isEnterpriseDomain
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         */
        NewUserMinimumParams.prototype.isEnterpriseDomain = false;

        /**
         * Creates a new NewUserMinimumParams instance using the specified properties.
         * @function create
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams=} [properties] Properties to set
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams instance
         */
        NewUserMinimumParams.create = function create(properties) {
            return new NewUserMinimumParams(properties);
        };

        /**
         * Encodes the specified NewUserMinimumParams message. Does not implicitly {@link Authentication.NewUserMinimumParams.verify|verify} messages.
         * @function encode
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams} message NewUserMinimumParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewUserMinimumParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minimumIterations);
            if (message.passwordMatchRegex != null && message.passwordMatchRegex.length)
                for (let i = 0; i < message.passwordMatchRegex.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.passwordMatchRegex[i]);
            if (message.passwordMatchDescription != null && message.passwordMatchDescription.length)
                for (let i = 0; i < message.passwordMatchDescription.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.passwordMatchDescription[i]);
            if (message.isEnterpriseDomain != null && message.hasOwnProperty("isEnterpriseDomain"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isEnterpriseDomain);
            return writer;
        };

        /**
         * Encodes the specified NewUserMinimumParams message, length delimited. Does not implicitly {@link Authentication.NewUserMinimumParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.INewUserMinimumParams} message NewUserMinimumParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewUserMinimumParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewUserMinimumParams message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewUserMinimumParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.NewUserMinimumParams();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minimumIterations = reader.int32();
                    break;
                case 2:
                    if (!(message.passwordMatchRegex && message.passwordMatchRegex.length))
                        message.passwordMatchRegex = [];
                    message.passwordMatchRegex.push(reader.string());
                    break;
                case 3:
                    if (!(message.passwordMatchDescription && message.passwordMatchDescription.length))
                        message.passwordMatchDescription = [];
                    message.passwordMatchDescription.push(reader.string());
                    break;
                case 4:
                    message.isEnterpriseDomain = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewUserMinimumParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewUserMinimumParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewUserMinimumParams message.
         * @function verify
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewUserMinimumParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                if (!$util.isInteger(message.minimumIterations))
                    return "minimumIterations: integer expected";
            if (message.passwordMatchRegex != null && message.hasOwnProperty("passwordMatchRegex")) {
                if (!Array.isArray(message.passwordMatchRegex))
                    return "passwordMatchRegex: array expected";
                for (let i = 0; i < message.passwordMatchRegex.length; ++i)
                    if (!$util.isString(message.passwordMatchRegex[i]))
                        return "passwordMatchRegex: string[] expected";
            }
            if (message.passwordMatchDescription != null && message.hasOwnProperty("passwordMatchDescription")) {
                if (!Array.isArray(message.passwordMatchDescription))
                    return "passwordMatchDescription: array expected";
                for (let i = 0; i < message.passwordMatchDescription.length; ++i)
                    if (!$util.isString(message.passwordMatchDescription[i]))
                        return "passwordMatchDescription: string[] expected";
            }
            if (message.isEnterpriseDomain != null && message.hasOwnProperty("isEnterpriseDomain"))
                if (typeof message.isEnterpriseDomain !== "boolean")
                    return "isEnterpriseDomain: boolean expected";
            return null;
        };

        /**
         * Creates a NewUserMinimumParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.NewUserMinimumParams} NewUserMinimumParams
         */
        NewUserMinimumParams.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.NewUserMinimumParams)
                return object;
            let message = new $root.Authentication.NewUserMinimumParams();
            if (object.minimumIterations != null)
                message.minimumIterations = object.minimumIterations | 0;
            if (object.passwordMatchRegex) {
                if (!Array.isArray(object.passwordMatchRegex))
                    throw TypeError(".Authentication.NewUserMinimumParams.passwordMatchRegex: array expected");
                message.passwordMatchRegex = [];
                for (let i = 0; i < object.passwordMatchRegex.length; ++i)
                    message.passwordMatchRegex[i] = String(object.passwordMatchRegex[i]);
            }
            if (object.passwordMatchDescription) {
                if (!Array.isArray(object.passwordMatchDescription))
                    throw TypeError(".Authentication.NewUserMinimumParams.passwordMatchDescription: array expected");
                message.passwordMatchDescription = [];
                for (let i = 0; i < object.passwordMatchDescription.length; ++i)
                    message.passwordMatchDescription[i] = String(object.passwordMatchDescription[i]);
            }
            if (object.isEnterpriseDomain != null)
                message.isEnterpriseDomain = Boolean(object.isEnterpriseDomain);
            return message;
        };

        /**
         * Creates a plain object from a NewUserMinimumParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.NewUserMinimumParams
         * @static
         * @param {Authentication.NewUserMinimumParams} message NewUserMinimumParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewUserMinimumParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.passwordMatchRegex = [];
                object.passwordMatchDescription = [];
            }
            if (options.defaults) {
                object.minimumIterations = 0;
                object.isEnterpriseDomain = false;
            }
            if (message.minimumIterations != null && message.hasOwnProperty("minimumIterations"))
                object.minimumIterations = message.minimumIterations;
            if (message.passwordMatchRegex && message.passwordMatchRegex.length) {
                object.passwordMatchRegex = [];
                for (let j = 0; j < message.passwordMatchRegex.length; ++j)
                    object.passwordMatchRegex[j] = message.passwordMatchRegex[j];
            }
            if (message.passwordMatchDescription && message.passwordMatchDescription.length) {
                object.passwordMatchDescription = [];
                for (let j = 0; j < message.passwordMatchDescription.length; ++j)
                    object.passwordMatchDescription[j] = message.passwordMatchDescription[j];
            }
            if (message.isEnterpriseDomain != null && message.hasOwnProperty("isEnterpriseDomain"))
                object.isEnterpriseDomain = message.isEnterpriseDomain;
            return object;
        };

        /**
         * Converts this NewUserMinimumParams to JSON.
         * @function toJSON
         * @memberof Authentication.NewUserMinimumParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewUserMinimumParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewUserMinimumParams;
    })();

    Authentication.PreLoginRequest = (function() {

        /**
         * Properties of a PreLoginRequest.
         * @memberof Authentication
         * @interface IPreLoginRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] PreLoginRequest authRequest
         * @property {Authentication.LoginType|null} [loginType] PreLoginRequest loginType
         * @property {Uint8Array|null} [twoFactorToken] PreLoginRequest twoFactorToken
         */

        /**
         * Constructs a new PreLoginRequest.
         * @memberof Authentication
         * @classdesc Represents a PreLoginRequest.
         * @implements IPreLoginRequest
         * @constructor
         * @param {Authentication.IPreLoginRequest=} [properties] Properties to set
         */
        function PreLoginRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreLoginRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.authRequest = null;

        /**
         * PreLoginRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.loginType = 0;

        /**
         * PreLoginRequest twoFactorToken.
         * @member {Uint8Array} twoFactorToken
         * @memberof Authentication.PreLoginRequest
         * @instance
         */
        PreLoginRequest.prototype.twoFactorToken = $util.newBuffer([]);

        /**
         * Creates a new PreLoginRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest=} [properties] Properties to set
         * @returns {Authentication.PreLoginRequest} PreLoginRequest instance
         */
        PreLoginRequest.create = function create(properties) {
            return new PreLoginRequest(properties);
        };

        /**
         * Encodes the specified PreLoginRequest message. Does not implicitly {@link Authentication.PreLoginRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest} message PreLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.loginType);
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.twoFactorToken);
            return writer;
        };

        /**
         * Encodes the specified PreLoginRequest message, length delimited. Does not implicitly {@link Authentication.PreLoginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.IPreLoginRequest} message PreLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreLoginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.PreLoginRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.loginType = reader.int32();
                    break;
                case 3:
                    message.twoFactorToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreLoginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreLoginRequest message.
         * @function verify
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreLoginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                if (!(message.twoFactorToken && typeof message.twoFactorToken.length === "number" || $util.isString(message.twoFactorToken)))
                    return "twoFactorToken: buffer expected";
            return null;
        };

        /**
         * Creates a PreLoginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.PreLoginRequest} PreLoginRequest
         */
        PreLoginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.PreLoginRequest)
                return object;
            let message = new $root.Authentication.PreLoginRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.PreLoginRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.twoFactorToken != null)
                if (typeof object.twoFactorToken === "string")
                    $util.base64.decode(object.twoFactorToken, message.twoFactorToken = $util.newBuffer($util.base64.length(object.twoFactorToken)), 0);
                else if (object.twoFactorToken.length)
                    message.twoFactorToken = object.twoFactorToken;
            return message;
        };

        /**
         * Creates a plain object from a PreLoginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.PreLoginRequest
         * @static
         * @param {Authentication.PreLoginRequest} message PreLoginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreLoginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.loginType = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.twoFactorToken = "";
                else {
                    object.twoFactorToken = [];
                    if (options.bytes !== Array)
                        object.twoFactorToken = $util.newBuffer(object.twoFactorToken);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.twoFactorToken != null && message.hasOwnProperty("twoFactorToken"))
                object.twoFactorToken = options.bytes === String ? $util.base64.encode(message.twoFactorToken, 0, message.twoFactorToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.twoFactorToken) : message.twoFactorToken;
            return object;
        };

        /**
         * Converts this PreLoginRequest to JSON.
         * @function toJSON
         * @memberof Authentication.PreLoginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreLoginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreLoginRequest;
    })();

    Authentication.LoginRequest = (function() {

        /**
         * Properties of a LoginRequest.
         * @memberof Authentication
         * @interface ILoginRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] LoginRequest authRequest
         * @property {Authentication.LoginType|null} [loginType] LoginRequest loginType
         * @property {Uint8Array|null} [authenticationHashPrime] LoginRequest authenticationHashPrime
         * @property {Uint8Array|null} [encryptedLoginToken] LoginRequest encryptedLoginToken
         * @property {Uint8Array|null} [authResponse] LoginRequest authResponse
         * @property {number|null} [mcEnterpriseId] LoginRequest mcEnterpriseId
         * @property {string|null} [pushToken] LoginRequest pushToken
         * @property {string|null} [platform] LoginRequest platform
         */

        /**
         * Constructs a new LoginRequest.
         * @memberof Authentication
         * @classdesc Represents a LoginRequest.
         * @implements ILoginRequest
         * @constructor
         * @param {Authentication.ILoginRequest=} [properties] Properties to set
         */
        function LoginRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.authRequest = null;

        /**
         * LoginRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.loginType = 0;

        /**
         * LoginRequest authenticationHashPrime.
         * @member {Uint8Array} authenticationHashPrime
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.authenticationHashPrime = $util.newBuffer([]);

        /**
         * LoginRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * LoginRequest authResponse.
         * @member {Uint8Array} authResponse
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.authResponse = $util.newBuffer([]);

        /**
         * LoginRequest mcEnterpriseId.
         * @member {number} mcEnterpriseId
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.mcEnterpriseId = 0;

        /**
         * LoginRequest pushToken.
         * @member {string} pushToken
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.pushToken = "";

        /**
         * LoginRequest platform.
         * @member {string} platform
         * @memberof Authentication.LoginRequest
         * @instance
         */
        LoginRequest.prototype.platform = "";

        /**
         * Creates a new LoginRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest=} [properties] Properties to set
         * @returns {Authentication.LoginRequest} LoginRequest instance
         */
        LoginRequest.create = function create(properties) {
            return new LoginRequest(properties);
        };

        /**
         * Encodes the specified LoginRequest message. Does not implicitly {@link Authentication.LoginRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest} message LoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.loginType);
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.authenticationHashPrime);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedLoginToken);
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.authResponse);
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.mcEnterpriseId);
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.pushToken);
            if (message.platform != null && message.hasOwnProperty("platform"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.platform);
            return writer;
        };

        /**
         * Encodes the specified LoginRequest message, length delimited. Does not implicitly {@link Authentication.LoginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.ILoginRequest} message LoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginRequest} LoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.loginType = reader.int32();
                    break;
                case 3:
                    message.authenticationHashPrime = reader.bytes();
                    break;
                case 4:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 5:
                    message.authResponse = reader.bytes();
                    break;
                case 6:
                    message.mcEnterpriseId = reader.int32();
                    break;
                case 7:
                    message.pushToken = reader.string();
                    break;
                case 8:
                    message.platform = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginRequest} LoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginRequest message.
         * @function verify
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                if (!(message.authenticationHashPrime && typeof message.authenticationHashPrime.length === "number" || $util.isString(message.authenticationHashPrime)))
                    return "authenticationHashPrime: buffer expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                if (!(message.authResponse && typeof message.authResponse.length === "number" || $util.isString(message.authResponse)))
                    return "authResponse: buffer expected";
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                if (!$util.isInteger(message.mcEnterpriseId))
                    return "mcEnterpriseId: integer expected";
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                if (!$util.isString(message.pushToken))
                    return "pushToken: string expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                if (!$util.isString(message.platform))
                    return "platform: string expected";
            return null;
        };

        /**
         * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginRequest} LoginRequest
         */
        LoginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginRequest)
                return object;
            let message = new $root.Authentication.LoginRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.LoginRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.authenticationHashPrime != null)
                if (typeof object.authenticationHashPrime === "string")
                    $util.base64.decode(object.authenticationHashPrime, message.authenticationHashPrime = $util.newBuffer($util.base64.length(object.authenticationHashPrime)), 0);
                else if (object.authenticationHashPrime.length)
                    message.authenticationHashPrime = object.authenticationHashPrime;
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            if (object.authResponse != null)
                if (typeof object.authResponse === "string")
                    $util.base64.decode(object.authResponse, message.authResponse = $util.newBuffer($util.base64.length(object.authResponse)), 0);
                else if (object.authResponse.length)
                    message.authResponse = object.authResponse;
            if (object.mcEnterpriseId != null)
                message.mcEnterpriseId = object.mcEnterpriseId | 0;
            if (object.pushToken != null)
                message.pushToken = String(object.pushToken);
            if (object.platform != null)
                message.platform = String(object.platform);
            return message;
        };

        /**
         * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginRequest
         * @static
         * @param {Authentication.LoginRequest} message LoginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.loginType = options.enums === String ? "NORMAL" : 0;
                if (options.bytes === String)
                    object.authenticationHashPrime = "";
                else {
                    object.authenticationHashPrime = [];
                    if (options.bytes !== Array)
                        object.authenticationHashPrime = $util.newBuffer(object.authenticationHashPrime);
                }
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                if (options.bytes === String)
                    object.authResponse = "";
                else {
                    object.authResponse = [];
                    if (options.bytes !== Array)
                        object.authResponse = $util.newBuffer(object.authResponse);
                }
                object.mcEnterpriseId = 0;
                object.pushToken = "";
                object.platform = "";
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.authenticationHashPrime != null && message.hasOwnProperty("authenticationHashPrime"))
                object.authenticationHashPrime = options.bytes === String ? $util.base64.encode(message.authenticationHashPrime, 0, message.authenticationHashPrime.length) : options.bytes === Array ? Array.prototype.slice.call(message.authenticationHashPrime) : message.authenticationHashPrime;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                object.authResponse = options.bytes === String ? $util.base64.encode(message.authResponse, 0, message.authResponse.length) : options.bytes === Array ? Array.prototype.slice.call(message.authResponse) : message.authResponse;
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                object.mcEnterpriseId = message.mcEnterpriseId;
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                object.pushToken = message.pushToken;
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = message.platform;
            return object;
        };

        /**
         * Converts this LoginRequest to JSON.
         * @function toJSON
         * @memberof Authentication.LoginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginRequest;
    })();

    Authentication.DeviceResponse = (function() {

        /**
         * Properties of a DeviceResponse.
         * @memberof Authentication
         * @interface IDeviceResponse
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceResponse encryptedDeviceToken
         * @property {Authentication.DeviceStatus|null} [status] DeviceResponse status
         */

        /**
         * Constructs a new DeviceResponse.
         * @memberof Authentication
         * @classdesc Represents a DeviceResponse.
         * @implements IDeviceResponse
         * @constructor
         * @param {Authentication.IDeviceResponse=} [properties] Properties to set
         */
        function DeviceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceResponse encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceResponse
         * @instance
         */
        DeviceResponse.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceResponse status.
         * @member {Authentication.DeviceStatus} status
         * @memberof Authentication.DeviceResponse
         * @instance
         */
        DeviceResponse.prototype.status = 0;

        /**
         * Creates a new DeviceResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse=} [properties] Properties to set
         * @returns {Authentication.DeviceResponse} DeviceResponse instance
         */
        DeviceResponse.create = function create(properties) {
            return new DeviceResponse(properties);
        };

        /**
         * Encodes the specified DeviceResponse message. Does not implicitly {@link Authentication.DeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse} message DeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified DeviceResponse message, length delimited. Does not implicitly {@link Authentication.DeviceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.IDeviceResponse} message DeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceResponse} DeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceResponse} DeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceResponse message.
         * @function verify
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceResponse} DeviceResponse
         */
        DeviceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceResponse)
                return object;
            let message = new $root.Authentication.DeviceResponse();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            switch (object.status) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.status = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.status = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.status = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.status = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceResponse
         * @static
         * @param {Authentication.DeviceResponse} message DeviceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.status = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Authentication.DeviceStatus[message.status] : message.status;
            return object;
        };

        /**
         * Converts this DeviceResponse to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceResponse;
    })();

    Authentication.Salt = (function() {

        /**
         * Properties of a Salt.
         * @memberof Authentication
         * @interface ISalt
         * @property {number|null} [iterations] Salt iterations
         * @property {Uint8Array|null} [salt] Salt salt
         * @property {number|null} [algorithm] Salt algorithm
         * @property {Uint8Array|null} [uid] Salt uid
         * @property {string|null} [name] Salt name
         */

        /**
         * Constructs a new Salt.
         * @memberof Authentication
         * @classdesc Represents a Salt.
         * @implements ISalt
         * @constructor
         * @param {Authentication.ISalt=} [properties] Properties to set
         */
        function Salt(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Salt iterations.
         * @member {number} iterations
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.iterations = 0;

        /**
         * Salt salt.
         * @member {Uint8Array} salt
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.salt = $util.newBuffer([]);

        /**
         * Salt algorithm.
         * @member {number} algorithm
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.algorithm = 0;

        /**
         * Salt uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.uid = $util.newBuffer([]);

        /**
         * Salt name.
         * @member {string} name
         * @memberof Authentication.Salt
         * @instance
         */
        Salt.prototype.name = "";

        /**
         * Creates a new Salt instance using the specified properties.
         * @function create
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt=} [properties] Properties to set
         * @returns {Authentication.Salt} Salt instance
         */
        Salt.create = function create(properties) {
            return new Salt(properties);
        };

        /**
         * Encodes the specified Salt message. Does not implicitly {@link Authentication.Salt.verify|verify} messages.
         * @function encode
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.iterations);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.algorithm);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.uid);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Salt message, length delimited. Does not implicitly {@link Authentication.Salt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.ISalt} message Salt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Salt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Salt message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.Salt();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.iterations = reader.int32();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.algorithm = reader.int32();
                    break;
                case 4:
                    message.uid = reader.bytes();
                    break;
                case 5:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Salt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.Salt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.Salt} Salt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Salt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Salt message.
         * @function verify
         * @memberof Authentication.Salt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Salt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Salt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.Salt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.Salt} Salt
         */
        Salt.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.Salt)
                return object;
            let message = new $root.Authentication.Salt();
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Salt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.Salt
         * @static
         * @param {Authentication.Salt} message Salt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Salt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.iterations = 0;
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.algorithm = 0;
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.name = "";
            }
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this Salt to JSON.
         * @function toJSON
         * @memberof Authentication.Salt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Salt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Salt;
    })();

    Authentication.TwoFactorChannel = (function() {

        /**
         * Properties of a TwoFactorChannel.
         * @memberof Authentication
         * @interface ITwoFactorChannel
         * @property {number|null} [type] TwoFactorChannel type
         */

        /**
         * Constructs a new TwoFactorChannel.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorChannel.
         * @implements ITwoFactorChannel
         * @constructor
         * @param {Authentication.ITwoFactorChannel=} [properties] Properties to set
         */
        function TwoFactorChannel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorChannel type.
         * @member {number} type
         * @memberof Authentication.TwoFactorChannel
         * @instance
         */
        TwoFactorChannel.prototype.type = 0;

        /**
         * Creates a new TwoFactorChannel instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel=} [properties] Properties to set
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel instance
         */
        TwoFactorChannel.create = function create(properties) {
            return new TwoFactorChannel(properties);
        };

        /**
         * Encodes the specified TwoFactorChannel message. Does not implicitly {@link Authentication.TwoFactorChannel.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel} message TwoFactorChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorChannel message, length delimited. Does not implicitly {@link Authentication.TwoFactorChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.ITwoFactorChannel} message TwoFactorChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorChannel message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorChannel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorChannel message.
         * @function verify
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        /**
         * Creates a TwoFactorChannel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorChannel} TwoFactorChannel
         */
        TwoFactorChannel.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorChannel)
                return object;
            let message = new $root.Authentication.TwoFactorChannel();
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorChannel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorChannel
         * @static
         * @param {Authentication.TwoFactorChannel} message TwoFactorChannel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorChannel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this TwoFactorChannel to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorChannel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorChannel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorChannel;
    })();

    /**
     * LoginMethod enum.
     * @name Authentication.LoginMethod
     * @enum {string}
     * @property {number} INVALID_LOGINMETHOD=0 INVALID_LOGINMETHOD value
     * @property {number} EXISTING_ACCOUNT=1 EXISTING_ACCOUNT value
     * @property {number} SSO_DOMAIN=2 SSO_DOMAIN value
     * @property {number} AFTER_SSO=3 AFTER_SSO value
     * @property {number} NEW_ACCOUNT=4 NEW_ACCOUNT value
     */
    Authentication.LoginMethod = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INVALID_LOGINMETHOD"] = 0;
        values[valuesById[1] = "EXISTING_ACCOUNT"] = 1;
        values[valuesById[2] = "SSO_DOMAIN"] = 2;
        values[valuesById[3] = "AFTER_SSO"] = 3;
        values[valuesById[4] = "NEW_ACCOUNT"] = 4;
        return values;
    })();

    /**
     * LoginState enum.
     * @name Authentication.LoginState
     * @enum {string}
     * @property {number} INVALID_LOGINSTATE=0 INVALID_LOGINSTATE value
     * @property {number} LOGGED_OUT=1 LOGGED_OUT value
     * @property {number} DEVICE_APPROVAL_REQUIRED=2 DEVICE_APPROVAL_REQUIRED value
     * @property {number} DEVICE_LOCKED=3 DEVICE_LOCKED value
     * @property {number} ACCOUNT_LOCKED=4 ACCOUNT_LOCKED value
     * @property {number} DEVICE_ACCOUNT_LOCKED=5 DEVICE_ACCOUNT_LOCKED value
     * @property {number} UPGRADE=6 UPGRADE value
     * @property {number} LICENSE_EXPIRED=7 LICENSE_EXPIRED value
     * @property {number} REGION_REDIRECT=8 REGION_REDIRECT value
     * @property {number} REDIRECT_CLOUD_SSO=9 REDIRECT_CLOUD_SSO value
     * @property {number} REDIRECT_ONSITE_SSO=10 REDIRECT_ONSITE_SSO value
     * @property {number} REQUIRES_2FA=12 REQUIRES_2FA value
     * @property {number} REQUIRES_AUTH_HASH=13 REQUIRES_AUTH_HASH value
     * @property {number} REQUIRES_USERNAME=14 REQUIRES_USERNAME value
     * @property {number} AFTER_CLOUD_SSO_LOGIN=15 AFTER_CLOUD_SSO_LOGIN value
     * @property {number} REQUIRES_ACCOUNT_CREATION=16 REQUIRES_ACCOUNT_CREATION value
     * @property {number} REQUIRES_DEVICE_ENCRYPTED_DATA_KEY=17 REQUIRES_DEVICE_ENCRYPTED_DATA_KEY value
     * @property {number} LOGIN_TOKEN_EXPIRED=18 LOGIN_TOKEN_EXPIRED value
     * @property {number} LOGGED_IN=99 LOGGED_IN value
     */
    Authentication.LoginState = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INVALID_LOGINSTATE"] = 0;
        values[valuesById[1] = "LOGGED_OUT"] = 1;
        values[valuesById[2] = "DEVICE_APPROVAL_REQUIRED"] = 2;
        values[valuesById[3] = "DEVICE_LOCKED"] = 3;
        values[valuesById[4] = "ACCOUNT_LOCKED"] = 4;
        values[valuesById[5] = "DEVICE_ACCOUNT_LOCKED"] = 5;
        values[valuesById[6] = "UPGRADE"] = 6;
        values[valuesById[7] = "LICENSE_EXPIRED"] = 7;
        values[valuesById[8] = "REGION_REDIRECT"] = 8;
        values[valuesById[9] = "REDIRECT_CLOUD_SSO"] = 9;
        values[valuesById[10] = "REDIRECT_ONSITE_SSO"] = 10;
        values[valuesById[12] = "REQUIRES_2FA"] = 12;
        values[valuesById[13] = "REQUIRES_AUTH_HASH"] = 13;
        values[valuesById[14] = "REQUIRES_USERNAME"] = 14;
        values[valuesById[15] = "AFTER_CLOUD_SSO_LOGIN"] = 15;
        values[valuesById[16] = "REQUIRES_ACCOUNT_CREATION"] = 16;
        values[valuesById[17] = "REQUIRES_DEVICE_ENCRYPTED_DATA_KEY"] = 17;
        values[valuesById[18] = "LOGIN_TOKEN_EXPIRED"] = 18;
        values[valuesById[99] = "LOGGED_IN"] = 99;
        return values;
    })();

    /**
     * EncryptedDataKeyType enum.
     * @name Authentication.EncryptedDataKeyType
     * @enum {string}
     * @property {number} NO_KEY=0 NO_KEY value
     * @property {number} BY_DEVICE_PUBLIC_KEY=1 BY_DEVICE_PUBLIC_KEY value
     * @property {number} BY_PASSWORD=2 BY_PASSWORD value
     * @property {number} BY_ALTERNATE=3 BY_ALTERNATE value
     * @property {number} BY_BIO=4 BY_BIO value
     */
    Authentication.EncryptedDataKeyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_KEY"] = 0;
        values[valuesById[1] = "BY_DEVICE_PUBLIC_KEY"] = 1;
        values[valuesById[2] = "BY_PASSWORD"] = 2;
        values[valuesById[3] = "BY_ALTERNATE"] = 3;
        values[valuesById[4] = "BY_BIO"] = 4;
        return values;
    })();

    Authentication.StartLoginRequest = (function() {

        /**
         * Properties of a StartLoginRequest.
         * @memberof Authentication
         * @interface IStartLoginRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] StartLoginRequest encryptedDeviceToken
         * @property {string|null} [username] StartLoginRequest username
         * @property {string|null} [clientVersion] StartLoginRequest clientVersion
         * @property {Uint8Array|null} [messageSessionUid] StartLoginRequest messageSessionUid
         * @property {Uint8Array|null} [encryptedLoginToken] StartLoginRequest encryptedLoginToken
         * @property {Authentication.LoginType|null} [loginType] StartLoginRequest loginType
         * @property {number|null} [mcEnterpriseId] StartLoginRequest mcEnterpriseId
         * @property {Authentication.LoginMethod|null} [loginMethod] StartLoginRequest loginMethod
         * @property {boolean|null} [forceNewLogin] StartLoginRequest forceNewLogin
         * @property {Uint8Array|null} [cloneCode] StartLoginRequest cloneCode
         * @property {string|null} [v2TwoFactorToken] StartLoginRequest v2TwoFactorToken
         */

        /**
         * Constructs a new StartLoginRequest.
         * @memberof Authentication
         * @classdesc Represents a StartLoginRequest.
         * @implements IStartLoginRequest
         * @constructor
         * @param {Authentication.IStartLoginRequest=} [properties] Properties to set
         */
        function StartLoginRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartLoginRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * StartLoginRequest username.
         * @member {string} username
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.username = "";

        /**
         * StartLoginRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.clientVersion = "";

        /**
         * StartLoginRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * StartLoginRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * StartLoginRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.loginType = 0;

        /**
         * StartLoginRequest mcEnterpriseId.
         * @member {number} mcEnterpriseId
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.mcEnterpriseId = 0;

        /**
         * StartLoginRequest loginMethod.
         * @member {Authentication.LoginMethod} loginMethod
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.loginMethod = 0;

        /**
         * StartLoginRequest forceNewLogin.
         * @member {boolean} forceNewLogin
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.forceNewLogin = false;

        /**
         * StartLoginRequest cloneCode.
         * @member {Uint8Array} cloneCode
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.cloneCode = $util.newBuffer([]);

        /**
         * StartLoginRequest v2TwoFactorToken.
         * @member {string} v2TwoFactorToken
         * @memberof Authentication.StartLoginRequest
         * @instance
         */
        StartLoginRequest.prototype.v2TwoFactorToken = "";

        /**
         * Creates a new StartLoginRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Authentication.IStartLoginRequest=} [properties] Properties to set
         * @returns {Authentication.StartLoginRequest} StartLoginRequest instance
         */
        StartLoginRequest.create = function create(properties) {
            return new StartLoginRequest(properties);
        };

        /**
         * Encodes the specified StartLoginRequest message. Does not implicitly {@link Authentication.StartLoginRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Authentication.IStartLoginRequest} message StartLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartLoginRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.messageSessionUid);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedLoginToken);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.loginType);
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.mcEnterpriseId);
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.loginMethod);
            if (message.forceNewLogin != null && message.hasOwnProperty("forceNewLogin"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.forceNewLogin);
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.cloneCode);
            if (message.v2TwoFactorToken != null && message.hasOwnProperty("v2TwoFactorToken"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.v2TwoFactorToken);
            return writer;
        };

        /**
         * Encodes the specified StartLoginRequest message, length delimited. Does not implicitly {@link Authentication.StartLoginRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Authentication.IStartLoginRequest} message StartLoginRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartLoginRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartLoginRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.StartLoginRequest} StartLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartLoginRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.StartLoginRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 5:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 6:
                    message.loginType = reader.int32();
                    break;
                case 7:
                    message.mcEnterpriseId = reader.int32();
                    break;
                case 8:
                    message.loginMethod = reader.int32();
                    break;
                case 9:
                    message.forceNewLogin = reader.bool();
                    break;
                case 10:
                    message.cloneCode = reader.bytes();
                    break;
                case 11:
                    message.v2TwoFactorToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartLoginRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.StartLoginRequest} StartLoginRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartLoginRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartLoginRequest message.
         * @function verify
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartLoginRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                if (!$util.isInteger(message.mcEnterpriseId))
                    return "mcEnterpriseId: integer expected";
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                switch (message.loginMethod) {
                default:
                    return "loginMethod: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.forceNewLogin != null && message.hasOwnProperty("forceNewLogin"))
                if (typeof message.forceNewLogin !== "boolean")
                    return "forceNewLogin: boolean expected";
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                if (!(message.cloneCode && typeof message.cloneCode.length === "number" || $util.isString(message.cloneCode)))
                    return "cloneCode: buffer expected";
            if (message.v2TwoFactorToken != null && message.hasOwnProperty("v2TwoFactorToken"))
                if (!$util.isString(message.v2TwoFactorToken))
                    return "v2TwoFactorToken: string expected";
            return null;
        };

        /**
         * Creates a StartLoginRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.StartLoginRequest} StartLoginRequest
         */
        StartLoginRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.StartLoginRequest)
                return object;
            let message = new $root.Authentication.StartLoginRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.username != null)
                message.username = String(object.username);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.mcEnterpriseId != null)
                message.mcEnterpriseId = object.mcEnterpriseId | 0;
            switch (object.loginMethod) {
            case "INVALID_LOGINMETHOD":
            case 0:
                message.loginMethod = 0;
                break;
            case "EXISTING_ACCOUNT":
            case 1:
                message.loginMethod = 1;
                break;
            case "SSO_DOMAIN":
            case 2:
                message.loginMethod = 2;
                break;
            case "AFTER_SSO":
            case 3:
                message.loginMethod = 3;
                break;
            case "NEW_ACCOUNT":
            case 4:
                message.loginMethod = 4;
                break;
            }
            if (object.forceNewLogin != null)
                message.forceNewLogin = Boolean(object.forceNewLogin);
            if (object.cloneCode != null)
                if (typeof object.cloneCode === "string")
                    $util.base64.decode(object.cloneCode, message.cloneCode = $util.newBuffer($util.base64.length(object.cloneCode)), 0);
                else if (object.cloneCode.length)
                    message.cloneCode = object.cloneCode;
            if (object.v2TwoFactorToken != null)
                message.v2TwoFactorToken = String(object.v2TwoFactorToken);
            return message;
        };

        /**
         * Creates a plain object from a StartLoginRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.StartLoginRequest
         * @static
         * @param {Authentication.StartLoginRequest} message StartLoginRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StartLoginRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.username = "";
                object.clientVersion = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                object.loginType = options.enums === String ? "NORMAL" : 0;
                object.mcEnterpriseId = 0;
                object.loginMethod = options.enums === String ? "INVALID_LOGINMETHOD" : 0;
                object.forceNewLogin = false;
                if (options.bytes === String)
                    object.cloneCode = "";
                else {
                    object.cloneCode = [];
                    if (options.bytes !== Array)
                        object.cloneCode = $util.newBuffer(object.cloneCode);
                }
                object.v2TwoFactorToken = "";
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                object.mcEnterpriseId = message.mcEnterpriseId;
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                object.loginMethod = options.enums === String ? $root.Authentication.LoginMethod[message.loginMethod] : message.loginMethod;
            if (message.forceNewLogin != null && message.hasOwnProperty("forceNewLogin"))
                object.forceNewLogin = message.forceNewLogin;
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                object.cloneCode = options.bytes === String ? $util.base64.encode(message.cloneCode, 0, message.cloneCode.length) : options.bytes === Array ? Array.prototype.slice.call(message.cloneCode) : message.cloneCode;
            if (message.v2TwoFactorToken != null && message.hasOwnProperty("v2TwoFactorToken"))
                object.v2TwoFactorToken = message.v2TwoFactorToken;
            return object;
        };

        /**
         * Converts this StartLoginRequest to JSON.
         * @function toJSON
         * @memberof Authentication.StartLoginRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StartLoginRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StartLoginRequest;
    })();

    Authentication.LoginResponse = (function() {

        /**
         * Properties of a LoginResponse.
         * @memberof Authentication
         * @interface ILoginResponse
         * @property {Authentication.LoginState|null} [loginState] LoginResponse loginState
         * @property {Uint8Array|null} [accountUid] LoginResponse accountUid
         * @property {string|null} [primaryUsername] LoginResponse primaryUsername
         * @property {Uint8Array|null} [encryptedDataKey] LoginResponse encryptedDataKey
         * @property {Authentication.EncryptedDataKeyType|null} [encryptedDataKeyType] LoginResponse encryptedDataKeyType
         * @property {Uint8Array|null} [encryptedLoginToken] LoginResponse encryptedLoginToken
         * @property {Uint8Array|null} [encryptedSessionToken] LoginResponse encryptedSessionToken
         * @property {Authentication.SessionTokenType|null} [sessionTokenType] LoginResponse sessionTokenType
         * @property {string|null} [message] LoginResponse message
         * @property {string|null} [url] LoginResponse url
         * @property {Array.<Authentication.ITwoFactorChannelInfo>|null} [channels] LoginResponse channels
         * @property {Array.<Authentication.ISalt>|null} [salt] LoginResponse salt
         * @property {Uint8Array|null} [cloneCode] LoginResponse cloneCode
         * @property {string|null} [stateSpecificValue] LoginResponse stateSpecificValue
         * @property {string|null} [ssoClientVersion] LoginResponse ssoClientVersion
         */

        /**
         * Constructs a new LoginResponse.
         * @memberof Authentication
         * @classdesc Represents a LoginResponse.
         * @implements ILoginResponse
         * @constructor
         * @param {Authentication.ILoginResponse=} [properties] Properties to set
         */
        function LoginResponse(properties) {
            this.channels = [];
            this.salt = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResponse loginState.
         * @member {Authentication.LoginState} loginState
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.loginState = 0;

        /**
         * LoginResponse accountUid.
         * @member {Uint8Array} accountUid
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.accountUid = $util.newBuffer([]);

        /**
         * LoginResponse primaryUsername.
         * @member {string} primaryUsername
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.primaryUsername = "";

        /**
         * LoginResponse encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * LoginResponse encryptedDataKeyType.
         * @member {Authentication.EncryptedDataKeyType} encryptedDataKeyType
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedDataKeyType = 0;

        /**
         * LoginResponse encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * LoginResponse encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * LoginResponse sessionTokenType.
         * @member {Authentication.SessionTokenType} sessionTokenType
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.sessionTokenType = 0;

        /**
         * LoginResponse message.
         * @member {string} message
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.message = "";

        /**
         * LoginResponse url.
         * @member {string} url
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.url = "";

        /**
         * LoginResponse channels.
         * @member {Array.<Authentication.ITwoFactorChannelInfo>} channels
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.channels = $util.emptyArray;

        /**
         * LoginResponse salt.
         * @member {Array.<Authentication.ISalt>} salt
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.salt = $util.emptyArray;

        /**
         * LoginResponse cloneCode.
         * @member {Uint8Array} cloneCode
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.cloneCode = $util.newBuffer([]);

        /**
         * LoginResponse stateSpecificValue.
         * @member {string} stateSpecificValue
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.stateSpecificValue = "";

        /**
         * LoginResponse ssoClientVersion.
         * @member {string} ssoClientVersion
         * @memberof Authentication.LoginResponse
         * @instance
         */
        LoginResponse.prototype.ssoClientVersion = "";

        /**
         * Creates a new LoginResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse=} [properties] Properties to set
         * @returns {Authentication.LoginResponse} LoginResponse instance
         */
        LoginResponse.create = function create(properties) {
            return new LoginResponse(properties);
        };

        /**
         * Encodes the specified LoginResponse message. Does not implicitly {@link Authentication.LoginResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.loginState);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountUid);
            if (message.primaryUsername != null && message.hasOwnProperty("primaryUsername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.primaryUsername);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedDataKey);
            if (message.encryptedDataKeyType != null && message.hasOwnProperty("encryptedDataKeyType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.encryptedDataKeyType);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedLoginToken);
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.encryptedSessionToken);
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.sessionTokenType);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.message);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.url);
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.Authentication.TwoFactorChannelInfo.encode(message.channels[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.salt != null && message.salt.length)
                for (let i = 0; i < message.salt.length; ++i)
                    $root.Authentication.Salt.encode(message.salt[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.cloneCode);
            if (message.stateSpecificValue != null && message.hasOwnProperty("stateSpecificValue"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.stateSpecificValue);
            if (message.ssoClientVersion != null && message.hasOwnProperty("ssoClientVersion"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.ssoClientVersion);
            return writer;
        };

        /**
         * Encodes the specified LoginResponse message, length delimited. Does not implicitly {@link Authentication.LoginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.ILoginResponse} message LoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.loginState = reader.int32();
                    break;
                case 2:
                    message.accountUid = reader.bytes();
                    break;
                case 3:
                    message.primaryUsername = reader.string();
                    break;
                case 4:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 5:
                    message.encryptedDataKeyType = reader.int32();
                    break;
                case 6:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 7:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 8:
                    message.sessionTokenType = reader.int32();
                    break;
                case 9:
                    message.message = reader.string();
                    break;
                case 10:
                    message.url = reader.string();
                    break;
                case 11:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.Authentication.TwoFactorChannelInfo.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.salt && message.salt.length))
                        message.salt = [];
                    message.salt.push($root.Authentication.Salt.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.cloneCode = reader.bytes();
                    break;
                case 14:
                    message.stateSpecificValue = reader.string();
                    break;
                case 15:
                    message.ssoClientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginResponse} LoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginResponse message.
         * @function verify
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                switch (message.loginState) {
                default:
                    return "loginState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 99:
                    break;
                }
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.primaryUsername != null && message.hasOwnProperty("primaryUsername"))
                if (!$util.isString(message.primaryUsername))
                    return "primaryUsername: string expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.encryptedDataKeyType != null && message.hasOwnProperty("encryptedDataKeyType"))
                switch (message.encryptedDataKeyType) {
                default:
                    return "encryptedDataKeyType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                switch (message.sessionTokenType) {
                default:
                    return "sessionTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.Authentication.TwoFactorChannelInfo.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            if (message.salt != null && message.hasOwnProperty("salt")) {
                if (!Array.isArray(message.salt))
                    return "salt: array expected";
                for (let i = 0; i < message.salt.length; ++i) {
                    let error = $root.Authentication.Salt.verify(message.salt[i]);
                    if (error)
                        return "salt." + error;
                }
            }
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                if (!(message.cloneCode && typeof message.cloneCode.length === "number" || $util.isString(message.cloneCode)))
                    return "cloneCode: buffer expected";
            if (message.stateSpecificValue != null && message.hasOwnProperty("stateSpecificValue"))
                if (!$util.isString(message.stateSpecificValue))
                    return "stateSpecificValue: string expected";
            if (message.ssoClientVersion != null && message.hasOwnProperty("ssoClientVersion"))
                if (!$util.isString(message.ssoClientVersion))
                    return "ssoClientVersion: string expected";
            return null;
        };

        /**
         * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginResponse} LoginResponse
         */
        LoginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginResponse)
                return object;
            let message = new $root.Authentication.LoginResponse();
            switch (object.loginState) {
            case "INVALID_LOGINSTATE":
            case 0:
                message.loginState = 0;
                break;
            case "LOGGED_OUT":
            case 1:
                message.loginState = 1;
                break;
            case "DEVICE_APPROVAL_REQUIRED":
            case 2:
                message.loginState = 2;
                break;
            case "DEVICE_LOCKED":
            case 3:
                message.loginState = 3;
                break;
            case "ACCOUNT_LOCKED":
            case 4:
                message.loginState = 4;
                break;
            case "DEVICE_ACCOUNT_LOCKED":
            case 5:
                message.loginState = 5;
                break;
            case "UPGRADE":
            case 6:
                message.loginState = 6;
                break;
            case "LICENSE_EXPIRED":
            case 7:
                message.loginState = 7;
                break;
            case "REGION_REDIRECT":
            case 8:
                message.loginState = 8;
                break;
            case "REDIRECT_CLOUD_SSO":
            case 9:
                message.loginState = 9;
                break;
            case "REDIRECT_ONSITE_SSO":
            case 10:
                message.loginState = 10;
                break;
            case "REQUIRES_2FA":
            case 12:
                message.loginState = 12;
                break;
            case "REQUIRES_AUTH_HASH":
            case 13:
                message.loginState = 13;
                break;
            case "REQUIRES_USERNAME":
            case 14:
                message.loginState = 14;
                break;
            case "AFTER_CLOUD_SSO_LOGIN":
            case 15:
                message.loginState = 15;
                break;
            case "REQUIRES_ACCOUNT_CREATION":
            case 16:
                message.loginState = 16;
                break;
            case "REQUIRES_DEVICE_ENCRYPTED_DATA_KEY":
            case 17:
                message.loginState = 17;
                break;
            case "LOGIN_TOKEN_EXPIRED":
            case 18:
                message.loginState = 18;
                break;
            case "LOGGED_IN":
            case 99:
                message.loginState = 99;
                break;
            }
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            if (object.primaryUsername != null)
                message.primaryUsername = String(object.primaryUsername);
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            switch (object.encryptedDataKeyType) {
            case "NO_KEY":
            case 0:
                message.encryptedDataKeyType = 0;
                break;
            case "BY_DEVICE_PUBLIC_KEY":
            case 1:
                message.encryptedDataKeyType = 1;
                break;
            case "BY_PASSWORD":
            case 2:
                message.encryptedDataKeyType = 2;
                break;
            case "BY_ALTERNATE":
            case 3:
                message.encryptedDataKeyType = 3;
                break;
            case "BY_BIO":
            case 4:
                message.encryptedDataKeyType = 4;
                break;
            }
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            switch (object.sessionTokenType) {
            case "NO_RESTRICTION":
            case 0:
                message.sessionTokenType = 0;
                break;
            case "ACCOUNT_RECOVERY":
            case 1:
                message.sessionTokenType = 1;
                break;
            case "SHARE_ACCOUNT":
            case 2:
                message.sessionTokenType = 2;
                break;
            case "PURCHASE":
            case 3:
                message.sessionTokenType = 3;
                break;
            case "RESTRICT":
            case 4:
                message.sessionTokenType = 4;
                break;
            case "ACCEPT_INVITE":
            case 5:
                message.sessionTokenType = 5;
                break;
            case "SUPPORT_SERVER":
            case 6:
                message.sessionTokenType = 6;
                break;
            case "ENTERPRISE_CREATION":
            case 7:
                message.sessionTokenType = 7;
                break;
            case "EXPIRED_BUT_ALLOWED_TO_SYNC":
            case 8:
                message.sessionTokenType = 8;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.url != null)
                message.url = String(object.url);
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".Authentication.LoginResponse.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".Authentication.LoginResponse.channels: object expected");
                    message.channels[i] = $root.Authentication.TwoFactorChannelInfo.fromObject(object.channels[i]);
                }
            }
            if (object.salt) {
                if (!Array.isArray(object.salt))
                    throw TypeError(".Authentication.LoginResponse.salt: array expected");
                message.salt = [];
                for (let i = 0; i < object.salt.length; ++i) {
                    if (typeof object.salt[i] !== "object")
                        throw TypeError(".Authentication.LoginResponse.salt: object expected");
                    message.salt[i] = $root.Authentication.Salt.fromObject(object.salt[i]);
                }
            }
            if (object.cloneCode != null)
                if (typeof object.cloneCode === "string")
                    $util.base64.decode(object.cloneCode, message.cloneCode = $util.newBuffer($util.base64.length(object.cloneCode)), 0);
                else if (object.cloneCode.length)
                    message.cloneCode = object.cloneCode;
            if (object.stateSpecificValue != null)
                message.stateSpecificValue = String(object.stateSpecificValue);
            if (object.ssoClientVersion != null)
                message.ssoClientVersion = String(object.ssoClientVersion);
            return message;
        };

        /**
         * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginResponse
         * @static
         * @param {Authentication.LoginResponse} message LoginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.channels = [];
                object.salt = [];
            }
            if (options.defaults) {
                object.loginState = options.enums === String ? "INVALID_LOGINSTATE" : 0;
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                object.primaryUsername = "";
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
                object.encryptedDataKeyType = options.enums === String ? "NO_KEY" : 0;
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                object.sessionTokenType = options.enums === String ? "NO_RESTRICTION" : 0;
                object.message = "";
                object.url = "";
                if (options.bytes === String)
                    object.cloneCode = "";
                else {
                    object.cloneCode = [];
                    if (options.bytes !== Array)
                        object.cloneCode = $util.newBuffer(object.cloneCode);
                }
                object.stateSpecificValue = "";
                object.ssoClientVersion = "";
            }
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                object.loginState = options.enums === String ? $root.Authentication.LoginState[message.loginState] : message.loginState;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.primaryUsername != null && message.hasOwnProperty("primaryUsername"))
                object.primaryUsername = message.primaryUsername;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.encryptedDataKeyType != null && message.hasOwnProperty("encryptedDataKeyType"))
                object.encryptedDataKeyType = options.enums === String ? $root.Authentication.EncryptedDataKeyType[message.encryptedDataKeyType] : message.encryptedDataKeyType;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                object.sessionTokenType = options.enums === String ? $root.Authentication.SessionTokenType[message.sessionTokenType] : message.sessionTokenType;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.Authentication.TwoFactorChannelInfo.toObject(message.channels[j], options);
            }
            if (message.salt && message.salt.length) {
                object.salt = [];
                for (let j = 0; j < message.salt.length; ++j)
                    object.salt[j] = $root.Authentication.Salt.toObject(message.salt[j], options);
            }
            if (message.cloneCode != null && message.hasOwnProperty("cloneCode"))
                object.cloneCode = options.bytes === String ? $util.base64.encode(message.cloneCode, 0, message.cloneCode.length) : options.bytes === Array ? Array.prototype.slice.call(message.cloneCode) : message.cloneCode;
            if (message.stateSpecificValue != null && message.hasOwnProperty("stateSpecificValue"))
                object.stateSpecificValue = message.stateSpecificValue;
            if (message.ssoClientVersion != null && message.hasOwnProperty("ssoClientVersion"))
                object.ssoClientVersion = message.ssoClientVersion;
            return object;
        };

        /**
         * Converts this LoginResponse to JSON.
         * @function toJSON
         * @memberof Authentication.LoginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginResponse;
    })();

    Authentication.SsoUserInfo = (function() {

        /**
         * Properties of a SsoUserInfo.
         * @memberof Authentication
         * @interface ISsoUserInfo
         * @property {string|null} [companyName] SsoUserInfo companyName
         * @property {string|null} [samlRequest] SsoUserInfo samlRequest
         * @property {string|null} [samlRequestType] SsoUserInfo samlRequestType
         * @property {string|null} [ssoDomainName] SsoUserInfo ssoDomainName
         * @property {string|null} [loginUrl] SsoUserInfo loginUrl
         * @property {string|null} [logoutUrl] SsoUserInfo logoutUrl
         */

        /**
         * Constructs a new SsoUserInfo.
         * @memberof Authentication
         * @classdesc Represents a SsoUserInfo.
         * @implements ISsoUserInfo
         * @constructor
         * @param {Authentication.ISsoUserInfo=} [properties] Properties to set
         */
        function SsoUserInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoUserInfo companyName.
         * @member {string} companyName
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.companyName = "";

        /**
         * SsoUserInfo samlRequest.
         * @member {string} samlRequest
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.samlRequest = "";

        /**
         * SsoUserInfo samlRequestType.
         * @member {string} samlRequestType
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.samlRequestType = "";

        /**
         * SsoUserInfo ssoDomainName.
         * @member {string} ssoDomainName
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.ssoDomainName = "";

        /**
         * SsoUserInfo loginUrl.
         * @member {string} loginUrl
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.loginUrl = "";

        /**
         * SsoUserInfo logoutUrl.
         * @member {string} logoutUrl
         * @memberof Authentication.SsoUserInfo
         * @instance
         */
        SsoUserInfo.prototype.logoutUrl = "";

        /**
         * Creates a new SsoUserInfo instance using the specified properties.
         * @function create
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo=} [properties] Properties to set
         * @returns {Authentication.SsoUserInfo} SsoUserInfo instance
         */
        SsoUserInfo.create = function create(properties) {
            return new SsoUserInfo(properties);
        };

        /**
         * Encodes the specified SsoUserInfo message. Does not implicitly {@link Authentication.SsoUserInfo.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo} message SsoUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.companyName);
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.samlRequest);
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.samlRequestType);
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ssoDomainName);
            if (message.loginUrl != null && message.hasOwnProperty("loginUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.loginUrl);
            if (message.logoutUrl != null && message.hasOwnProperty("logoutUrl"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.logoutUrl);
            return writer;
        };

        /**
         * Encodes the specified SsoUserInfo message, length delimited. Does not implicitly {@link Authentication.SsoUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.ISsoUserInfo} message SsoUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SsoUserInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.companyName = reader.string();
                    break;
                case 2:
                    message.samlRequest = reader.string();
                    break;
                case 3:
                    message.samlRequestType = reader.string();
                    break;
                case 4:
                    message.ssoDomainName = reader.string();
                    break;
                case 5:
                    message.loginUrl = reader.string();
                    break;
                case 6:
                    message.logoutUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoUserInfo message.
         * @function verify
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                if (!$util.isString(message.companyName))
                    return "companyName: string expected";
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                if (!$util.isString(message.samlRequest))
                    return "samlRequest: string expected";
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                if (!$util.isString(message.samlRequestType))
                    return "samlRequestType: string expected";
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                if (!$util.isString(message.ssoDomainName))
                    return "ssoDomainName: string expected";
            if (message.loginUrl != null && message.hasOwnProperty("loginUrl"))
                if (!$util.isString(message.loginUrl))
                    return "loginUrl: string expected";
            if (message.logoutUrl != null && message.hasOwnProperty("logoutUrl"))
                if (!$util.isString(message.logoutUrl))
                    return "logoutUrl: string expected";
            return null;
        };

        /**
         * Creates a SsoUserInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SsoUserInfo} SsoUserInfo
         */
        SsoUserInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SsoUserInfo)
                return object;
            let message = new $root.Authentication.SsoUserInfo();
            if (object.companyName != null)
                message.companyName = String(object.companyName);
            if (object.samlRequest != null)
                message.samlRequest = String(object.samlRequest);
            if (object.samlRequestType != null)
                message.samlRequestType = String(object.samlRequestType);
            if (object.ssoDomainName != null)
                message.ssoDomainName = String(object.ssoDomainName);
            if (object.loginUrl != null)
                message.loginUrl = String(object.loginUrl);
            if (object.logoutUrl != null)
                message.logoutUrl = String(object.logoutUrl);
            return message;
        };

        /**
         * Creates a plain object from a SsoUserInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SsoUserInfo
         * @static
         * @param {Authentication.SsoUserInfo} message SsoUserInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoUserInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.companyName = "";
                object.samlRequest = "";
                object.samlRequestType = "";
                object.ssoDomainName = "";
                object.loginUrl = "";
                object.logoutUrl = "";
            }
            if (message.companyName != null && message.hasOwnProperty("companyName"))
                object.companyName = message.companyName;
            if (message.samlRequest != null && message.hasOwnProperty("samlRequest"))
                object.samlRequest = message.samlRequest;
            if (message.samlRequestType != null && message.hasOwnProperty("samlRequestType"))
                object.samlRequestType = message.samlRequestType;
            if (message.ssoDomainName != null && message.hasOwnProperty("ssoDomainName"))
                object.ssoDomainName = message.ssoDomainName;
            if (message.loginUrl != null && message.hasOwnProperty("loginUrl"))
                object.loginUrl = message.loginUrl;
            if (message.logoutUrl != null && message.hasOwnProperty("logoutUrl"))
                object.logoutUrl = message.logoutUrl;
            return object;
        };

        /**
         * Converts this SsoUserInfo to JSON.
         * @function toJSON
         * @memberof Authentication.SsoUserInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoUserInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoUserInfo;
    })();

    Authentication.PreLoginResponse = (function() {

        /**
         * Properties of a PreLoginResponse.
         * @memberof Authentication
         * @interface IPreLoginResponse
         * @property {Authentication.DeviceStatus|null} [deviceStatus] PreLoginResponse deviceStatus
         * @property {Array.<Authentication.ISalt>|null} [salt] PreLoginResponse salt
         * @property {Array.<Authentication.ITwoFactorChannel>|null} [OBSOLETE_FIELD] PreLoginResponse OBSOLETE_FIELD
         * @property {Authentication.ISsoUserInfo|null} [ssoUserInfo] PreLoginResponse ssoUserInfo
         */

        /**
         * Constructs a new PreLoginResponse.
         * @memberof Authentication
         * @classdesc Represents a PreLoginResponse.
         * @implements IPreLoginResponse
         * @constructor
         * @param {Authentication.IPreLoginResponse=} [properties] Properties to set
         */
        function PreLoginResponse(properties) {
            this.salt = [];
            this.OBSOLETE_FIELD = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PreLoginResponse deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.deviceStatus = 0;

        /**
         * PreLoginResponse salt.
         * @member {Array.<Authentication.ISalt>} salt
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.salt = $util.emptyArray;

        /**
         * PreLoginResponse OBSOLETE_FIELD.
         * @member {Array.<Authentication.ITwoFactorChannel>} OBSOLETE_FIELD
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.OBSOLETE_FIELD = $util.emptyArray;

        /**
         * PreLoginResponse ssoUserInfo.
         * @member {Authentication.ISsoUserInfo|null|undefined} ssoUserInfo
         * @memberof Authentication.PreLoginResponse
         * @instance
         */
        PreLoginResponse.prototype.ssoUserInfo = null;

        /**
         * Creates a new PreLoginResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse=} [properties] Properties to set
         * @returns {Authentication.PreLoginResponse} PreLoginResponse instance
         */
        PreLoginResponse.create = function create(properties) {
            return new PreLoginResponse(properties);
        };

        /**
         * Encodes the specified PreLoginResponse message. Does not implicitly {@link Authentication.PreLoginResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse} message PreLoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.deviceStatus);
            if (message.salt != null && message.salt.length)
                for (let i = 0; i < message.salt.length; ++i)
                    $root.Authentication.Salt.encode(message.salt[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.OBSOLETE_FIELD != null && message.OBSOLETE_FIELD.length)
                for (let i = 0; i < message.OBSOLETE_FIELD.length; ++i)
                    $root.Authentication.TwoFactorChannel.encode(message.OBSOLETE_FIELD[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo"))
                $root.Authentication.SsoUserInfo.encode(message.ssoUserInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PreLoginResponse message, length delimited. Does not implicitly {@link Authentication.PreLoginResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.IPreLoginResponse} message PreLoginResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PreLoginResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PreLoginResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.PreLoginResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceStatus = reader.int32();
                    break;
                case 2:
                    if (!(message.salt && message.salt.length))
                        message.salt = [];
                    message.salt.push($root.Authentication.Salt.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.OBSOLETE_FIELD && message.OBSOLETE_FIELD.length))
                        message.OBSOLETE_FIELD = [];
                    message.OBSOLETE_FIELD.push($root.Authentication.TwoFactorChannel.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.ssoUserInfo = $root.Authentication.SsoUserInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PreLoginResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PreLoginResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PreLoginResponse message.
         * @function verify
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PreLoginResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.salt != null && message.hasOwnProperty("salt")) {
                if (!Array.isArray(message.salt))
                    return "salt: array expected";
                for (let i = 0; i < message.salt.length; ++i) {
                    let error = $root.Authentication.Salt.verify(message.salt[i]);
                    if (error)
                        return "salt." + error;
                }
            }
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD")) {
                if (!Array.isArray(message.OBSOLETE_FIELD))
                    return "OBSOLETE_FIELD: array expected";
                for (let i = 0; i < message.OBSOLETE_FIELD.length; ++i) {
                    let error = $root.Authentication.TwoFactorChannel.verify(message.OBSOLETE_FIELD[i]);
                    if (error)
                        return "OBSOLETE_FIELD." + error;
                }
            }
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo")) {
                let error = $root.Authentication.SsoUserInfo.verify(message.ssoUserInfo);
                if (error)
                    return "ssoUserInfo." + error;
            }
            return null;
        };

        /**
         * Creates a PreLoginResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.PreLoginResponse} PreLoginResponse
         */
        PreLoginResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.PreLoginResponse)
                return object;
            let message = new $root.Authentication.PreLoginResponse();
            switch (object.deviceStatus) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.deviceStatus = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.deviceStatus = 3;
                break;
            }
            if (object.salt) {
                if (!Array.isArray(object.salt))
                    throw TypeError(".Authentication.PreLoginResponse.salt: array expected");
                message.salt = [];
                for (let i = 0; i < object.salt.length; ++i) {
                    if (typeof object.salt[i] !== "object")
                        throw TypeError(".Authentication.PreLoginResponse.salt: object expected");
                    message.salt[i] = $root.Authentication.Salt.fromObject(object.salt[i]);
                }
            }
            if (object.OBSOLETE_FIELD) {
                if (!Array.isArray(object.OBSOLETE_FIELD))
                    throw TypeError(".Authentication.PreLoginResponse.OBSOLETE_FIELD: array expected");
                message.OBSOLETE_FIELD = [];
                for (let i = 0; i < object.OBSOLETE_FIELD.length; ++i) {
                    if (typeof object.OBSOLETE_FIELD[i] !== "object")
                        throw TypeError(".Authentication.PreLoginResponse.OBSOLETE_FIELD: object expected");
                    message.OBSOLETE_FIELD[i] = $root.Authentication.TwoFactorChannel.fromObject(object.OBSOLETE_FIELD[i]);
                }
            }
            if (object.ssoUserInfo != null) {
                if (typeof object.ssoUserInfo !== "object")
                    throw TypeError(".Authentication.PreLoginResponse.ssoUserInfo: object expected");
                message.ssoUserInfo = $root.Authentication.SsoUserInfo.fromObject(object.ssoUserInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a PreLoginResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.PreLoginResponse
         * @static
         * @param {Authentication.PreLoginResponse} message PreLoginResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PreLoginResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.salt = [];
                object.OBSOLETE_FIELD = [];
            }
            if (options.defaults) {
                object.deviceStatus = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
                object.ssoUserInfo = null;
            }
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            if (message.salt && message.salt.length) {
                object.salt = [];
                for (let j = 0; j < message.salt.length; ++j)
                    object.salt[j] = $root.Authentication.Salt.toObject(message.salt[j], options);
            }
            if (message.OBSOLETE_FIELD && message.OBSOLETE_FIELD.length) {
                object.OBSOLETE_FIELD = [];
                for (let j = 0; j < message.OBSOLETE_FIELD.length; ++j)
                    object.OBSOLETE_FIELD[j] = $root.Authentication.TwoFactorChannel.toObject(message.OBSOLETE_FIELD[j], options);
            }
            if (message.ssoUserInfo != null && message.hasOwnProperty("ssoUserInfo"))
                object.ssoUserInfo = $root.Authentication.SsoUserInfo.toObject(message.ssoUserInfo, options);
            return object;
        };

        /**
         * Converts this PreLoginResponse to JSON.
         * @function toJSON
         * @memberof Authentication.PreLoginResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PreLoginResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PreLoginResponse;
    })();

    Authentication.LoginToMcRequest = (function() {

        /**
         * Properties of a LoginToMcRequest.
         * @memberof Authentication
         * @interface ILoginToMcRequest
         * @property {number|null} [mcEnterpriseId] LoginToMcRequest mcEnterpriseId
         */

        /**
         * Constructs a new LoginToMcRequest.
         * @memberof Authentication
         * @classdesc Represents a LoginToMcRequest.
         * @implements ILoginToMcRequest
         * @constructor
         * @param {Authentication.ILoginToMcRequest=} [properties] Properties to set
         */
        function LoginToMcRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginToMcRequest mcEnterpriseId.
         * @member {number} mcEnterpriseId
         * @memberof Authentication.LoginToMcRequest
         * @instance
         */
        LoginToMcRequest.prototype.mcEnterpriseId = 0;

        /**
         * Creates a new LoginToMcRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Authentication.ILoginToMcRequest=} [properties] Properties to set
         * @returns {Authentication.LoginToMcRequest} LoginToMcRequest instance
         */
        LoginToMcRequest.create = function create(properties) {
            return new LoginToMcRequest(properties);
        };

        /**
         * Encodes the specified LoginToMcRequest message. Does not implicitly {@link Authentication.LoginToMcRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Authentication.ILoginToMcRequest} message LoginToMcRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToMcRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mcEnterpriseId);
            return writer;
        };

        /**
         * Encodes the specified LoginToMcRequest message, length delimited. Does not implicitly {@link Authentication.LoginToMcRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Authentication.ILoginToMcRequest} message LoginToMcRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToMcRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginToMcRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginToMcRequest} LoginToMcRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToMcRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginToMcRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mcEnterpriseId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginToMcRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginToMcRequest} LoginToMcRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToMcRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginToMcRequest message.
         * @function verify
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginToMcRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                if (!$util.isInteger(message.mcEnterpriseId))
                    return "mcEnterpriseId: integer expected";
            return null;
        };

        /**
         * Creates a LoginToMcRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginToMcRequest} LoginToMcRequest
         */
        LoginToMcRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginToMcRequest)
                return object;
            let message = new $root.Authentication.LoginToMcRequest();
            if (object.mcEnterpriseId != null)
                message.mcEnterpriseId = object.mcEnterpriseId | 0;
            return message;
        };

        /**
         * Creates a plain object from a LoginToMcRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginToMcRequest
         * @static
         * @param {Authentication.LoginToMcRequest} message LoginToMcRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginToMcRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.mcEnterpriseId = 0;
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                object.mcEnterpriseId = message.mcEnterpriseId;
            return object;
        };

        /**
         * Converts this LoginToMcRequest to JSON.
         * @function toJSON
         * @memberof Authentication.LoginToMcRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginToMcRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginToMcRequest;
    })();

    Authentication.LoginToMcResponse = (function() {

        /**
         * Properties of a LoginToMcResponse.
         * @memberof Authentication
         * @interface ILoginToMcResponse
         * @property {Uint8Array|null} [encryptedSessionToken] LoginToMcResponse encryptedSessionToken
         * @property {string|null} [encryptedTreeKey] LoginToMcResponse encryptedTreeKey
         */

        /**
         * Constructs a new LoginToMcResponse.
         * @memberof Authentication
         * @classdesc Represents a LoginToMcResponse.
         * @implements ILoginToMcResponse
         * @constructor
         * @param {Authentication.ILoginToMcResponse=} [properties] Properties to set
         */
        function LoginToMcResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginToMcResponse encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof Authentication.LoginToMcResponse
         * @instance
         */
        LoginToMcResponse.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * LoginToMcResponse encryptedTreeKey.
         * @member {string} encryptedTreeKey
         * @memberof Authentication.LoginToMcResponse
         * @instance
         */
        LoginToMcResponse.prototype.encryptedTreeKey = "";

        /**
         * Creates a new LoginToMcResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Authentication.ILoginToMcResponse=} [properties] Properties to set
         * @returns {Authentication.LoginToMcResponse} LoginToMcResponse instance
         */
        LoginToMcResponse.create = function create(properties) {
            return new LoginToMcResponse(properties);
        };

        /**
         * Encodes the specified LoginToMcResponse message. Does not implicitly {@link Authentication.LoginToMcResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Authentication.ILoginToMcResponse} message LoginToMcResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToMcResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedSessionToken);
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.encryptedTreeKey);
            return writer;
        };

        /**
         * Encodes the specified LoginToMcResponse message, length delimited. Does not implicitly {@link Authentication.LoginToMcResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Authentication.ILoginToMcResponse} message LoginToMcResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToMcResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginToMcResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginToMcResponse} LoginToMcResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToMcResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginToMcResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 2:
                    message.encryptedTreeKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginToMcResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginToMcResponse} LoginToMcResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToMcResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginToMcResponse message.
         * @function verify
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginToMcResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                if (!$util.isString(message.encryptedTreeKey))
                    return "encryptedTreeKey: string expected";
            return null;
        };

        /**
         * Creates a LoginToMcResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginToMcResponse} LoginToMcResponse
         */
        LoginToMcResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginToMcResponse)
                return object;
            let message = new $root.Authentication.LoginToMcResponse();
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.encryptedTreeKey != null)
                message.encryptedTreeKey = String(object.encryptedTreeKey);
            return message;
        };

        /**
         * Creates a plain object from a LoginToMcResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginToMcResponse
         * @static
         * @param {Authentication.LoginToMcResponse} message LoginToMcResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginToMcResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                object.encryptedTreeKey = "";
            }
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                object.encryptedTreeKey = message.encryptedTreeKey;
            return object;
        };

        /**
         * Converts this LoginToMcResponse to JSON.
         * @function toJSON
         * @memberof Authentication.LoginToMcResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginToMcResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginToMcResponse;
    })();

    Authentication.LoginAsUserRequest = (function() {

        /**
         * Properties of a LoginAsUserRequest.
         * @memberof Authentication
         * @interface ILoginAsUserRequest
         * @property {string|null} [username] LoginAsUserRequest username
         */

        /**
         * Constructs a new LoginAsUserRequest.
         * @memberof Authentication
         * @classdesc Represents a LoginAsUserRequest.
         * @implements ILoginAsUserRequest
         * @constructor
         * @param {Authentication.ILoginAsUserRequest=} [properties] Properties to set
         */
        function LoginAsUserRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginAsUserRequest username.
         * @member {string} username
         * @memberof Authentication.LoginAsUserRequest
         * @instance
         */
        LoginAsUserRequest.prototype.username = "";

        /**
         * Creates a new LoginAsUserRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Authentication.ILoginAsUserRequest=} [properties] Properties to set
         * @returns {Authentication.LoginAsUserRequest} LoginAsUserRequest instance
         */
        LoginAsUserRequest.create = function create(properties) {
            return new LoginAsUserRequest(properties);
        };

        /**
         * Encodes the specified LoginAsUserRequest message. Does not implicitly {@link Authentication.LoginAsUserRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Authentication.ILoginAsUserRequest} message LoginAsUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAsUserRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified LoginAsUserRequest message, length delimited. Does not implicitly {@link Authentication.LoginAsUserRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Authentication.ILoginAsUserRequest} message LoginAsUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAsUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginAsUserRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginAsUserRequest} LoginAsUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAsUserRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginAsUserRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginAsUserRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginAsUserRequest} LoginAsUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAsUserRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginAsUserRequest message.
         * @function verify
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginAsUserRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a LoginAsUserRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginAsUserRequest} LoginAsUserRequest
         */
        LoginAsUserRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginAsUserRequest)
                return object;
            let message = new $root.Authentication.LoginAsUserRequest();
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a LoginAsUserRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginAsUserRequest
         * @static
         * @param {Authentication.LoginAsUserRequest} message LoginAsUserRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginAsUserRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.username = "";
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this LoginAsUserRequest to JSON.
         * @function toJSON
         * @memberof Authentication.LoginAsUserRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginAsUserRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginAsUserRequest;
    })();

    Authentication.LoginAsUserResponse = (function() {

        /**
         * Properties of a LoginAsUserResponse.
         * @memberof Authentication
         * @interface ILoginAsUserResponse
         * @property {Uint8Array|null} [encryptedSessionToken] LoginAsUserResponse encryptedSessionToken
         * @property {Uint8Array|null} [encryptedSharedAccountKey] LoginAsUserResponse encryptedSharedAccountKey
         */

        /**
         * Constructs a new LoginAsUserResponse.
         * @memberof Authentication
         * @classdesc Represents a LoginAsUserResponse.
         * @implements ILoginAsUserResponse
         * @constructor
         * @param {Authentication.ILoginAsUserResponse=} [properties] Properties to set
         */
        function LoginAsUserResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginAsUserResponse encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof Authentication.LoginAsUserResponse
         * @instance
         */
        LoginAsUserResponse.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * LoginAsUserResponse encryptedSharedAccountKey.
         * @member {Uint8Array} encryptedSharedAccountKey
         * @memberof Authentication.LoginAsUserResponse
         * @instance
         */
        LoginAsUserResponse.prototype.encryptedSharedAccountKey = $util.newBuffer([]);

        /**
         * Creates a new LoginAsUserResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Authentication.ILoginAsUserResponse=} [properties] Properties to set
         * @returns {Authentication.LoginAsUserResponse} LoginAsUserResponse instance
         */
        LoginAsUserResponse.create = function create(properties) {
            return new LoginAsUserResponse(properties);
        };

        /**
         * Encodes the specified LoginAsUserResponse message. Does not implicitly {@link Authentication.LoginAsUserResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Authentication.ILoginAsUserResponse} message LoginAsUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAsUserResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedSessionToken);
            if (message.encryptedSharedAccountKey != null && message.hasOwnProperty("encryptedSharedAccountKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedSharedAccountKey);
            return writer;
        };

        /**
         * Encodes the specified LoginAsUserResponse message, length delimited. Does not implicitly {@link Authentication.LoginAsUserResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Authentication.ILoginAsUserResponse} message LoginAsUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginAsUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginAsUserResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.LoginAsUserResponse} LoginAsUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAsUserResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.LoginAsUserResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 2:
                    message.encryptedSharedAccountKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginAsUserResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.LoginAsUserResponse} LoginAsUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginAsUserResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginAsUserResponse message.
         * @function verify
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginAsUserResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.encryptedSharedAccountKey != null && message.hasOwnProperty("encryptedSharedAccountKey"))
                if (!(message.encryptedSharedAccountKey && typeof message.encryptedSharedAccountKey.length === "number" || $util.isString(message.encryptedSharedAccountKey)))
                    return "encryptedSharedAccountKey: buffer expected";
            return null;
        };

        /**
         * Creates a LoginAsUserResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.LoginAsUserResponse} LoginAsUserResponse
         */
        LoginAsUserResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.LoginAsUserResponse)
                return object;
            let message = new $root.Authentication.LoginAsUserResponse();
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.encryptedSharedAccountKey != null)
                if (typeof object.encryptedSharedAccountKey === "string")
                    $util.base64.decode(object.encryptedSharedAccountKey, message.encryptedSharedAccountKey = $util.newBuffer($util.base64.length(object.encryptedSharedAccountKey)), 0);
                else if (object.encryptedSharedAccountKey.length)
                    message.encryptedSharedAccountKey = object.encryptedSharedAccountKey;
            return message;
        };

        /**
         * Creates a plain object from a LoginAsUserResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.LoginAsUserResponse
         * @static
         * @param {Authentication.LoginAsUserResponse} message LoginAsUserResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginAsUserResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                if (options.bytes === String)
                    object.encryptedSharedAccountKey = "";
                else {
                    object.encryptedSharedAccountKey = [];
                    if (options.bytes !== Array)
                        object.encryptedSharedAccountKey = $util.newBuffer(object.encryptedSharedAccountKey);
                }
            }
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.encryptedSharedAccountKey != null && message.hasOwnProperty("encryptedSharedAccountKey"))
                object.encryptedSharedAccountKey = options.bytes === String ? $util.base64.encode(message.encryptedSharedAccountKey, 0, message.encryptedSharedAccountKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSharedAccountKey) : message.encryptedSharedAccountKey;
            return object;
        };

        /**
         * Converts this LoginAsUserResponse to JSON.
         * @function toJSON
         * @memberof Authentication.LoginAsUserResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginAsUserResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginAsUserResponse;
    })();

    /**
     * PasswordMethod enum.
     * @name Authentication.PasswordMethod
     * @enum {string}
     * @property {number} ENTERED=0 ENTERED value
     * @property {number} BIOMETRICS=1 BIOMETRICS value
     */
    Authentication.PasswordMethod = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENTERED"] = 0;
        values[valuesById[1] = "BIOMETRICS"] = 1;
        return values;
    })();

    Authentication.ValidateAuthHashRequest = (function() {

        /**
         * Properties of a ValidateAuthHashRequest.
         * @memberof Authentication
         * @interface IValidateAuthHashRequest
         * @property {Authentication.PasswordMethod|null} [passwordMethod] ValidateAuthHashRequest passwordMethod
         * @property {Uint8Array|null} [authResponse] ValidateAuthHashRequest authResponse
         * @property {Uint8Array|null} [encryptedLoginToken] ValidateAuthHashRequest encryptedLoginToken
         */

        /**
         * Constructs a new ValidateAuthHashRequest.
         * @memberof Authentication
         * @classdesc Represents a ValidateAuthHashRequest.
         * @implements IValidateAuthHashRequest
         * @constructor
         * @param {Authentication.IValidateAuthHashRequest=} [properties] Properties to set
         */
        function ValidateAuthHashRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidateAuthHashRequest passwordMethod.
         * @member {Authentication.PasswordMethod} passwordMethod
         * @memberof Authentication.ValidateAuthHashRequest
         * @instance
         */
        ValidateAuthHashRequest.prototype.passwordMethod = 0;

        /**
         * ValidateAuthHashRequest authResponse.
         * @member {Uint8Array} authResponse
         * @memberof Authentication.ValidateAuthHashRequest
         * @instance
         */
        ValidateAuthHashRequest.prototype.authResponse = $util.newBuffer([]);

        /**
         * ValidateAuthHashRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.ValidateAuthHashRequest
         * @instance
         */
        ValidateAuthHashRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * Creates a new ValidateAuthHashRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Authentication.IValidateAuthHashRequest=} [properties] Properties to set
         * @returns {Authentication.ValidateAuthHashRequest} ValidateAuthHashRequest instance
         */
        ValidateAuthHashRequest.create = function create(properties) {
            return new ValidateAuthHashRequest(properties);
        };

        /**
         * Encodes the specified ValidateAuthHashRequest message. Does not implicitly {@link Authentication.ValidateAuthHashRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Authentication.IValidateAuthHashRequest} message ValidateAuthHashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateAuthHashRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passwordMethod != null && message.hasOwnProperty("passwordMethod"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.passwordMethod);
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.authResponse);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedLoginToken);
            return writer;
        };

        /**
         * Encodes the specified ValidateAuthHashRequest message, length delimited. Does not implicitly {@link Authentication.ValidateAuthHashRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Authentication.IValidateAuthHashRequest} message ValidateAuthHashRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateAuthHashRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidateAuthHashRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ValidateAuthHashRequest} ValidateAuthHashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateAuthHashRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ValidateAuthHashRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.passwordMethod = reader.int32();
                    break;
                case 2:
                    message.authResponse = reader.bytes();
                    break;
                case 3:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidateAuthHashRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ValidateAuthHashRequest} ValidateAuthHashRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateAuthHashRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidateAuthHashRequest message.
         * @function verify
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidateAuthHashRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passwordMethod != null && message.hasOwnProperty("passwordMethod"))
                switch (message.passwordMethod) {
                default:
                    return "passwordMethod: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                if (!(message.authResponse && typeof message.authResponse.length === "number" || $util.isString(message.authResponse)))
                    return "authResponse: buffer expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            return null;
        };

        /**
         * Creates a ValidateAuthHashRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ValidateAuthHashRequest} ValidateAuthHashRequest
         */
        ValidateAuthHashRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ValidateAuthHashRequest)
                return object;
            let message = new $root.Authentication.ValidateAuthHashRequest();
            switch (object.passwordMethod) {
            case "ENTERED":
            case 0:
                message.passwordMethod = 0;
                break;
            case "BIOMETRICS":
            case 1:
                message.passwordMethod = 1;
                break;
            }
            if (object.authResponse != null)
                if (typeof object.authResponse === "string")
                    $util.base64.decode(object.authResponse, message.authResponse = $util.newBuffer($util.base64.length(object.authResponse)), 0);
                else if (object.authResponse.length)
                    message.authResponse = object.authResponse;
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            return message;
        };

        /**
         * Creates a plain object from a ValidateAuthHashRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ValidateAuthHashRequest
         * @static
         * @param {Authentication.ValidateAuthHashRequest} message ValidateAuthHashRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidateAuthHashRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.passwordMethod = options.enums === String ? "ENTERED" : 0;
                if (options.bytes === String)
                    object.authResponse = "";
                else {
                    object.authResponse = [];
                    if (options.bytes !== Array)
                        object.authResponse = $util.newBuffer(object.authResponse);
                }
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
            }
            if (message.passwordMethod != null && message.hasOwnProperty("passwordMethod"))
                object.passwordMethod = options.enums === String ? $root.Authentication.PasswordMethod[message.passwordMethod] : message.passwordMethod;
            if (message.authResponse != null && message.hasOwnProperty("authResponse"))
                object.authResponse = options.bytes === String ? $util.base64.encode(message.authResponse, 0, message.authResponse.length) : options.bytes === Array ? Array.prototype.slice.call(message.authResponse) : message.authResponse;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            return object;
        };

        /**
         * Converts this ValidateAuthHashRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ValidateAuthHashRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidateAuthHashRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidateAuthHashRequest;
    })();

    /**
     * TwoFactorPushType enum.
     * @name Authentication.TwoFactorPushType
     * @enum {string}
     * @property {number} TWO_FA_PUSH_NONE=0 TWO_FA_PUSH_NONE value
     * @property {number} TWO_FA_PUSH_SMS=1 TWO_FA_PUSH_SMS value
     * @property {number} TWO_FA_PUSH_KEEPER=2 TWO_FA_PUSH_KEEPER value
     * @property {number} TWO_FA_PUSH_DUO_PUSH=3 TWO_FA_PUSH_DUO_PUSH value
     * @property {number} TWO_FA_PUSH_DUO_TEXT=4 TWO_FA_PUSH_DUO_TEXT value
     * @property {number} TWO_FA_PUSH_DUO_CALL=5 TWO_FA_PUSH_DUO_CALL value
     * @property {number} TWO_FA_PUSH_DNA=6 TWO_FA_PUSH_DNA value
     */
    Authentication.TwoFactorPushType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TWO_FA_PUSH_NONE"] = 0;
        values[valuesById[1] = "TWO_FA_PUSH_SMS"] = 1;
        values[valuesById[2] = "TWO_FA_PUSH_KEEPER"] = 2;
        values[valuesById[3] = "TWO_FA_PUSH_DUO_PUSH"] = 3;
        values[valuesById[4] = "TWO_FA_PUSH_DUO_TEXT"] = 4;
        values[valuesById[5] = "TWO_FA_PUSH_DUO_CALL"] = 5;
        values[valuesById[6] = "TWO_FA_PUSH_DNA"] = 6;
        return values;
    })();

    /**
     * TwoFactorValueType enum.
     * @name Authentication.TwoFactorValueType
     * @enum {string}
     * @property {number} TWO_FA_CODE_NONE=0 TWO_FA_CODE_NONE value
     * @property {number} TWO_FA_CODE_TOTP=1 TWO_FA_CODE_TOTP value
     * @property {number} TWO_FA_CODE_SMS=2 TWO_FA_CODE_SMS value
     * @property {number} TWO_FA_CODE_DUO=3 TWO_FA_CODE_DUO value
     * @property {number} TWO_FA_CODE_RSA=4 TWO_FA_CODE_RSA value
     * @property {number} TWO_FA_RESP_U2F=5 TWO_FA_RESP_U2F value
     * @property {number} TWO_FA_RESP_WEBAUTHN=6 TWO_FA_RESP_WEBAUTHN value
     * @property {number} TWO_FA_CODE_DNA=7 TWO_FA_CODE_DNA value
     */
    Authentication.TwoFactorValueType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TWO_FA_CODE_NONE"] = 0;
        values[valuesById[1] = "TWO_FA_CODE_TOTP"] = 1;
        values[valuesById[2] = "TWO_FA_CODE_SMS"] = 2;
        values[valuesById[3] = "TWO_FA_CODE_DUO"] = 3;
        values[valuesById[4] = "TWO_FA_CODE_RSA"] = 4;
        values[valuesById[5] = "TWO_FA_RESP_U2F"] = 5;
        values[valuesById[6] = "TWO_FA_RESP_WEBAUTHN"] = 6;
        values[valuesById[7] = "TWO_FA_CODE_DNA"] = 7;
        return values;
    })();

    /**
     * TwoFactorChannelType enum.
     * @name Authentication.TwoFactorChannelType
     * @enum {string}
     * @property {number} TWO_FA_CT_NONE=0 TWO_FA_CT_NONE value
     * @property {number} TWO_FA_CT_TOTP=1 TWO_FA_CT_TOTP value
     * @property {number} TWO_FA_CT_SMS=2 TWO_FA_CT_SMS value
     * @property {number} TWO_FA_CT_DUO=3 TWO_FA_CT_DUO value
     * @property {number} TWO_FA_CT_RSA=4 TWO_FA_CT_RSA value
     * @property {number} TWO_FA_CT_BACKUP=5 TWO_FA_CT_BACKUP value
     * @property {number} TWO_FA_CT_U2F=6 TWO_FA_CT_U2F value
     * @property {number} TWO_FA_CT_WEBAUTHN=7 TWO_FA_CT_WEBAUTHN value
     * @property {number} TWO_FA_CT_KEEPER=8 TWO_FA_CT_KEEPER value
     * @property {number} TWO_FA_CT_DNA=9 TWO_FA_CT_DNA value
     */
    Authentication.TwoFactorChannelType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TWO_FA_CT_NONE"] = 0;
        values[valuesById[1] = "TWO_FA_CT_TOTP"] = 1;
        values[valuesById[2] = "TWO_FA_CT_SMS"] = 2;
        values[valuesById[3] = "TWO_FA_CT_DUO"] = 3;
        values[valuesById[4] = "TWO_FA_CT_RSA"] = 4;
        values[valuesById[5] = "TWO_FA_CT_BACKUP"] = 5;
        values[valuesById[6] = "TWO_FA_CT_U2F"] = 6;
        values[valuesById[7] = "TWO_FA_CT_WEBAUTHN"] = 7;
        values[valuesById[8] = "TWO_FA_CT_KEEPER"] = 8;
        values[valuesById[9] = "TWO_FA_CT_DNA"] = 9;
        return values;
    })();

    Authentication.TwoFactorChannelInfo = (function() {

        /**
         * Properties of a TwoFactorChannelInfo.
         * @memberof Authentication
         * @interface ITwoFactorChannelInfo
         * @property {Authentication.TwoFactorChannelType|null} [channelType] TwoFactorChannelInfo channelType
         * @property {Uint8Array|null} [channelUid] TwoFactorChannelInfo channelUid
         * @property {string|null} [channelName] TwoFactorChannelInfo channelName
         * @property {string|null} [challenge] TwoFactorChannelInfo challenge
         * @property {Array.<string>|null} [capabilities] TwoFactorChannelInfo capabilities
         * @property {string|null} [phoneNumber] TwoFactorChannelInfo phoneNumber
         * @property {Authentication.TwoFactorExpiration|null} [maxExpiration] TwoFactorChannelInfo maxExpiration
         */

        /**
         * Constructs a new TwoFactorChannelInfo.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorChannelInfo.
         * @implements ITwoFactorChannelInfo
         * @constructor
         * @param {Authentication.ITwoFactorChannelInfo=} [properties] Properties to set
         */
        function TwoFactorChannelInfo(properties) {
            this.capabilities = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorChannelInfo channelType.
         * @member {Authentication.TwoFactorChannelType} channelType
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.channelType = 0;

        /**
         * TwoFactorChannelInfo channelUid.
         * @member {Uint8Array} channelUid
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.channelUid = $util.newBuffer([]);

        /**
         * TwoFactorChannelInfo channelName.
         * @member {string} channelName
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.channelName = "";

        /**
         * TwoFactorChannelInfo challenge.
         * @member {string} challenge
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.challenge = "";

        /**
         * TwoFactorChannelInfo capabilities.
         * @member {Array.<string>} capabilities
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.capabilities = $util.emptyArray;

        /**
         * TwoFactorChannelInfo phoneNumber.
         * @member {string} phoneNumber
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.phoneNumber = "";

        /**
         * TwoFactorChannelInfo maxExpiration.
         * @member {Authentication.TwoFactorExpiration} maxExpiration
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         */
        TwoFactorChannelInfo.prototype.maxExpiration = 0;

        /**
         * Creates a new TwoFactorChannelInfo instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Authentication.ITwoFactorChannelInfo=} [properties] Properties to set
         * @returns {Authentication.TwoFactorChannelInfo} TwoFactorChannelInfo instance
         */
        TwoFactorChannelInfo.create = function create(properties) {
            return new TwoFactorChannelInfo(properties);
        };

        /**
         * Encodes the specified TwoFactorChannelInfo message. Does not implicitly {@link Authentication.TwoFactorChannelInfo.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Authentication.ITwoFactorChannelInfo} message TwoFactorChannelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannelInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.channelType);
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.channelUid);
            if (message.channelName != null && message.hasOwnProperty("channelName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelName);
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.challenge);
            if (message.capabilities != null && message.capabilities.length)
                for (let i = 0; i < message.capabilities.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.capabilities[i]);
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.phoneNumber);
            if (message.maxExpiration != null && message.hasOwnProperty("maxExpiration"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxExpiration);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorChannelInfo message, length delimited. Does not implicitly {@link Authentication.TwoFactorChannelInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Authentication.ITwoFactorChannelInfo} message TwoFactorChannelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorChannelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorChannelInfo} TwoFactorChannelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorChannelInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelType = reader.int32();
                    break;
                case 2:
                    message.channelUid = reader.bytes();
                    break;
                case 3:
                    message.channelName = reader.string();
                    break;
                case 4:
                    message.challenge = reader.string();
                    break;
                case 5:
                    if (!(message.capabilities && message.capabilities.length))
                        message.capabilities = [];
                    message.capabilities.push(reader.string());
                    break;
                case 6:
                    message.phoneNumber = reader.string();
                    break;
                case 7:
                    message.maxExpiration = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorChannelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorChannelInfo} TwoFactorChannelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorChannelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorChannelInfo message.
         * @function verify
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorChannelInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                switch (message.channelType) {
                default:
                    return "channelType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                if (!(message.channelUid && typeof message.channelUid.length === "number" || $util.isString(message.channelUid)))
                    return "channelUid: buffer expected";
            if (message.channelName != null && message.hasOwnProperty("channelName"))
                if (!$util.isString(message.channelName))
                    return "channelName: string expected";
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                if (!$util.isString(message.challenge))
                    return "challenge: string expected";
            if (message.capabilities != null && message.hasOwnProperty("capabilities")) {
                if (!Array.isArray(message.capabilities))
                    return "capabilities: array expected";
                for (let i = 0; i < message.capabilities.length; ++i)
                    if (!$util.isString(message.capabilities[i]))
                        return "capabilities: string[] expected";
            }
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                if (!$util.isString(message.phoneNumber))
                    return "phoneNumber: string expected";
            if (message.maxExpiration != null && message.hasOwnProperty("maxExpiration"))
                switch (message.maxExpiration) {
                default:
                    return "maxExpiration: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a TwoFactorChannelInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorChannelInfo} TwoFactorChannelInfo
         */
        TwoFactorChannelInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorChannelInfo)
                return object;
            let message = new $root.Authentication.TwoFactorChannelInfo();
            switch (object.channelType) {
            case "TWO_FA_CT_NONE":
            case 0:
                message.channelType = 0;
                break;
            case "TWO_FA_CT_TOTP":
            case 1:
                message.channelType = 1;
                break;
            case "TWO_FA_CT_SMS":
            case 2:
                message.channelType = 2;
                break;
            case "TWO_FA_CT_DUO":
            case 3:
                message.channelType = 3;
                break;
            case "TWO_FA_CT_RSA":
            case 4:
                message.channelType = 4;
                break;
            case "TWO_FA_CT_BACKUP":
            case 5:
                message.channelType = 5;
                break;
            case "TWO_FA_CT_U2F":
            case 6:
                message.channelType = 6;
                break;
            case "TWO_FA_CT_WEBAUTHN":
            case 7:
                message.channelType = 7;
                break;
            case "TWO_FA_CT_KEEPER":
            case 8:
                message.channelType = 8;
                break;
            case "TWO_FA_CT_DNA":
            case 9:
                message.channelType = 9;
                break;
            }
            if (object.channelUid != null)
                if (typeof object.channelUid === "string")
                    $util.base64.decode(object.channelUid, message.channelUid = $util.newBuffer($util.base64.length(object.channelUid)), 0);
                else if (object.channelUid.length)
                    message.channelUid = object.channelUid;
            if (object.channelName != null)
                message.channelName = String(object.channelName);
            if (object.challenge != null)
                message.challenge = String(object.challenge);
            if (object.capabilities) {
                if (!Array.isArray(object.capabilities))
                    throw TypeError(".Authentication.TwoFactorChannelInfo.capabilities: array expected");
                message.capabilities = [];
                for (let i = 0; i < object.capabilities.length; ++i)
                    message.capabilities[i] = String(object.capabilities[i]);
            }
            if (object.phoneNumber != null)
                message.phoneNumber = String(object.phoneNumber);
            switch (object.maxExpiration) {
            case "TWO_FA_EXP_IMMEDIATELY":
            case 0:
                message.maxExpiration = 0;
                break;
            case "TWO_FA_EXP_5_MINUTES":
            case 1:
                message.maxExpiration = 1;
                break;
            case "TWO_FA_EXP_12_HOURS":
            case 2:
                message.maxExpiration = 2;
                break;
            case "TWO_FA_EXP_24_HOURS":
            case 3:
                message.maxExpiration = 3;
                break;
            case "TWO_FA_EXP_30_DAYS":
            case 4:
                message.maxExpiration = 4;
                break;
            case "TWO_FA_EXP_NEVER":
            case 5:
                message.maxExpiration = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorChannelInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorChannelInfo
         * @static
         * @param {Authentication.TwoFactorChannelInfo} message TwoFactorChannelInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorChannelInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.capabilities = [];
            if (options.defaults) {
                object.channelType = options.enums === String ? "TWO_FA_CT_NONE" : 0;
                if (options.bytes === String)
                    object.channelUid = "";
                else {
                    object.channelUid = [];
                    if (options.bytes !== Array)
                        object.channelUid = $util.newBuffer(object.channelUid);
                }
                object.channelName = "";
                object.challenge = "";
                object.phoneNumber = "";
                object.maxExpiration = options.enums === String ? "TWO_FA_EXP_IMMEDIATELY" : 0;
            }
            if (message.channelType != null && message.hasOwnProperty("channelType"))
                object.channelType = options.enums === String ? $root.Authentication.TwoFactorChannelType[message.channelType] : message.channelType;
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                object.channelUid = options.bytes === String ? $util.base64.encode(message.channelUid, 0, message.channelUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelUid) : message.channelUid;
            if (message.channelName != null && message.hasOwnProperty("channelName"))
                object.channelName = message.channelName;
            if (message.challenge != null && message.hasOwnProperty("challenge"))
                object.challenge = message.challenge;
            if (message.capabilities && message.capabilities.length) {
                object.capabilities = [];
                for (let j = 0; j < message.capabilities.length; ++j)
                    object.capabilities[j] = message.capabilities[j];
            }
            if (message.phoneNumber != null && message.hasOwnProperty("phoneNumber"))
                object.phoneNumber = message.phoneNumber;
            if (message.maxExpiration != null && message.hasOwnProperty("maxExpiration"))
                object.maxExpiration = options.enums === String ? $root.Authentication.TwoFactorExpiration[message.maxExpiration] : message.maxExpiration;
            return object;
        };

        /**
         * Converts this TwoFactorChannelInfo to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorChannelInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorChannelInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorChannelInfo;
    })();

    /**
     * TwoFactorExpiration enum.
     * @name Authentication.TwoFactorExpiration
     * @enum {string}
     * @property {number} TWO_FA_EXP_IMMEDIATELY=0 TWO_FA_EXP_IMMEDIATELY value
     * @property {number} TWO_FA_EXP_5_MINUTES=1 TWO_FA_EXP_5_MINUTES value
     * @property {number} TWO_FA_EXP_12_HOURS=2 TWO_FA_EXP_12_HOURS value
     * @property {number} TWO_FA_EXP_24_HOURS=3 TWO_FA_EXP_24_HOURS value
     * @property {number} TWO_FA_EXP_30_DAYS=4 TWO_FA_EXP_30_DAYS value
     * @property {number} TWO_FA_EXP_NEVER=5 TWO_FA_EXP_NEVER value
     */
    Authentication.TwoFactorExpiration = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TWO_FA_EXP_IMMEDIATELY"] = 0;
        values[valuesById[1] = "TWO_FA_EXP_5_MINUTES"] = 1;
        values[valuesById[2] = "TWO_FA_EXP_12_HOURS"] = 2;
        values[valuesById[3] = "TWO_FA_EXP_24_HOURS"] = 3;
        values[valuesById[4] = "TWO_FA_EXP_30_DAYS"] = 4;
        values[valuesById[5] = "TWO_FA_EXP_NEVER"] = 5;
        return values;
    })();

    Authentication.TwoFactorValidateRequest = (function() {

        /**
         * Properties of a TwoFactorValidateRequest.
         * @memberof Authentication
         * @interface ITwoFactorValidateRequest
         * @property {Uint8Array|null} [encryptedLoginToken] TwoFactorValidateRequest encryptedLoginToken
         * @property {Authentication.TwoFactorValueType|null} [valueType] TwoFactorValidateRequest valueType
         * @property {string|null} [value] TwoFactorValidateRequest value
         * @property {Uint8Array|null} [channelUid] TwoFactorValidateRequest channelUid
         * @property {Authentication.TwoFactorExpiration|null} [expireIn] TwoFactorValidateRequest expireIn
         */

        /**
         * Constructs a new TwoFactorValidateRequest.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorValidateRequest.
         * @implements ITwoFactorValidateRequest
         * @constructor
         * @param {Authentication.ITwoFactorValidateRequest=} [properties] Properties to set
         */
        function TwoFactorValidateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorValidateRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         */
        TwoFactorValidateRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * TwoFactorValidateRequest valueType.
         * @member {Authentication.TwoFactorValueType} valueType
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         */
        TwoFactorValidateRequest.prototype.valueType = 0;

        /**
         * TwoFactorValidateRequest value.
         * @member {string} value
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         */
        TwoFactorValidateRequest.prototype.value = "";

        /**
         * TwoFactorValidateRequest channelUid.
         * @member {Uint8Array} channelUid
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         */
        TwoFactorValidateRequest.prototype.channelUid = $util.newBuffer([]);

        /**
         * TwoFactorValidateRequest expireIn.
         * @member {Authentication.TwoFactorExpiration} expireIn
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         */
        TwoFactorValidateRequest.prototype.expireIn = 0;

        /**
         * Creates a new TwoFactorValidateRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Authentication.ITwoFactorValidateRequest=} [properties] Properties to set
         * @returns {Authentication.TwoFactorValidateRequest} TwoFactorValidateRequest instance
         */
        TwoFactorValidateRequest.create = function create(properties) {
            return new TwoFactorValidateRequest(properties);
        };

        /**
         * Encodes the specified TwoFactorValidateRequest message. Does not implicitly {@link Authentication.TwoFactorValidateRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Authentication.ITwoFactorValidateRequest} message TwoFactorValidateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorValidateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedLoginToken);
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.valueType);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.channelUid);
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.expireIn);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorValidateRequest message, length delimited. Does not implicitly {@link Authentication.TwoFactorValidateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Authentication.ITwoFactorValidateRequest} message TwoFactorValidateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorValidateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorValidateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorValidateRequest} TwoFactorValidateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorValidateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorValidateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 2:
                    message.valueType = reader.int32();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                case 4:
                    message.channelUid = reader.bytes();
                    break;
                case 5:
                    message.expireIn = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorValidateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorValidateRequest} TwoFactorValidateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorValidateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorValidateRequest message.
         * @function verify
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorValidateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                switch (message.valueType) {
                default:
                    return "valueType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                if (!(message.channelUid && typeof message.channelUid.length === "number" || $util.isString(message.channelUid)))
                    return "channelUid: buffer expected";
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                switch (message.expireIn) {
                default:
                    return "expireIn: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a TwoFactorValidateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorValidateRequest} TwoFactorValidateRequest
         */
        TwoFactorValidateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorValidateRequest)
                return object;
            let message = new $root.Authentication.TwoFactorValidateRequest();
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            switch (object.valueType) {
            case "TWO_FA_CODE_NONE":
            case 0:
                message.valueType = 0;
                break;
            case "TWO_FA_CODE_TOTP":
            case 1:
                message.valueType = 1;
                break;
            case "TWO_FA_CODE_SMS":
            case 2:
                message.valueType = 2;
                break;
            case "TWO_FA_CODE_DUO":
            case 3:
                message.valueType = 3;
                break;
            case "TWO_FA_CODE_RSA":
            case 4:
                message.valueType = 4;
                break;
            case "TWO_FA_RESP_U2F":
            case 5:
                message.valueType = 5;
                break;
            case "TWO_FA_RESP_WEBAUTHN":
            case 6:
                message.valueType = 6;
                break;
            case "TWO_FA_CODE_DNA":
            case 7:
                message.valueType = 7;
                break;
            }
            if (object.value != null)
                message.value = String(object.value);
            if (object.channelUid != null)
                if (typeof object.channelUid === "string")
                    $util.base64.decode(object.channelUid, message.channelUid = $util.newBuffer($util.base64.length(object.channelUid)), 0);
                else if (object.channelUid.length)
                    message.channelUid = object.channelUid;
            switch (object.expireIn) {
            case "TWO_FA_EXP_IMMEDIATELY":
            case 0:
                message.expireIn = 0;
                break;
            case "TWO_FA_EXP_5_MINUTES":
            case 1:
                message.expireIn = 1;
                break;
            case "TWO_FA_EXP_12_HOURS":
            case 2:
                message.expireIn = 2;
                break;
            case "TWO_FA_EXP_24_HOURS":
            case 3:
                message.expireIn = 3;
                break;
            case "TWO_FA_EXP_30_DAYS":
            case 4:
                message.expireIn = 4;
                break;
            case "TWO_FA_EXP_NEVER":
            case 5:
                message.expireIn = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorValidateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorValidateRequest
         * @static
         * @param {Authentication.TwoFactorValidateRequest} message TwoFactorValidateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorValidateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                object.valueType = options.enums === String ? "TWO_FA_CODE_NONE" : 0;
                object.value = "";
                if (options.bytes === String)
                    object.channelUid = "";
                else {
                    object.channelUid = [];
                    if (options.bytes !== Array)
                        object.channelUid = $util.newBuffer(object.channelUid);
                }
                object.expireIn = options.enums === String ? "TWO_FA_EXP_IMMEDIATELY" : 0;
            }
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                object.valueType = options.enums === String ? $root.Authentication.TwoFactorValueType[message.valueType] : message.valueType;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                object.channelUid = options.bytes === String ? $util.base64.encode(message.channelUid, 0, message.channelUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelUid) : message.channelUid;
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                object.expireIn = options.enums === String ? $root.Authentication.TwoFactorExpiration[message.expireIn] : message.expireIn;
            return object;
        };

        /**
         * Converts this TwoFactorValidateRequest to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorValidateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorValidateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorValidateRequest;
    })();

    Authentication.TwoFactorValidateResponse = (function() {

        /**
         * Properties of a TwoFactorValidateResponse.
         * @memberof Authentication
         * @interface ITwoFactorValidateResponse
         * @property {Uint8Array|null} [encryptedLoginToken] TwoFactorValidateResponse encryptedLoginToken
         */

        /**
         * Constructs a new TwoFactorValidateResponse.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorValidateResponse.
         * @implements ITwoFactorValidateResponse
         * @constructor
         * @param {Authentication.ITwoFactorValidateResponse=} [properties] Properties to set
         */
        function TwoFactorValidateResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorValidateResponse encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.TwoFactorValidateResponse
         * @instance
         */
        TwoFactorValidateResponse.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * Creates a new TwoFactorValidateResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Authentication.ITwoFactorValidateResponse=} [properties] Properties to set
         * @returns {Authentication.TwoFactorValidateResponse} TwoFactorValidateResponse instance
         */
        TwoFactorValidateResponse.create = function create(properties) {
            return new TwoFactorValidateResponse(properties);
        };

        /**
         * Encodes the specified TwoFactorValidateResponse message. Does not implicitly {@link Authentication.TwoFactorValidateResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Authentication.ITwoFactorValidateResponse} message TwoFactorValidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorValidateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedLoginToken);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorValidateResponse message, length delimited. Does not implicitly {@link Authentication.TwoFactorValidateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Authentication.ITwoFactorValidateResponse} message TwoFactorValidateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorValidateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorValidateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorValidateResponse} TwoFactorValidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorValidateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorValidateResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorValidateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorValidateResponse} TwoFactorValidateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorValidateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorValidateResponse message.
         * @function verify
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorValidateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            return null;
        };

        /**
         * Creates a TwoFactorValidateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorValidateResponse} TwoFactorValidateResponse
         */
        TwoFactorValidateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorValidateResponse)
                return object;
            let message = new $root.Authentication.TwoFactorValidateResponse();
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorValidateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorValidateResponse
         * @static
         * @param {Authentication.TwoFactorValidateResponse} message TwoFactorValidateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorValidateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            return object;
        };

        /**
         * Converts this TwoFactorValidateResponse to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorValidateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorValidateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorValidateResponse;
    })();

    Authentication.TwoFactorSendPushRequest = (function() {

        /**
         * Properties of a TwoFactorSendPushRequest.
         * @memberof Authentication
         * @interface ITwoFactorSendPushRequest
         * @property {Uint8Array|null} [encryptedLoginToken] TwoFactorSendPushRequest encryptedLoginToken
         * @property {Authentication.TwoFactorPushType|null} [pushType] TwoFactorSendPushRequest pushType
         * @property {Uint8Array|null} [channelUid] TwoFactorSendPushRequest channelUid
         * @property {Authentication.TwoFactorExpiration|null} [expireIn] TwoFactorSendPushRequest expireIn
         */

        /**
         * Constructs a new TwoFactorSendPushRequest.
         * @memberof Authentication
         * @classdesc Represents a TwoFactorSendPushRequest.
         * @implements ITwoFactorSendPushRequest
         * @constructor
         * @param {Authentication.ITwoFactorSendPushRequest=} [properties] Properties to set
         */
        function TwoFactorSendPushRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorSendPushRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.TwoFactorSendPushRequest
         * @instance
         */
        TwoFactorSendPushRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * TwoFactorSendPushRequest pushType.
         * @member {Authentication.TwoFactorPushType} pushType
         * @memberof Authentication.TwoFactorSendPushRequest
         * @instance
         */
        TwoFactorSendPushRequest.prototype.pushType = 0;

        /**
         * TwoFactorSendPushRequest channelUid.
         * @member {Uint8Array} channelUid
         * @memberof Authentication.TwoFactorSendPushRequest
         * @instance
         */
        TwoFactorSendPushRequest.prototype.channelUid = $util.newBuffer([]);

        /**
         * TwoFactorSendPushRequest expireIn.
         * @member {Authentication.TwoFactorExpiration} expireIn
         * @memberof Authentication.TwoFactorSendPushRequest
         * @instance
         */
        TwoFactorSendPushRequest.prototype.expireIn = 0;

        /**
         * Creates a new TwoFactorSendPushRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Authentication.ITwoFactorSendPushRequest=} [properties] Properties to set
         * @returns {Authentication.TwoFactorSendPushRequest} TwoFactorSendPushRequest instance
         */
        TwoFactorSendPushRequest.create = function create(properties) {
            return new TwoFactorSendPushRequest(properties);
        };

        /**
         * Encodes the specified TwoFactorSendPushRequest message. Does not implicitly {@link Authentication.TwoFactorSendPushRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Authentication.ITwoFactorSendPushRequest} message TwoFactorSendPushRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorSendPushRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedLoginToken);
            if (message.pushType != null && message.hasOwnProperty("pushType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pushType);
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.channelUid);
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.expireIn);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorSendPushRequest message, length delimited. Does not implicitly {@link Authentication.TwoFactorSendPushRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Authentication.ITwoFactorSendPushRequest} message TwoFactorSendPushRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorSendPushRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorSendPushRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.TwoFactorSendPushRequest} TwoFactorSendPushRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorSendPushRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.TwoFactorSendPushRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 2:
                    message.pushType = reader.int32();
                    break;
                case 3:
                    message.channelUid = reader.bytes();
                    break;
                case 4:
                    message.expireIn = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorSendPushRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.TwoFactorSendPushRequest} TwoFactorSendPushRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorSendPushRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorSendPushRequest message.
         * @function verify
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorSendPushRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.pushType != null && message.hasOwnProperty("pushType"))
                switch (message.pushType) {
                default:
                    return "pushType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                if (!(message.channelUid && typeof message.channelUid.length === "number" || $util.isString(message.channelUid)))
                    return "channelUid: buffer expected";
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                switch (message.expireIn) {
                default:
                    return "expireIn: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a TwoFactorSendPushRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.TwoFactorSendPushRequest} TwoFactorSendPushRequest
         */
        TwoFactorSendPushRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.TwoFactorSendPushRequest)
                return object;
            let message = new $root.Authentication.TwoFactorSendPushRequest();
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            switch (object.pushType) {
            case "TWO_FA_PUSH_NONE":
            case 0:
                message.pushType = 0;
                break;
            case "TWO_FA_PUSH_SMS":
            case 1:
                message.pushType = 1;
                break;
            case "TWO_FA_PUSH_KEEPER":
            case 2:
                message.pushType = 2;
                break;
            case "TWO_FA_PUSH_DUO_PUSH":
            case 3:
                message.pushType = 3;
                break;
            case "TWO_FA_PUSH_DUO_TEXT":
            case 4:
                message.pushType = 4;
                break;
            case "TWO_FA_PUSH_DUO_CALL":
            case 5:
                message.pushType = 5;
                break;
            case "TWO_FA_PUSH_DNA":
            case 6:
                message.pushType = 6;
                break;
            }
            if (object.channelUid != null)
                if (typeof object.channelUid === "string")
                    $util.base64.decode(object.channelUid, message.channelUid = $util.newBuffer($util.base64.length(object.channelUid)), 0);
                else if (object.channelUid.length)
                    message.channelUid = object.channelUid;
            switch (object.expireIn) {
            case "TWO_FA_EXP_IMMEDIATELY":
            case 0:
                message.expireIn = 0;
                break;
            case "TWO_FA_EXP_5_MINUTES":
            case 1:
                message.expireIn = 1;
                break;
            case "TWO_FA_EXP_12_HOURS":
            case 2:
                message.expireIn = 2;
                break;
            case "TWO_FA_EXP_24_HOURS":
            case 3:
                message.expireIn = 3;
                break;
            case "TWO_FA_EXP_30_DAYS":
            case 4:
                message.expireIn = 4;
                break;
            case "TWO_FA_EXP_NEVER":
            case 5:
                message.expireIn = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorSendPushRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.TwoFactorSendPushRequest
         * @static
         * @param {Authentication.TwoFactorSendPushRequest} message TwoFactorSendPushRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorSendPushRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                object.pushType = options.enums === String ? "TWO_FA_PUSH_NONE" : 0;
                if (options.bytes === String)
                    object.channelUid = "";
                else {
                    object.channelUid = [];
                    if (options.bytes !== Array)
                        object.channelUid = $util.newBuffer(object.channelUid);
                }
                object.expireIn = options.enums === String ? "TWO_FA_EXP_IMMEDIATELY" : 0;
            }
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.pushType != null && message.hasOwnProperty("pushType"))
                object.pushType = options.enums === String ? $root.Authentication.TwoFactorPushType[message.pushType] : message.pushType;
            if (message.channelUid != null && message.hasOwnProperty("channelUid"))
                object.channelUid = options.bytes === String ? $util.base64.encode(message.channelUid, 0, message.channelUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.channelUid) : message.channelUid;
            if (message.expireIn != null && message.hasOwnProperty("expireIn"))
                object.expireIn = options.enums === String ? $root.Authentication.TwoFactorExpiration[message.expireIn] : message.expireIn;
            return object;
        };

        /**
         * Converts this TwoFactorSendPushRequest to JSON.
         * @function toJSON
         * @memberof Authentication.TwoFactorSendPushRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorSendPushRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorSendPushRequest;
    })();

    Authentication.License = (function() {

        /**
         * Properties of a License.
         * @memberof Authentication
         * @interface ILicense
         * @property {number|Long|null} [created] License created
         * @property {number|Long|null} [expiration] License expiration
         * @property {Authentication.LicenseStatus|null} [licenseStatus] License licenseStatus
         * @property {boolean|null} [paid] License paid
         * @property {string|null} [message] License message
         */

        /**
         * Constructs a new License.
         * @memberof Authentication
         * @classdesc Represents a License.
         * @implements ILicense
         * @constructor
         * @param {Authentication.ILicense=} [properties] Properties to set
         */
        function License(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * License created.
         * @member {number|Long} created
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License expiration.
         * @member {number|Long} expiration
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License licenseStatus.
         * @member {Authentication.LicenseStatus} licenseStatus
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.licenseStatus = 0;

        /**
         * License paid.
         * @member {boolean} paid
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.paid = false;

        /**
         * License message.
         * @member {string} message
         * @memberof Authentication.License
         * @instance
         */
        License.prototype.message = "";

        /**
         * Creates a new License instance using the specified properties.
         * @function create
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense=} [properties] Properties to set
         * @returns {Authentication.License} License instance
         */
        License.create = function create(properties) {
            return new License(properties);
        };

        /**
         * Encodes the specified License message. Does not implicitly {@link Authentication.License.verify|verify} messages.
         * @function encode
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.licenseStatus);
            if (message.paid != null && message.hasOwnProperty("paid"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.paid);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified License message, length delimited. Does not implicitly {@link Authentication.License.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.License
         * @static
         * @param {Authentication.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a License message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.License();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.licenseStatus = reader.int32();
                    break;
                case 4:
                    message.paid = reader.bool();
                    break;
                case 5:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a License message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a License message.
         * @function verify
         * @memberof Authentication.License
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        License.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                switch (message.licenseStatus) {
                default:
                    return "licenseStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.paid != null && message.hasOwnProperty("paid"))
                if (typeof message.paid !== "boolean")
                    return "paid: boolean expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a License message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.License
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.License} License
         */
        License.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.License)
                return object;
            let message = new $root.Authentication.License();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            switch (object.licenseStatus) {
            case "OTHER":
            case 0:
                message.licenseStatus = 0;
                break;
            case "ACTIVE":
            case 1:
                message.licenseStatus = 1;
                break;
            case "EXPIRED":
            case 2:
                message.licenseStatus = 2;
                break;
            case "DISABLED":
            case 3:
                message.licenseStatus = 3;
                break;
            }
            if (object.paid != null)
                message.paid = Boolean(object.paid);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a License message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.License
         * @static
         * @param {Authentication.License} message License
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        License.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.licenseStatus = options.enums === String ? "OTHER" : 0;
                object.paid = false;
                object.message = "";
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                object.licenseStatus = options.enums === String ? $root.Authentication.LicenseStatus[message.licenseStatus] : message.licenseStatus;
            if (message.paid != null && message.hasOwnProperty("paid"))
                object.paid = message.paid;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this License to JSON.
         * @function toJSON
         * @memberof Authentication.License
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        License.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return License;
    })();

    /**
     * LicenseType enum.
     * @name Authentication.LicenseType
     * @enum {string}
     * @property {number} VAULT=0 VAULT value
     * @property {number} CHAT=1 CHAT value
     * @property {number} STORAGE=2 STORAGE value
     * @property {number} BREACHWATCH=3 BREACHWATCH value
     */
    Authentication.LicenseType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VAULT"] = 0;
        values[valuesById[1] = "CHAT"] = 1;
        values[valuesById[2] = "STORAGE"] = 2;
        values[valuesById[3] = "BREACHWATCH"] = 3;
        return values;
    })();

    Authentication.OwnerlessRecord = (function() {

        /**
         * Properties of an OwnerlessRecord.
         * @memberof Authentication
         * @interface IOwnerlessRecord
         * @property {Uint8Array|null} [recordUid] OwnerlessRecord recordUid
         * @property {Uint8Array|null} [recordKey] OwnerlessRecord recordKey
         * @property {number|null} [status] OwnerlessRecord status
         */

        /**
         * Constructs a new OwnerlessRecord.
         * @memberof Authentication
         * @classdesc Represents an OwnerlessRecord.
         * @implements IOwnerlessRecord
         * @constructor
         * @param {Authentication.IOwnerlessRecord=} [properties] Properties to set
         */
        function OwnerlessRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwnerlessRecord recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.recordUid = $util.newBuffer([]);

        /**
         * OwnerlessRecord recordKey.
         * @member {Uint8Array} recordKey
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.recordKey = $util.newBuffer([]);

        /**
         * OwnerlessRecord status.
         * @member {number} status
         * @memberof Authentication.OwnerlessRecord
         * @instance
         */
        OwnerlessRecord.prototype.status = 0;

        /**
         * Creates a new OwnerlessRecord instance using the specified properties.
         * @function create
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord=} [properties] Properties to set
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord instance
         */
        OwnerlessRecord.create = function create(properties) {
            return new OwnerlessRecord(properties);
        };

        /**
         * Encodes the specified OwnerlessRecord message. Does not implicitly {@link Authentication.OwnerlessRecord.verify|verify} messages.
         * @function encode
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord} message OwnerlessRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordKey);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified OwnerlessRecord message, length delimited. Does not implicitly {@link Authentication.OwnerlessRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.IOwnerlessRecord} message OwnerlessRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwnerlessRecord message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.OwnerlessRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordKey = reader.bytes();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OwnerlessRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwnerlessRecord message.
         * @function verify
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwnerlessRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                if (!(message.recordKey && typeof message.recordKey.length === "number" || $util.isString(message.recordKey)))
                    return "recordKey: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            return null;
        };

        /**
         * Creates an OwnerlessRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.OwnerlessRecord} OwnerlessRecord
         */
        OwnerlessRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.OwnerlessRecord)
                return object;
            let message = new $root.Authentication.OwnerlessRecord();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.recordKey != null)
                if (typeof object.recordKey === "string")
                    $util.base64.decode(object.recordKey, message.recordKey = $util.newBuffer($util.base64.length(object.recordKey)), 0);
                else if (object.recordKey.length)
                    message.recordKey = object.recordKey;
            if (object.status != null)
                message.status = object.status | 0;
            return message;
        };

        /**
         * Creates a plain object from an OwnerlessRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.OwnerlessRecord
         * @static
         * @param {Authentication.OwnerlessRecord} message OwnerlessRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwnerlessRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.recordKey = "";
                else {
                    object.recordKey = [];
                    if (options.bytes !== Array)
                        object.recordKey = $util.newBuffer(object.recordKey);
                }
                object.status = 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                object.recordKey = options.bytes === String ? $util.base64.encode(message.recordKey, 0, message.recordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordKey) : message.recordKey;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this OwnerlessRecord to JSON.
         * @function toJSON
         * @memberof Authentication.OwnerlessRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwnerlessRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OwnerlessRecord;
    })();

    Authentication.OwnerlessRecords = (function() {

        /**
         * Properties of an OwnerlessRecords.
         * @memberof Authentication
         * @interface IOwnerlessRecords
         * @property {Array.<Authentication.IOwnerlessRecord>|null} [ownerlessRecord] OwnerlessRecords ownerlessRecord
         */

        /**
         * Constructs a new OwnerlessRecords.
         * @memberof Authentication
         * @classdesc Represents an OwnerlessRecords.
         * @implements IOwnerlessRecords
         * @constructor
         * @param {Authentication.IOwnerlessRecords=} [properties] Properties to set
         */
        function OwnerlessRecords(properties) {
            this.ownerlessRecord = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OwnerlessRecords ownerlessRecord.
         * @member {Array.<Authentication.IOwnerlessRecord>} ownerlessRecord
         * @memberof Authentication.OwnerlessRecords
         * @instance
         */
        OwnerlessRecords.prototype.ownerlessRecord = $util.emptyArray;

        /**
         * Creates a new OwnerlessRecords instance using the specified properties.
         * @function create
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords=} [properties] Properties to set
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords instance
         */
        OwnerlessRecords.create = function create(properties) {
            return new OwnerlessRecords(properties);
        };

        /**
         * Encodes the specified OwnerlessRecords message. Does not implicitly {@link Authentication.OwnerlessRecords.verify|verify} messages.
         * @function encode
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords} message OwnerlessRecords message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecords.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ownerlessRecord != null && message.ownerlessRecord.length)
                for (let i = 0; i < message.ownerlessRecord.length; ++i)
                    $root.Authentication.OwnerlessRecord.encode(message.ownerlessRecord[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OwnerlessRecords message, length delimited. Does not implicitly {@link Authentication.OwnerlessRecords.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.IOwnerlessRecords} message OwnerlessRecords message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OwnerlessRecords.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OwnerlessRecords message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecords.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.OwnerlessRecords();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ownerlessRecord && message.ownerlessRecord.length))
                        message.ownerlessRecord = [];
                    message.ownerlessRecord.push($root.Authentication.OwnerlessRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OwnerlessRecords message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OwnerlessRecords.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OwnerlessRecords message.
         * @function verify
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OwnerlessRecords.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ownerlessRecord != null && message.hasOwnProperty("ownerlessRecord")) {
                if (!Array.isArray(message.ownerlessRecord))
                    return "ownerlessRecord: array expected";
                for (let i = 0; i < message.ownerlessRecord.length; ++i) {
                    let error = $root.Authentication.OwnerlessRecord.verify(message.ownerlessRecord[i]);
                    if (error)
                        return "ownerlessRecord." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OwnerlessRecords message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.OwnerlessRecords} OwnerlessRecords
         */
        OwnerlessRecords.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.OwnerlessRecords)
                return object;
            let message = new $root.Authentication.OwnerlessRecords();
            if (object.ownerlessRecord) {
                if (!Array.isArray(object.ownerlessRecord))
                    throw TypeError(".Authentication.OwnerlessRecords.ownerlessRecord: array expected");
                message.ownerlessRecord = [];
                for (let i = 0; i < object.ownerlessRecord.length; ++i) {
                    if (typeof object.ownerlessRecord[i] !== "object")
                        throw TypeError(".Authentication.OwnerlessRecords.ownerlessRecord: object expected");
                    message.ownerlessRecord[i] = $root.Authentication.OwnerlessRecord.fromObject(object.ownerlessRecord[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OwnerlessRecords message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.OwnerlessRecords
         * @static
         * @param {Authentication.OwnerlessRecords} message OwnerlessRecords
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OwnerlessRecords.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ownerlessRecord = [];
            if (message.ownerlessRecord && message.ownerlessRecord.length) {
                object.ownerlessRecord = [];
                for (let j = 0; j < message.ownerlessRecord.length; ++j)
                    object.ownerlessRecord[j] = $root.Authentication.OwnerlessRecord.toObject(message.ownerlessRecord[j], options);
            }
            return object;
        };

        /**
         * Converts this OwnerlessRecords to JSON.
         * @function toJSON
         * @memberof Authentication.OwnerlessRecords
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OwnerlessRecords.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OwnerlessRecords;
    })();

    Authentication.UserAuthRequest = (function() {

        /**
         * Properties of a UserAuthRequest.
         * @memberof Authentication
         * @interface IUserAuthRequest
         * @property {Uint8Array|null} [uid] UserAuthRequest uid
         * @property {Uint8Array|null} [salt] UserAuthRequest salt
         * @property {number|null} [iterations] UserAuthRequest iterations
         * @property {Uint8Array|null} [encryptedClientKey] UserAuthRequest encryptedClientKey
         * @property {Uint8Array|null} [authHash] UserAuthRequest authHash
         * @property {Uint8Array|null} [encryptedDataKey] UserAuthRequest encryptedDataKey
         * @property {Authentication.LoginType|null} [loginType] UserAuthRequest loginType
         * @property {string|null} [name] UserAuthRequest name
         * @property {number|null} [algorithm] UserAuthRequest algorithm
         */

        /**
         * Constructs a new UserAuthRequest.
         * @memberof Authentication
         * @classdesc Represents a UserAuthRequest.
         * @implements IUserAuthRequest
         * @constructor
         * @param {Authentication.IUserAuthRequest=} [properties] Properties to set
         */
        function UserAuthRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAuthRequest uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.uid = $util.newBuffer([]);

        /**
         * UserAuthRequest salt.
         * @member {Uint8Array} salt
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.salt = $util.newBuffer([]);

        /**
         * UserAuthRequest iterations.
         * @member {number} iterations
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.iterations = 0;

        /**
         * UserAuthRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * UserAuthRequest authHash.
         * @member {Uint8Array} authHash
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.authHash = $util.newBuffer([]);

        /**
         * UserAuthRequest encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * UserAuthRequest loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.loginType = 0;

        /**
         * UserAuthRequest name.
         * @member {string} name
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.name = "";

        /**
         * UserAuthRequest algorithm.
         * @member {number} algorithm
         * @memberof Authentication.UserAuthRequest
         * @instance
         */
        UserAuthRequest.prototype.algorithm = 0;

        /**
         * Creates a new UserAuthRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest=} [properties] Properties to set
         * @returns {Authentication.UserAuthRequest} UserAuthRequest instance
         */
        UserAuthRequest.create = function create(properties) {
            return new UserAuthRequest(properties);
        };

        /**
         * Encodes the specified UserAuthRequest message. Does not implicitly {@link Authentication.UserAuthRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.salt != null && message.hasOwnProperty("salt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.salt);
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.iterations);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedClientKey);
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.authHash);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.encryptedDataKey);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.loginType);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.algorithm);
            return writer;
        };

        /**
         * Encodes the specified UserAuthRequest message, length delimited. Does not implicitly {@link Authentication.UserAuthRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.IUserAuthRequest} message UserAuthRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAuthRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserAuthRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.salt = reader.bytes();
                    break;
                case 3:
                    message.iterations = reader.int32();
                    break;
                case 4:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 5:
                    message.authHash = reader.bytes();
                    break;
                case 6:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 7:
                    message.loginType = reader.int32();
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 9:
                    message.algorithm = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserAuthRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAuthRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserAuthRequest message.
         * @function verify
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserAuthRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.salt != null && message.hasOwnProperty("salt"))
                if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                    return "salt: buffer expected";
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                if (!$util.isInteger(message.iterations))
                    return "iterations: integer expected";
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                if (!(message.authHash && typeof message.authHash.length === "number" || $util.isString(message.authHash)))
                    return "authHash: buffer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                if (!$util.isInteger(message.algorithm))
                    return "algorithm: integer expected";
            return null;
        };

        /**
         * Creates a UserAuthRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserAuthRequest} UserAuthRequest
         */
        UserAuthRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserAuthRequest)
                return object;
            let message = new $root.Authentication.UserAuthRequest();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.salt != null)
                if (typeof object.salt === "string")
                    $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                else if (object.salt.length)
                    message.salt = object.salt;
            if (object.iterations != null)
                message.iterations = object.iterations | 0;
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.authHash != null)
                if (typeof object.authHash === "string")
                    $util.base64.decode(object.authHash, message.authHash = $util.newBuffer($util.base64.length(object.authHash)), 0);
                else if (object.authHash.length)
                    message.authHash = object.authHash;
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.algorithm != null)
                message.algorithm = object.algorithm | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserAuthRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserAuthRequest
         * @static
         * @param {Authentication.UserAuthRequest} message UserAuthRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserAuthRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                if (options.bytes === String)
                    object.salt = "";
                else {
                    object.salt = [];
                    if (options.bytes !== Array)
                        object.salt = $util.newBuffer(object.salt);
                }
                object.iterations = 0;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.authHash = "";
                else {
                    object.authHash = [];
                    if (options.bytes !== Array)
                        object.authHash = $util.newBuffer(object.authHash);
                }
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
                object.loginType = options.enums === String ? "NORMAL" : 0;
                object.name = "";
                object.algorithm = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.salt != null && message.hasOwnProperty("salt"))
                object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
            if (message.iterations != null && message.hasOwnProperty("iterations"))
                object.iterations = message.iterations;
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.authHash != null && message.hasOwnProperty("authHash"))
                object.authHash = options.bytes === String ? $util.base64.encode(message.authHash, 0, message.authHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.authHash) : message.authHash;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                object.algorithm = message.algorithm;
            return object;
        };

        /**
         * Converts this UserAuthRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UserAuthRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserAuthRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserAuthRequest;
    })();

    Authentication.UidRequest = (function() {

        /**
         * Properties of an UidRequest.
         * @memberof Authentication
         * @interface IUidRequest
         * @property {Array.<Uint8Array>|null} [uid] UidRequest uid
         */

        /**
         * Constructs a new UidRequest.
         * @memberof Authentication
         * @classdesc Represents an UidRequest.
         * @implements IUidRequest
         * @constructor
         * @param {Authentication.IUidRequest=} [properties] Properties to set
         */
        function UidRequest(properties) {
            this.uid = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UidRequest uid.
         * @member {Array.<Uint8Array>} uid
         * @memberof Authentication.UidRequest
         * @instance
         */
        UidRequest.prototype.uid = $util.emptyArray;

        /**
         * Creates a new UidRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest=} [properties] Properties to set
         * @returns {Authentication.UidRequest} UidRequest instance
         */
        UidRequest.create = function create(properties) {
            return new UidRequest(properties);
        };

        /**
         * Encodes the specified UidRequest message. Does not implicitly {@link Authentication.UidRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest} message UidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.uid.length)
                for (let i = 0; i < message.uid.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid[i]);
            return writer;
        };

        /**
         * Encodes the specified UidRequest message, length delimited. Does not implicitly {@link Authentication.UidRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.IUidRequest} message UidRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UidRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UidRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UidRequest} UidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UidRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.uid && message.uid.length))
                        message.uid = [];
                    message.uid.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UidRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UidRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UidRequest} UidRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UidRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UidRequest message.
         * @function verify
         * @memberof Authentication.UidRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UidRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid")) {
                if (!Array.isArray(message.uid))
                    return "uid: array expected";
                for (let i = 0; i < message.uid.length; ++i)
                    if (!(message.uid[i] && typeof message.uid[i].length === "number" || $util.isString(message.uid[i])))
                        return "uid: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an UidRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UidRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UidRequest} UidRequest
         */
        UidRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UidRequest)
                return object;
            let message = new $root.Authentication.UidRequest();
            if (object.uid) {
                if (!Array.isArray(object.uid))
                    throw TypeError(".Authentication.UidRequest.uid: array expected");
                message.uid = [];
                for (let i = 0; i < object.uid.length; ++i)
                    if (typeof object.uid[i] === "string")
                        $util.base64.decode(object.uid[i], message.uid[i] = $util.newBuffer($util.base64.length(object.uid[i])), 0);
                    else if (object.uid[i].length)
                        message.uid[i] = object.uid[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an UidRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UidRequest
         * @static
         * @param {Authentication.UidRequest} message UidRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UidRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.uid = [];
            if (message.uid && message.uid.length) {
                object.uid = [];
                for (let j = 0; j < message.uid.length; ++j)
                    object.uid[j] = options.bytes === String ? $util.base64.encode(message.uid[j], 0, message.uid[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.uid[j]) : message.uid[j];
            }
            return object;
        };

        /**
         * Converts this UidRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UidRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UidRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UidRequest;
    })();

    Authentication.DeviceUpdateRequest = (function() {

        /**
         * Properties of a DeviceUpdateRequest.
         * @memberof Authentication
         * @interface IDeviceUpdateRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceUpdateRequest encryptedDeviceToken
         * @property {string|null} [clientVersion] DeviceUpdateRequest clientVersion
         * @property {string|null} [deviceName] DeviceUpdateRequest deviceName
         * @property {Uint8Array|null} [devicePublicKey] DeviceUpdateRequest devicePublicKey
         * @property {Authentication.DeviceStatus|null} [deviceStatus] DeviceUpdateRequest deviceStatus
         */

        /**
         * Constructs a new DeviceUpdateRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceUpdateRequest.
         * @implements IDeviceUpdateRequest
         * @constructor
         * @param {Authentication.IDeviceUpdateRequest=} [properties] Properties to set
         */
        function DeviceUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceUpdateRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         */
        DeviceUpdateRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceUpdateRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         */
        DeviceUpdateRequest.prototype.clientVersion = "";

        /**
         * DeviceUpdateRequest deviceName.
         * @member {string} deviceName
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         */
        DeviceUpdateRequest.prototype.deviceName = "";

        /**
         * DeviceUpdateRequest devicePublicKey.
         * @member {Uint8Array} devicePublicKey
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         */
        DeviceUpdateRequest.prototype.devicePublicKey = $util.newBuffer([]);

        /**
         * DeviceUpdateRequest deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         */
        DeviceUpdateRequest.prototype.deviceStatus = 0;

        /**
         * Creates a new DeviceUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Authentication.IDeviceUpdateRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceUpdateRequest} DeviceUpdateRequest instance
         */
        DeviceUpdateRequest.create = function create(properties) {
            return new DeviceUpdateRequest(properties);
        };

        /**
         * Encodes the specified DeviceUpdateRequest message. Does not implicitly {@link Authentication.DeviceUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Authentication.IDeviceUpdateRequest} message DeviceUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceName);
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.devicePublicKey);
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deviceStatus);
            return writer;
        };

        /**
         * Encodes the specified DeviceUpdateRequest message, length delimited. Does not implicitly {@link Authentication.DeviceUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Authentication.IDeviceUpdateRequest} message DeviceUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceUpdateRequest} DeviceUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.deviceName = reader.string();
                    break;
                case 4:
                    message.devicePublicKey = reader.bytes();
                    break;
                case 5:
                    message.deviceStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceUpdateRequest} DeviceUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceUpdateRequest message.
         * @function verify
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                if (!(message.devicePublicKey && typeof message.devicePublicKey.length === "number" || $util.isString(message.devicePublicKey)))
                    return "devicePublicKey: buffer expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceUpdateRequest} DeviceUpdateRequest
         */
        DeviceUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceUpdateRequest)
                return object;
            let message = new $root.Authentication.DeviceUpdateRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.devicePublicKey != null)
                if (typeof object.devicePublicKey === "string")
                    $util.base64.decode(object.devicePublicKey, message.devicePublicKey = $util.newBuffer($util.base64.length(object.devicePublicKey)), 0);
                else if (object.devicePublicKey.length)
                    message.devicePublicKey = object.devicePublicKey;
            switch (object.deviceStatus) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.deviceStatus = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.deviceStatus = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceUpdateRequest
         * @static
         * @param {Authentication.DeviceUpdateRequest} message DeviceUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.clientVersion = "";
                object.deviceName = "";
                if (options.bytes === String)
                    object.devicePublicKey = "";
                else {
                    object.devicePublicKey = [];
                    if (options.bytes !== Array)
                        object.devicePublicKey = $util.newBuffer(object.devicePublicKey);
                }
                object.deviceStatus = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                object.devicePublicKey = options.bytes === String ? $util.base64.encode(message.devicePublicKey, 0, message.devicePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.devicePublicKey) : message.devicePublicKey;
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            return object;
        };

        /**
         * Converts this DeviceUpdateRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceUpdateRequest;
    })();

    Authentication.RegisterDeviceInRegionRequest = (function() {

        /**
         * Properties of a RegisterDeviceInRegionRequest.
         * @memberof Authentication
         * @interface IRegisterDeviceInRegionRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] RegisterDeviceInRegionRequest encryptedDeviceToken
         * @property {string|null} [clientVersion] RegisterDeviceInRegionRequest clientVersion
         * @property {string|null} [deviceName] RegisterDeviceInRegionRequest deviceName
         * @property {Uint8Array|null} [devicePublicKey] RegisterDeviceInRegionRequest devicePublicKey
         */

        /**
         * Constructs a new RegisterDeviceInRegionRequest.
         * @memberof Authentication
         * @classdesc Represents a RegisterDeviceInRegionRequest.
         * @implements IRegisterDeviceInRegionRequest
         * @constructor
         * @param {Authentication.IRegisterDeviceInRegionRequest=} [properties] Properties to set
         */
        function RegisterDeviceInRegionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterDeviceInRegionRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @instance
         */
        RegisterDeviceInRegionRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * RegisterDeviceInRegionRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @instance
         */
        RegisterDeviceInRegionRequest.prototype.clientVersion = "";

        /**
         * RegisterDeviceInRegionRequest deviceName.
         * @member {string} deviceName
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @instance
         */
        RegisterDeviceInRegionRequest.prototype.deviceName = "";

        /**
         * RegisterDeviceInRegionRequest devicePublicKey.
         * @member {Uint8Array} devicePublicKey
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @instance
         */
        RegisterDeviceInRegionRequest.prototype.devicePublicKey = $util.newBuffer([]);

        /**
         * Creates a new RegisterDeviceInRegionRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Authentication.IRegisterDeviceInRegionRequest=} [properties] Properties to set
         * @returns {Authentication.RegisterDeviceInRegionRequest} RegisterDeviceInRegionRequest instance
         */
        RegisterDeviceInRegionRequest.create = function create(properties) {
            return new RegisterDeviceInRegionRequest(properties);
        };

        /**
         * Encodes the specified RegisterDeviceInRegionRequest message. Does not implicitly {@link Authentication.RegisterDeviceInRegionRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Authentication.IRegisterDeviceInRegionRequest} message RegisterDeviceInRegionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterDeviceInRegionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceName);
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.devicePublicKey);
            return writer;
        };

        /**
         * Encodes the specified RegisterDeviceInRegionRequest message, length delimited. Does not implicitly {@link Authentication.RegisterDeviceInRegionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Authentication.IRegisterDeviceInRegionRequest} message RegisterDeviceInRegionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterDeviceInRegionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterDeviceInRegionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegisterDeviceInRegionRequest} RegisterDeviceInRegionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterDeviceInRegionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegisterDeviceInRegionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.deviceName = reader.string();
                    break;
                case 4:
                    message.devicePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterDeviceInRegionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegisterDeviceInRegionRequest} RegisterDeviceInRegionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterDeviceInRegionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterDeviceInRegionRequest message.
         * @function verify
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterDeviceInRegionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                if (!(message.devicePublicKey && typeof message.devicePublicKey.length === "number" || $util.isString(message.devicePublicKey)))
                    return "devicePublicKey: buffer expected";
            return null;
        };

        /**
         * Creates a RegisterDeviceInRegionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegisterDeviceInRegionRequest} RegisterDeviceInRegionRequest
         */
        RegisterDeviceInRegionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegisterDeviceInRegionRequest)
                return object;
            let message = new $root.Authentication.RegisterDeviceInRegionRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.devicePublicKey != null)
                if (typeof object.devicePublicKey === "string")
                    $util.base64.decode(object.devicePublicKey, message.devicePublicKey = $util.newBuffer($util.base64.length(object.devicePublicKey)), 0);
                else if (object.devicePublicKey.length)
                    message.devicePublicKey = object.devicePublicKey;
            return message;
        };

        /**
         * Creates a plain object from a RegisterDeviceInRegionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @static
         * @param {Authentication.RegisterDeviceInRegionRequest} message RegisterDeviceInRegionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterDeviceInRegionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.clientVersion = "";
                object.deviceName = "";
                if (options.bytes === String)
                    object.devicePublicKey = "";
                else {
                    object.devicePublicKey = [];
                    if (options.bytes !== Array)
                        object.devicePublicKey = $util.newBuffer(object.devicePublicKey);
                }
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                object.devicePublicKey = options.bytes === String ? $util.base64.encode(message.devicePublicKey, 0, message.devicePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.devicePublicKey) : message.devicePublicKey;
            return object;
        };

        /**
         * Converts this RegisterDeviceInRegionRequest to JSON.
         * @function toJSON
         * @memberof Authentication.RegisterDeviceInRegionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterDeviceInRegionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterDeviceInRegionRequest;
    })();

    Authentication.RegistrationRequest = (function() {

        /**
         * Properties of a RegistrationRequest.
         * @memberof Authentication
         * @interface IRegistrationRequest
         * @property {Authentication.IAuthRequest|null} [authRequest] RegistrationRequest authRequest
         * @property {Authentication.IUserAuthRequest|null} [userAuthRequest] RegistrationRequest userAuthRequest
         * @property {Uint8Array|null} [encryptedClientKey] RegistrationRequest encryptedClientKey
         * @property {Uint8Array|null} [encryptedPrivateKey] RegistrationRequest encryptedPrivateKey
         * @property {Uint8Array|null} [publicKey] RegistrationRequest publicKey
         * @property {string|null} [verificationCode] RegistrationRequest verificationCode
         * @property {Uint8Array|null} [deprecatedAuthHashHash] RegistrationRequest deprecatedAuthHashHash
         * @property {Uint8Array|null} [deprecatedEncryptedClientKey] RegistrationRequest deprecatedEncryptedClientKey
         * @property {Uint8Array|null} [deprecatedEncryptedPrivateKey] RegistrationRequest deprecatedEncryptedPrivateKey
         * @property {Uint8Array|null} [deprecatedEncryptionParams] RegistrationRequest deprecatedEncryptionParams
         */

        /**
         * Constructs a new RegistrationRequest.
         * @memberof Authentication
         * @classdesc Represents a RegistrationRequest.
         * @implements IRegistrationRequest
         * @constructor
         * @param {Authentication.IRegistrationRequest=} [properties] Properties to set
         */
        function RegistrationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegistrationRequest authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.authRequest = null;

        /**
         * RegistrationRequest userAuthRequest.
         * @member {Authentication.IUserAuthRequest|null|undefined} userAuthRequest
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.userAuthRequest = null;

        /**
         * RegistrationRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * RegistrationRequest encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * RegistrationRequest publicKey.
         * @member {Uint8Array} publicKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.publicKey = $util.newBuffer([]);

        /**
         * RegistrationRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.verificationCode = "";

        /**
         * RegistrationRequest deprecatedAuthHashHash.
         * @member {Uint8Array} deprecatedAuthHashHash
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedAuthHashHash = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptedClientKey.
         * @member {Uint8Array} deprecatedEncryptedClientKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptedClientKey = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptedPrivateKey.
         * @member {Uint8Array} deprecatedEncryptedPrivateKey
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptedPrivateKey = $util.newBuffer([]);

        /**
         * RegistrationRequest deprecatedEncryptionParams.
         * @member {Uint8Array} deprecatedEncryptionParams
         * @memberof Authentication.RegistrationRequest
         * @instance
         */
        RegistrationRequest.prototype.deprecatedEncryptionParams = $util.newBuffer([]);

        /**
         * Creates a new RegistrationRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest=} [properties] Properties to set
         * @returns {Authentication.RegistrationRequest} RegistrationRequest instance
         */
        RegistrationRequest.create = function create(properties) {
            return new RegistrationRequest(properties);
        };

        /**
         * Encodes the specified RegistrationRequest message. Does not implicitly {@link Authentication.RegistrationRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest} message RegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegistrationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                $root.Authentication.UserAuthRequest.encode(message.userAuthRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedClientKey);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPrivateKey);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.verificationCode);
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.deprecatedAuthHashHash);
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.deprecatedEncryptedClientKey);
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.deprecatedEncryptedPrivateKey);
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.deprecatedEncryptionParams);
            return writer;
        };

        /**
         * Encodes the specified RegistrationRequest message, length delimited. Does not implicitly {@link Authentication.RegistrationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.IRegistrationRequest} message RegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegistrationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegistrationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegistrationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegistrationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.userAuthRequest = $root.Authentication.UserAuthRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 4:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                case 6:
                    message.verificationCode = reader.string();
                    break;
                case 7:
                    message.deprecatedAuthHashHash = reader.bytes();
                    break;
                case 8:
                    message.deprecatedEncryptedClientKey = reader.bytes();
                    break;
                case 9:
                    message.deprecatedEncryptedPrivateKey = reader.bytes();
                    break;
                case 10:
                    message.deprecatedEncryptionParams = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegistrationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegistrationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegistrationRequest message.
         * @function verify
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegistrationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest")) {
                let error = $root.Authentication.UserAuthRequest.verify(message.userAuthRequest);
                if (error)
                    return "userAuthRequest." + error;
            }
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                if (!(message.deprecatedAuthHashHash && typeof message.deprecatedAuthHashHash.length === "number" || $util.isString(message.deprecatedAuthHashHash)))
                    return "deprecatedAuthHashHash: buffer expected";
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                if (!(message.deprecatedEncryptedClientKey && typeof message.deprecatedEncryptedClientKey.length === "number" || $util.isString(message.deprecatedEncryptedClientKey)))
                    return "deprecatedEncryptedClientKey: buffer expected";
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                if (!(message.deprecatedEncryptedPrivateKey && typeof message.deprecatedEncryptedPrivateKey.length === "number" || $util.isString(message.deprecatedEncryptedPrivateKey)))
                    return "deprecatedEncryptedPrivateKey: buffer expected";
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                if (!(message.deprecatedEncryptionParams && typeof message.deprecatedEncryptionParams.length === "number" || $util.isString(message.deprecatedEncryptionParams)))
                    return "deprecatedEncryptionParams: buffer expected";
            return null;
        };

        /**
         * Creates a RegistrationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegistrationRequest} RegistrationRequest
         */
        RegistrationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegistrationRequest)
                return object;
            let message = new $root.Authentication.RegistrationRequest();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.RegistrationRequest.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            if (object.userAuthRequest != null) {
                if (typeof object.userAuthRequest !== "object")
                    throw TypeError(".Authentication.RegistrationRequest.userAuthRequest: object expected");
                message.userAuthRequest = $root.Authentication.UserAuthRequest.fromObject(object.userAuthRequest);
            }
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.deprecatedAuthHashHash != null)
                if (typeof object.deprecatedAuthHashHash === "string")
                    $util.base64.decode(object.deprecatedAuthHashHash, message.deprecatedAuthHashHash = $util.newBuffer($util.base64.length(object.deprecatedAuthHashHash)), 0);
                else if (object.deprecatedAuthHashHash.length)
                    message.deprecatedAuthHashHash = object.deprecatedAuthHashHash;
            if (object.deprecatedEncryptedClientKey != null)
                if (typeof object.deprecatedEncryptedClientKey === "string")
                    $util.base64.decode(object.deprecatedEncryptedClientKey, message.deprecatedEncryptedClientKey = $util.newBuffer($util.base64.length(object.deprecatedEncryptedClientKey)), 0);
                else if (object.deprecatedEncryptedClientKey.length)
                    message.deprecatedEncryptedClientKey = object.deprecatedEncryptedClientKey;
            if (object.deprecatedEncryptedPrivateKey != null)
                if (typeof object.deprecatedEncryptedPrivateKey === "string")
                    $util.base64.decode(object.deprecatedEncryptedPrivateKey, message.deprecatedEncryptedPrivateKey = $util.newBuffer($util.base64.length(object.deprecatedEncryptedPrivateKey)), 0);
                else if (object.deprecatedEncryptedPrivateKey.length)
                    message.deprecatedEncryptedPrivateKey = object.deprecatedEncryptedPrivateKey;
            if (object.deprecatedEncryptionParams != null)
                if (typeof object.deprecatedEncryptionParams === "string")
                    $util.base64.decode(object.deprecatedEncryptionParams, message.deprecatedEncryptionParams = $util.newBuffer($util.base64.length(object.deprecatedEncryptionParams)), 0);
                else if (object.deprecatedEncryptionParams.length)
                    message.deprecatedEncryptionParams = object.deprecatedEncryptionParams;
            return message;
        };

        /**
         * Creates a plain object from a RegistrationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegistrationRequest
         * @static
         * @param {Authentication.RegistrationRequest} message RegistrationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegistrationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.userAuthRequest = null;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.verificationCode = "";
                if (options.bytes === String)
                    object.deprecatedAuthHashHash = "";
                else {
                    object.deprecatedAuthHashHash = [];
                    if (options.bytes !== Array)
                        object.deprecatedAuthHashHash = $util.newBuffer(object.deprecatedAuthHashHash);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptedClientKey = "";
                else {
                    object.deprecatedEncryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptedClientKey = $util.newBuffer(object.deprecatedEncryptedClientKey);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptedPrivateKey = "";
                else {
                    object.deprecatedEncryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptedPrivateKey = $util.newBuffer(object.deprecatedEncryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.deprecatedEncryptionParams = "";
                else {
                    object.deprecatedEncryptionParams = [];
                    if (options.bytes !== Array)
                        object.deprecatedEncryptionParams = $util.newBuffer(object.deprecatedEncryptionParams);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                object.userAuthRequest = $root.Authentication.UserAuthRequest.toObject(message.userAuthRequest, options);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.deprecatedAuthHashHash != null && message.hasOwnProperty("deprecatedAuthHashHash"))
                object.deprecatedAuthHashHash = options.bytes === String ? $util.base64.encode(message.deprecatedAuthHashHash, 0, message.deprecatedAuthHashHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedAuthHashHash) : message.deprecatedAuthHashHash;
            if (message.deprecatedEncryptedClientKey != null && message.hasOwnProperty("deprecatedEncryptedClientKey"))
                object.deprecatedEncryptedClientKey = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptedClientKey, 0, message.deprecatedEncryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptedClientKey) : message.deprecatedEncryptedClientKey;
            if (message.deprecatedEncryptedPrivateKey != null && message.hasOwnProperty("deprecatedEncryptedPrivateKey"))
                object.deprecatedEncryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptedPrivateKey, 0, message.deprecatedEncryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptedPrivateKey) : message.deprecatedEncryptedPrivateKey;
            if (message.deprecatedEncryptionParams != null && message.hasOwnProperty("deprecatedEncryptionParams"))
                object.deprecatedEncryptionParams = options.bytes === String ? $util.base64.encode(message.deprecatedEncryptionParams, 0, message.deprecatedEncryptionParams.length) : options.bytes === Array ? Array.prototype.slice.call(message.deprecatedEncryptionParams) : message.deprecatedEncryptionParams;
            return object;
        };

        /**
         * Converts this RegistrationRequest to JSON.
         * @function toJSON
         * @memberof Authentication.RegistrationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegistrationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegistrationRequest;
    })();

    Authentication.ConvertUserToV3Request = (function() {

        /**
         * Properties of a ConvertUserToV3Request.
         * @memberof Authentication
         * @interface IConvertUserToV3Request
         * @property {Authentication.IAuthRequest|null} [authRequest] ConvertUserToV3Request authRequest
         * @property {Authentication.IUserAuthRequest|null} [userAuthRequest] ConvertUserToV3Request userAuthRequest
         * @property {Uint8Array|null} [encryptedClientKey] ConvertUserToV3Request encryptedClientKey
         * @property {Uint8Array|null} [encryptedPrivateKey] ConvertUserToV3Request encryptedPrivateKey
         * @property {Uint8Array|null} [publicKey] ConvertUserToV3Request publicKey
         */

        /**
         * Constructs a new ConvertUserToV3Request.
         * @memberof Authentication
         * @classdesc Represents a ConvertUserToV3Request.
         * @implements IConvertUserToV3Request
         * @constructor
         * @param {Authentication.IConvertUserToV3Request=} [properties] Properties to set
         */
        function ConvertUserToV3Request(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConvertUserToV3Request authRequest.
         * @member {Authentication.IAuthRequest|null|undefined} authRequest
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.authRequest = null;

        /**
         * ConvertUserToV3Request userAuthRequest.
         * @member {Authentication.IUserAuthRequest|null|undefined} userAuthRequest
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.userAuthRequest = null;

        /**
         * ConvertUserToV3Request encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * ConvertUserToV3Request encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * ConvertUserToV3Request publicKey.
         * @member {Uint8Array} publicKey
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         */
        ConvertUserToV3Request.prototype.publicKey = $util.newBuffer([]);

        /**
         * Creates a new ConvertUserToV3Request instance using the specified properties.
         * @function create
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request=} [properties] Properties to set
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request instance
         */
        ConvertUserToV3Request.create = function create(properties) {
            return new ConvertUserToV3Request(properties);
        };

        /**
         * Encodes the specified ConvertUserToV3Request message. Does not implicitly {@link Authentication.ConvertUserToV3Request.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request} message ConvertUserToV3Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConvertUserToV3Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                $root.Authentication.AuthRequest.encode(message.authRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                $root.Authentication.UserAuthRequest.encode(message.userAuthRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedClientKey);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedPrivateKey);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified ConvertUserToV3Request message, length delimited. Does not implicitly {@link Authentication.ConvertUserToV3Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.IConvertUserToV3Request} message ConvertUserToV3Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConvertUserToV3Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConvertUserToV3Request message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConvertUserToV3Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ConvertUserToV3Request();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authRequest = $root.Authentication.AuthRequest.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.userAuthRequest = $root.Authentication.UserAuthRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 4:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                case 5:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConvertUserToV3Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConvertUserToV3Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConvertUserToV3Request message.
         * @function verify
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConvertUserToV3Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.authRequest != null && message.hasOwnProperty("authRequest")) {
                let error = $root.Authentication.AuthRequest.verify(message.authRequest);
                if (error)
                    return "authRequest." + error;
            }
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest")) {
                let error = $root.Authentication.UserAuthRequest.verify(message.userAuthRequest);
                if (error)
                    return "userAuthRequest." + error;
            }
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            return null;
        };

        /**
         * Creates a ConvertUserToV3Request message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ConvertUserToV3Request} ConvertUserToV3Request
         */
        ConvertUserToV3Request.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ConvertUserToV3Request)
                return object;
            let message = new $root.Authentication.ConvertUserToV3Request();
            if (object.authRequest != null) {
                if (typeof object.authRequest !== "object")
                    throw TypeError(".Authentication.ConvertUserToV3Request.authRequest: object expected");
                message.authRequest = $root.Authentication.AuthRequest.fromObject(object.authRequest);
            }
            if (object.userAuthRequest != null) {
                if (typeof object.userAuthRequest !== "object")
                    throw TypeError(".Authentication.ConvertUserToV3Request.userAuthRequest: object expected");
                message.userAuthRequest = $root.Authentication.UserAuthRequest.fromObject(object.userAuthRequest);
            }
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };

        /**
         * Creates a plain object from a ConvertUserToV3Request message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ConvertUserToV3Request
         * @static
         * @param {Authentication.ConvertUserToV3Request} message ConvertUserToV3Request
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConvertUserToV3Request.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.authRequest = null;
                object.userAuthRequest = null;
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            }
            if (message.authRequest != null && message.hasOwnProperty("authRequest"))
                object.authRequest = $root.Authentication.AuthRequest.toObject(message.authRequest, options);
            if (message.userAuthRequest != null && message.hasOwnProperty("userAuthRequest"))
                object.userAuthRequest = $root.Authentication.UserAuthRequest.toObject(message.userAuthRequest, options);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };

        /**
         * Converts this ConvertUserToV3Request to JSON.
         * @function toJSON
         * @memberof Authentication.ConvertUserToV3Request
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConvertUserToV3Request.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConvertUserToV3Request;
    })();

    Authentication.RevisionResponse = (function() {

        /**
         * Properties of a RevisionResponse.
         * @memberof Authentication
         * @interface IRevisionResponse
         * @property {number|Long|null} [revision] RevisionResponse revision
         */

        /**
         * Constructs a new RevisionResponse.
         * @memberof Authentication
         * @classdesc Represents a RevisionResponse.
         * @implements IRevisionResponse
         * @constructor
         * @param {Authentication.IRevisionResponse=} [properties] Properties to set
         */
        function RevisionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RevisionResponse revision.
         * @member {number|Long} revision
         * @memberof Authentication.RevisionResponse
         * @instance
         */
        RevisionResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RevisionResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse=} [properties] Properties to set
         * @returns {Authentication.RevisionResponse} RevisionResponse instance
         */
        RevisionResponse.create = function create(properties) {
            return new RevisionResponse(properties);
        };

        /**
         * Encodes the specified RevisionResponse message. Does not implicitly {@link Authentication.RevisionResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse} message RevisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevisionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.revision);
            return writer;
        };

        /**
         * Encodes the specified RevisionResponse message, length delimited. Does not implicitly {@link Authentication.RevisionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.IRevisionResponse} message RevisionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RevisionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RevisionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RevisionResponse} RevisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevisionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RevisionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.revision = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RevisionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RevisionResponse} RevisionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RevisionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RevisionResponse message.
         * @function verify
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RevisionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            return null;
        };

        /**
         * Creates a RevisionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RevisionResponse} RevisionResponse
         */
        RevisionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RevisionResponse)
                return object;
            let message = new $root.Authentication.RevisionResponse();
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RevisionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RevisionResponse
         * @static
         * @param {Authentication.RevisionResponse} message RevisionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RevisionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            return object;
        };

        /**
         * Converts this RevisionResponse to JSON.
         * @function toJSON
         * @memberof Authentication.RevisionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RevisionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RevisionResponse;
    })();

    Authentication.ChangeEmailRequest = (function() {

        /**
         * Properties of a ChangeEmailRequest.
         * @memberof Authentication
         * @interface IChangeEmailRequest
         * @property {string|null} [newEmail] ChangeEmailRequest newEmail
         */

        /**
         * Constructs a new ChangeEmailRequest.
         * @memberof Authentication
         * @classdesc Represents a ChangeEmailRequest.
         * @implements IChangeEmailRequest
         * @constructor
         * @param {Authentication.IChangeEmailRequest=} [properties] Properties to set
         */
        function ChangeEmailRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailRequest newEmail.
         * @member {string} newEmail
         * @memberof Authentication.ChangeEmailRequest
         * @instance
         */
        ChangeEmailRequest.prototype.newEmail = "";

        /**
         * Creates a new ChangeEmailRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest=} [properties] Properties to set
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest instance
         */
        ChangeEmailRequest.create = function create(properties) {
            return new ChangeEmailRequest(properties);
        };

        /**
         * Encodes the specified ChangeEmailRequest message. Does not implicitly {@link Authentication.ChangeEmailRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest} message ChangeEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.newEmail);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailRequest message, length delimited. Does not implicitly {@link Authentication.ChangeEmailRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.IChangeEmailRequest} message ChangeEmailRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeEmailRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newEmail = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailRequest message.
         * @function verify
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                if (!$util.isString(message.newEmail))
                    return "newEmail: string expected";
            return null;
        };

        /**
         * Creates a ChangeEmailRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeEmailRequest} ChangeEmailRequest
         */
        ChangeEmailRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeEmailRequest)
                return object;
            let message = new $root.Authentication.ChangeEmailRequest();
            if (object.newEmail != null)
                message.newEmail = String(object.newEmail);
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeEmailRequest
         * @static
         * @param {Authentication.ChangeEmailRequest} message ChangeEmailRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.newEmail = "";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                object.newEmail = message.newEmail;
            return object;
        };

        /**
         * Converts this ChangeEmailRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeEmailRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailRequest;
    })();

    Authentication.ChangeEmailResponse = (function() {

        /**
         * Properties of a ChangeEmailResponse.
         * @memberof Authentication
         * @interface IChangeEmailResponse
         * @property {Uint8Array|null} [encryptedChangeEmailToken] ChangeEmailResponse encryptedChangeEmailToken
         */

        /**
         * Constructs a new ChangeEmailResponse.
         * @memberof Authentication
         * @classdesc Represents a ChangeEmailResponse.
         * @implements IChangeEmailResponse
         * @constructor
         * @param {Authentication.IChangeEmailResponse=} [properties] Properties to set
         */
        function ChangeEmailResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailResponse encryptedChangeEmailToken.
         * @member {Uint8Array} encryptedChangeEmailToken
         * @memberof Authentication.ChangeEmailResponse
         * @instance
         */
        ChangeEmailResponse.prototype.encryptedChangeEmailToken = $util.newBuffer([]);

        /**
         * Creates a new ChangeEmailResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse=} [properties] Properties to set
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse instance
         */
        ChangeEmailResponse.create = function create(properties) {
            return new ChangeEmailResponse(properties);
        };

        /**
         * Encodes the specified ChangeEmailResponse message. Does not implicitly {@link Authentication.ChangeEmailResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse} message ChangeEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedChangeEmailToken);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailResponse message, length delimited. Does not implicitly {@link Authentication.ChangeEmailResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.IChangeEmailResponse} message ChangeEmailResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeEmailResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedChangeEmailToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailResponse message.
         * @function verify
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                if (!(message.encryptedChangeEmailToken && typeof message.encryptedChangeEmailToken.length === "number" || $util.isString(message.encryptedChangeEmailToken)))
                    return "encryptedChangeEmailToken: buffer expected";
            return null;
        };

        /**
         * Creates a ChangeEmailResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeEmailResponse} ChangeEmailResponse
         */
        ChangeEmailResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeEmailResponse)
                return object;
            let message = new $root.Authentication.ChangeEmailResponse();
            if (object.encryptedChangeEmailToken != null)
                if (typeof object.encryptedChangeEmailToken === "string")
                    $util.base64.decode(object.encryptedChangeEmailToken, message.encryptedChangeEmailToken = $util.newBuffer($util.base64.length(object.encryptedChangeEmailToken)), 0);
                else if (object.encryptedChangeEmailToken.length)
                    message.encryptedChangeEmailToken = object.encryptedChangeEmailToken;
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeEmailResponse
         * @static
         * @param {Authentication.ChangeEmailResponse} message ChangeEmailResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedChangeEmailToken = "";
                else {
                    object.encryptedChangeEmailToken = [];
                    if (options.bytes !== Array)
                        object.encryptedChangeEmailToken = $util.newBuffer(object.encryptedChangeEmailToken);
                }
            if (message.encryptedChangeEmailToken != null && message.hasOwnProperty("encryptedChangeEmailToken"))
                object.encryptedChangeEmailToken = options.bytes === String ? $util.base64.encode(message.encryptedChangeEmailToken, 0, message.encryptedChangeEmailToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedChangeEmailToken) : message.encryptedChangeEmailToken;
            return object;
        };

        /**
         * Converts this ChangeEmailResponse to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeEmailResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailResponse;
    })();

    Authentication.EmailVerificationLinkResponse = (function() {

        /**
         * Properties of an EmailVerificationLinkResponse.
         * @memberof Authentication
         * @interface IEmailVerificationLinkResponse
         * @property {boolean|null} [emailVerified] EmailVerificationLinkResponse emailVerified
         */

        /**
         * Constructs a new EmailVerificationLinkResponse.
         * @memberof Authentication
         * @classdesc Represents an EmailVerificationLinkResponse.
         * @implements IEmailVerificationLinkResponse
         * @constructor
         * @param {Authentication.IEmailVerificationLinkResponse=} [properties] Properties to set
         */
        function EmailVerificationLinkResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmailVerificationLinkResponse emailVerified.
         * @member {boolean} emailVerified
         * @memberof Authentication.EmailVerificationLinkResponse
         * @instance
         */
        EmailVerificationLinkResponse.prototype.emailVerified = false;

        /**
         * Creates a new EmailVerificationLinkResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse=} [properties] Properties to set
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse instance
         */
        EmailVerificationLinkResponse.create = function create(properties) {
            return new EmailVerificationLinkResponse(properties);
        };

        /**
         * Encodes the specified EmailVerificationLinkResponse message. Does not implicitly {@link Authentication.EmailVerificationLinkResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse} message EmailVerificationLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationLinkResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.emailVerified);
            return writer;
        };

        /**
         * Encodes the specified EmailVerificationLinkResponse message, length delimited. Does not implicitly {@link Authentication.EmailVerificationLinkResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.IEmailVerificationLinkResponse} message EmailVerificationLinkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationLinkResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmailVerificationLinkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationLinkResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.EmailVerificationLinkResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailVerified = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmailVerificationLinkResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationLinkResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmailVerificationLinkResponse message.
         * @function verify
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmailVerificationLinkResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                if (typeof message.emailVerified !== "boolean")
                    return "emailVerified: boolean expected";
            return null;
        };

        /**
         * Creates an EmailVerificationLinkResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.EmailVerificationLinkResponse} EmailVerificationLinkResponse
         */
        EmailVerificationLinkResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.EmailVerificationLinkResponse)
                return object;
            let message = new $root.Authentication.EmailVerificationLinkResponse();
            if (object.emailVerified != null)
                message.emailVerified = Boolean(object.emailVerified);
            return message;
        };

        /**
         * Creates a plain object from an EmailVerificationLinkResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.EmailVerificationLinkResponse
         * @static
         * @param {Authentication.EmailVerificationLinkResponse} message EmailVerificationLinkResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmailVerificationLinkResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.emailVerified = false;
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                object.emailVerified = message.emailVerified;
            return object;
        };

        /**
         * Converts this EmailVerificationLinkResponse to JSON.
         * @function toJSON
         * @memberof Authentication.EmailVerificationLinkResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmailVerificationLinkResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmailVerificationLinkResponse;
    })();

    Authentication.SecurityData = (function() {

        /**
         * Properties of a SecurityData.
         * @memberof Authentication
         * @interface ISecurityData
         * @property {Uint8Array|null} [uid] SecurityData uid
         * @property {Uint8Array|null} [data] SecurityData data
         */

        /**
         * Constructs a new SecurityData.
         * @memberof Authentication
         * @classdesc Represents a SecurityData.
         * @implements ISecurityData
         * @constructor
         * @param {Authentication.ISecurityData=} [properties] Properties to set
         */
        function SecurityData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityData uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.SecurityData
         * @instance
         */
        SecurityData.prototype.uid = $util.newBuffer([]);

        /**
         * SecurityData data.
         * @member {Uint8Array} data
         * @memberof Authentication.SecurityData
         * @instance
         */
        SecurityData.prototype.data = $util.newBuffer([]);

        /**
         * Creates a new SecurityData instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData=} [properties] Properties to set
         * @returns {Authentication.SecurityData} SecurityData instance
         */
        SecurityData.create = function create(properties) {
            return new SecurityData(properties);
        };

        /**
         * Encodes the specified SecurityData message. Does not implicitly {@link Authentication.SecurityData.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData} message SecurityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            return writer;
        };

        /**
         * Encodes the specified SecurityData message, length delimited. Does not implicitly {@link Authentication.SecurityData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.ISecurityData} message SecurityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityData message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityData} SecurityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityData} SecurityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityData message.
         * @function verify
         * @memberof Authentication.SecurityData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            return null;
        };

        /**
         * Creates a SecurityData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityData} SecurityData
         */
        SecurityData.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityData)
                return object;
            let message = new $root.Authentication.SecurityData();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            return message;
        };

        /**
         * Creates a plain object from a SecurityData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityData
         * @static
         * @param {Authentication.SecurityData} message SecurityData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
        };

        /**
         * Converts this SecurityData to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityData;
    })();

    Authentication.SecurityDataRequest = (function() {

        /**
         * Properties of a SecurityDataRequest.
         * @memberof Authentication
         * @interface ISecurityDataRequest
         * @property {Array.<Authentication.ISecurityData>|null} [recordSecurityData] SecurityDataRequest recordSecurityData
         * @property {Array.<Authentication.ISecurityData>|null} [masterPasswordSecurityData] SecurityDataRequest masterPasswordSecurityData
         */

        /**
         * Constructs a new SecurityDataRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityDataRequest.
         * @implements ISecurityDataRequest
         * @constructor
         * @param {Authentication.ISecurityDataRequest=} [properties] Properties to set
         */
        function SecurityDataRequest(properties) {
            this.recordSecurityData = [];
            this.masterPasswordSecurityData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityDataRequest recordSecurityData.
         * @member {Array.<Authentication.ISecurityData>} recordSecurityData
         * @memberof Authentication.SecurityDataRequest
         * @instance
         */
        SecurityDataRequest.prototype.recordSecurityData = $util.emptyArray;

        /**
         * SecurityDataRequest masterPasswordSecurityData.
         * @member {Array.<Authentication.ISecurityData>} masterPasswordSecurityData
         * @memberof Authentication.SecurityDataRequest
         * @instance
         */
        SecurityDataRequest.prototype.masterPasswordSecurityData = $util.emptyArray;

        /**
         * Creates a new SecurityDataRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest instance
         */
        SecurityDataRequest.create = function create(properties) {
            return new SecurityDataRequest(properties);
        };

        /**
         * Encodes the specified SecurityDataRequest message. Does not implicitly {@link Authentication.SecurityDataRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest} message SecurityDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityDataRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordSecurityData != null && message.recordSecurityData.length)
                for (let i = 0; i < message.recordSecurityData.length; ++i)
                    $root.Authentication.SecurityData.encode(message.recordSecurityData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.masterPasswordSecurityData != null && message.masterPasswordSecurityData.length)
                for (let i = 0; i < message.masterPasswordSecurityData.length; ++i)
                    $root.Authentication.SecurityData.encode(message.masterPasswordSecurityData[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityDataRequest message, length delimited. Does not implicitly {@link Authentication.SecurityDataRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.ISecurityDataRequest} message SecurityDataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityDataRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityDataRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityDataRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityDataRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.recordSecurityData && message.recordSecurityData.length))
                        message.recordSecurityData = [];
                    message.recordSecurityData.push($root.Authentication.SecurityData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.masterPasswordSecurityData && message.masterPasswordSecurityData.length))
                        message.masterPasswordSecurityData = [];
                    message.masterPasswordSecurityData.push($root.Authentication.SecurityData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityDataRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityDataRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityDataRequest message.
         * @function verify
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityDataRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordSecurityData != null && message.hasOwnProperty("recordSecurityData")) {
                if (!Array.isArray(message.recordSecurityData))
                    return "recordSecurityData: array expected";
                for (let i = 0; i < message.recordSecurityData.length; ++i) {
                    let error = $root.Authentication.SecurityData.verify(message.recordSecurityData[i]);
                    if (error)
                        return "recordSecurityData." + error;
                }
            }
            if (message.masterPasswordSecurityData != null && message.hasOwnProperty("masterPasswordSecurityData")) {
                if (!Array.isArray(message.masterPasswordSecurityData))
                    return "masterPasswordSecurityData: array expected";
                for (let i = 0; i < message.masterPasswordSecurityData.length; ++i) {
                    let error = $root.Authentication.SecurityData.verify(message.masterPasswordSecurityData[i]);
                    if (error)
                        return "masterPasswordSecurityData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityDataRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityDataRequest} SecurityDataRequest
         */
        SecurityDataRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityDataRequest)
                return object;
            let message = new $root.Authentication.SecurityDataRequest();
            if (object.recordSecurityData) {
                if (!Array.isArray(object.recordSecurityData))
                    throw TypeError(".Authentication.SecurityDataRequest.recordSecurityData: array expected");
                message.recordSecurityData = [];
                for (let i = 0; i < object.recordSecurityData.length; ++i) {
                    if (typeof object.recordSecurityData[i] !== "object")
                        throw TypeError(".Authentication.SecurityDataRequest.recordSecurityData: object expected");
                    message.recordSecurityData[i] = $root.Authentication.SecurityData.fromObject(object.recordSecurityData[i]);
                }
            }
            if (object.masterPasswordSecurityData) {
                if (!Array.isArray(object.masterPasswordSecurityData))
                    throw TypeError(".Authentication.SecurityDataRequest.masterPasswordSecurityData: array expected");
                message.masterPasswordSecurityData = [];
                for (let i = 0; i < object.masterPasswordSecurityData.length; ++i) {
                    if (typeof object.masterPasswordSecurityData[i] !== "object")
                        throw TypeError(".Authentication.SecurityDataRequest.masterPasswordSecurityData: object expected");
                    message.masterPasswordSecurityData[i] = $root.Authentication.SecurityData.fromObject(object.masterPasswordSecurityData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityDataRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityDataRequest
         * @static
         * @param {Authentication.SecurityDataRequest} message SecurityDataRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityDataRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.recordSecurityData = [];
                object.masterPasswordSecurityData = [];
            }
            if (message.recordSecurityData && message.recordSecurityData.length) {
                object.recordSecurityData = [];
                for (let j = 0; j < message.recordSecurityData.length; ++j)
                    object.recordSecurityData[j] = $root.Authentication.SecurityData.toObject(message.recordSecurityData[j], options);
            }
            if (message.masterPasswordSecurityData && message.masterPasswordSecurityData.length) {
                object.masterPasswordSecurityData = [];
                for (let j = 0; j < message.masterPasswordSecurityData.length; ++j)
                    object.masterPasswordSecurityData[j] = $root.Authentication.SecurityData.toObject(message.masterPasswordSecurityData[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityDataRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityDataRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityDataRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityDataRequest;
    })();

    Authentication.SecurityReportIncrementalData = (function() {

        /**
         * Properties of a SecurityReportIncrementalData.
         * @memberof Authentication
         * @interface ISecurityReportIncrementalData
         * @property {number|Long|null} [enterpriseUserId] SecurityReportIncrementalData enterpriseUserId
         * @property {Uint8Array|null} [currentSecurityData] SecurityReportIncrementalData currentSecurityData
         * @property {number|Long|null} [currentSecurityDataRevision] SecurityReportIncrementalData currentSecurityDataRevision
         * @property {Uint8Array|null} [oldSecurityData] SecurityReportIncrementalData oldSecurityData
         * @property {number|Long|null} [oldSecurityDataRevision] SecurityReportIncrementalData oldSecurityDataRevision
         */

        /**
         * Constructs a new SecurityReportIncrementalData.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportIncrementalData.
         * @implements ISecurityReportIncrementalData
         * @constructor
         * @param {Authentication.ISecurityReportIncrementalData=} [properties] Properties to set
         */
        function SecurityReportIncrementalData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportIncrementalData enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportIncrementalData currentSecurityData.
         * @member {Uint8Array} currentSecurityData
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.currentSecurityData = $util.newBuffer([]);

        /**
         * SecurityReportIncrementalData currentSecurityDataRevision.
         * @member {number|Long} currentSecurityDataRevision
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.currentSecurityDataRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportIncrementalData oldSecurityData.
         * @member {Uint8Array} oldSecurityData
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.oldSecurityData = $util.newBuffer([]);

        /**
         * SecurityReportIncrementalData oldSecurityDataRevision.
         * @member {number|Long} oldSecurityDataRevision
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         */
        SecurityReportIncrementalData.prototype.oldSecurityDataRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SecurityReportIncrementalData instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData=} [properties] Properties to set
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData instance
         */
        SecurityReportIncrementalData.create = function create(properties) {
            return new SecurityReportIncrementalData(properties);
        };

        /**
         * Encodes the specified SecurityReportIncrementalData message. Does not implicitly {@link Authentication.SecurityReportIncrementalData.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData} message SecurityReportIncrementalData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportIncrementalData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.currentSecurityData);
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.currentSecurityDataRevision);
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.oldSecurityData);
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.oldSecurityDataRevision);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportIncrementalData message, length delimited. Does not implicitly {@link Authentication.SecurityReportIncrementalData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.ISecurityReportIncrementalData} message SecurityReportIncrementalData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportIncrementalData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportIncrementalData message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportIncrementalData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportIncrementalData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.currentSecurityData = reader.bytes();
                    break;
                case 3:
                    message.currentSecurityDataRevision = reader.int64();
                    break;
                case 4:
                    message.oldSecurityData = reader.bytes();
                    break;
                case 5:
                    message.oldSecurityDataRevision = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportIncrementalData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportIncrementalData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportIncrementalData message.
         * @function verify
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportIncrementalData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                if (!(message.currentSecurityData && typeof message.currentSecurityData.length === "number" || $util.isString(message.currentSecurityData)))
                    return "currentSecurityData: buffer expected";
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                if (!$util.isInteger(message.currentSecurityDataRevision) && !(message.currentSecurityDataRevision && $util.isInteger(message.currentSecurityDataRevision.low) && $util.isInteger(message.currentSecurityDataRevision.high)))
                    return "currentSecurityDataRevision: integer|Long expected";
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                if (!(message.oldSecurityData && typeof message.oldSecurityData.length === "number" || $util.isString(message.oldSecurityData)))
                    return "oldSecurityData: buffer expected";
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                if (!$util.isInteger(message.oldSecurityDataRevision) && !(message.oldSecurityDataRevision && $util.isInteger(message.oldSecurityDataRevision.low) && $util.isInteger(message.oldSecurityDataRevision.high)))
                    return "oldSecurityDataRevision: integer|Long expected";
            return null;
        };

        /**
         * Creates a SecurityReportIncrementalData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportIncrementalData} SecurityReportIncrementalData
         */
        SecurityReportIncrementalData.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportIncrementalData)
                return object;
            let message = new $root.Authentication.SecurityReportIncrementalData();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.currentSecurityData != null)
                if (typeof object.currentSecurityData === "string")
                    $util.base64.decode(object.currentSecurityData, message.currentSecurityData = $util.newBuffer($util.base64.length(object.currentSecurityData)), 0);
                else if (object.currentSecurityData.length)
                    message.currentSecurityData = object.currentSecurityData;
            if (object.currentSecurityDataRevision != null)
                if ($util.Long)
                    (message.currentSecurityDataRevision = $util.Long.fromValue(object.currentSecurityDataRevision)).unsigned = false;
                else if (typeof object.currentSecurityDataRevision === "string")
                    message.currentSecurityDataRevision = parseInt(object.currentSecurityDataRevision, 10);
                else if (typeof object.currentSecurityDataRevision === "number")
                    message.currentSecurityDataRevision = object.currentSecurityDataRevision;
                else if (typeof object.currentSecurityDataRevision === "object")
                    message.currentSecurityDataRevision = new $util.LongBits(object.currentSecurityDataRevision.low >>> 0, object.currentSecurityDataRevision.high >>> 0).toNumber();
            if (object.oldSecurityData != null)
                if (typeof object.oldSecurityData === "string")
                    $util.base64.decode(object.oldSecurityData, message.oldSecurityData = $util.newBuffer($util.base64.length(object.oldSecurityData)), 0);
                else if (object.oldSecurityData.length)
                    message.oldSecurityData = object.oldSecurityData;
            if (object.oldSecurityDataRevision != null)
                if ($util.Long)
                    (message.oldSecurityDataRevision = $util.Long.fromValue(object.oldSecurityDataRevision)).unsigned = false;
                else if (typeof object.oldSecurityDataRevision === "string")
                    message.oldSecurityDataRevision = parseInt(object.oldSecurityDataRevision, 10);
                else if (typeof object.oldSecurityDataRevision === "number")
                    message.oldSecurityDataRevision = object.oldSecurityDataRevision;
                else if (typeof object.oldSecurityDataRevision === "object")
                    message.oldSecurityDataRevision = new $util.LongBits(object.oldSecurityDataRevision.low >>> 0, object.oldSecurityDataRevision.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportIncrementalData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportIncrementalData
         * @static
         * @param {Authentication.SecurityReportIncrementalData} message SecurityReportIncrementalData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportIncrementalData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.currentSecurityData = "";
                else {
                    object.currentSecurityData = [];
                    if (options.bytes !== Array)
                        object.currentSecurityData = $util.newBuffer(object.currentSecurityData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.currentSecurityDataRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.currentSecurityDataRevision = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.oldSecurityData = "";
                else {
                    object.oldSecurityData = [];
                    if (options.bytes !== Array)
                        object.oldSecurityData = $util.newBuffer(object.oldSecurityData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.oldSecurityDataRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.oldSecurityDataRevision = options.longs === String ? "0" : 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.currentSecurityData != null && message.hasOwnProperty("currentSecurityData"))
                object.currentSecurityData = options.bytes === String ? $util.base64.encode(message.currentSecurityData, 0, message.currentSecurityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentSecurityData) : message.currentSecurityData;
            if (message.currentSecurityDataRevision != null && message.hasOwnProperty("currentSecurityDataRevision"))
                if (typeof message.currentSecurityDataRevision === "number")
                    object.currentSecurityDataRevision = options.longs === String ? String(message.currentSecurityDataRevision) : message.currentSecurityDataRevision;
                else
                    object.currentSecurityDataRevision = options.longs === String ? $util.Long.prototype.toString.call(message.currentSecurityDataRevision) : options.longs === Number ? new $util.LongBits(message.currentSecurityDataRevision.low >>> 0, message.currentSecurityDataRevision.high >>> 0).toNumber() : message.currentSecurityDataRevision;
            if (message.oldSecurityData != null && message.hasOwnProperty("oldSecurityData"))
                object.oldSecurityData = options.bytes === String ? $util.base64.encode(message.oldSecurityData, 0, message.oldSecurityData.length) : options.bytes === Array ? Array.prototype.slice.call(message.oldSecurityData) : message.oldSecurityData;
            if (message.oldSecurityDataRevision != null && message.hasOwnProperty("oldSecurityDataRevision"))
                if (typeof message.oldSecurityDataRevision === "number")
                    object.oldSecurityDataRevision = options.longs === String ? String(message.oldSecurityDataRevision) : message.oldSecurityDataRevision;
                else
                    object.oldSecurityDataRevision = options.longs === String ? $util.Long.prototype.toString.call(message.oldSecurityDataRevision) : options.longs === Number ? new $util.LongBits(message.oldSecurityDataRevision.low >>> 0, message.oldSecurityDataRevision.high >>> 0).toNumber() : message.oldSecurityDataRevision;
            return object;
        };

        /**
         * Converts this SecurityReportIncrementalData to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportIncrementalData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportIncrementalData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportIncrementalData;
    })();

    Authentication.SecurityReport = (function() {

        /**
         * Properties of a SecurityReport.
         * @memberof Authentication
         * @interface ISecurityReport
         * @property {number|Long|null} [enterpriseUserId] SecurityReport enterpriseUserId
         * @property {Uint8Array|null} [encryptedReportData] SecurityReport encryptedReportData
         * @property {number|Long|null} [revision] SecurityReport revision
         * @property {string|null} [twoFactor] SecurityReport twoFactor
         * @property {number|Long|null} [lastLogin] SecurityReport lastLogin
         * @property {number|null} [numberOfReusedPassword] SecurityReport numberOfReusedPassword
         * @property {Array.<Authentication.ISecurityReportIncrementalData>|null} [securityReportIncrementalData] SecurityReport securityReportIncrementalData
         */

        /**
         * Constructs a new SecurityReport.
         * @memberof Authentication
         * @classdesc Represents a SecurityReport.
         * @implements ISecurityReport
         * @constructor
         * @param {Authentication.ISecurityReport=} [properties] Properties to set
         */
        function SecurityReport(properties) {
            this.securityReportIncrementalData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReport enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport encryptedReportData.
         * @member {Uint8Array} encryptedReportData
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.encryptedReportData = $util.newBuffer([]);

        /**
         * SecurityReport revision.
         * @member {number|Long} revision
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport twoFactor.
         * @member {string} twoFactor
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.twoFactor = "";

        /**
         * SecurityReport lastLogin.
         * @member {number|Long} lastLogin
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.lastLogin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReport numberOfReusedPassword.
         * @member {number} numberOfReusedPassword
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.numberOfReusedPassword = 0;

        /**
         * SecurityReport securityReportIncrementalData.
         * @member {Array.<Authentication.ISecurityReportIncrementalData>} securityReportIncrementalData
         * @memberof Authentication.SecurityReport
         * @instance
         */
        SecurityReport.prototype.securityReportIncrementalData = $util.emptyArray;

        /**
         * Creates a new SecurityReport instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport=} [properties] Properties to set
         * @returns {Authentication.SecurityReport} SecurityReport instance
         */
        SecurityReport.create = function create(properties) {
            return new SecurityReport(properties);
        };

        /**
         * Encodes the specified SecurityReport message. Does not implicitly {@link Authentication.SecurityReport.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport} message SecurityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedReportData);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.revision);
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.twoFactor);
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.lastLogin);
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.numberOfReusedPassword);
            if (message.securityReportIncrementalData != null && message.securityReportIncrementalData.length)
                for (let i = 0; i < message.securityReportIncrementalData.length; ++i)
                    $root.Authentication.SecurityReportIncrementalData.encode(message.securityReportIncrementalData[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityReport message, length delimited. Does not implicitly {@link Authentication.SecurityReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.ISecurityReport} message SecurityReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReport message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReport} SecurityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.encryptedReportData = reader.bytes();
                    break;
                case 3:
                    message.revision = reader.int64();
                    break;
                case 4:
                    message.twoFactor = reader.string();
                    break;
                case 5:
                    message.lastLogin = reader.int64();
                    break;
                case 6:
                    message.numberOfReusedPassword = reader.int32();
                    break;
                case 7:
                    if (!(message.securityReportIncrementalData && message.securityReportIncrementalData.length))
                        message.securityReportIncrementalData = [];
                    message.securityReportIncrementalData.push($root.Authentication.SecurityReportIncrementalData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReport} SecurityReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReport message.
         * @function verify
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                if (!(message.encryptedReportData && typeof message.encryptedReportData.length === "number" || $util.isString(message.encryptedReportData)))
                    return "encryptedReportData: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                if (!$util.isString(message.twoFactor))
                    return "twoFactor: string expected";
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (!$util.isInteger(message.lastLogin) && !(message.lastLogin && $util.isInteger(message.lastLogin.low) && $util.isInteger(message.lastLogin.high)))
                    return "lastLogin: integer|Long expected";
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                if (!$util.isInteger(message.numberOfReusedPassword))
                    return "numberOfReusedPassword: integer expected";
            if (message.securityReportIncrementalData != null && message.hasOwnProperty("securityReportIncrementalData")) {
                if (!Array.isArray(message.securityReportIncrementalData))
                    return "securityReportIncrementalData: array expected";
                for (let i = 0; i < message.securityReportIncrementalData.length; ++i) {
                    let error = $root.Authentication.SecurityReportIncrementalData.verify(message.securityReportIncrementalData[i]);
                    if (error)
                        return "securityReportIncrementalData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReport} SecurityReport
         */
        SecurityReport.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReport)
                return object;
            let message = new $root.Authentication.SecurityReport();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.encryptedReportData != null)
                if (typeof object.encryptedReportData === "string")
                    $util.base64.decode(object.encryptedReportData, message.encryptedReportData = $util.newBuffer($util.base64.length(object.encryptedReportData)), 0);
                else if (object.encryptedReportData.length)
                    message.encryptedReportData = object.encryptedReportData;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.twoFactor != null)
                message.twoFactor = String(object.twoFactor);
            if (object.lastLogin != null)
                if ($util.Long)
                    (message.lastLogin = $util.Long.fromValue(object.lastLogin)).unsigned = false;
                else if (typeof object.lastLogin === "string")
                    message.lastLogin = parseInt(object.lastLogin, 10);
                else if (typeof object.lastLogin === "number")
                    message.lastLogin = object.lastLogin;
                else if (typeof object.lastLogin === "object")
                    message.lastLogin = new $util.LongBits(object.lastLogin.low >>> 0, object.lastLogin.high >>> 0).toNumber();
            if (object.numberOfReusedPassword != null)
                message.numberOfReusedPassword = object.numberOfReusedPassword | 0;
            if (object.securityReportIncrementalData) {
                if (!Array.isArray(object.securityReportIncrementalData))
                    throw TypeError(".Authentication.SecurityReport.securityReportIncrementalData: array expected");
                message.securityReportIncrementalData = [];
                for (let i = 0; i < object.securityReportIncrementalData.length; ++i) {
                    if (typeof object.securityReportIncrementalData[i] !== "object")
                        throw TypeError(".Authentication.SecurityReport.securityReportIncrementalData: object expected");
                    message.securityReportIncrementalData[i] = $root.Authentication.SecurityReportIncrementalData.fromObject(object.securityReportIncrementalData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReport
         * @static
         * @param {Authentication.SecurityReport} message SecurityReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReportIncrementalData = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedReportData = "";
                else {
                    object.encryptedReportData = [];
                    if (options.bytes !== Array)
                        object.encryptedReportData = $util.newBuffer(object.encryptedReportData);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.twoFactor = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastLogin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastLogin = options.longs === String ? "0" : 0;
                object.numberOfReusedPassword = 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.encryptedReportData != null && message.hasOwnProperty("encryptedReportData"))
                object.encryptedReportData = options.bytes === String ? $util.base64.encode(message.encryptedReportData, 0, message.encryptedReportData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedReportData) : message.encryptedReportData;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.twoFactor != null && message.hasOwnProperty("twoFactor"))
                object.twoFactor = message.twoFactor;
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (typeof message.lastLogin === "number")
                    object.lastLogin = options.longs === String ? String(message.lastLogin) : message.lastLogin;
                else
                    object.lastLogin = options.longs === String ? $util.Long.prototype.toString.call(message.lastLogin) : options.longs === Number ? new $util.LongBits(message.lastLogin.low >>> 0, message.lastLogin.high >>> 0).toNumber() : message.lastLogin;
            if (message.numberOfReusedPassword != null && message.hasOwnProperty("numberOfReusedPassword"))
                object.numberOfReusedPassword = message.numberOfReusedPassword;
            if (message.securityReportIncrementalData && message.securityReportIncrementalData.length) {
                object.securityReportIncrementalData = [];
                for (let j = 0; j < message.securityReportIncrementalData.length; ++j)
                    object.securityReportIncrementalData[j] = $root.Authentication.SecurityReportIncrementalData.toObject(message.securityReportIncrementalData[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityReport to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReport;
    })();

    Authentication.SecurityReportSaveRequest = (function() {

        /**
         * Properties of a SecurityReportSaveRequest.
         * @memberof Authentication
         * @interface ISecurityReportSaveRequest
         * @property {Array.<Authentication.ISecurityReport>|null} [securityReport] SecurityReportSaveRequest securityReport
         */

        /**
         * Constructs a new SecurityReportSaveRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportSaveRequest.
         * @implements ISecurityReportSaveRequest
         * @constructor
         * @param {Authentication.ISecurityReportSaveRequest=} [properties] Properties to set
         */
        function SecurityReportSaveRequest(properties) {
            this.securityReport = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportSaveRequest securityReport.
         * @member {Array.<Authentication.ISecurityReport>} securityReport
         * @memberof Authentication.SecurityReportSaveRequest
         * @instance
         */
        SecurityReportSaveRequest.prototype.securityReport = $util.emptyArray;

        /**
         * Creates a new SecurityReportSaveRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest instance
         */
        SecurityReportSaveRequest.create = function create(properties) {
            return new SecurityReportSaveRequest(properties);
        };

        /**
         * Encodes the specified SecurityReportSaveRequest message. Does not implicitly {@link Authentication.SecurityReportSaveRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest} message SecurityReportSaveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportSaveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.securityReport != null && message.securityReport.length)
                for (let i = 0; i < message.securityReport.length; ++i)
                    $root.Authentication.SecurityReport.encode(message.securityReport[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityReportSaveRequest message, length delimited. Does not implicitly {@link Authentication.SecurityReportSaveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.ISecurityReportSaveRequest} message SecurityReportSaveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportSaveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportSaveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportSaveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportSaveRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.securityReport && message.securityReport.length))
                        message.securityReport = [];
                    message.securityReport.push($root.Authentication.SecurityReport.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportSaveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportSaveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportSaveRequest message.
         * @function verify
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportSaveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.securityReport != null && message.hasOwnProperty("securityReport")) {
                if (!Array.isArray(message.securityReport))
                    return "securityReport: array expected";
                for (let i = 0; i < message.securityReport.length; ++i) {
                    let error = $root.Authentication.SecurityReport.verify(message.securityReport[i]);
                    if (error)
                        return "securityReport." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SecurityReportSaveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportSaveRequest} SecurityReportSaveRequest
         */
        SecurityReportSaveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportSaveRequest)
                return object;
            let message = new $root.Authentication.SecurityReportSaveRequest();
            if (object.securityReport) {
                if (!Array.isArray(object.securityReport))
                    throw TypeError(".Authentication.SecurityReportSaveRequest.securityReport: array expected");
                message.securityReport = [];
                for (let i = 0; i < object.securityReport.length; ++i) {
                    if (typeof object.securityReport[i] !== "object")
                        throw TypeError(".Authentication.SecurityReportSaveRequest.securityReport: object expected");
                    message.securityReport[i] = $root.Authentication.SecurityReport.fromObject(object.securityReport[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportSaveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportSaveRequest
         * @static
         * @param {Authentication.SecurityReportSaveRequest} message SecurityReportSaveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportSaveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReport = [];
            if (message.securityReport && message.securityReport.length) {
                object.securityReport = [];
                for (let j = 0; j < message.securityReport.length; ++j)
                    object.securityReport[j] = $root.Authentication.SecurityReport.toObject(message.securityReport[j], options);
            }
            return object;
        };

        /**
         * Converts this SecurityReportSaveRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportSaveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportSaveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportSaveRequest;
    })();

    Authentication.SecurityReportRequest = (function() {

        /**
         * Properties of a SecurityReportRequest.
         * @memberof Authentication
         * @interface ISecurityReportRequest
         * @property {number|Long|null} [fromPage] SecurityReportRequest fromPage
         */

        /**
         * Constructs a new SecurityReportRequest.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportRequest.
         * @implements ISecurityReportRequest
         * @constructor
         * @param {Authentication.ISecurityReportRequest=} [properties] Properties to set
         */
        function SecurityReportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportRequest fromPage.
         * @member {number|Long} fromPage
         * @memberof Authentication.SecurityReportRequest
         * @instance
         */
        SecurityReportRequest.prototype.fromPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SecurityReportRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest=} [properties] Properties to set
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest instance
         */
        SecurityReportRequest.create = function create(properties) {
            return new SecurityReportRequest(properties);
        };

        /**
         * Encodes the specified SecurityReportRequest message. Does not implicitly {@link Authentication.SecurityReportRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest} message SecurityReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fromPage);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportRequest message, length delimited. Does not implicitly {@link Authentication.SecurityReportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.ISecurityReportRequest} message SecurityReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fromPage = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportRequest message.
         * @function verify
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (!$util.isInteger(message.fromPage) && !(message.fromPage && $util.isInteger(message.fromPage.low) && $util.isInteger(message.fromPage.high)))
                    return "fromPage: integer|Long expected";
            return null;
        };

        /**
         * Creates a SecurityReportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportRequest} SecurityReportRequest
         */
        SecurityReportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportRequest)
                return object;
            let message = new $root.Authentication.SecurityReportRequest();
            if (object.fromPage != null)
                if ($util.Long)
                    (message.fromPage = $util.Long.fromValue(object.fromPage)).unsigned = false;
                else if (typeof object.fromPage === "string")
                    message.fromPage = parseInt(object.fromPage, 10);
                else if (typeof object.fromPage === "number")
                    message.fromPage = object.fromPage;
                else if (typeof object.fromPage === "object")
                    message.fromPage = new $util.LongBits(object.fromPage.low >>> 0, object.fromPage.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportRequest
         * @static
         * @param {Authentication.SecurityReportRequest} message SecurityReportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fromPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromPage = options.longs === String ? "0" : 0;
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (typeof message.fromPage === "number")
                    object.fromPage = options.longs === String ? String(message.fromPage) : message.fromPage;
                else
                    object.fromPage = options.longs === String ? $util.Long.prototype.toString.call(message.fromPage) : options.longs === Number ? new $util.LongBits(message.fromPage.low >>> 0, message.fromPage.high >>> 0).toNumber() : message.fromPage;
            return object;
        };

        /**
         * Converts this SecurityReportRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportRequest;
    })();

    Authentication.SecurityReportResponse = (function() {

        /**
         * Properties of a SecurityReportResponse.
         * @memberof Authentication
         * @interface ISecurityReportResponse
         * @property {Uint8Array|null} [enterprisePrivateKey] SecurityReportResponse enterprisePrivateKey
         * @property {Array.<Authentication.ISecurityReport>|null} [securityReport] SecurityReportResponse securityReport
         * @property {number|Long|null} [asOfRevision] SecurityReportResponse asOfRevision
         * @property {number|Long|null} [fromPage] SecurityReportResponse fromPage
         * @property {number|Long|null} [toPage] SecurityReportResponse toPage
         * @property {boolean|null} [complete] SecurityReportResponse complete
         */

        /**
         * Constructs a new SecurityReportResponse.
         * @memberof Authentication
         * @classdesc Represents a SecurityReportResponse.
         * @implements ISecurityReportResponse
         * @constructor
         * @param {Authentication.ISecurityReportResponse=} [properties] Properties to set
         */
        function SecurityReportResponse(properties) {
            this.securityReport = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityReportResponse enterprisePrivateKey.
         * @member {Uint8Array} enterprisePrivateKey
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.enterprisePrivateKey = $util.newBuffer([]);

        /**
         * SecurityReportResponse securityReport.
         * @member {Array.<Authentication.ISecurityReport>} securityReport
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.securityReport = $util.emptyArray;

        /**
         * SecurityReportResponse asOfRevision.
         * @member {number|Long} asOfRevision
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.asOfRevision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse fromPage.
         * @member {number|Long} fromPage
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.fromPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse toPage.
         * @member {number|Long} toPage
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.toPage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityReportResponse complete.
         * @member {boolean} complete
         * @memberof Authentication.SecurityReportResponse
         * @instance
         */
        SecurityReportResponse.prototype.complete = false;

        /**
         * Creates a new SecurityReportResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse=} [properties] Properties to set
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse instance
         */
        SecurityReportResponse.create = function create(properties) {
            return new SecurityReportResponse(properties);
        };

        /**
         * Encodes the specified SecurityReportResponse message. Does not implicitly {@link Authentication.SecurityReportResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse} message SecurityReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePrivateKey);
            if (message.securityReport != null && message.securityReport.length)
                for (let i = 0; i < message.securityReport.length; ++i)
                    $root.Authentication.SecurityReport.encode(message.securityReport[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.asOfRevision);
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fromPage);
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.toPage);
            if (message.complete != null && message.hasOwnProperty("complete"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.complete);
            return writer;
        };

        /**
         * Encodes the specified SecurityReportResponse message, length delimited. Does not implicitly {@link Authentication.SecurityReportResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.ISecurityReportResponse} message SecurityReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SecurityReportResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePrivateKey = reader.bytes();
                    break;
                case 2:
                    if (!(message.securityReport && message.securityReport.length))
                        message.securityReport = [];
                    message.securityReport.push($root.Authentication.SecurityReport.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.asOfRevision = reader.int64();
                    break;
                case 4:
                    message.fromPage = reader.int64();
                    break;
                case 5:
                    message.toPage = reader.int64();
                    break;
                case 6:
                    message.complete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityReportResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityReportResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityReportResponse message.
         * @function verify
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityReportResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                if (!(message.enterprisePrivateKey && typeof message.enterprisePrivateKey.length === "number" || $util.isString(message.enterprisePrivateKey)))
                    return "enterprisePrivateKey: buffer expected";
            if (message.securityReport != null && message.hasOwnProperty("securityReport")) {
                if (!Array.isArray(message.securityReport))
                    return "securityReport: array expected";
                for (let i = 0; i < message.securityReport.length; ++i) {
                    let error = $root.Authentication.SecurityReport.verify(message.securityReport[i]);
                    if (error)
                        return "securityReport." + error;
                }
            }
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                if (!$util.isInteger(message.asOfRevision) && !(message.asOfRevision && $util.isInteger(message.asOfRevision.low) && $util.isInteger(message.asOfRevision.high)))
                    return "asOfRevision: integer|Long expected";
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (!$util.isInteger(message.fromPage) && !(message.fromPage && $util.isInteger(message.fromPage.low) && $util.isInteger(message.fromPage.high)))
                    return "fromPage: integer|Long expected";
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                if (!$util.isInteger(message.toPage) && !(message.toPage && $util.isInteger(message.toPage.low) && $util.isInteger(message.toPage.high)))
                    return "toPage: integer|Long expected";
            if (message.complete != null && message.hasOwnProperty("complete"))
                if (typeof message.complete !== "boolean")
                    return "complete: boolean expected";
            return null;
        };

        /**
         * Creates a SecurityReportResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SecurityReportResponse} SecurityReportResponse
         */
        SecurityReportResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SecurityReportResponse)
                return object;
            let message = new $root.Authentication.SecurityReportResponse();
            if (object.enterprisePrivateKey != null)
                if (typeof object.enterprisePrivateKey === "string")
                    $util.base64.decode(object.enterprisePrivateKey, message.enterprisePrivateKey = $util.newBuffer($util.base64.length(object.enterprisePrivateKey)), 0);
                else if (object.enterprisePrivateKey.length)
                    message.enterprisePrivateKey = object.enterprisePrivateKey;
            if (object.securityReport) {
                if (!Array.isArray(object.securityReport))
                    throw TypeError(".Authentication.SecurityReportResponse.securityReport: array expected");
                message.securityReport = [];
                for (let i = 0; i < object.securityReport.length; ++i) {
                    if (typeof object.securityReport[i] !== "object")
                        throw TypeError(".Authentication.SecurityReportResponse.securityReport: object expected");
                    message.securityReport[i] = $root.Authentication.SecurityReport.fromObject(object.securityReport[i]);
                }
            }
            if (object.asOfRevision != null)
                if ($util.Long)
                    (message.asOfRevision = $util.Long.fromValue(object.asOfRevision)).unsigned = false;
                else if (typeof object.asOfRevision === "string")
                    message.asOfRevision = parseInt(object.asOfRevision, 10);
                else if (typeof object.asOfRevision === "number")
                    message.asOfRevision = object.asOfRevision;
                else if (typeof object.asOfRevision === "object")
                    message.asOfRevision = new $util.LongBits(object.asOfRevision.low >>> 0, object.asOfRevision.high >>> 0).toNumber();
            if (object.fromPage != null)
                if ($util.Long)
                    (message.fromPage = $util.Long.fromValue(object.fromPage)).unsigned = false;
                else if (typeof object.fromPage === "string")
                    message.fromPage = parseInt(object.fromPage, 10);
                else if (typeof object.fromPage === "number")
                    message.fromPage = object.fromPage;
                else if (typeof object.fromPage === "object")
                    message.fromPage = new $util.LongBits(object.fromPage.low >>> 0, object.fromPage.high >>> 0).toNumber();
            if (object.toPage != null)
                if ($util.Long)
                    (message.toPage = $util.Long.fromValue(object.toPage)).unsigned = false;
                else if (typeof object.toPage === "string")
                    message.toPage = parseInt(object.toPage, 10);
                else if (typeof object.toPage === "number")
                    message.toPage = object.toPage;
                else if (typeof object.toPage === "object")
                    message.toPage = new $util.LongBits(object.toPage.low >>> 0, object.toPage.high >>> 0).toNumber();
            if (object.complete != null)
                message.complete = Boolean(object.complete);
            return message;
        };

        /**
         * Creates a plain object from a SecurityReportResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SecurityReportResponse
         * @static
         * @param {Authentication.SecurityReportResponse} message SecurityReportResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityReportResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.securityReport = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.enterprisePrivateKey = "";
                else {
                    object.enterprisePrivateKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePrivateKey = $util.newBuffer(object.enterprisePrivateKey);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.asOfRevision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.asOfRevision = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fromPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fromPage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.toPage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.toPage = options.longs === String ? "0" : 0;
                object.complete = false;
            }
            if (message.enterprisePrivateKey != null && message.hasOwnProperty("enterprisePrivateKey"))
                object.enterprisePrivateKey = options.bytes === String ? $util.base64.encode(message.enterprisePrivateKey, 0, message.enterprisePrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePrivateKey) : message.enterprisePrivateKey;
            if (message.securityReport && message.securityReport.length) {
                object.securityReport = [];
                for (let j = 0; j < message.securityReport.length; ++j)
                    object.securityReport[j] = $root.Authentication.SecurityReport.toObject(message.securityReport[j], options);
            }
            if (message.asOfRevision != null && message.hasOwnProperty("asOfRevision"))
                if (typeof message.asOfRevision === "number")
                    object.asOfRevision = options.longs === String ? String(message.asOfRevision) : message.asOfRevision;
                else
                    object.asOfRevision = options.longs === String ? $util.Long.prototype.toString.call(message.asOfRevision) : options.longs === Number ? new $util.LongBits(message.asOfRevision.low >>> 0, message.asOfRevision.high >>> 0).toNumber() : message.asOfRevision;
            if (message.fromPage != null && message.hasOwnProperty("fromPage"))
                if (typeof message.fromPage === "number")
                    object.fromPage = options.longs === String ? String(message.fromPage) : message.fromPage;
                else
                    object.fromPage = options.longs === String ? $util.Long.prototype.toString.call(message.fromPage) : options.longs === Number ? new $util.LongBits(message.fromPage.low >>> 0, message.fromPage.high >>> 0).toNumber() : message.fromPage;
            if (message.toPage != null && message.hasOwnProperty("toPage"))
                if (typeof message.toPage === "number")
                    object.toPage = options.longs === String ? String(message.toPage) : message.toPage;
                else
                    object.toPage = options.longs === String ? $util.Long.prototype.toString.call(message.toPage) : options.longs === Number ? new $util.LongBits(message.toPage.low >>> 0, message.toPage.high >>> 0).toNumber() : message.toPage;
            if (message.complete != null && message.hasOwnProperty("complete"))
                object.complete = message.complete;
            return object;
        };

        /**
         * Converts this SecurityReportResponse to JSON.
         * @function toJSON
         * @memberof Authentication.SecurityReportResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityReportResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityReportResponse;
    })();

    Authentication.ReusedPasswordsRequest = (function() {

        /**
         * Properties of a ReusedPasswordsRequest.
         * @memberof Authentication
         * @interface IReusedPasswordsRequest
         * @property {number|null} [count] ReusedPasswordsRequest count
         */

        /**
         * Constructs a new ReusedPasswordsRequest.
         * @memberof Authentication
         * @classdesc Represents a ReusedPasswordsRequest.
         * @implements IReusedPasswordsRequest
         * @constructor
         * @param {Authentication.IReusedPasswordsRequest=} [properties] Properties to set
         */
        function ReusedPasswordsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReusedPasswordsRequest count.
         * @member {number} count
         * @memberof Authentication.ReusedPasswordsRequest
         * @instance
         */
        ReusedPasswordsRequest.prototype.count = 0;

        /**
         * Creates a new ReusedPasswordsRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest=} [properties] Properties to set
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest instance
         */
        ReusedPasswordsRequest.create = function create(properties) {
            return new ReusedPasswordsRequest(properties);
        };

        /**
         * Encodes the specified ReusedPasswordsRequest message. Does not implicitly {@link Authentication.ReusedPasswordsRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest} message ReusedPasswordsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReusedPasswordsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ReusedPasswordsRequest message, length delimited. Does not implicitly {@link Authentication.ReusedPasswordsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.IReusedPasswordsRequest} message ReusedPasswordsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReusedPasswordsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReusedPasswordsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReusedPasswordsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ReusedPasswordsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReusedPasswordsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReusedPasswordsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReusedPasswordsRequest message.
         * @function verify
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReusedPasswordsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a ReusedPasswordsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ReusedPasswordsRequest} ReusedPasswordsRequest
         */
        ReusedPasswordsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ReusedPasswordsRequest)
                return object;
            let message = new $root.Authentication.ReusedPasswordsRequest();
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a ReusedPasswordsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ReusedPasswordsRequest
         * @static
         * @param {Authentication.ReusedPasswordsRequest} message ReusedPasswordsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReusedPasswordsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.count = 0;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this ReusedPasswordsRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ReusedPasswordsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReusedPasswordsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReusedPasswordsRequest;
    })();

    Authentication.SummaryConsoleReport = (function() {

        /**
         * Properties of a SummaryConsoleReport.
         * @memberof Authentication
         * @interface ISummaryConsoleReport
         * @property {number|null} [reportType] SummaryConsoleReport reportType
         * @property {Uint8Array|null} [reportData] SummaryConsoleReport reportData
         */

        /**
         * Constructs a new SummaryConsoleReport.
         * @memberof Authentication
         * @classdesc Represents a SummaryConsoleReport.
         * @implements ISummaryConsoleReport
         * @constructor
         * @param {Authentication.ISummaryConsoleReport=} [properties] Properties to set
         */
        function SummaryConsoleReport(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SummaryConsoleReport reportType.
         * @member {number} reportType
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         */
        SummaryConsoleReport.prototype.reportType = 0;

        /**
         * SummaryConsoleReport reportData.
         * @member {Uint8Array} reportData
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         */
        SummaryConsoleReport.prototype.reportData = $util.newBuffer([]);

        /**
         * Creates a new SummaryConsoleReport instance using the specified properties.
         * @function create
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport=} [properties] Properties to set
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport instance
         */
        SummaryConsoleReport.create = function create(properties) {
            return new SummaryConsoleReport(properties);
        };

        /**
         * Encodes the specified SummaryConsoleReport message. Does not implicitly {@link Authentication.SummaryConsoleReport.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport} message SummaryConsoleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryConsoleReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reportType);
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.reportData);
            return writer;
        };

        /**
         * Encodes the specified SummaryConsoleReport message, length delimited. Does not implicitly {@link Authentication.SummaryConsoleReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.ISummaryConsoleReport} message SummaryConsoleReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummaryConsoleReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SummaryConsoleReport message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryConsoleReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SummaryConsoleReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reportType = reader.int32();
                    break;
                case 2:
                    message.reportData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SummaryConsoleReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummaryConsoleReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SummaryConsoleReport message.
         * @function verify
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SummaryConsoleReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                if (!$util.isInteger(message.reportType))
                    return "reportType: integer expected";
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                if (!(message.reportData && typeof message.reportData.length === "number" || $util.isString(message.reportData)))
                    return "reportData: buffer expected";
            return null;
        };

        /**
         * Creates a SummaryConsoleReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SummaryConsoleReport} SummaryConsoleReport
         */
        SummaryConsoleReport.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SummaryConsoleReport)
                return object;
            let message = new $root.Authentication.SummaryConsoleReport();
            if (object.reportType != null)
                message.reportType = object.reportType | 0;
            if (object.reportData != null)
                if (typeof object.reportData === "string")
                    $util.base64.decode(object.reportData, message.reportData = $util.newBuffer($util.base64.length(object.reportData)), 0);
                else if (object.reportData.length)
                    message.reportData = object.reportData;
            return message;
        };

        /**
         * Creates a plain object from a SummaryConsoleReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SummaryConsoleReport
         * @static
         * @param {Authentication.SummaryConsoleReport} message SummaryConsoleReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SummaryConsoleReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.reportType = 0;
                if (options.bytes === String)
                    object.reportData = "";
                else {
                    object.reportData = [];
                    if (options.bytes !== Array)
                        object.reportData = $util.newBuffer(object.reportData);
                }
            }
            if (message.reportType != null && message.hasOwnProperty("reportType"))
                object.reportType = message.reportType;
            if (message.reportData != null && message.hasOwnProperty("reportData"))
                object.reportData = options.bytes === String ? $util.base64.encode(message.reportData, 0, message.reportData.length) : options.bytes === Array ? Array.prototype.slice.call(message.reportData) : message.reportData;
            return object;
        };

        /**
         * Converts this SummaryConsoleReport to JSON.
         * @function toJSON
         * @memberof Authentication.SummaryConsoleReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SummaryConsoleReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SummaryConsoleReport;
    })();

    /**
     * ObjectTypes enum.
     * @name Authentication.ObjectTypes
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} SHARED_FOLDER_USER=1 SHARED_FOLDER_USER value
     * @property {number} SHARED_FOLDER_TEAM=2 SHARED_FOLDER_TEAM value
     * @property {number} USER_FOLDER=3 USER_FOLDER value
     * @property {number} TEAM_USER=4 TEAM_USER value
     */
    Authentication.ObjectTypes = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "SHARED_FOLDER_USER"] = 1;
        values[valuesById[2] = "SHARED_FOLDER_TEAM"] = 2;
        values[valuesById[3] = "USER_FOLDER"] = 3;
        values[valuesById[4] = "TEAM_USER"] = 4;
        return values;
    })();

    Authentication.ChangeToKeyTypeOne = (function() {

        /**
         * Properties of a ChangeToKeyTypeOne.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOne
         * @property {Authentication.ObjectTypes|null} [objectType] ChangeToKeyTypeOne objectType
         * @property {Uint8Array|null} [primaryUid] ChangeToKeyTypeOne primaryUid
         * @property {Uint8Array|null} [secondaryUid] ChangeToKeyTypeOne secondaryUid
         * @property {Uint8Array|null} [key] ChangeToKeyTypeOne key
         */

        /**
         * Constructs a new ChangeToKeyTypeOne.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOne.
         * @implements IChangeToKeyTypeOne
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOne=} [properties] Properties to set
         */
        function ChangeToKeyTypeOne(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOne objectType.
         * @member {Authentication.ObjectTypes} objectType
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.objectType = 0;

        /**
         * ChangeToKeyTypeOne primaryUid.
         * @member {Uint8Array} primaryUid
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.primaryUid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOne secondaryUid.
         * @member {Uint8Array} secondaryUid
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.secondaryUid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOne key.
         * @member {Uint8Array} key
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         */
        ChangeToKeyTypeOne.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new ChangeToKeyTypeOne instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne instance
         */
        ChangeToKeyTypeOne.create = function create(properties) {
            return new ChangeToKeyTypeOne(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOne message. Does not implicitly {@link Authentication.ChangeToKeyTypeOne.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne} message ChangeToKeyTypeOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOne.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.objectType);
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.primaryUid);
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.secondaryUid);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOne message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOne.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.IChangeToKeyTypeOne} message ChangeToKeyTypeOne message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOne.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOne message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOne.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOne();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.objectType = reader.int32();
                    break;
                case 2:
                    message.primaryUid = reader.bytes();
                    break;
                case 3:
                    message.secondaryUid = reader.bytes();
                    break;
                case 4:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOne message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOne.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOne message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOne.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                switch (message.objectType) {
                default:
                    return "objectType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                if (!(message.primaryUid && typeof message.primaryUid.length === "number" || $util.isString(message.primaryUid)))
                    return "primaryUid: buffer expected";
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                if (!(message.secondaryUid && typeof message.secondaryUid.length === "number" || $util.isString(message.secondaryUid)))
                    return "secondaryUid: buffer expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOne message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOne} ChangeToKeyTypeOne
         */
        ChangeToKeyTypeOne.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOne)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOne();
            switch (object.objectType) {
            case "RECORD":
            case 0:
                message.objectType = 0;
                break;
            case "SHARED_FOLDER_USER":
            case 1:
                message.objectType = 1;
                break;
            case "SHARED_FOLDER_TEAM":
            case 2:
                message.objectType = 2;
                break;
            case "USER_FOLDER":
            case 3:
                message.objectType = 3;
                break;
            case "TEAM_USER":
            case 4:
                message.objectType = 4;
                break;
            }
            if (object.primaryUid != null)
                if (typeof object.primaryUid === "string")
                    $util.base64.decode(object.primaryUid, message.primaryUid = $util.newBuffer($util.base64.length(object.primaryUid)), 0);
                else if (object.primaryUid.length)
                    message.primaryUid = object.primaryUid;
            if (object.secondaryUid != null)
                if (typeof object.secondaryUid === "string")
                    $util.base64.decode(object.secondaryUid, message.secondaryUid = $util.newBuffer($util.base64.length(object.secondaryUid)), 0);
                else if (object.secondaryUid.length)
                    message.secondaryUid = object.secondaryUid;
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOne message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOne
         * @static
         * @param {Authentication.ChangeToKeyTypeOne} message ChangeToKeyTypeOne
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOne.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.objectType = options.enums === String ? "RECORD" : 0;
                if (options.bytes === String)
                    object.primaryUid = "";
                else {
                    object.primaryUid = [];
                    if (options.bytes !== Array)
                        object.primaryUid = $util.newBuffer(object.primaryUid);
                }
                if (options.bytes === String)
                    object.secondaryUid = "";
                else {
                    object.secondaryUid = [];
                    if (options.bytes !== Array)
                        object.secondaryUid = $util.newBuffer(object.secondaryUid);
                }
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            }
            if (message.objectType != null && message.hasOwnProperty("objectType"))
                object.objectType = options.enums === String ? $root.Authentication.ObjectTypes[message.objectType] : message.objectType;
            if (message.primaryUid != null && message.hasOwnProperty("primaryUid"))
                object.primaryUid = options.bytes === String ? $util.base64.encode(message.primaryUid, 0, message.primaryUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.primaryUid) : message.primaryUid;
            if (message.secondaryUid != null && message.hasOwnProperty("secondaryUid"))
                object.secondaryUid = options.bytes === String ? $util.base64.encode(message.secondaryUid, 0, message.secondaryUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.secondaryUid) : message.secondaryUid;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOne to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOne
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOne.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOne;
    })();

    Authentication.ChangeToKeyTypeOneRequest = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneRequest.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneRequest
         * @property {Array.<Authentication.IChangeToKeyTypeOne>|null} [changeToKeyTypeOne] ChangeToKeyTypeOneRequest changeToKeyTypeOne
         */

        /**
         * Constructs a new ChangeToKeyTypeOneRequest.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneRequest.
         * @implements IChangeToKeyTypeOneRequest
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneRequest=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneRequest(properties) {
            this.changeToKeyTypeOne = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneRequest changeToKeyTypeOne.
         * @member {Array.<Authentication.IChangeToKeyTypeOne>} changeToKeyTypeOne
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @instance
         */
        ChangeToKeyTypeOneRequest.prototype.changeToKeyTypeOne = $util.emptyArray;

        /**
         * Creates a new ChangeToKeyTypeOneRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest instance
         */
        ChangeToKeyTypeOneRequest.create = function create(properties) {
            return new ChangeToKeyTypeOneRequest(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneRequest message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changeToKeyTypeOne != null && message.changeToKeyTypeOne.length)
                for (let i = 0; i < message.changeToKeyTypeOne.length; ++i)
                    $root.Authentication.ChangeToKeyTypeOne.encode(message.changeToKeyTypeOne[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneRequest message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.IChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.changeToKeyTypeOne && message.changeToKeyTypeOne.length))
                        message.changeToKeyTypeOne = [];
                    message.changeToKeyTypeOne.push($root.Authentication.ChangeToKeyTypeOne.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneRequest message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changeToKeyTypeOne != null && message.hasOwnProperty("changeToKeyTypeOne")) {
                if (!Array.isArray(message.changeToKeyTypeOne))
                    return "changeToKeyTypeOne: array expected";
                for (let i = 0; i < message.changeToKeyTypeOne.length; ++i) {
                    let error = $root.Authentication.ChangeToKeyTypeOne.verify(message.changeToKeyTypeOne[i]);
                    if (error)
                        return "changeToKeyTypeOne." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneRequest} ChangeToKeyTypeOneRequest
         */
        ChangeToKeyTypeOneRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneRequest)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneRequest();
            if (object.changeToKeyTypeOne) {
                if (!Array.isArray(object.changeToKeyTypeOne))
                    throw TypeError(".Authentication.ChangeToKeyTypeOneRequest.changeToKeyTypeOne: array expected");
                message.changeToKeyTypeOne = [];
                for (let i = 0; i < object.changeToKeyTypeOne.length; ++i) {
                    if (typeof object.changeToKeyTypeOne[i] !== "object")
                        throw TypeError(".Authentication.ChangeToKeyTypeOneRequest.changeToKeyTypeOne: object expected");
                    message.changeToKeyTypeOne[i] = $root.Authentication.ChangeToKeyTypeOne.fromObject(object.changeToKeyTypeOne[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @static
         * @param {Authentication.ChangeToKeyTypeOneRequest} message ChangeToKeyTypeOneRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.changeToKeyTypeOne = [];
            if (message.changeToKeyTypeOne && message.changeToKeyTypeOne.length) {
                object.changeToKeyTypeOne = [];
                for (let j = 0; j < message.changeToKeyTypeOne.length; ++j)
                    object.changeToKeyTypeOne[j] = $root.Authentication.ChangeToKeyTypeOne.toObject(message.changeToKeyTypeOne[j], options);
            }
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneRequest;
    })();

    Authentication.ChangeToKeyTypeOneStatus = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneStatus.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneStatus
         * @property {Uint8Array|null} [uid] ChangeToKeyTypeOneStatus uid
         * @property {string|null} [type] ChangeToKeyTypeOneStatus type
         * @property {string|null} [status] ChangeToKeyTypeOneStatus status
         * @property {string|null} [reason] ChangeToKeyTypeOneStatus reason
         */

        /**
         * Constructs a new ChangeToKeyTypeOneStatus.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneStatus.
         * @implements IChangeToKeyTypeOneStatus
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneStatus=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneStatus uid.
         * @member {Uint8Array} uid
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.uid = $util.newBuffer([]);

        /**
         * ChangeToKeyTypeOneStatus type.
         * @member {string} type
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.type = "";

        /**
         * ChangeToKeyTypeOneStatus status.
         * @member {string} status
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.status = "";

        /**
         * ChangeToKeyTypeOneStatus reason.
         * @member {string} reason
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         */
        ChangeToKeyTypeOneStatus.prototype.reason = "";

        /**
         * Creates a new ChangeToKeyTypeOneStatus instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus instance
         */
        ChangeToKeyTypeOneStatus.create = function create(properties) {
            return new ChangeToKeyTypeOneStatus(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneStatus message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneStatus.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.uid);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneStatus message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.IChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uid = reader.bytes();
                    break;
                case 2:
                    message.type = reader.string();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                case 4:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneStatus message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneStatus} ChangeToKeyTypeOneStatus
         */
        ChangeToKeyTypeOneStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneStatus)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneStatus();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            if (object.type != null)
                message.type = String(object.type);
            if (object.status != null)
                message.status = String(object.status);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @static
         * @param {Authentication.ChangeToKeyTypeOneStatus} message ChangeToKeyTypeOneStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.type = "";
                object.status = "";
                object.reason = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneStatus to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneStatus;
    })();

    Authentication.ChangeToKeyTypeOneResponse = (function() {

        /**
         * Properties of a ChangeToKeyTypeOneResponse.
         * @memberof Authentication
         * @interface IChangeToKeyTypeOneResponse
         * @property {Array.<Authentication.IChangeToKeyTypeOneStatus>|null} [changeToKeyTypeOneStatus] ChangeToKeyTypeOneResponse changeToKeyTypeOneStatus
         */

        /**
         * Constructs a new ChangeToKeyTypeOneResponse.
         * @memberof Authentication
         * @classdesc Represents a ChangeToKeyTypeOneResponse.
         * @implements IChangeToKeyTypeOneResponse
         * @constructor
         * @param {Authentication.IChangeToKeyTypeOneResponse=} [properties] Properties to set
         */
        function ChangeToKeyTypeOneResponse(properties) {
            this.changeToKeyTypeOneStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeToKeyTypeOneResponse changeToKeyTypeOneStatus.
         * @member {Array.<Authentication.IChangeToKeyTypeOneStatus>} changeToKeyTypeOneStatus
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @instance
         */
        ChangeToKeyTypeOneResponse.prototype.changeToKeyTypeOneStatus = $util.emptyArray;

        /**
         * Creates a new ChangeToKeyTypeOneResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse=} [properties] Properties to set
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse instance
         */
        ChangeToKeyTypeOneResponse.create = function create(properties) {
            return new ChangeToKeyTypeOneResponse(properties);
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneResponse message. Does not implicitly {@link Authentication.ChangeToKeyTypeOneResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.changeToKeyTypeOneStatus != null && message.changeToKeyTypeOneStatus.length)
                for (let i = 0; i < message.changeToKeyTypeOneStatus.length; ++i)
                    $root.Authentication.ChangeToKeyTypeOneStatus.encode(message.changeToKeyTypeOneStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeToKeyTypeOneResponse message, length delimited. Does not implicitly {@link Authentication.ChangeToKeyTypeOneResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.IChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeToKeyTypeOneResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeToKeyTypeOneResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ChangeToKeyTypeOneResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.changeToKeyTypeOneStatus && message.changeToKeyTypeOneStatus.length))
                        message.changeToKeyTypeOneStatus = [];
                    message.changeToKeyTypeOneStatus.push($root.Authentication.ChangeToKeyTypeOneStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeToKeyTypeOneResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeToKeyTypeOneResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeToKeyTypeOneResponse message.
         * @function verify
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeToKeyTypeOneResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.changeToKeyTypeOneStatus != null && message.hasOwnProperty("changeToKeyTypeOneStatus")) {
                if (!Array.isArray(message.changeToKeyTypeOneStatus))
                    return "changeToKeyTypeOneStatus: array expected";
                for (let i = 0; i < message.changeToKeyTypeOneStatus.length; ++i) {
                    let error = $root.Authentication.ChangeToKeyTypeOneStatus.verify(message.changeToKeyTypeOneStatus[i]);
                    if (error)
                        return "changeToKeyTypeOneStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChangeToKeyTypeOneResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ChangeToKeyTypeOneResponse} ChangeToKeyTypeOneResponse
         */
        ChangeToKeyTypeOneResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ChangeToKeyTypeOneResponse)
                return object;
            let message = new $root.Authentication.ChangeToKeyTypeOneResponse();
            if (object.changeToKeyTypeOneStatus) {
                if (!Array.isArray(object.changeToKeyTypeOneStatus))
                    throw TypeError(".Authentication.ChangeToKeyTypeOneResponse.changeToKeyTypeOneStatus: array expected");
                message.changeToKeyTypeOneStatus = [];
                for (let i = 0; i < object.changeToKeyTypeOneStatus.length; ++i) {
                    if (typeof object.changeToKeyTypeOneStatus[i] !== "object")
                        throw TypeError(".Authentication.ChangeToKeyTypeOneResponse.changeToKeyTypeOneStatus: object expected");
                    message.changeToKeyTypeOneStatus[i] = $root.Authentication.ChangeToKeyTypeOneStatus.fromObject(object.changeToKeyTypeOneStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChangeToKeyTypeOneResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @static
         * @param {Authentication.ChangeToKeyTypeOneResponse} message ChangeToKeyTypeOneResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeToKeyTypeOneResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.changeToKeyTypeOneStatus = [];
            if (message.changeToKeyTypeOneStatus && message.changeToKeyTypeOneStatus.length) {
                object.changeToKeyTypeOneStatus = [];
                for (let j = 0; j < message.changeToKeyTypeOneStatus.length; ++j)
                    object.changeToKeyTypeOneStatus[j] = $root.Authentication.ChangeToKeyTypeOneStatus.toObject(message.changeToKeyTypeOneStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this ChangeToKeyTypeOneResponse to JSON.
         * @function toJSON
         * @memberof Authentication.ChangeToKeyTypeOneResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeToKeyTypeOneResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeToKeyTypeOneResponse;
    })();

    Authentication.SetKey = (function() {

        /**
         * Properties of a SetKey.
         * @memberof Authentication
         * @interface ISetKey
         * @property {number|Long|null} [id] SetKey id
         * @property {Uint8Array|null} [key] SetKey key
         */

        /**
         * Constructs a new SetKey.
         * @memberof Authentication
         * @classdesc Represents a SetKey.
         * @implements ISetKey
         * @constructor
         * @param {Authentication.ISetKey=} [properties] Properties to set
         */
        function SetKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetKey id.
         * @member {number|Long} id
         * @memberof Authentication.SetKey
         * @instance
         */
        SetKey.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetKey key.
         * @member {Uint8Array} key
         * @memberof Authentication.SetKey
         * @instance
         */
        SetKey.prototype.key = $util.newBuffer([]);

        /**
         * Creates a new SetKey instance using the specified properties.
         * @function create
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey=} [properties] Properties to set
         * @returns {Authentication.SetKey} SetKey instance
         */
        SetKey.create = function create(properties) {
            return new SetKey(properties);
        };

        /**
         * Encodes the specified SetKey message. Does not implicitly {@link Authentication.SetKey.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey} message SetKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            return writer;
        };

        /**
         * Encodes the specified SetKey message, length delimited. Does not implicitly {@link Authentication.SetKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.ISetKey} message SetKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetKey message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SetKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SetKey} SetKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SetKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SetKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SetKey} SetKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetKey message.
         * @function verify
         * @memberof Authentication.SetKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
            return null;
        };

        /**
         * Creates a SetKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SetKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SetKey} SetKey
         */
        SetKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SetKey)
                return object;
            let message = new $root.Authentication.SetKey();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.key != null)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            return message;
        };

        /**
         * Creates a plain object from a SetKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SetKey
         * @static
         * @param {Authentication.SetKey} message SetKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.key = "";
                else {
                    object.key = [];
                    if (options.bytes !== Array)
                        object.key = $util.newBuffer(object.key);
                }
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            return object;
        };

        /**
         * Converts this SetKey to JSON.
         * @function toJSON
         * @memberof Authentication.SetKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetKey;
    })();

    Authentication.SetKeyRequest = (function() {

        /**
         * Properties of a SetKeyRequest.
         * @memberof Authentication
         * @interface ISetKeyRequest
         * @property {Array.<Authentication.ISetKey>|null} [keys] SetKeyRequest keys
         */

        /**
         * Constructs a new SetKeyRequest.
         * @memberof Authentication
         * @classdesc Represents a SetKeyRequest.
         * @implements ISetKeyRequest
         * @constructor
         * @param {Authentication.ISetKeyRequest=} [properties] Properties to set
         */
        function SetKeyRequest(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetKeyRequest keys.
         * @member {Array.<Authentication.ISetKey>} keys
         * @memberof Authentication.SetKeyRequest
         * @instance
         */
        SetKeyRequest.prototype.keys = $util.emptyArray;

        /**
         * Creates a new SetKeyRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest=} [properties] Properties to set
         * @returns {Authentication.SetKeyRequest} SetKeyRequest instance
         */
        SetKeyRequest.create = function create(properties) {
            return new SetKeyRequest(properties);
        };

        /**
         * Encodes the specified SetKeyRequest message. Does not implicitly {@link Authentication.SetKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest} message SetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (let i = 0; i < message.keys.length; ++i)
                    $root.Authentication.SetKey.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetKeyRequest message, length delimited. Does not implicitly {@link Authentication.SetKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.ISetKeyRequest} message SetKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SetKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.Authentication.SetKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetKeyRequest message.
         * @function verify
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (let i = 0; i < message.keys.length; ++i) {
                    let error = $root.Authentication.SetKey.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SetKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SetKeyRequest} SetKeyRequest
         */
        SetKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SetKeyRequest)
                return object;
            let message = new $root.Authentication.SetKeyRequest();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".Authentication.SetKeyRequest.keys: array expected");
                message.keys = [];
                for (let i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".Authentication.SetKeyRequest.keys: object expected");
                    message.keys[i] = $root.Authentication.SetKey.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SetKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SetKeyRequest
         * @static
         * @param {Authentication.SetKeyRequest} message SetKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (let j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.Authentication.SetKey.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this SetKeyRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SetKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetKeyRequest;
    })();

    Authentication.CreateUserRequest = (function() {

        /**
         * Properties of a CreateUserRequest.
         * @memberof Authentication
         * @interface ICreateUserRequest
         * @property {string|null} [username] CreateUserRequest username
         * @property {Uint8Array|null} [authVerifier] CreateUserRequest authVerifier
         * @property {Uint8Array|null} [encryptionParams] CreateUserRequest encryptionParams
         * @property {Uint8Array|null} [rsaPublicKey] CreateUserRequest rsaPublicKey
         * @property {Uint8Array|null} [rsaEncryptedPrivateKey] CreateUserRequest rsaEncryptedPrivateKey
         * @property {Uint8Array|null} [eccPublicKey] CreateUserRequest eccPublicKey
         * @property {Uint8Array|null} [eccEncryptedPrivateKey] CreateUserRequest eccEncryptedPrivateKey
         * @property {Uint8Array|null} [encryptedDeviceToken] CreateUserRequest encryptedDeviceToken
         * @property {Uint8Array|null} [encryptedClientKey] CreateUserRequest encryptedClientKey
         * @property {string|null} [clientVersion] CreateUserRequest clientVersion
         * @property {Uint8Array|null} [encryptedDeviceDataKey] CreateUserRequest encryptedDeviceDataKey
         * @property {Uint8Array|null} [encryptedLoginToken] CreateUserRequest encryptedLoginToken
         * @property {Uint8Array|null} [messageSessionUid] CreateUserRequest messageSessionUid
         * @property {string|null} [installReferrer] CreateUserRequest installReferrer
         * @property {number|null} [mccMNC] CreateUserRequest mccMNC
         * @property {string|null} [mfg] CreateUserRequest mfg
         * @property {string|null} [model] CreateUserRequest model
         * @property {string|null} [brand] CreateUserRequest brand
         * @property {string|null} [product] CreateUserRequest product
         * @property {string|null} [device] CreateUserRequest device
         * @property {string|null} [carrier] CreateUserRequest carrier
         * @property {string|null} [verificationCode] CreateUserRequest verificationCode
         * @property {Enterprise.IEnterpriseRegistration|null} [enterpriseRegistration] CreateUserRequest enterpriseRegistration
         */

        /**
         * Constructs a new CreateUserRequest.
         * @memberof Authentication
         * @classdesc Represents a CreateUserRequest.
         * @implements ICreateUserRequest
         * @constructor
         * @param {Authentication.ICreateUserRequest=} [properties] Properties to set
         */
        function CreateUserRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateUserRequest username.
         * @member {string} username
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.username = "";

        /**
         * CreateUserRequest authVerifier.
         * @member {Uint8Array} authVerifier
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.authVerifier = $util.newBuffer([]);

        /**
         * CreateUserRequest encryptionParams.
         * @member {Uint8Array} encryptionParams
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.encryptionParams = $util.newBuffer([]);

        /**
         * CreateUserRequest rsaPublicKey.
         * @member {Uint8Array} rsaPublicKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.rsaPublicKey = $util.newBuffer([]);

        /**
         * CreateUserRequest rsaEncryptedPrivateKey.
         * @member {Uint8Array} rsaEncryptedPrivateKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.rsaEncryptedPrivateKey = $util.newBuffer([]);

        /**
         * CreateUserRequest eccPublicKey.
         * @member {Uint8Array} eccPublicKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.eccPublicKey = $util.newBuffer([]);

        /**
         * CreateUserRequest eccEncryptedPrivateKey.
         * @member {Uint8Array} eccEncryptedPrivateKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.eccEncryptedPrivateKey = $util.newBuffer([]);

        /**
         * CreateUserRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * CreateUserRequest encryptedClientKey.
         * @member {Uint8Array} encryptedClientKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.encryptedClientKey = $util.newBuffer([]);

        /**
         * CreateUserRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.clientVersion = "";

        /**
         * CreateUserRequest encryptedDeviceDataKey.
         * @member {Uint8Array} encryptedDeviceDataKey
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.encryptedDeviceDataKey = $util.newBuffer([]);

        /**
         * CreateUserRequest encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * CreateUserRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * CreateUserRequest installReferrer.
         * @member {string} installReferrer
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.installReferrer = "";

        /**
         * CreateUserRequest mccMNC.
         * @member {number} mccMNC
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.mccMNC = 0;

        /**
         * CreateUserRequest mfg.
         * @member {string} mfg
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.mfg = "";

        /**
         * CreateUserRequest model.
         * @member {string} model
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.model = "";

        /**
         * CreateUserRequest brand.
         * @member {string} brand
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.brand = "";

        /**
         * CreateUserRequest product.
         * @member {string} product
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.product = "";

        /**
         * CreateUserRequest device.
         * @member {string} device
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.device = "";

        /**
         * CreateUserRequest carrier.
         * @member {string} carrier
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.carrier = "";

        /**
         * CreateUserRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.verificationCode = "";

        /**
         * CreateUserRequest enterpriseRegistration.
         * @member {Enterprise.IEnterpriseRegistration|null|undefined} enterpriseRegistration
         * @memberof Authentication.CreateUserRequest
         * @instance
         */
        CreateUserRequest.prototype.enterpriseRegistration = null;

        /**
         * Creates a new CreateUserRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Authentication.ICreateUserRequest=} [properties] Properties to set
         * @returns {Authentication.CreateUserRequest} CreateUserRequest instance
         */
        CreateUserRequest.create = function create(properties) {
            return new CreateUserRequest(properties);
        };

        /**
         * Encodes the specified CreateUserRequest message. Does not implicitly {@link Authentication.CreateUserRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Authentication.ICreateUserRequest} message CreateUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateUserRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.authVerifier);
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptionParams);
            if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rsaPublicKey);
            if (message.rsaEncryptedPrivateKey != null && message.hasOwnProperty("rsaEncryptedPrivateKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.rsaEncryptedPrivateKey);
            if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.eccPublicKey);
            if (message.eccEncryptedPrivateKey != null && message.hasOwnProperty("eccEncryptedPrivateKey"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.eccEncryptedPrivateKey);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encryptedDeviceToken);
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.encryptedClientKey);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.clientVersion);
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.encryptedDeviceDataKey);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.encryptedLoginToken);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.messageSessionUid);
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.installReferrer);
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.mccMNC);
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.mfg);
            if (message.model != null && message.hasOwnProperty("model"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.model);
            if (message.brand != null && message.hasOwnProperty("brand"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.brand);
            if (message.product != null && message.hasOwnProperty("product"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.product);
            if (message.device != null && message.hasOwnProperty("device"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.device);
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.carrier);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.verificationCode);
            if (message.enterpriseRegistration != null && message.hasOwnProperty("enterpriseRegistration"))
                $root.Enterprise.EnterpriseRegistration.encode(message.enterpriseRegistration, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateUserRequest message, length delimited. Does not implicitly {@link Authentication.CreateUserRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Authentication.ICreateUserRequest} message CreateUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateUserRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.CreateUserRequest} CreateUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateUserRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.CreateUserRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.authVerifier = reader.bytes();
                    break;
                case 3:
                    message.encryptionParams = reader.bytes();
                    break;
                case 4:
                    message.rsaPublicKey = reader.bytes();
                    break;
                case 5:
                    message.rsaEncryptedPrivateKey = reader.bytes();
                    break;
                case 6:
                    message.eccPublicKey = reader.bytes();
                    break;
                case 7:
                    message.eccEncryptedPrivateKey = reader.bytes();
                    break;
                case 8:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 9:
                    message.encryptedClientKey = reader.bytes();
                    break;
                case 10:
                    message.clientVersion = reader.string();
                    break;
                case 11:
                    message.encryptedDeviceDataKey = reader.bytes();
                    break;
                case 12:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 13:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 14:
                    message.installReferrer = reader.string();
                    break;
                case 15:
                    message.mccMNC = reader.int32();
                    break;
                case 16:
                    message.mfg = reader.string();
                    break;
                case 17:
                    message.model = reader.string();
                    break;
                case 18:
                    message.brand = reader.string();
                    break;
                case 19:
                    message.product = reader.string();
                    break;
                case 20:
                    message.device = reader.string();
                    break;
                case 21:
                    message.carrier = reader.string();
                    break;
                case 22:
                    message.verificationCode = reader.string();
                    break;
                case 23:
                    message.enterpriseRegistration = $root.Enterprise.EnterpriseRegistration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateUserRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.CreateUserRequest} CreateUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateUserRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateUserRequest message.
         * @function verify
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateUserRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                if (!(message.authVerifier && typeof message.authVerifier.length === "number" || $util.isString(message.authVerifier)))
                    return "authVerifier: buffer expected";
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                if (!(message.encryptionParams && typeof message.encryptionParams.length === "number" || $util.isString(message.encryptionParams)))
                    return "encryptionParams: buffer expected";
            if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
                if (!(message.rsaPublicKey && typeof message.rsaPublicKey.length === "number" || $util.isString(message.rsaPublicKey)))
                    return "rsaPublicKey: buffer expected";
            if (message.rsaEncryptedPrivateKey != null && message.hasOwnProperty("rsaEncryptedPrivateKey"))
                if (!(message.rsaEncryptedPrivateKey && typeof message.rsaEncryptedPrivateKey.length === "number" || $util.isString(message.rsaEncryptedPrivateKey)))
                    return "rsaEncryptedPrivateKey: buffer expected";
            if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
                if (!(message.eccPublicKey && typeof message.eccPublicKey.length === "number" || $util.isString(message.eccPublicKey)))
                    return "eccPublicKey: buffer expected";
            if (message.eccEncryptedPrivateKey != null && message.hasOwnProperty("eccEncryptedPrivateKey"))
                if (!(message.eccEncryptedPrivateKey && typeof message.eccEncryptedPrivateKey.length === "number" || $util.isString(message.eccEncryptedPrivateKey)))
                    return "eccEncryptedPrivateKey: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                if (!(message.encryptedClientKey && typeof message.encryptedClientKey.length === "number" || $util.isString(message.encryptedClientKey)))
                    return "encryptedClientKey: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                if (!(message.encryptedDeviceDataKey && typeof message.encryptedDeviceDataKey.length === "number" || $util.isString(message.encryptedDeviceDataKey)))
                    return "encryptedDeviceDataKey: buffer expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                if (!$util.isString(message.installReferrer))
                    return "installReferrer: string expected";
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                if (!$util.isInteger(message.mccMNC))
                    return "mccMNC: integer expected";
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                if (!$util.isString(message.mfg))
                    return "mfg: string expected";
            if (message.model != null && message.hasOwnProperty("model"))
                if (!$util.isString(message.model))
                    return "model: string expected";
            if (message.brand != null && message.hasOwnProperty("brand"))
                if (!$util.isString(message.brand))
                    return "brand: string expected";
            if (message.product != null && message.hasOwnProperty("product"))
                if (!$util.isString(message.product))
                    return "product: string expected";
            if (message.device != null && message.hasOwnProperty("device"))
                if (!$util.isString(message.device))
                    return "device: string expected";
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                if (!$util.isString(message.carrier))
                    return "carrier: string expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.enterpriseRegistration != null && message.hasOwnProperty("enterpriseRegistration")) {
                let error = $root.Enterprise.EnterpriseRegistration.verify(message.enterpriseRegistration);
                if (error)
                    return "enterpriseRegistration." + error;
            }
            return null;
        };

        /**
         * Creates a CreateUserRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.CreateUserRequest} CreateUserRequest
         */
        CreateUserRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.CreateUserRequest)
                return object;
            let message = new $root.Authentication.CreateUserRequest();
            if (object.username != null)
                message.username = String(object.username);
            if (object.authVerifier != null)
                if (typeof object.authVerifier === "string")
                    $util.base64.decode(object.authVerifier, message.authVerifier = $util.newBuffer($util.base64.length(object.authVerifier)), 0);
                else if (object.authVerifier.length)
                    message.authVerifier = object.authVerifier;
            if (object.encryptionParams != null)
                if (typeof object.encryptionParams === "string")
                    $util.base64.decode(object.encryptionParams, message.encryptionParams = $util.newBuffer($util.base64.length(object.encryptionParams)), 0);
                else if (object.encryptionParams.length)
                    message.encryptionParams = object.encryptionParams;
            if (object.rsaPublicKey != null)
                if (typeof object.rsaPublicKey === "string")
                    $util.base64.decode(object.rsaPublicKey, message.rsaPublicKey = $util.newBuffer($util.base64.length(object.rsaPublicKey)), 0);
                else if (object.rsaPublicKey.length)
                    message.rsaPublicKey = object.rsaPublicKey;
            if (object.rsaEncryptedPrivateKey != null)
                if (typeof object.rsaEncryptedPrivateKey === "string")
                    $util.base64.decode(object.rsaEncryptedPrivateKey, message.rsaEncryptedPrivateKey = $util.newBuffer($util.base64.length(object.rsaEncryptedPrivateKey)), 0);
                else if (object.rsaEncryptedPrivateKey.length)
                    message.rsaEncryptedPrivateKey = object.rsaEncryptedPrivateKey;
            if (object.eccPublicKey != null)
                if (typeof object.eccPublicKey === "string")
                    $util.base64.decode(object.eccPublicKey, message.eccPublicKey = $util.newBuffer($util.base64.length(object.eccPublicKey)), 0);
                else if (object.eccPublicKey.length)
                    message.eccPublicKey = object.eccPublicKey;
            if (object.eccEncryptedPrivateKey != null)
                if (typeof object.eccEncryptedPrivateKey === "string")
                    $util.base64.decode(object.eccEncryptedPrivateKey, message.eccEncryptedPrivateKey = $util.newBuffer($util.base64.length(object.eccEncryptedPrivateKey)), 0);
                else if (object.eccEncryptedPrivateKey.length)
                    message.eccEncryptedPrivateKey = object.eccEncryptedPrivateKey;
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.encryptedClientKey != null)
                if (typeof object.encryptedClientKey === "string")
                    $util.base64.decode(object.encryptedClientKey, message.encryptedClientKey = $util.newBuffer($util.base64.length(object.encryptedClientKey)), 0);
                else if (object.encryptedClientKey.length)
                    message.encryptedClientKey = object.encryptedClientKey;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.encryptedDeviceDataKey != null)
                if (typeof object.encryptedDeviceDataKey === "string")
                    $util.base64.decode(object.encryptedDeviceDataKey, message.encryptedDeviceDataKey = $util.newBuffer($util.base64.length(object.encryptedDeviceDataKey)), 0);
                else if (object.encryptedDeviceDataKey.length)
                    message.encryptedDeviceDataKey = object.encryptedDeviceDataKey;
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.installReferrer != null)
                message.installReferrer = String(object.installReferrer);
            if (object.mccMNC != null)
                message.mccMNC = object.mccMNC | 0;
            if (object.mfg != null)
                message.mfg = String(object.mfg);
            if (object.model != null)
                message.model = String(object.model);
            if (object.brand != null)
                message.brand = String(object.brand);
            if (object.product != null)
                message.product = String(object.product);
            if (object.device != null)
                message.device = String(object.device);
            if (object.carrier != null)
                message.carrier = String(object.carrier);
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.enterpriseRegistration != null) {
                if (typeof object.enterpriseRegistration !== "object")
                    throw TypeError(".Authentication.CreateUserRequest.enterpriseRegistration: object expected");
                message.enterpriseRegistration = $root.Enterprise.EnterpriseRegistration.fromObject(object.enterpriseRegistration);
            }
            return message;
        };

        /**
         * Creates a plain object from a CreateUserRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.CreateUserRequest
         * @static
         * @param {Authentication.CreateUserRequest} message CreateUserRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateUserRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                if (options.bytes === String)
                    object.authVerifier = "";
                else {
                    object.authVerifier = [];
                    if (options.bytes !== Array)
                        object.authVerifier = $util.newBuffer(object.authVerifier);
                }
                if (options.bytes === String)
                    object.encryptionParams = "";
                else {
                    object.encryptionParams = [];
                    if (options.bytes !== Array)
                        object.encryptionParams = $util.newBuffer(object.encryptionParams);
                }
                if (options.bytes === String)
                    object.rsaPublicKey = "";
                else {
                    object.rsaPublicKey = [];
                    if (options.bytes !== Array)
                        object.rsaPublicKey = $util.newBuffer(object.rsaPublicKey);
                }
                if (options.bytes === String)
                    object.rsaEncryptedPrivateKey = "";
                else {
                    object.rsaEncryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.rsaEncryptedPrivateKey = $util.newBuffer(object.rsaEncryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.eccPublicKey = "";
                else {
                    object.eccPublicKey = [];
                    if (options.bytes !== Array)
                        object.eccPublicKey = $util.newBuffer(object.eccPublicKey);
                }
                if (options.bytes === String)
                    object.eccEncryptedPrivateKey = "";
                else {
                    object.eccEncryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.eccEncryptedPrivateKey = $util.newBuffer(object.eccEncryptedPrivateKey);
                }
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                if (options.bytes === String)
                    object.encryptedClientKey = "";
                else {
                    object.encryptedClientKey = [];
                    if (options.bytes !== Array)
                        object.encryptedClientKey = $util.newBuffer(object.encryptedClientKey);
                }
                object.clientVersion = "";
                if (options.bytes === String)
                    object.encryptedDeviceDataKey = "";
                else {
                    object.encryptedDeviceDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceDataKey = $util.newBuffer(object.encryptedDeviceDataKey);
                }
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.installReferrer = "";
                object.mccMNC = 0;
                object.mfg = "";
                object.model = "";
                object.brand = "";
                object.product = "";
                object.device = "";
                object.carrier = "";
                object.verificationCode = "";
                object.enterpriseRegistration = null;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.authVerifier != null && message.hasOwnProperty("authVerifier"))
                object.authVerifier = options.bytes === String ? $util.base64.encode(message.authVerifier, 0, message.authVerifier.length) : options.bytes === Array ? Array.prototype.slice.call(message.authVerifier) : message.authVerifier;
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                object.encryptionParams = options.bytes === String ? $util.base64.encode(message.encryptionParams, 0, message.encryptionParams.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptionParams) : message.encryptionParams;
            if (message.rsaPublicKey != null && message.hasOwnProperty("rsaPublicKey"))
                object.rsaPublicKey = options.bytes === String ? $util.base64.encode(message.rsaPublicKey, 0, message.rsaPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rsaPublicKey) : message.rsaPublicKey;
            if (message.rsaEncryptedPrivateKey != null && message.hasOwnProperty("rsaEncryptedPrivateKey"))
                object.rsaEncryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.rsaEncryptedPrivateKey, 0, message.rsaEncryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rsaEncryptedPrivateKey) : message.rsaEncryptedPrivateKey;
            if (message.eccPublicKey != null && message.hasOwnProperty("eccPublicKey"))
                object.eccPublicKey = options.bytes === String ? $util.base64.encode(message.eccPublicKey, 0, message.eccPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.eccPublicKey) : message.eccPublicKey;
            if (message.eccEncryptedPrivateKey != null && message.hasOwnProperty("eccEncryptedPrivateKey"))
                object.eccEncryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.eccEncryptedPrivateKey, 0, message.eccEncryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.eccEncryptedPrivateKey) : message.eccEncryptedPrivateKey;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.encryptedClientKey != null && message.hasOwnProperty("encryptedClientKey"))
                object.encryptedClientKey = options.bytes === String ? $util.base64.encode(message.encryptedClientKey, 0, message.encryptedClientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedClientKey) : message.encryptedClientKey;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                object.encryptedDeviceDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDeviceDataKey, 0, message.encryptedDeviceDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceDataKey) : message.encryptedDeviceDataKey;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.installReferrer != null && message.hasOwnProperty("installReferrer"))
                object.installReferrer = message.installReferrer;
            if (message.mccMNC != null && message.hasOwnProperty("mccMNC"))
                object.mccMNC = message.mccMNC;
            if (message.mfg != null && message.hasOwnProperty("mfg"))
                object.mfg = message.mfg;
            if (message.model != null && message.hasOwnProperty("model"))
                object.model = message.model;
            if (message.brand != null && message.hasOwnProperty("brand"))
                object.brand = message.brand;
            if (message.product != null && message.hasOwnProperty("product"))
                object.product = message.product;
            if (message.device != null && message.hasOwnProperty("device"))
                object.device = message.device;
            if (message.carrier != null && message.hasOwnProperty("carrier"))
                object.carrier = message.carrier;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.enterpriseRegistration != null && message.hasOwnProperty("enterpriseRegistration"))
                object.enterpriseRegistration = $root.Enterprise.EnterpriseRegistration.toObject(message.enterpriseRegistration, options);
            return object;
        };

        /**
         * Converts this CreateUserRequest to JSON.
         * @function toJSON
         * @memberof Authentication.CreateUserRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateUserRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateUserRequest;
    })();

    Authentication.NodeEnforcementAddOrUpdateRequest = (function() {

        /**
         * Properties of a NodeEnforcementAddOrUpdateRequest.
         * @memberof Authentication
         * @interface INodeEnforcementAddOrUpdateRequest
         * @property {number|Long|null} [nodeId] NodeEnforcementAddOrUpdateRequest nodeId
         * @property {string|null} [enforcement] NodeEnforcementAddOrUpdateRequest enforcement
         * @property {string|null} [value] NodeEnforcementAddOrUpdateRequest value
         */

        /**
         * Constructs a new NodeEnforcementAddOrUpdateRequest.
         * @memberof Authentication
         * @classdesc Represents a NodeEnforcementAddOrUpdateRequest.
         * @implements INodeEnforcementAddOrUpdateRequest
         * @constructor
         * @param {Authentication.INodeEnforcementAddOrUpdateRequest=} [properties] Properties to set
         */
        function NodeEnforcementAddOrUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeEnforcementAddOrUpdateRequest nodeId.
         * @member {number|Long} nodeId
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @instance
         */
        NodeEnforcementAddOrUpdateRequest.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeEnforcementAddOrUpdateRequest enforcement.
         * @member {string} enforcement
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @instance
         */
        NodeEnforcementAddOrUpdateRequest.prototype.enforcement = "";

        /**
         * NodeEnforcementAddOrUpdateRequest value.
         * @member {string} value
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @instance
         */
        NodeEnforcementAddOrUpdateRequest.prototype.value = "";

        /**
         * Creates a new NodeEnforcementAddOrUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Authentication.INodeEnforcementAddOrUpdateRequest=} [properties] Properties to set
         * @returns {Authentication.NodeEnforcementAddOrUpdateRequest} NodeEnforcementAddOrUpdateRequest instance
         */
        NodeEnforcementAddOrUpdateRequest.create = function create(properties) {
            return new NodeEnforcementAddOrUpdateRequest(properties);
        };

        /**
         * Encodes the specified NodeEnforcementAddOrUpdateRequest message. Does not implicitly {@link Authentication.NodeEnforcementAddOrUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Authentication.INodeEnforcementAddOrUpdateRequest} message NodeEnforcementAddOrUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEnforcementAddOrUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.nodeId);
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.enforcement);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified NodeEnforcementAddOrUpdateRequest message, length delimited. Does not implicitly {@link Authentication.NodeEnforcementAddOrUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Authentication.INodeEnforcementAddOrUpdateRequest} message NodeEnforcementAddOrUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEnforcementAddOrUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeEnforcementAddOrUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.NodeEnforcementAddOrUpdateRequest} NodeEnforcementAddOrUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEnforcementAddOrUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.NodeEnforcementAddOrUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeId = reader.int64();
                    break;
                case 2:
                    message.enforcement = reader.string();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeEnforcementAddOrUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.NodeEnforcementAddOrUpdateRequest} NodeEnforcementAddOrUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEnforcementAddOrUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeEnforcementAddOrUpdateRequest message.
         * @function verify
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeEnforcementAddOrUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                    return "nodeId: integer|Long expected";
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                if (!$util.isString(message.enforcement))
                    return "enforcement: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a NodeEnforcementAddOrUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.NodeEnforcementAddOrUpdateRequest} NodeEnforcementAddOrUpdateRequest
         */
        NodeEnforcementAddOrUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.NodeEnforcementAddOrUpdateRequest)
                return object;
            let message = new $root.Authentication.NodeEnforcementAddOrUpdateRequest();
            if (object.nodeId != null)
                if ($util.Long)
                    (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
                else if (typeof object.nodeId === "string")
                    message.nodeId = parseInt(object.nodeId, 10);
                else if (typeof object.nodeId === "number")
                    message.nodeId = object.nodeId;
                else if (typeof object.nodeId === "object")
                    message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber();
            if (object.enforcement != null)
                message.enforcement = String(object.enforcement);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a NodeEnforcementAddOrUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @static
         * @param {Authentication.NodeEnforcementAddOrUpdateRequest} message NodeEnforcementAddOrUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeEnforcementAddOrUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nodeId = options.longs === String ? "0" : 0;
                object.enforcement = "";
                object.value = "";
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (typeof message.nodeId === "number")
                    object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                else
                    object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber() : message.nodeId;
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                object.enforcement = message.enforcement;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this NodeEnforcementAddOrUpdateRequest to JSON.
         * @function toJSON
         * @memberof Authentication.NodeEnforcementAddOrUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeEnforcementAddOrUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeEnforcementAddOrUpdateRequest;
    })();

    Authentication.NodeEnforcementRemoveRequest = (function() {

        /**
         * Properties of a NodeEnforcementRemoveRequest.
         * @memberof Authentication
         * @interface INodeEnforcementRemoveRequest
         * @property {number|Long|null} [nodeId] NodeEnforcementRemoveRequest nodeId
         * @property {string|null} [enforcement] NodeEnforcementRemoveRequest enforcement
         */

        /**
         * Constructs a new NodeEnforcementRemoveRequest.
         * @memberof Authentication
         * @classdesc Represents a NodeEnforcementRemoveRequest.
         * @implements INodeEnforcementRemoveRequest
         * @constructor
         * @param {Authentication.INodeEnforcementRemoveRequest=} [properties] Properties to set
         */
        function NodeEnforcementRemoveRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeEnforcementRemoveRequest nodeId.
         * @member {number|Long} nodeId
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @instance
         */
        NodeEnforcementRemoveRequest.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeEnforcementRemoveRequest enforcement.
         * @member {string} enforcement
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @instance
         */
        NodeEnforcementRemoveRequest.prototype.enforcement = "";

        /**
         * Creates a new NodeEnforcementRemoveRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Authentication.INodeEnforcementRemoveRequest=} [properties] Properties to set
         * @returns {Authentication.NodeEnforcementRemoveRequest} NodeEnforcementRemoveRequest instance
         */
        NodeEnforcementRemoveRequest.create = function create(properties) {
            return new NodeEnforcementRemoveRequest(properties);
        };

        /**
         * Encodes the specified NodeEnforcementRemoveRequest message. Does not implicitly {@link Authentication.NodeEnforcementRemoveRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Authentication.INodeEnforcementRemoveRequest} message NodeEnforcementRemoveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEnforcementRemoveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.nodeId);
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.enforcement);
            return writer;
        };

        /**
         * Encodes the specified NodeEnforcementRemoveRequest message, length delimited. Does not implicitly {@link Authentication.NodeEnforcementRemoveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Authentication.INodeEnforcementRemoveRequest} message NodeEnforcementRemoveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeEnforcementRemoveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeEnforcementRemoveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.NodeEnforcementRemoveRequest} NodeEnforcementRemoveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEnforcementRemoveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.NodeEnforcementRemoveRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeId = reader.int64();
                    break;
                case 2:
                    message.enforcement = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeEnforcementRemoveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.NodeEnforcementRemoveRequest} NodeEnforcementRemoveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeEnforcementRemoveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeEnforcementRemoveRequest message.
         * @function verify
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeEnforcementRemoveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                    return "nodeId: integer|Long expected";
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                if (!$util.isString(message.enforcement))
                    return "enforcement: string expected";
            return null;
        };

        /**
         * Creates a NodeEnforcementRemoveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.NodeEnforcementRemoveRequest} NodeEnforcementRemoveRequest
         */
        NodeEnforcementRemoveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.NodeEnforcementRemoveRequest)
                return object;
            let message = new $root.Authentication.NodeEnforcementRemoveRequest();
            if (object.nodeId != null)
                if ($util.Long)
                    (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = false;
                else if (typeof object.nodeId === "string")
                    message.nodeId = parseInt(object.nodeId, 10);
                else if (typeof object.nodeId === "number")
                    message.nodeId = object.nodeId;
                else if (typeof object.nodeId === "object")
                    message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber();
            if (object.enforcement != null)
                message.enforcement = String(object.enforcement);
            return message;
        };

        /**
         * Creates a plain object from a NodeEnforcementRemoveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @static
         * @param {Authentication.NodeEnforcementRemoveRequest} message NodeEnforcementRemoveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeEnforcementRemoveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.nodeId = options.longs === String ? "0" : 0;
                object.enforcement = "";
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (typeof message.nodeId === "number")
                    object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                else
                    object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber() : message.nodeId;
            if (message.enforcement != null && message.hasOwnProperty("enforcement"))
                object.enforcement = message.enforcement;
            return object;
        };

        /**
         * Converts this NodeEnforcementRemoveRequest to JSON.
         * @function toJSON
         * @memberof Authentication.NodeEnforcementRemoveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeEnforcementRemoveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeEnforcementRemoveRequest;
    })();

    Authentication.UserAccounts = (function() {

        /**
         * Properties of a UserAccounts.
         * @memberof Authentication
         * @interface IUserAccounts
         * @property {Array.<Uint8Array>|null} [accountUid] UserAccounts accountUid
         */

        /**
         * Constructs a new UserAccounts.
         * @memberof Authentication
         * @classdesc Represents a UserAccounts.
         * @implements IUserAccounts
         * @constructor
         * @param {Authentication.IUserAccounts=} [properties] Properties to set
         */
        function UserAccounts(properties) {
            this.accountUid = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserAccounts accountUid.
         * @member {Array.<Uint8Array>} accountUid
         * @memberof Authentication.UserAccounts
         * @instance
         */
        UserAccounts.prototype.accountUid = $util.emptyArray;

        /**
         * Creates a new UserAccounts instance using the specified properties.
         * @function create
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Authentication.IUserAccounts=} [properties] Properties to set
         * @returns {Authentication.UserAccounts} UserAccounts instance
         */
        UserAccounts.create = function create(properties) {
            return new UserAccounts(properties);
        };

        /**
         * Encodes the specified UserAccounts message. Does not implicitly {@link Authentication.UserAccounts.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Authentication.IUserAccounts} message UserAccounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAccounts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountUid != null && message.accountUid.length)
                for (let i = 0; i < message.accountUid.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountUid[i]);
            return writer;
        };

        /**
         * Encodes the specified UserAccounts message, length delimited. Does not implicitly {@link Authentication.UserAccounts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Authentication.IUserAccounts} message UserAccounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserAccounts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserAccounts message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserAccounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserAccounts} UserAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAccounts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserAccounts();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.accountUid && message.accountUid.length))
                        message.accountUid = [];
                    message.accountUid.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserAccounts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserAccounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserAccounts} UserAccounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserAccounts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserAccounts message.
         * @function verify
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserAccounts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                if (!Array.isArray(message.accountUid))
                    return "accountUid: array expected";
                for (let i = 0; i < message.accountUid.length; ++i)
                    if (!(message.accountUid[i] && typeof message.accountUid[i].length === "number" || $util.isString(message.accountUid[i])))
                        return "accountUid: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a UserAccounts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserAccounts} UserAccounts
         */
        UserAccounts.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserAccounts)
                return object;
            let message = new $root.Authentication.UserAccounts();
            if (object.accountUid) {
                if (!Array.isArray(object.accountUid))
                    throw TypeError(".Authentication.UserAccounts.accountUid: array expected");
                message.accountUid = [];
                for (let i = 0; i < object.accountUid.length; ++i)
                    if (typeof object.accountUid[i] === "string")
                        $util.base64.decode(object.accountUid[i], message.accountUid[i] = $util.newBuffer($util.base64.length(object.accountUid[i])), 0);
                    else if (object.accountUid[i].length)
                        message.accountUid[i] = object.accountUid[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a UserAccounts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserAccounts
         * @static
         * @param {Authentication.UserAccounts} message UserAccounts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserAccounts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.accountUid = [];
            if (message.accountUid && message.accountUid.length) {
                object.accountUid = [];
                for (let j = 0; j < message.accountUid.length; ++j)
                    object.accountUid[j] = options.bytes === String ? $util.base64.encode(message.accountUid[j], 0, message.accountUid[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid[j]) : message.accountUid[j];
            }
            return object;
        };

        /**
         * Converts this UserAccounts to JSON.
         * @function toJSON
         * @memberof Authentication.UserAccounts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserAccounts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserAccounts;
    })();

    Authentication.ApiRequestByKey = (function() {

        /**
         * Properties of an ApiRequestByKey.
         * @memberof Authentication
         * @interface IApiRequestByKey
         * @property {number|null} [keyId] ApiRequestByKey keyId
         * @property {Uint8Array|null} [payload] ApiRequestByKey payload
         * @property {string|null} [username] ApiRequestByKey username
         * @property {string|null} [locale] ApiRequestByKey locale
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] ApiRequestByKey supportedLanguage
         * @property {number|null} [type] ApiRequestByKey type
         */

        /**
         * Constructs a new ApiRequestByKey.
         * @memberof Authentication
         * @classdesc Represents an ApiRequestByKey.
         * @implements IApiRequestByKey
         * @constructor
         * @param {Authentication.IApiRequestByKey=} [properties] Properties to set
         */
        function ApiRequestByKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiRequestByKey keyId.
         * @member {number} keyId
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.keyId = 0;

        /**
         * ApiRequestByKey payload.
         * @member {Uint8Array} payload
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.payload = $util.newBuffer([]);

        /**
         * ApiRequestByKey username.
         * @member {string} username
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.username = "";

        /**
         * ApiRequestByKey locale.
         * @member {string} locale
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.locale = "";

        /**
         * ApiRequestByKey supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.supportedLanguage = 0;

        /**
         * ApiRequestByKey type.
         * @member {number} type
         * @memberof Authentication.ApiRequestByKey
         * @instance
         */
        ApiRequestByKey.prototype.type = 0;

        /**
         * Creates a new ApiRequestByKey instance using the specified properties.
         * @function create
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Authentication.IApiRequestByKey=} [properties] Properties to set
         * @returns {Authentication.ApiRequestByKey} ApiRequestByKey instance
         */
        ApiRequestByKey.create = function create(properties) {
            return new ApiRequestByKey(properties);
        };

        /**
         * Encodes the specified ApiRequestByKey message. Does not implicitly {@link Authentication.ApiRequestByKey.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Authentication.IApiRequestByKey} message ApiRequestByKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestByKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.keyId);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.locale);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.supportedLanguage);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ApiRequestByKey message, length delimited. Does not implicitly {@link Authentication.ApiRequestByKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Authentication.IApiRequestByKey} message ApiRequestByKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiRequestByKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiRequestByKey message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApiRequestByKey} ApiRequestByKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestByKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApiRequestByKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyId = reader.int32();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                case 4:
                    message.locale = reader.string();
                    break;
                case 5:
                    message.supportedLanguage = reader.int32();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiRequestByKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApiRequestByKey} ApiRequestByKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiRequestByKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiRequestByKey message.
         * @function verify
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiRequestByKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                if (!$util.isInteger(message.keyId))
                    return "keyId: integer expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        /**
         * Creates an ApiRequestByKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApiRequestByKey} ApiRequestByKey
         */
        ApiRequestByKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApiRequestByKey)
                return object;
            let message = new $root.Authentication.ApiRequestByKey();
            if (object.keyId != null)
                message.keyId = object.keyId | 0;
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.username != null)
                message.username = String(object.username);
            if (object.locale != null)
                message.locale = String(object.locale);
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };

        /**
         * Creates a plain object from an ApiRequestByKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApiRequestByKey
         * @static
         * @param {Authentication.ApiRequestByKey} message ApiRequestByKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiRequestByKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.keyId = 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                object.username = "";
                object.locale = "";
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.type = 0;
            }
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                object.keyId = message.keyId;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };

        /**
         * Converts this ApiRequestByKey to JSON.
         * @function toJSON
         * @memberof Authentication.ApiRequestByKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiRequestByKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiRequestByKey;
    })();

    Authentication.MemcacheRequest = (function() {

        /**
         * Properties of a MemcacheRequest.
         * @memberof Authentication
         * @interface IMemcacheRequest
         * @property {string|null} [key] MemcacheRequest key
         * @property {number|null} [userId] MemcacheRequest userId
         */

        /**
         * Constructs a new MemcacheRequest.
         * @memberof Authentication
         * @classdesc Represents a MemcacheRequest.
         * @implements IMemcacheRequest
         * @constructor
         * @param {Authentication.IMemcacheRequest=} [properties] Properties to set
         */
        function MemcacheRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemcacheRequest key.
         * @member {string} key
         * @memberof Authentication.MemcacheRequest
         * @instance
         */
        MemcacheRequest.prototype.key = "";

        /**
         * MemcacheRequest userId.
         * @member {number} userId
         * @memberof Authentication.MemcacheRequest
         * @instance
         */
        MemcacheRequest.prototype.userId = 0;

        /**
         * Creates a new MemcacheRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Authentication.IMemcacheRequest=} [properties] Properties to set
         * @returns {Authentication.MemcacheRequest} MemcacheRequest instance
         */
        MemcacheRequest.create = function create(properties) {
            return new MemcacheRequest(properties);
        };

        /**
         * Encodes the specified MemcacheRequest message. Does not implicitly {@link Authentication.MemcacheRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Authentication.IMemcacheRequest} message MemcacheRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemcacheRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            return writer;
        };

        /**
         * Encodes the specified MemcacheRequest message, length delimited. Does not implicitly {@link Authentication.MemcacheRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Authentication.IMemcacheRequest} message MemcacheRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemcacheRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemcacheRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.MemcacheRequest} MemcacheRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemcacheRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.MemcacheRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemcacheRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.MemcacheRequest} MemcacheRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemcacheRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemcacheRequest message.
         * @function verify
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemcacheRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            return null;
        };

        /**
         * Creates a MemcacheRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.MemcacheRequest} MemcacheRequest
         */
        MemcacheRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.MemcacheRequest)
                return object;
            let message = new $root.Authentication.MemcacheRequest();
            if (object.key != null)
                message.key = String(object.key);
            if (object.userId != null)
                message.userId = object.userId | 0;
            return message;
        };

        /**
         * Creates a plain object from a MemcacheRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.MemcacheRequest
         * @static
         * @param {Authentication.MemcacheRequest} message MemcacheRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemcacheRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.userId = 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this MemcacheRequest to JSON.
         * @function toJSON
         * @memberof Authentication.MemcacheRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemcacheRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemcacheRequest;
    })();

    Authentication.MemcacheResponse = (function() {

        /**
         * Properties of a MemcacheResponse.
         * @memberof Authentication
         * @interface IMemcacheResponse
         * @property {string|null} [key] MemcacheResponse key
         * @property {string|null} [value] MemcacheResponse value
         */

        /**
         * Constructs a new MemcacheResponse.
         * @memberof Authentication
         * @classdesc Represents a MemcacheResponse.
         * @implements IMemcacheResponse
         * @constructor
         * @param {Authentication.IMemcacheResponse=} [properties] Properties to set
         */
        function MemcacheResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MemcacheResponse key.
         * @member {string} key
         * @memberof Authentication.MemcacheResponse
         * @instance
         */
        MemcacheResponse.prototype.key = "";

        /**
         * MemcacheResponse value.
         * @member {string} value
         * @memberof Authentication.MemcacheResponse
         * @instance
         */
        MemcacheResponse.prototype.value = "";

        /**
         * Creates a new MemcacheResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Authentication.IMemcacheResponse=} [properties] Properties to set
         * @returns {Authentication.MemcacheResponse} MemcacheResponse instance
         */
        MemcacheResponse.create = function create(properties) {
            return new MemcacheResponse(properties);
        };

        /**
         * Encodes the specified MemcacheResponse message. Does not implicitly {@link Authentication.MemcacheResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Authentication.IMemcacheResponse} message MemcacheResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemcacheResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified MemcacheResponse message, length delimited. Does not implicitly {@link Authentication.MemcacheResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Authentication.IMemcacheResponse} message MemcacheResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MemcacheResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MemcacheResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.MemcacheResponse} MemcacheResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemcacheResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.MemcacheResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MemcacheResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.MemcacheResponse} MemcacheResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MemcacheResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MemcacheResponse message.
         * @function verify
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MemcacheResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a MemcacheResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.MemcacheResponse} MemcacheResponse
         */
        MemcacheResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.MemcacheResponse)
                return object;
            let message = new $root.Authentication.MemcacheResponse();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a MemcacheResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.MemcacheResponse
         * @static
         * @param {Authentication.MemcacheResponse} message MemcacheResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MemcacheResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this MemcacheResponse to JSON.
         * @function toJSON
         * @memberof Authentication.MemcacheResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MemcacheResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MemcacheResponse;
    })();

    Authentication.MasterPasswordReentryRequest = (function() {

        /**
         * Properties of a MasterPasswordReentryRequest.
         * @memberof Authentication
         * @interface IMasterPasswordReentryRequest
         * @property {string|null} [pbkdf2Password] MasterPasswordReentryRequest pbkdf2Password
         * @property {Authentication.MasterPasswordReentryActionType|null} [action] MasterPasswordReentryRequest action
         */

        /**
         * Constructs a new MasterPasswordReentryRequest.
         * @memberof Authentication
         * @classdesc Represents a MasterPasswordReentryRequest.
         * @implements IMasterPasswordReentryRequest
         * @constructor
         * @param {Authentication.IMasterPasswordReentryRequest=} [properties] Properties to set
         */
        function MasterPasswordReentryRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MasterPasswordReentryRequest pbkdf2Password.
         * @member {string} pbkdf2Password
         * @memberof Authentication.MasterPasswordReentryRequest
         * @instance
         */
        MasterPasswordReentryRequest.prototype.pbkdf2Password = "";

        /**
         * MasterPasswordReentryRequest action.
         * @member {Authentication.MasterPasswordReentryActionType} action
         * @memberof Authentication.MasterPasswordReentryRequest
         * @instance
         */
        MasterPasswordReentryRequest.prototype.action = 0;

        /**
         * Creates a new MasterPasswordReentryRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Authentication.IMasterPasswordReentryRequest=} [properties] Properties to set
         * @returns {Authentication.MasterPasswordReentryRequest} MasterPasswordReentryRequest instance
         */
        MasterPasswordReentryRequest.create = function create(properties) {
            return new MasterPasswordReentryRequest(properties);
        };

        /**
         * Encodes the specified MasterPasswordReentryRequest message. Does not implicitly {@link Authentication.MasterPasswordReentryRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Authentication.IMasterPasswordReentryRequest} message MasterPasswordReentryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPasswordReentryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pbkdf2Password != null && message.hasOwnProperty("pbkdf2Password"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pbkdf2Password);
            if (message.action != null && message.hasOwnProperty("action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.action);
            return writer;
        };

        /**
         * Encodes the specified MasterPasswordReentryRequest message, length delimited. Does not implicitly {@link Authentication.MasterPasswordReentryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Authentication.IMasterPasswordReentryRequest} message MasterPasswordReentryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MasterPasswordReentryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MasterPasswordReentryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.MasterPasswordReentryRequest} MasterPasswordReentryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPasswordReentryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.MasterPasswordReentryRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pbkdf2Password = reader.string();
                    break;
                case 2:
                    message.action = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MasterPasswordReentryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.MasterPasswordReentryRequest} MasterPasswordReentryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MasterPasswordReentryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MasterPasswordReentryRequest message.
         * @function verify
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MasterPasswordReentryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pbkdf2Password != null && message.hasOwnProperty("pbkdf2Password"))
                if (!$util.isString(message.pbkdf2Password))
                    return "pbkdf2Password: string expected";
            if (message.action != null && message.hasOwnProperty("action"))
                switch (message.action) {
                default:
                    return "action: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a MasterPasswordReentryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.MasterPasswordReentryRequest} MasterPasswordReentryRequest
         */
        MasterPasswordReentryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.MasterPasswordReentryRequest)
                return object;
            let message = new $root.Authentication.MasterPasswordReentryRequest();
            if (object.pbkdf2Password != null)
                message.pbkdf2Password = String(object.pbkdf2Password);
            switch (object.action) {
            case "UNMASK":
            case 0:
                message.action = 0;
                break;
            case "COPY":
            case 1:
                message.action = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a MasterPasswordReentryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.MasterPasswordReentryRequest
         * @static
         * @param {Authentication.MasterPasswordReentryRequest} message MasterPasswordReentryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MasterPasswordReentryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pbkdf2Password = "";
                object.action = options.enums === String ? "UNMASK" : 0;
            }
            if (message.pbkdf2Password != null && message.hasOwnProperty("pbkdf2Password"))
                object.pbkdf2Password = message.pbkdf2Password;
            if (message.action != null && message.hasOwnProperty("action"))
                object.action = options.enums === String ? $root.Authentication.MasterPasswordReentryActionType[message.action] : message.action;
            return object;
        };

        /**
         * Converts this MasterPasswordReentryRequest to JSON.
         * @function toJSON
         * @memberof Authentication.MasterPasswordReentryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MasterPasswordReentryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MasterPasswordReentryRequest;
    })();

    Authentication.DeviceRegistrationRequest = (function() {

        /**
         * Properties of a DeviceRegistrationRequest.
         * @memberof Authentication
         * @interface IDeviceRegistrationRequest
         * @property {string|null} [clientVersion] DeviceRegistrationRequest clientVersion
         * @property {string|null} [deviceName] DeviceRegistrationRequest deviceName
         * @property {Uint8Array|null} [devicePublicKey] DeviceRegistrationRequest devicePublicKey
         */

        /**
         * Constructs a new DeviceRegistrationRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceRegistrationRequest.
         * @implements IDeviceRegistrationRequest
         * @constructor
         * @param {Authentication.IDeviceRegistrationRequest=} [properties] Properties to set
         */
        function DeviceRegistrationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRegistrationRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceRegistrationRequest
         * @instance
         */
        DeviceRegistrationRequest.prototype.clientVersion = "";

        /**
         * DeviceRegistrationRequest deviceName.
         * @member {string} deviceName
         * @memberof Authentication.DeviceRegistrationRequest
         * @instance
         */
        DeviceRegistrationRequest.prototype.deviceName = "";

        /**
         * DeviceRegistrationRequest devicePublicKey.
         * @member {Uint8Array} devicePublicKey
         * @memberof Authentication.DeviceRegistrationRequest
         * @instance
         */
        DeviceRegistrationRequest.prototype.devicePublicKey = $util.newBuffer([]);

        /**
         * Creates a new DeviceRegistrationRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Authentication.IDeviceRegistrationRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceRegistrationRequest} DeviceRegistrationRequest instance
         */
        DeviceRegistrationRequest.create = function create(properties) {
            return new DeviceRegistrationRequest(properties);
        };

        /**
         * Encodes the specified DeviceRegistrationRequest message. Does not implicitly {@link Authentication.DeviceRegistrationRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Authentication.IDeviceRegistrationRequest} message DeviceRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistrationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientVersion);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.devicePublicKey);
            return writer;
        };

        /**
         * Encodes the specified DeviceRegistrationRequest message, length delimited. Does not implicitly {@link Authentication.DeviceRegistrationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Authentication.IDeviceRegistrationRequest} message DeviceRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistrationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRegistrationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceRegistrationRequest} DeviceRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistrationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceRegistrationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientVersion = reader.string();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                case 3:
                    message.devicePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRegistrationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceRegistrationRequest} DeviceRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistrationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRegistrationRequest message.
         * @function verify
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRegistrationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                if (!(message.devicePublicKey && typeof message.devicePublicKey.length === "number" || $util.isString(message.devicePublicKey)))
                    return "devicePublicKey: buffer expected";
            return null;
        };

        /**
         * Creates a DeviceRegistrationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceRegistrationRequest} DeviceRegistrationRequest
         */
        DeviceRegistrationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceRegistrationRequest)
                return object;
            let message = new $root.Authentication.DeviceRegistrationRequest();
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.devicePublicKey != null)
                if (typeof object.devicePublicKey === "string")
                    $util.base64.decode(object.devicePublicKey, message.devicePublicKey = $util.newBuffer($util.base64.length(object.devicePublicKey)), 0);
                else if (object.devicePublicKey.length)
                    message.devicePublicKey = object.devicePublicKey;
            return message;
        };

        /**
         * Creates a plain object from a DeviceRegistrationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceRegistrationRequest
         * @static
         * @param {Authentication.DeviceRegistrationRequest} message DeviceRegistrationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRegistrationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.clientVersion = "";
                object.deviceName = "";
                if (options.bytes === String)
                    object.devicePublicKey = "";
                else {
                    object.devicePublicKey = [];
                    if (options.bytes !== Array)
                        object.devicePublicKey = $util.newBuffer(object.devicePublicKey);
                }
            }
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                object.devicePublicKey = options.bytes === String ? $util.base64.encode(message.devicePublicKey, 0, message.devicePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.devicePublicKey) : message.devicePublicKey;
            return object;
        };

        /**
         * Converts this DeviceRegistrationRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceRegistrationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRegistrationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRegistrationRequest;
    })();

    Authentication.DeviceVerificationRequest = (function() {

        /**
         * Properties of a DeviceVerificationRequest.
         * @memberof Authentication
         * @interface IDeviceVerificationRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceVerificationRequest encryptedDeviceToken
         * @property {string|null} [username] DeviceVerificationRequest username
         * @property {string|null} [verificationChannel] DeviceVerificationRequest verificationChannel
         * @property {Uint8Array|null} [messageSessionUid] DeviceVerificationRequest messageSessionUid
         * @property {string|null} [clientVersion] DeviceVerificationRequest clientVersion
         */

        /**
         * Constructs a new DeviceVerificationRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceVerificationRequest.
         * @implements IDeviceVerificationRequest
         * @constructor
         * @param {Authentication.IDeviceVerificationRequest=} [properties] Properties to set
         */
        function DeviceVerificationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceVerificationRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         */
        DeviceVerificationRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceVerificationRequest username.
         * @member {string} username
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         */
        DeviceVerificationRequest.prototype.username = "";

        /**
         * DeviceVerificationRequest verificationChannel.
         * @member {string} verificationChannel
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         */
        DeviceVerificationRequest.prototype.verificationChannel = "";

        /**
         * DeviceVerificationRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         */
        DeviceVerificationRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * DeviceVerificationRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         */
        DeviceVerificationRequest.prototype.clientVersion = "";

        /**
         * Creates a new DeviceVerificationRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Authentication.IDeviceVerificationRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceVerificationRequest} DeviceVerificationRequest instance
         */
        DeviceVerificationRequest.create = function create(properties) {
            return new DeviceVerificationRequest(properties);
        };

        /**
         * Encodes the specified DeviceVerificationRequest message. Does not implicitly {@link Authentication.DeviceVerificationRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Authentication.IDeviceVerificationRequest} message DeviceVerificationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.verificationChannel != null && message.hasOwnProperty("verificationChannel"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.verificationChannel);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.messageSessionUid);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.clientVersion);
            return writer;
        };

        /**
         * Encodes the specified DeviceVerificationRequest message, length delimited. Does not implicitly {@link Authentication.DeviceVerificationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Authentication.IDeviceVerificationRequest} message DeviceVerificationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceVerificationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceVerificationRequest} DeviceVerificationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceVerificationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.verificationChannel = reader.string();
                    break;
                case 4:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 5:
                    message.clientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceVerificationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceVerificationRequest} DeviceVerificationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceVerificationRequest message.
         * @function verify
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceVerificationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.verificationChannel != null && message.hasOwnProperty("verificationChannel"))
                if (!$util.isString(message.verificationChannel))
                    return "verificationChannel: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            return null;
        };

        /**
         * Creates a DeviceVerificationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceVerificationRequest} DeviceVerificationRequest
         */
        DeviceVerificationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceVerificationRequest)
                return object;
            let message = new $root.Authentication.DeviceVerificationRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.username != null)
                message.username = String(object.username);
            if (object.verificationChannel != null)
                message.verificationChannel = String(object.verificationChannel);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            return message;
        };

        /**
         * Creates a plain object from a DeviceVerificationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceVerificationRequest
         * @static
         * @param {Authentication.DeviceVerificationRequest} message DeviceVerificationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceVerificationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.username = "";
                object.verificationChannel = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.clientVersion = "";
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.verificationChannel != null && message.hasOwnProperty("verificationChannel"))
                object.verificationChannel = message.verificationChannel;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            return object;
        };

        /**
         * Converts this DeviceVerificationRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceVerificationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceVerificationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceVerificationRequest;
    })();

    Authentication.DeviceVerificationResponse = (function() {

        /**
         * Properties of a DeviceVerificationResponse.
         * @memberof Authentication
         * @interface IDeviceVerificationResponse
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceVerificationResponse encryptedDeviceToken
         * @property {string|null} [username] DeviceVerificationResponse username
         * @property {Uint8Array|null} [messageSessionUid] DeviceVerificationResponse messageSessionUid
         * @property {string|null} [clientVersion] DeviceVerificationResponse clientVersion
         * @property {Authentication.DeviceStatus|null} [deviceStatus] DeviceVerificationResponse deviceStatus
         */

        /**
         * Constructs a new DeviceVerificationResponse.
         * @memberof Authentication
         * @classdesc Represents a DeviceVerificationResponse.
         * @implements IDeviceVerificationResponse
         * @constructor
         * @param {Authentication.IDeviceVerificationResponse=} [properties] Properties to set
         */
        function DeviceVerificationResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceVerificationResponse encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         */
        DeviceVerificationResponse.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceVerificationResponse username.
         * @member {string} username
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         */
        DeviceVerificationResponse.prototype.username = "";

        /**
         * DeviceVerificationResponse messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         */
        DeviceVerificationResponse.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * DeviceVerificationResponse clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         */
        DeviceVerificationResponse.prototype.clientVersion = "";

        /**
         * DeviceVerificationResponse deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         */
        DeviceVerificationResponse.prototype.deviceStatus = 0;

        /**
         * Creates a new DeviceVerificationResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Authentication.IDeviceVerificationResponse=} [properties] Properties to set
         * @returns {Authentication.DeviceVerificationResponse} DeviceVerificationResponse instance
         */
        DeviceVerificationResponse.create = function create(properties) {
            return new DeviceVerificationResponse(properties);
        };

        /**
         * Encodes the specified DeviceVerificationResponse message. Does not implicitly {@link Authentication.DeviceVerificationResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Authentication.IDeviceVerificationResponse} message DeviceVerificationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.messageSessionUid);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientVersion);
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deviceStatus);
            return writer;
        };

        /**
         * Encodes the specified DeviceVerificationResponse message, length delimited. Does not implicitly {@link Authentication.DeviceVerificationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Authentication.IDeviceVerificationResponse} message DeviceVerificationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceVerificationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceVerificationResponse} DeviceVerificationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceVerificationResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 4:
                    message.clientVersion = reader.string();
                    break;
                case 5:
                    message.deviceStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceVerificationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceVerificationResponse} DeviceVerificationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceVerificationResponse message.
         * @function verify
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceVerificationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceVerificationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceVerificationResponse} DeviceVerificationResponse
         */
        DeviceVerificationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceVerificationResponse)
                return object;
            let message = new $root.Authentication.DeviceVerificationResponse();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.username != null)
                message.username = String(object.username);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            switch (object.deviceStatus) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.deviceStatus = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.deviceStatus = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceVerificationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceVerificationResponse
         * @static
         * @param {Authentication.DeviceVerificationResponse} message DeviceVerificationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceVerificationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.username = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.clientVersion = "";
                object.deviceStatus = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            return object;
        };

        /**
         * Converts this DeviceVerificationResponse to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceVerificationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceVerificationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceVerificationResponse;
    })();

    Authentication.DeviceApprovalRequest = (function() {

        /**
         * Properties of a DeviceApprovalRequest.
         * @memberof Authentication
         * @interface IDeviceApprovalRequest
         * @property {string|null} [email] DeviceApprovalRequest email
         * @property {string|null} [twoFactorChannel] DeviceApprovalRequest twoFactorChannel
         * @property {string|null} [clientVersion] DeviceApprovalRequest clientVersion
         * @property {string|null} [locale] DeviceApprovalRequest locale
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceApprovalRequest encryptedDeviceToken
         * @property {string|null} [totpCode] DeviceApprovalRequest totpCode
         * @property {string|null} [deviceIp] DeviceApprovalRequest deviceIp
         * @property {string|null} [deviceTokenExpireDays] DeviceApprovalRequest deviceTokenExpireDays
         */

        /**
         * Constructs a new DeviceApprovalRequest.
         * @memberof Authentication
         * @classdesc Represents a DeviceApprovalRequest.
         * @implements IDeviceApprovalRequest
         * @constructor
         * @param {Authentication.IDeviceApprovalRequest=} [properties] Properties to set
         */
        function DeviceApprovalRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalRequest email.
         * @member {string} email
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.email = "";

        /**
         * DeviceApprovalRequest twoFactorChannel.
         * @member {string} twoFactorChannel
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.twoFactorChannel = "";

        /**
         * DeviceApprovalRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.clientVersion = "";

        /**
         * DeviceApprovalRequest locale.
         * @member {string} locale
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.locale = "";

        /**
         * DeviceApprovalRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceApprovalRequest totpCode.
         * @member {string} totpCode
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.totpCode = "";

        /**
         * DeviceApprovalRequest deviceIp.
         * @member {string} deviceIp
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.deviceIp = "";

        /**
         * DeviceApprovalRequest deviceTokenExpireDays.
         * @member {string} deviceTokenExpireDays
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         */
        DeviceApprovalRequest.prototype.deviceTokenExpireDays = "";

        /**
         * Creates a new DeviceApprovalRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest=} [properties] Properties to set
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest instance
         */
        DeviceApprovalRequest.create = function create(properties) {
            return new DeviceApprovalRequest(properties);
        };

        /**
         * Encodes the specified DeviceApprovalRequest message. Does not implicitly {@link Authentication.DeviceApprovalRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest} message DeviceApprovalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.twoFactorChannel);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.locale);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedDeviceToken);
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.totpCode);
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.deviceIp);
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.deviceTokenExpireDays);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalRequest message, length delimited. Does not implicitly {@link Authentication.DeviceApprovalRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.IDeviceApprovalRequest} message DeviceApprovalRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceApprovalRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.twoFactorChannel = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.locale = reader.string();
                    break;
                case 5:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 6:
                    message.totpCode = reader.string();
                    break;
                case 7:
                    message.deviceIp = reader.string();
                    break;
                case 8:
                    message.deviceTokenExpireDays = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalRequest message.
         * @function verify
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                if (!$util.isString(message.twoFactorChannel))
                    return "twoFactorChannel: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                if (!$util.isString(message.totpCode))
                    return "totpCode: string expected";
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                if (!$util.isString(message.deviceIp))
                    return "deviceIp: string expected";
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                if (!$util.isString(message.deviceTokenExpireDays))
                    return "deviceTokenExpireDays: string expected";
            return null;
        };

        /**
         * Creates a DeviceApprovalRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceApprovalRequest} DeviceApprovalRequest
         */
        DeviceApprovalRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceApprovalRequest)
                return object;
            let message = new $root.Authentication.DeviceApprovalRequest();
            if (object.email != null)
                message.email = String(object.email);
            if (object.twoFactorChannel != null)
                message.twoFactorChannel = String(object.twoFactorChannel);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.totpCode != null)
                message.totpCode = String(object.totpCode);
            if (object.deviceIp != null)
                message.deviceIp = String(object.deviceIp);
            if (object.deviceTokenExpireDays != null)
                message.deviceTokenExpireDays = String(object.deviceTokenExpireDays);
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceApprovalRequest
         * @static
         * @param {Authentication.DeviceApprovalRequest} message DeviceApprovalRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.twoFactorChannel = "";
                object.clientVersion = "";
                object.locale = "";
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.totpCode = "";
                object.deviceIp = "";
                object.deviceTokenExpireDays = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.twoFactorChannel != null && message.hasOwnProperty("twoFactorChannel"))
                object.twoFactorChannel = message.twoFactorChannel;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.totpCode != null && message.hasOwnProperty("totpCode"))
                object.totpCode = message.totpCode;
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                object.deviceIp = message.deviceIp;
            if (message.deviceTokenExpireDays != null && message.hasOwnProperty("deviceTokenExpireDays"))
                object.deviceTokenExpireDays = message.deviceTokenExpireDays;
            return object;
        };

        /**
         * Converts this DeviceApprovalRequest to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceApprovalRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalRequest;
    })();

    Authentication.DeviceApprovalResponse = (function() {

        /**
         * Properties of a DeviceApprovalResponse.
         * @memberof Authentication
         * @interface IDeviceApprovalResponse
         * @property {Uint8Array|null} [encryptedTwoFactorToken] DeviceApprovalResponse encryptedTwoFactorToken
         */

        /**
         * Constructs a new DeviceApprovalResponse.
         * @memberof Authentication
         * @classdesc Represents a DeviceApprovalResponse.
         * @implements IDeviceApprovalResponse
         * @constructor
         * @param {Authentication.IDeviceApprovalResponse=} [properties] Properties to set
         */
        function DeviceApprovalResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalResponse encryptedTwoFactorToken.
         * @member {Uint8Array} encryptedTwoFactorToken
         * @memberof Authentication.DeviceApprovalResponse
         * @instance
         */
        DeviceApprovalResponse.prototype.encryptedTwoFactorToken = $util.newBuffer([]);

        /**
         * Creates a new DeviceApprovalResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse=} [properties] Properties to set
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse instance
         */
        DeviceApprovalResponse.create = function create(properties) {
            return new DeviceApprovalResponse(properties);
        };

        /**
         * Encodes the specified DeviceApprovalResponse message. Does not implicitly {@link Authentication.DeviceApprovalResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse} message DeviceApprovalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTwoFactorToken);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalResponse message, length delimited. Does not implicitly {@link Authentication.DeviceApprovalResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.IDeviceApprovalResponse} message DeviceApprovalResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceApprovalResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTwoFactorToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalResponse message.
         * @function verify
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                if (!(message.encryptedTwoFactorToken && typeof message.encryptedTwoFactorToken.length === "number" || $util.isString(message.encryptedTwoFactorToken)))
                    return "encryptedTwoFactorToken: buffer expected";
            return null;
        };

        /**
         * Creates a DeviceApprovalResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceApprovalResponse} DeviceApprovalResponse
         */
        DeviceApprovalResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceApprovalResponse)
                return object;
            let message = new $root.Authentication.DeviceApprovalResponse();
            if (object.encryptedTwoFactorToken != null)
                if (typeof object.encryptedTwoFactorToken === "string")
                    $util.base64.decode(object.encryptedTwoFactorToken, message.encryptedTwoFactorToken = $util.newBuffer($util.base64.length(object.encryptedTwoFactorToken)), 0);
                else if (object.encryptedTwoFactorToken.length)
                    message.encryptedTwoFactorToken = object.encryptedTwoFactorToken;
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceApprovalResponse
         * @static
         * @param {Authentication.DeviceApprovalResponse} message DeviceApprovalResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedTwoFactorToken = "";
                else {
                    object.encryptedTwoFactorToken = [];
                    if (options.bytes !== Array)
                        object.encryptedTwoFactorToken = $util.newBuffer(object.encryptedTwoFactorToken);
                }
            if (message.encryptedTwoFactorToken != null && message.hasOwnProperty("encryptedTwoFactorToken"))
                object.encryptedTwoFactorToken = options.bytes === String ? $util.base64.encode(message.encryptedTwoFactorToken, 0, message.encryptedTwoFactorToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTwoFactorToken) : message.encryptedTwoFactorToken;
            return object;
        };

        /**
         * Converts this DeviceApprovalResponse to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceApprovalResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalResponse;
    })();

    Authentication.ApproveDeviceRequest = (function() {

        /**
         * Properties of an ApproveDeviceRequest.
         * @memberof Authentication
         * @interface IApproveDeviceRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] ApproveDeviceRequest encryptedDeviceToken
         * @property {Uint8Array|null} [encryptedDeviceDataKey] ApproveDeviceRequest encryptedDeviceDataKey
         * @property {boolean|null} [denyApproval] ApproveDeviceRequest denyApproval
         * @property {boolean|null} [linkDevice] ApproveDeviceRequest linkDevice
         */

        /**
         * Constructs a new ApproveDeviceRequest.
         * @memberof Authentication
         * @classdesc Represents an ApproveDeviceRequest.
         * @implements IApproveDeviceRequest
         * @constructor
         * @param {Authentication.IApproveDeviceRequest=} [properties] Properties to set
         */
        function ApproveDeviceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveDeviceRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.ApproveDeviceRequest
         * @instance
         */
        ApproveDeviceRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * ApproveDeviceRequest encryptedDeviceDataKey.
         * @member {Uint8Array} encryptedDeviceDataKey
         * @memberof Authentication.ApproveDeviceRequest
         * @instance
         */
        ApproveDeviceRequest.prototype.encryptedDeviceDataKey = $util.newBuffer([]);

        /**
         * ApproveDeviceRequest denyApproval.
         * @member {boolean} denyApproval
         * @memberof Authentication.ApproveDeviceRequest
         * @instance
         */
        ApproveDeviceRequest.prototype.denyApproval = false;

        /**
         * ApproveDeviceRequest linkDevice.
         * @member {boolean} linkDevice
         * @memberof Authentication.ApproveDeviceRequest
         * @instance
         */
        ApproveDeviceRequest.prototype.linkDevice = false;

        /**
         * Creates a new ApproveDeviceRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Authentication.IApproveDeviceRequest=} [properties] Properties to set
         * @returns {Authentication.ApproveDeviceRequest} ApproveDeviceRequest instance
         */
        ApproveDeviceRequest.create = function create(properties) {
            return new ApproveDeviceRequest(properties);
        };

        /**
         * Encodes the specified ApproveDeviceRequest message. Does not implicitly {@link Authentication.ApproveDeviceRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Authentication.IApproveDeviceRequest} message ApproveDeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveDeviceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceDataKey);
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.denyApproval);
            if (message.linkDevice != null && message.hasOwnProperty("linkDevice"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.linkDevice);
            return writer;
        };

        /**
         * Encodes the specified ApproveDeviceRequest message, length delimited. Does not implicitly {@link Authentication.ApproveDeviceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Authentication.IApproveDeviceRequest} message ApproveDeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveDeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveDeviceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ApproveDeviceRequest} ApproveDeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveDeviceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ApproveDeviceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceDataKey = reader.bytes();
                    break;
                case 3:
                    message.denyApproval = reader.bool();
                    break;
                case 4:
                    message.linkDevice = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveDeviceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ApproveDeviceRequest} ApproveDeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveDeviceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveDeviceRequest message.
         * @function verify
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveDeviceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                if (!(message.encryptedDeviceDataKey && typeof message.encryptedDeviceDataKey.length === "number" || $util.isString(message.encryptedDeviceDataKey)))
                    return "encryptedDeviceDataKey: buffer expected";
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                if (typeof message.denyApproval !== "boolean")
                    return "denyApproval: boolean expected";
            if (message.linkDevice != null && message.hasOwnProperty("linkDevice"))
                if (typeof message.linkDevice !== "boolean")
                    return "linkDevice: boolean expected";
            return null;
        };

        /**
         * Creates an ApproveDeviceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ApproveDeviceRequest} ApproveDeviceRequest
         */
        ApproveDeviceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ApproveDeviceRequest)
                return object;
            let message = new $root.Authentication.ApproveDeviceRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.encryptedDeviceDataKey != null)
                if (typeof object.encryptedDeviceDataKey === "string")
                    $util.base64.decode(object.encryptedDeviceDataKey, message.encryptedDeviceDataKey = $util.newBuffer($util.base64.length(object.encryptedDeviceDataKey)), 0);
                else if (object.encryptedDeviceDataKey.length)
                    message.encryptedDeviceDataKey = object.encryptedDeviceDataKey;
            if (object.denyApproval != null)
                message.denyApproval = Boolean(object.denyApproval);
            if (object.linkDevice != null)
                message.linkDevice = Boolean(object.linkDevice);
            return message;
        };

        /**
         * Creates a plain object from an ApproveDeviceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ApproveDeviceRequest
         * @static
         * @param {Authentication.ApproveDeviceRequest} message ApproveDeviceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveDeviceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                if (options.bytes === String)
                    object.encryptedDeviceDataKey = "";
                else {
                    object.encryptedDeviceDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceDataKey = $util.newBuffer(object.encryptedDeviceDataKey);
                }
                object.denyApproval = false;
                object.linkDevice = false;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                object.encryptedDeviceDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDeviceDataKey, 0, message.encryptedDeviceDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceDataKey) : message.encryptedDeviceDataKey;
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                object.denyApproval = message.denyApproval;
            if (message.linkDevice != null && message.hasOwnProperty("linkDevice"))
                object.linkDevice = message.linkDevice;
            return object;
        };

        /**
         * Converts this ApproveDeviceRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ApproveDeviceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveDeviceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveDeviceRequest;
    })();

    Authentication.EnterpriseUserAliasRequest = (function() {

        /**
         * Properties of an EnterpriseUserAliasRequest.
         * @memberof Authentication
         * @interface IEnterpriseUserAliasRequest
         * @property {number|Long|null} [enterpriseUserId] EnterpriseUserAliasRequest enterpriseUserId
         * @property {string|null} [alias] EnterpriseUserAliasRequest alias
         */

        /**
         * Constructs a new EnterpriseUserAliasRequest.
         * @memberof Authentication
         * @classdesc Represents an EnterpriseUserAliasRequest.
         * @implements IEnterpriseUserAliasRequest
         * @constructor
         * @param {Authentication.IEnterpriseUserAliasRequest=} [properties] Properties to set
         */
        function EnterpriseUserAliasRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUserAliasRequest enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @instance
         */
        EnterpriseUserAliasRequest.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterpriseUserAliasRequest alias.
         * @member {string} alias
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @instance
         */
        EnterpriseUserAliasRequest.prototype.alias = "";

        /**
         * Creates a new EnterpriseUserAliasRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Authentication.IEnterpriseUserAliasRequest=} [properties] Properties to set
         * @returns {Authentication.EnterpriseUserAliasRequest} EnterpriseUserAliasRequest instance
         */
        EnterpriseUserAliasRequest.create = function create(properties) {
            return new EnterpriseUserAliasRequest(properties);
        };

        /**
         * Encodes the specified EnterpriseUserAliasRequest message. Does not implicitly {@link Authentication.EnterpriseUserAliasRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Authentication.IEnterpriseUserAliasRequest} message EnterpriseUserAliasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserAliasRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUserAliasRequest message, length delimited. Does not implicitly {@link Authentication.EnterpriseUserAliasRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Authentication.IEnterpriseUserAliasRequest} message EnterpriseUserAliasRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserAliasRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUserAliasRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.EnterpriseUserAliasRequest} EnterpriseUserAliasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserAliasRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.EnterpriseUserAliasRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.alias = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUserAliasRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.EnterpriseUserAliasRequest} EnterpriseUserAliasRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserAliasRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUserAliasRequest message.
         * @function verify
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUserAliasRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            return null;
        };

        /**
         * Creates an EnterpriseUserAliasRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.EnterpriseUserAliasRequest} EnterpriseUserAliasRequest
         */
        EnterpriseUserAliasRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.EnterpriseUserAliasRequest)
                return object;
            let message = new $root.Authentication.EnterpriseUserAliasRequest();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.alias != null)
                message.alias = String(object.alias);
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUserAliasRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @static
         * @param {Authentication.EnterpriseUserAliasRequest} message EnterpriseUserAliasRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUserAliasRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.alias = "";
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            return object;
        };

        /**
         * Converts this EnterpriseUserAliasRequest to JSON.
         * @function toJSON
         * @memberof Authentication.EnterpriseUserAliasRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUserAliasRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUserAliasRequest;
    })();

    Authentication.Device = (function() {

        /**
         * Properties of a Device.
         * @memberof Authentication
         * @interface IDevice
         * @property {Uint8Array|null} [encryptedDeviceToken] Device encryptedDeviceToken
         */

        /**
         * Constructs a new Device.
         * @memberof Authentication
         * @classdesc Represents a Device.
         * @implements IDevice
         * @constructor
         * @param {Authentication.IDevice=} [properties] Properties to set
         */
        function Device(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Device encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.Device
         * @instance
         */
        Device.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * Creates a new Device instance using the specified properties.
         * @function create
         * @memberof Authentication.Device
         * @static
         * @param {Authentication.IDevice=} [properties] Properties to set
         * @returns {Authentication.Device} Device instance
         */
        Device.create = function create(properties) {
            return new Device(properties);
        };

        /**
         * Encodes the specified Device message. Does not implicitly {@link Authentication.Device.verify|verify} messages.
         * @function encode
         * @memberof Authentication.Device
         * @static
         * @param {Authentication.IDevice} message Device message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Device.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            return writer;
        };

        /**
         * Encodes the specified Device message, length delimited. Does not implicitly {@link Authentication.Device.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.Device
         * @static
         * @param {Authentication.IDevice} message Device message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Device.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Device message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.Device
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.Device} Device
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Device.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.Device();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Device message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.Device
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.Device} Device
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Device.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Device message.
         * @function verify
         * @memberof Authentication.Device
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Device.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            return null;
        };

        /**
         * Creates a Device message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.Device
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.Device} Device
         */
        Device.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.Device)
                return object;
            let message = new $root.Authentication.Device();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            return message;
        };

        /**
         * Creates a plain object from a Device message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.Device
         * @static
         * @param {Authentication.Device} message Device
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Device.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            return object;
        };

        /**
         * Converts this Device to JSON.
         * @function toJSON
         * @memberof Authentication.Device
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Device.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Device;
    })();

    Authentication.RegisterDeviceDataKeyRequest = (function() {

        /**
         * Properties of a RegisterDeviceDataKeyRequest.
         * @memberof Authentication
         * @interface IRegisterDeviceDataKeyRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] RegisterDeviceDataKeyRequest encryptedDeviceToken
         * @property {Uint8Array|null} [encryptedDeviceDataKey] RegisterDeviceDataKeyRequest encryptedDeviceDataKey
         */

        /**
         * Constructs a new RegisterDeviceDataKeyRequest.
         * @memberof Authentication
         * @classdesc Represents a RegisterDeviceDataKeyRequest.
         * @implements IRegisterDeviceDataKeyRequest
         * @constructor
         * @param {Authentication.IRegisterDeviceDataKeyRequest=} [properties] Properties to set
         */
        function RegisterDeviceDataKeyRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterDeviceDataKeyRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @instance
         */
        RegisterDeviceDataKeyRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * RegisterDeviceDataKeyRequest encryptedDeviceDataKey.
         * @member {Uint8Array} encryptedDeviceDataKey
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @instance
         */
        RegisterDeviceDataKeyRequest.prototype.encryptedDeviceDataKey = $util.newBuffer([]);

        /**
         * Creates a new RegisterDeviceDataKeyRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Authentication.IRegisterDeviceDataKeyRequest=} [properties] Properties to set
         * @returns {Authentication.RegisterDeviceDataKeyRequest} RegisterDeviceDataKeyRequest instance
         */
        RegisterDeviceDataKeyRequest.create = function create(properties) {
            return new RegisterDeviceDataKeyRequest(properties);
        };

        /**
         * Encodes the specified RegisterDeviceDataKeyRequest message. Does not implicitly {@link Authentication.RegisterDeviceDataKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Authentication.IRegisterDeviceDataKeyRequest} message RegisterDeviceDataKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterDeviceDataKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceDataKey);
            return writer;
        };

        /**
         * Encodes the specified RegisterDeviceDataKeyRequest message, length delimited. Does not implicitly {@link Authentication.RegisterDeviceDataKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Authentication.IRegisterDeviceDataKeyRequest} message RegisterDeviceDataKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterDeviceDataKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterDeviceDataKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.RegisterDeviceDataKeyRequest} RegisterDeviceDataKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterDeviceDataKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.RegisterDeviceDataKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceDataKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterDeviceDataKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.RegisterDeviceDataKeyRequest} RegisterDeviceDataKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterDeviceDataKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterDeviceDataKeyRequest message.
         * @function verify
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterDeviceDataKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                if (!(message.encryptedDeviceDataKey && typeof message.encryptedDeviceDataKey.length === "number" || $util.isString(message.encryptedDeviceDataKey)))
                    return "encryptedDeviceDataKey: buffer expected";
            return null;
        };

        /**
         * Creates a RegisterDeviceDataKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.RegisterDeviceDataKeyRequest} RegisterDeviceDataKeyRequest
         */
        RegisterDeviceDataKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.RegisterDeviceDataKeyRequest)
                return object;
            let message = new $root.Authentication.RegisterDeviceDataKeyRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.encryptedDeviceDataKey != null)
                if (typeof object.encryptedDeviceDataKey === "string")
                    $util.base64.decode(object.encryptedDeviceDataKey, message.encryptedDeviceDataKey = $util.newBuffer($util.base64.length(object.encryptedDeviceDataKey)), 0);
                else if (object.encryptedDeviceDataKey.length)
                    message.encryptedDeviceDataKey = object.encryptedDeviceDataKey;
            return message;
        };

        /**
         * Creates a plain object from a RegisterDeviceDataKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @static
         * @param {Authentication.RegisterDeviceDataKeyRequest} message RegisterDeviceDataKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RegisterDeviceDataKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                if (options.bytes === String)
                    object.encryptedDeviceDataKey = "";
                else {
                    object.encryptedDeviceDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceDataKey = $util.newBuffer(object.encryptedDeviceDataKey);
                }
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                object.encryptedDeviceDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDeviceDataKey, 0, message.encryptedDeviceDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceDataKey) : message.encryptedDeviceDataKey;
            return object;
        };

        /**
         * Converts this RegisterDeviceDataKeyRequest to JSON.
         * @function toJSON
         * @memberof Authentication.RegisterDeviceDataKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RegisterDeviceDataKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RegisterDeviceDataKeyRequest;
    })();

    Authentication.ValidateCreateUserVerificationCodeRequest = (function() {

        /**
         * Properties of a ValidateCreateUserVerificationCodeRequest.
         * @memberof Authentication
         * @interface IValidateCreateUserVerificationCodeRequest
         * @property {string|null} [username] ValidateCreateUserVerificationCodeRequest username
         * @property {string|null} [clientVersion] ValidateCreateUserVerificationCodeRequest clientVersion
         * @property {string|null} [verificationCode] ValidateCreateUserVerificationCodeRequest verificationCode
         */

        /**
         * Constructs a new ValidateCreateUserVerificationCodeRequest.
         * @memberof Authentication
         * @classdesc Represents a ValidateCreateUserVerificationCodeRequest.
         * @implements IValidateCreateUserVerificationCodeRequest
         * @constructor
         * @param {Authentication.IValidateCreateUserVerificationCodeRequest=} [properties] Properties to set
         */
        function ValidateCreateUserVerificationCodeRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidateCreateUserVerificationCodeRequest username.
         * @member {string} username
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @instance
         */
        ValidateCreateUserVerificationCodeRequest.prototype.username = "";

        /**
         * ValidateCreateUserVerificationCodeRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @instance
         */
        ValidateCreateUserVerificationCodeRequest.prototype.clientVersion = "";

        /**
         * ValidateCreateUserVerificationCodeRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @instance
         */
        ValidateCreateUserVerificationCodeRequest.prototype.verificationCode = "";

        /**
         * Creates a new ValidateCreateUserVerificationCodeRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateCreateUserVerificationCodeRequest=} [properties] Properties to set
         * @returns {Authentication.ValidateCreateUserVerificationCodeRequest} ValidateCreateUserVerificationCodeRequest instance
         */
        ValidateCreateUserVerificationCodeRequest.create = function create(properties) {
            return new ValidateCreateUserVerificationCodeRequest(properties);
        };

        /**
         * Encodes the specified ValidateCreateUserVerificationCodeRequest message. Does not implicitly {@link Authentication.ValidateCreateUserVerificationCodeRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateCreateUserVerificationCodeRequest} message ValidateCreateUserVerificationCodeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateCreateUserVerificationCodeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.verificationCode);
            return writer;
        };

        /**
         * Encodes the specified ValidateCreateUserVerificationCodeRequest message, length delimited. Does not implicitly {@link Authentication.ValidateCreateUserVerificationCodeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateCreateUserVerificationCodeRequest} message ValidateCreateUserVerificationCodeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateCreateUserVerificationCodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidateCreateUserVerificationCodeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ValidateCreateUserVerificationCodeRequest} ValidateCreateUserVerificationCodeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateCreateUserVerificationCodeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ValidateCreateUserVerificationCodeRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.verificationCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidateCreateUserVerificationCodeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ValidateCreateUserVerificationCodeRequest} ValidateCreateUserVerificationCodeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateCreateUserVerificationCodeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidateCreateUserVerificationCodeRequest message.
         * @function verify
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidateCreateUserVerificationCodeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            return null;
        };

        /**
         * Creates a ValidateCreateUserVerificationCodeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ValidateCreateUserVerificationCodeRequest} ValidateCreateUserVerificationCodeRequest
         */
        ValidateCreateUserVerificationCodeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ValidateCreateUserVerificationCodeRequest)
                return object;
            let message = new $root.Authentication.ValidateCreateUserVerificationCodeRequest();
            if (object.username != null)
                message.username = String(object.username);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            return message;
        };

        /**
         * Creates a plain object from a ValidateCreateUserVerificationCodeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @static
         * @param {Authentication.ValidateCreateUserVerificationCodeRequest} message ValidateCreateUserVerificationCodeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidateCreateUserVerificationCodeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                object.clientVersion = "";
                object.verificationCode = "";
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            return object;
        };

        /**
         * Converts this ValidateCreateUserVerificationCodeRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ValidateCreateUserVerificationCodeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidateCreateUserVerificationCodeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidateCreateUserVerificationCodeRequest;
    })();

    Authentication.ValidateDeviceVerificationCodeRequest = (function() {

        /**
         * Properties of a ValidateDeviceVerificationCodeRequest.
         * @memberof Authentication
         * @interface IValidateDeviceVerificationCodeRequest
         * @property {string|null} [username] ValidateDeviceVerificationCodeRequest username
         * @property {string|null} [clientVersion] ValidateDeviceVerificationCodeRequest clientVersion
         * @property {string|null} [verificationCode] ValidateDeviceVerificationCodeRequest verificationCode
         * @property {Uint8Array|null} [messageSessionUid] ValidateDeviceVerificationCodeRequest messageSessionUid
         */

        /**
         * Constructs a new ValidateDeviceVerificationCodeRequest.
         * @memberof Authentication
         * @classdesc Represents a ValidateDeviceVerificationCodeRequest.
         * @implements IValidateDeviceVerificationCodeRequest
         * @constructor
         * @param {Authentication.IValidateDeviceVerificationCodeRequest=} [properties] Properties to set
         */
        function ValidateDeviceVerificationCodeRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidateDeviceVerificationCodeRequest username.
         * @member {string} username
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @instance
         */
        ValidateDeviceVerificationCodeRequest.prototype.username = "";

        /**
         * ValidateDeviceVerificationCodeRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @instance
         */
        ValidateDeviceVerificationCodeRequest.prototype.clientVersion = "";

        /**
         * ValidateDeviceVerificationCodeRequest verificationCode.
         * @member {string} verificationCode
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @instance
         */
        ValidateDeviceVerificationCodeRequest.prototype.verificationCode = "";

        /**
         * ValidateDeviceVerificationCodeRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @instance
         */
        ValidateDeviceVerificationCodeRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * Creates a new ValidateDeviceVerificationCodeRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateDeviceVerificationCodeRequest=} [properties] Properties to set
         * @returns {Authentication.ValidateDeviceVerificationCodeRequest} ValidateDeviceVerificationCodeRequest instance
         */
        ValidateDeviceVerificationCodeRequest.create = function create(properties) {
            return new ValidateDeviceVerificationCodeRequest(properties);
        };

        /**
         * Encodes the specified ValidateDeviceVerificationCodeRequest message. Does not implicitly {@link Authentication.ValidateDeviceVerificationCodeRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateDeviceVerificationCodeRequest} message ValidateDeviceVerificationCodeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateDeviceVerificationCodeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.verificationCode);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.messageSessionUid);
            return writer;
        };

        /**
         * Encodes the specified ValidateDeviceVerificationCodeRequest message, length delimited. Does not implicitly {@link Authentication.ValidateDeviceVerificationCodeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Authentication.IValidateDeviceVerificationCodeRequest} message ValidateDeviceVerificationCodeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidateDeviceVerificationCodeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidateDeviceVerificationCodeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ValidateDeviceVerificationCodeRequest} ValidateDeviceVerificationCodeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateDeviceVerificationCodeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ValidateDeviceVerificationCodeRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.verificationCode = reader.string();
                    break;
                case 4:
                    message.messageSessionUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidateDeviceVerificationCodeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ValidateDeviceVerificationCodeRequest} ValidateDeviceVerificationCodeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidateDeviceVerificationCodeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidateDeviceVerificationCodeRequest message.
         * @function verify
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidateDeviceVerificationCodeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            return null;
        };

        /**
         * Creates a ValidateDeviceVerificationCodeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ValidateDeviceVerificationCodeRequest} ValidateDeviceVerificationCodeRequest
         */
        ValidateDeviceVerificationCodeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ValidateDeviceVerificationCodeRequest)
                return object;
            let message = new $root.Authentication.ValidateDeviceVerificationCodeRequest();
            if (object.username != null)
                message.username = String(object.username);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            return message;
        };

        /**
         * Creates a plain object from a ValidateDeviceVerificationCodeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @static
         * @param {Authentication.ValidateDeviceVerificationCodeRequest} message ValidateDeviceVerificationCodeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidateDeviceVerificationCodeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                object.clientVersion = "";
                object.verificationCode = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            return object;
        };

        /**
         * Converts this ValidateDeviceVerificationCodeRequest to JSON.
         * @function toJSON
         * @memberof Authentication.ValidateDeviceVerificationCodeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidateDeviceVerificationCodeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidateDeviceVerificationCodeRequest;
    })();

    Authentication.SendSessionMessageRequest = (function() {

        /**
         * Properties of a SendSessionMessageRequest.
         * @memberof Authentication
         * @interface ISendSessionMessageRequest
         * @property {Uint8Array|null} [messageSessionUid] SendSessionMessageRequest messageSessionUid
         * @property {string|null} [command] SendSessionMessageRequest command
         * @property {string|null} [username] SendSessionMessageRequest username
         */

        /**
         * Constructs a new SendSessionMessageRequest.
         * @memberof Authentication
         * @classdesc Represents a SendSessionMessageRequest.
         * @implements ISendSessionMessageRequest
         * @constructor
         * @param {Authentication.ISendSessionMessageRequest=} [properties] Properties to set
         */
        function SendSessionMessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendSessionMessageRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Authentication.SendSessionMessageRequest
         * @instance
         */
        SendSessionMessageRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * SendSessionMessageRequest command.
         * @member {string} command
         * @memberof Authentication.SendSessionMessageRequest
         * @instance
         */
        SendSessionMessageRequest.prototype.command = "";

        /**
         * SendSessionMessageRequest username.
         * @member {string} username
         * @memberof Authentication.SendSessionMessageRequest
         * @instance
         */
        SendSessionMessageRequest.prototype.username = "";

        /**
         * Creates a new SendSessionMessageRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Authentication.ISendSessionMessageRequest=} [properties] Properties to set
         * @returns {Authentication.SendSessionMessageRequest} SendSessionMessageRequest instance
         */
        SendSessionMessageRequest.create = function create(properties) {
            return new SendSessionMessageRequest(properties);
        };

        /**
         * Encodes the specified SendSessionMessageRequest message. Does not implicitly {@link Authentication.SendSessionMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Authentication.ISendSessionMessageRequest} message SendSessionMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendSessionMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageSessionUid);
            if (message.command != null && message.hasOwnProperty("command"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.command);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified SendSessionMessageRequest message, length delimited. Does not implicitly {@link Authentication.SendSessionMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Authentication.ISendSessionMessageRequest} message SendSessionMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendSessionMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendSessionMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SendSessionMessageRequest} SendSessionMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendSessionMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SendSessionMessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 2:
                    message.command = reader.string();
                    break;
                case 3:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendSessionMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SendSessionMessageRequest} SendSessionMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendSessionMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendSessionMessageRequest message.
         * @function verify
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendSessionMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a SendSessionMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SendSessionMessageRequest} SendSessionMessageRequest
         */
        SendSessionMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SendSessionMessageRequest)
                return object;
            let message = new $root.Authentication.SendSessionMessageRequest();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.command != null)
                message.command = String(object.command);
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a SendSessionMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SendSessionMessageRequest
         * @static
         * @param {Authentication.SendSessionMessageRequest} message SendSessionMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendSessionMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.command = "";
                object.username = "";
            }
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this SendSessionMessageRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SendSessionMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendSessionMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendSessionMessageRequest;
    })();

    Authentication.GlobalUserAccount = (function() {

        /**
         * Properties of a GlobalUserAccount.
         * @memberof Authentication
         * @interface IGlobalUserAccount
         * @property {string|null} [username] GlobalUserAccount username
         * @property {Uint8Array|null} [accountUid] GlobalUserAccount accountUid
         * @property {string|null} [regionName] GlobalUserAccount regionName
         */

        /**
         * Constructs a new GlobalUserAccount.
         * @memberof Authentication
         * @classdesc Represents a GlobalUserAccount.
         * @implements IGlobalUserAccount
         * @constructor
         * @param {Authentication.IGlobalUserAccount=} [properties] Properties to set
         */
        function GlobalUserAccount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GlobalUserAccount username.
         * @member {string} username
         * @memberof Authentication.GlobalUserAccount
         * @instance
         */
        GlobalUserAccount.prototype.username = "";

        /**
         * GlobalUserAccount accountUid.
         * @member {Uint8Array} accountUid
         * @memberof Authentication.GlobalUserAccount
         * @instance
         */
        GlobalUserAccount.prototype.accountUid = $util.newBuffer([]);

        /**
         * GlobalUserAccount regionName.
         * @member {string} regionName
         * @memberof Authentication.GlobalUserAccount
         * @instance
         */
        GlobalUserAccount.prototype.regionName = "";

        /**
         * Creates a new GlobalUserAccount instance using the specified properties.
         * @function create
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Authentication.IGlobalUserAccount=} [properties] Properties to set
         * @returns {Authentication.GlobalUserAccount} GlobalUserAccount instance
         */
        GlobalUserAccount.create = function create(properties) {
            return new GlobalUserAccount(properties);
        };

        /**
         * Encodes the specified GlobalUserAccount message. Does not implicitly {@link Authentication.GlobalUserAccount.verify|verify} messages.
         * @function encode
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Authentication.IGlobalUserAccount} message GlobalUserAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalUserAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountUid);
            if (message.regionName != null && message.hasOwnProperty("regionName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.regionName);
            return writer;
        };

        /**
         * Encodes the specified GlobalUserAccount message, length delimited. Does not implicitly {@link Authentication.GlobalUserAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Authentication.IGlobalUserAccount} message GlobalUserAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GlobalUserAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GlobalUserAccount message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.GlobalUserAccount} GlobalUserAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalUserAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.GlobalUserAccount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.accountUid = reader.bytes();
                    break;
                case 3:
                    message.regionName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GlobalUserAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.GlobalUserAccount} GlobalUserAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GlobalUserAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GlobalUserAccount message.
         * @function verify
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GlobalUserAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.regionName != null && message.hasOwnProperty("regionName"))
                if (!$util.isString(message.regionName))
                    return "regionName: string expected";
            return null;
        };

        /**
         * Creates a GlobalUserAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.GlobalUserAccount} GlobalUserAccount
         */
        GlobalUserAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.GlobalUserAccount)
                return object;
            let message = new $root.Authentication.GlobalUserAccount();
            if (object.username != null)
                message.username = String(object.username);
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            if (object.regionName != null)
                message.regionName = String(object.regionName);
            return message;
        };

        /**
         * Creates a plain object from a GlobalUserAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.GlobalUserAccount
         * @static
         * @param {Authentication.GlobalUserAccount} message GlobalUserAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GlobalUserAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                object.regionName = "";
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.regionName != null && message.hasOwnProperty("regionName"))
                object.regionName = message.regionName;
            return object;
        };

        /**
         * Converts this GlobalUserAccount to JSON.
         * @function toJSON
         * @memberof Authentication.GlobalUserAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GlobalUserAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GlobalUserAccount;
    })();

    Authentication.AccountUsername = (function() {

        /**
         * Properties of an AccountUsername.
         * @memberof Authentication
         * @interface IAccountUsername
         * @property {string|null} [username] AccountUsername username
         * @property {string|null} [dateActive] AccountUsername dateActive
         */

        /**
         * Constructs a new AccountUsername.
         * @memberof Authentication
         * @classdesc Represents an AccountUsername.
         * @implements IAccountUsername
         * @constructor
         * @param {Authentication.IAccountUsername=} [properties] Properties to set
         */
        function AccountUsername(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUsername username.
         * @member {string} username
         * @memberof Authentication.AccountUsername
         * @instance
         */
        AccountUsername.prototype.username = "";

        /**
         * AccountUsername dateActive.
         * @member {string} dateActive
         * @memberof Authentication.AccountUsername
         * @instance
         */
        AccountUsername.prototype.dateActive = "";

        /**
         * Creates a new AccountUsername instance using the specified properties.
         * @function create
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Authentication.IAccountUsername=} [properties] Properties to set
         * @returns {Authentication.AccountUsername} AccountUsername instance
         */
        AccountUsername.create = function create(properties) {
            return new AccountUsername(properties);
        };

        /**
         * Encodes the specified AccountUsername message. Does not implicitly {@link Authentication.AccountUsername.verify|verify} messages.
         * @function encode
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Authentication.IAccountUsername} message AccountUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUsername.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.dateActive != null && message.hasOwnProperty("dateActive"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.dateActive);
            return writer;
        };

        /**
         * Encodes the specified AccountUsername message, length delimited. Does not implicitly {@link Authentication.AccountUsername.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Authentication.IAccountUsername} message AccountUsername message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUsername.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUsername message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.AccountUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.AccountUsername} AccountUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUsername.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.AccountUsername();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.dateActive = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUsername message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.AccountUsername
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.AccountUsername} AccountUsername
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUsername.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUsername message.
         * @function verify
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUsername.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.dateActive != null && message.hasOwnProperty("dateActive"))
                if (!$util.isString(message.dateActive))
                    return "dateActive: string expected";
            return null;
        };

        /**
         * Creates an AccountUsername message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.AccountUsername} AccountUsername
         */
        AccountUsername.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.AccountUsername)
                return object;
            let message = new $root.Authentication.AccountUsername();
            if (object.username != null)
                message.username = String(object.username);
            if (object.dateActive != null)
                message.dateActive = String(object.dateActive);
            return message;
        };

        /**
         * Creates a plain object from an AccountUsername message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.AccountUsername
         * @static
         * @param {Authentication.AccountUsername} message AccountUsername
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUsername.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                object.dateActive = "";
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.dateActive != null && message.hasOwnProperty("dateActive"))
                object.dateActive = message.dateActive;
            return object;
        };

        /**
         * Converts this AccountUsername to JSON.
         * @function toJSON
         * @memberof Authentication.AccountUsername
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUsername.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountUsername;
    })();

    Authentication.SsoServiceProviderRequest = (function() {

        /**
         * Properties of a SsoServiceProviderRequest.
         * @memberof Authentication
         * @interface ISsoServiceProviderRequest
         * @property {string|null} [name] SsoServiceProviderRequest name
         * @property {string|null} [clientVersion] SsoServiceProviderRequest clientVersion
         * @property {string|null} [locale] SsoServiceProviderRequest locale
         */

        /**
         * Constructs a new SsoServiceProviderRequest.
         * @memberof Authentication
         * @classdesc This is the input to the get_sso_service_provider command.
         * @implements ISsoServiceProviderRequest
         * @constructor
         * @param {Authentication.ISsoServiceProviderRequest=} [properties] Properties to set
         */
        function SsoServiceProviderRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoServiceProviderRequest name.
         * @member {string} name
         * @memberof Authentication.SsoServiceProviderRequest
         * @instance
         */
        SsoServiceProviderRequest.prototype.name = "";

        /**
         * SsoServiceProviderRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.SsoServiceProviderRequest
         * @instance
         */
        SsoServiceProviderRequest.prototype.clientVersion = "";

        /**
         * SsoServiceProviderRequest locale.
         * @member {string} locale
         * @memberof Authentication.SsoServiceProviderRequest
         * @instance
         */
        SsoServiceProviderRequest.prototype.locale = "";

        /**
         * Creates a new SsoServiceProviderRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Authentication.ISsoServiceProviderRequest=} [properties] Properties to set
         * @returns {Authentication.SsoServiceProviderRequest} SsoServiceProviderRequest instance
         */
        SsoServiceProviderRequest.create = function create(properties) {
            return new SsoServiceProviderRequest(properties);
        };

        /**
         * Encodes the specified SsoServiceProviderRequest message. Does not implicitly {@link Authentication.SsoServiceProviderRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Authentication.ISsoServiceProviderRequest} message SsoServiceProviderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoServiceProviderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            return writer;
        };

        /**
         * Encodes the specified SsoServiceProviderRequest message, length delimited. Does not implicitly {@link Authentication.SsoServiceProviderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Authentication.ISsoServiceProviderRequest} message SsoServiceProviderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoServiceProviderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoServiceProviderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SsoServiceProviderRequest} SsoServiceProviderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoServiceProviderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SsoServiceProviderRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoServiceProviderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SsoServiceProviderRequest} SsoServiceProviderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoServiceProviderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoServiceProviderRequest message.
         * @function verify
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoServiceProviderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            return null;
        };

        /**
         * Creates a SsoServiceProviderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SsoServiceProviderRequest} SsoServiceProviderRequest
         */
        SsoServiceProviderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SsoServiceProviderRequest)
                return object;
            let message = new $root.Authentication.SsoServiceProviderRequest();
            if (object.name != null)
                message.name = String(object.name);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.locale != null)
                message.locale = String(object.locale);
            return message;
        };

        /**
         * Creates a plain object from a SsoServiceProviderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SsoServiceProviderRequest
         * @static
         * @param {Authentication.SsoServiceProviderRequest} message SsoServiceProviderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoServiceProviderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.clientVersion = "";
                object.locale = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            return object;
        };

        /**
         * Converts this SsoServiceProviderRequest to JSON.
         * @function toJSON
         * @memberof Authentication.SsoServiceProviderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoServiceProviderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoServiceProviderRequest;
    })();

    Authentication.SsoServiceProviderResponse = (function() {

        /**
         * Properties of a SsoServiceProviderResponse.
         * @memberof Authentication
         * @interface ISsoServiceProviderResponse
         * @property {string|null} [name] SsoServiceProviderResponse name
         * @property {string|null} [spUrl] SsoServiceProviderResponse spUrl
         * @property {boolean|null} [isCloud] SsoServiceProviderResponse isCloud
         * @property {string|null} [clientVersion] SsoServiceProviderResponse clientVersion
         */

        /**
         * Constructs a new SsoServiceProviderResponse.
         * @memberof Authentication
         * @classdesc This is the response from the get_sso_service_provider command.
         * @implements ISsoServiceProviderResponse
         * @constructor
         * @param {Authentication.ISsoServiceProviderResponse=} [properties] Properties to set
         */
        function SsoServiceProviderResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoServiceProviderResponse name.
         * @member {string} name
         * @memberof Authentication.SsoServiceProviderResponse
         * @instance
         */
        SsoServiceProviderResponse.prototype.name = "";

        /**
         * SsoServiceProviderResponse spUrl.
         * @member {string} spUrl
         * @memberof Authentication.SsoServiceProviderResponse
         * @instance
         */
        SsoServiceProviderResponse.prototype.spUrl = "";

        /**
         * SsoServiceProviderResponse isCloud.
         * @member {boolean} isCloud
         * @memberof Authentication.SsoServiceProviderResponse
         * @instance
         */
        SsoServiceProviderResponse.prototype.isCloud = false;

        /**
         * SsoServiceProviderResponse clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.SsoServiceProviderResponse
         * @instance
         */
        SsoServiceProviderResponse.prototype.clientVersion = "";

        /**
         * Creates a new SsoServiceProviderResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Authentication.ISsoServiceProviderResponse=} [properties] Properties to set
         * @returns {Authentication.SsoServiceProviderResponse} SsoServiceProviderResponse instance
         */
        SsoServiceProviderResponse.create = function create(properties) {
            return new SsoServiceProviderResponse(properties);
        };

        /**
         * Encodes the specified SsoServiceProviderResponse message. Does not implicitly {@link Authentication.SsoServiceProviderResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Authentication.ISsoServiceProviderResponse} message SsoServiceProviderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoServiceProviderResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.spUrl != null && message.hasOwnProperty("spUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.spUrl);
            if (message.isCloud != null && message.hasOwnProperty("isCloud"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isCloud);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientVersion);
            return writer;
        };

        /**
         * Encodes the specified SsoServiceProviderResponse message, length delimited. Does not implicitly {@link Authentication.SsoServiceProviderResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Authentication.ISsoServiceProviderResponse} message SsoServiceProviderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoServiceProviderResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoServiceProviderResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.SsoServiceProviderResponse} SsoServiceProviderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoServiceProviderResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.SsoServiceProviderResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.spUrl = reader.string();
                    break;
                case 3:
                    message.isCloud = reader.bool();
                    break;
                case 4:
                    message.clientVersion = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoServiceProviderResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.SsoServiceProviderResponse} SsoServiceProviderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoServiceProviderResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoServiceProviderResponse message.
         * @function verify
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoServiceProviderResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.spUrl != null && message.hasOwnProperty("spUrl"))
                if (!$util.isString(message.spUrl))
                    return "spUrl: string expected";
            if (message.isCloud != null && message.hasOwnProperty("isCloud"))
                if (typeof message.isCloud !== "boolean")
                    return "isCloud: boolean expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            return null;
        };

        /**
         * Creates a SsoServiceProviderResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.SsoServiceProviderResponse} SsoServiceProviderResponse
         */
        SsoServiceProviderResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.SsoServiceProviderResponse)
                return object;
            let message = new $root.Authentication.SsoServiceProviderResponse();
            if (object.name != null)
                message.name = String(object.name);
            if (object.spUrl != null)
                message.spUrl = String(object.spUrl);
            if (object.isCloud != null)
                message.isCloud = Boolean(object.isCloud);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            return message;
        };

        /**
         * Creates a plain object from a SsoServiceProviderResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.SsoServiceProviderResponse
         * @static
         * @param {Authentication.SsoServiceProviderResponse} message SsoServiceProviderResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoServiceProviderResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.spUrl = "";
                object.isCloud = false;
                object.clientVersion = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.spUrl != null && message.hasOwnProperty("spUrl"))
                object.spUrl = message.spUrl;
            if (message.isCloud != null && message.hasOwnProperty("isCloud"))
                object.isCloud = message.isCloud;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            return object;
        };

        /**
         * Converts this SsoServiceProviderResponse to JSON.
         * @function toJSON
         * @memberof Authentication.SsoServiceProviderResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoServiceProviderResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoServiceProviderResponse;
    })();

    Authentication.UserSettingRequest = (function() {

        /**
         * Properties of a UserSettingRequest.
         * @memberof Authentication
         * @interface IUserSettingRequest
         * @property {string|null} [setting] UserSettingRequest setting
         * @property {string|null} [value] UserSettingRequest value
         */

        /**
         * Constructs a new UserSettingRequest.
         * @memberof Authentication
         * @classdesc Represents a UserSettingRequest.
         * @implements IUserSettingRequest
         * @constructor
         * @param {Authentication.IUserSettingRequest=} [properties] Properties to set
         */
        function UserSettingRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSettingRequest setting.
         * @member {string} setting
         * @memberof Authentication.UserSettingRequest
         * @instance
         */
        UserSettingRequest.prototype.setting = "";

        /**
         * UserSettingRequest value.
         * @member {string} value
         * @memberof Authentication.UserSettingRequest
         * @instance
         */
        UserSettingRequest.prototype.value = "";

        /**
         * Creates a new UserSettingRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Authentication.IUserSettingRequest=} [properties] Properties to set
         * @returns {Authentication.UserSettingRequest} UserSettingRequest instance
         */
        UserSettingRequest.create = function create(properties) {
            return new UserSettingRequest(properties);
        };

        /**
         * Encodes the specified UserSettingRequest message. Does not implicitly {@link Authentication.UserSettingRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Authentication.IUserSettingRequest} message UserSettingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSettingRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.setting != null && message.hasOwnProperty("setting"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.setting);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified UserSettingRequest message, length delimited. Does not implicitly {@link Authentication.UserSettingRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Authentication.IUserSettingRequest} message UserSettingRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSettingRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSettingRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserSettingRequest} UserSettingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSettingRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserSettingRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.setting = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSettingRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserSettingRequest} UserSettingRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSettingRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSettingRequest message.
         * @function verify
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSettingRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.setting != null && message.hasOwnProperty("setting"))
                if (!$util.isString(message.setting))
                    return "setting: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a UserSettingRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserSettingRequest} UserSettingRequest
         */
        UserSettingRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserSettingRequest)
                return object;
            let message = new $root.Authentication.UserSettingRequest();
            if (object.setting != null)
                message.setting = String(object.setting);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a UserSettingRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserSettingRequest
         * @static
         * @param {Authentication.UserSettingRequest} message UserSettingRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSettingRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.setting = "";
                object.value = "";
            }
            if (message.setting != null && message.hasOwnProperty("setting"))
                object.setting = message.setting;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this UserSettingRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UserSettingRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSettingRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSettingRequest;
    })();

    /**
     * AlternateAuthenticationType enum.
     * @name Authentication.AlternateAuthenticationType
     * @enum {string}
     * @property {number} ALTERNATE_MASTER_PASSWORD=0 ALTERNATE_MASTER_PASSWORD value
     * @property {number} BIOMETRIC=1 BIOMETRIC value
     * @property {number} ACCOUNT_RECOVER=2 ACCOUNT_RECOVER value
     */
    Authentication.AlternateAuthenticationType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ALTERNATE_MASTER_PASSWORD"] = 0;
        values[valuesById[1] = "BIOMETRIC"] = 1;
        values[valuesById[2] = "ACCOUNT_RECOVER"] = 2;
        return values;
    })();

    /**
     * ThrottleType enum.
     * @name Authentication.ThrottleType
     * @enum {string}
     * @property {number} PASSWORD_RETRY_THROTTLE=0 PASSWORD_RETRY_THROTTLE value
     * @property {number} PASSWORD_RETRY_LEGACY_THROTTLE=1 PASSWORD_RETRY_LEGACY_THROTTLE value
     * @property {number} TWO_FA_THROTTLE=2 TWO_FA_THROTTLE value
     * @property {number} TWO_FA_LEGACY_THROTTLE=3 TWO_FA_LEGACY_THROTTLE value
     * @property {number} QA_RETRY_THROTTLE=4 QA_RETRY_THROTTLE value
     * @property {number} ACCOUNT_RECOVER_THROTTLE=5 ACCOUNT_RECOVER_THROTTLE value
     * @property {number} VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE=6 VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE value
     * @property {number} VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE=7 VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE value
     */
    Authentication.ThrottleType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PASSWORD_RETRY_THROTTLE"] = 0;
        values[valuesById[1] = "PASSWORD_RETRY_LEGACY_THROTTLE"] = 1;
        values[valuesById[2] = "TWO_FA_THROTTLE"] = 2;
        values[valuesById[3] = "TWO_FA_LEGACY_THROTTLE"] = 3;
        values[valuesById[4] = "QA_RETRY_THROTTLE"] = 4;
        values[valuesById[5] = "ACCOUNT_RECOVER_THROTTLE"] = 5;
        values[valuesById[6] = "VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE"] = 6;
        values[valuesById[7] = "VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE"] = 7;
        return values;
    })();

    Authentication.ThrottleState = (function() {

        /**
         * Properties of a ThrottleState.
         * @memberof Authentication
         * @interface IThrottleState
         * @property {Authentication.ThrottleType|null} [type] ThrottleState type
         * @property {string|null} [key] ThrottleState key
         * @property {string|null} [value] ThrottleState value
         * @property {boolean|null} [state] ThrottleState state
         */

        /**
         * Constructs a new ThrottleState.
         * @memberof Authentication
         * @classdesc Represents a ThrottleState.
         * @implements IThrottleState
         * @constructor
         * @param {Authentication.IThrottleState=} [properties] Properties to set
         */
        function ThrottleState(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ThrottleState type.
         * @member {Authentication.ThrottleType} type
         * @memberof Authentication.ThrottleState
         * @instance
         */
        ThrottleState.prototype.type = 0;

        /**
         * ThrottleState key.
         * @member {string} key
         * @memberof Authentication.ThrottleState
         * @instance
         */
        ThrottleState.prototype.key = "";

        /**
         * ThrottleState value.
         * @member {string} value
         * @memberof Authentication.ThrottleState
         * @instance
         */
        ThrottleState.prototype.value = "";

        /**
         * ThrottleState state.
         * @member {boolean} state
         * @memberof Authentication.ThrottleState
         * @instance
         */
        ThrottleState.prototype.state = false;

        /**
         * Creates a new ThrottleState instance using the specified properties.
         * @function create
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Authentication.IThrottleState=} [properties] Properties to set
         * @returns {Authentication.ThrottleState} ThrottleState instance
         */
        ThrottleState.create = function create(properties) {
            return new ThrottleState(properties);
        };

        /**
         * Encodes the specified ThrottleState message. Does not implicitly {@link Authentication.ThrottleState.verify|verify} messages.
         * @function encode
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Authentication.IThrottleState} message ThrottleState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.value);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.state);
            return writer;
        };

        /**
         * Encodes the specified ThrottleState message, length delimited. Does not implicitly {@link Authentication.ThrottleState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Authentication.IThrottleState} message ThrottleState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ThrottleState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ThrottleState message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.ThrottleState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.ThrottleState} ThrottleState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.ThrottleState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.key = reader.string();
                    break;
                case 3:
                    message.value = reader.string();
                    break;
                case 4:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ThrottleState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.ThrottleState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.ThrottleState} ThrottleState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ThrottleState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ThrottleState message.
         * @function verify
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ThrottleState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };

        /**
         * Creates a ThrottleState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.ThrottleState} ThrottleState
         */
        ThrottleState.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.ThrottleState)
                return object;
            let message = new $root.Authentication.ThrottleState();
            switch (object.type) {
            case "PASSWORD_RETRY_THROTTLE":
            case 0:
                message.type = 0;
                break;
            case "PASSWORD_RETRY_LEGACY_THROTTLE":
            case 1:
                message.type = 1;
                break;
            case "TWO_FA_THROTTLE":
            case 2:
                message.type = 2;
                break;
            case "TWO_FA_LEGACY_THROTTLE":
            case 3:
                message.type = 3;
                break;
            case "QA_RETRY_THROTTLE":
            case 4:
                message.type = 4;
                break;
            case "ACCOUNT_RECOVER_THROTTLE":
            case 5:
                message.type = 5;
                break;
            case "VALIDATE_DEVICE_VERIFICATION_CODE_THROTTLE":
            case 6:
                message.type = 6;
                break;
            case "VALIDATE_CREATE_USER_VERIFICATION_CODE_THROTTLE":
            case 7:
                message.type = 7;
                break;
            }
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            if (object.state != null)
                message.state = Boolean(object.state);
            return message;
        };

        /**
         * Creates a plain object from a ThrottleState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.ThrottleState
         * @static
         * @param {Authentication.ThrottleState} message ThrottleState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ThrottleState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "PASSWORD_RETRY_THROTTLE" : 0;
                object.key = "";
                object.value = "";
                object.state = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.Authentication.ThrottleType[message.type] : message.type;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            return object;
        };

        /**
         * Converts this ThrottleState to JSON.
         * @function toJSON
         * @memberof Authentication.ThrottleState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ThrottleState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ThrottleState;
    })();

    Authentication.DeviceInformation = (function() {

        /**
         * Properties of a DeviceInformation.
         * @memberof Authentication
         * @interface IDeviceInformation
         * @property {number|Long|null} [deviceId] DeviceInformation deviceId
         * @property {string|null} [deviceName] DeviceInformation deviceName
         * @property {string|null} [clientVersion] DeviceInformation clientVersion
         * @property {number|Long|null} [lastLogin] DeviceInformation lastLogin
         * @property {Authentication.DeviceStatus|null} [deviceStatus] DeviceInformation deviceStatus
         */

        /**
         * Constructs a new DeviceInformation.
         * @memberof Authentication
         * @classdesc Represents a DeviceInformation.
         * @implements IDeviceInformation
         * @constructor
         * @param {Authentication.IDeviceInformation=} [properties] Properties to set
         */
        function DeviceInformation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceInformation deviceId.
         * @member {number|Long} deviceId
         * @memberof Authentication.DeviceInformation
         * @instance
         */
        DeviceInformation.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceInformation deviceName.
         * @member {string} deviceName
         * @memberof Authentication.DeviceInformation
         * @instance
         */
        DeviceInformation.prototype.deviceName = "";

        /**
         * DeviceInformation clientVersion.
         * @member {string} clientVersion
         * @memberof Authentication.DeviceInformation
         * @instance
         */
        DeviceInformation.prototype.clientVersion = "";

        /**
         * DeviceInformation lastLogin.
         * @member {number|Long} lastLogin
         * @memberof Authentication.DeviceInformation
         * @instance
         */
        DeviceInformation.prototype.lastLogin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceInformation deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof Authentication.DeviceInformation
         * @instance
         */
        DeviceInformation.prototype.deviceStatus = 0;

        /**
         * Creates a new DeviceInformation instance using the specified properties.
         * @function create
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Authentication.IDeviceInformation=} [properties] Properties to set
         * @returns {Authentication.DeviceInformation} DeviceInformation instance
         */
        DeviceInformation.create = function create(properties) {
            return new DeviceInformation(properties);
        };

        /**
         * Encodes the specified DeviceInformation message. Does not implicitly {@link Authentication.DeviceInformation.verify|verify} messages.
         * @function encode
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Authentication.IDeviceInformation} message DeviceInformation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInformation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastLogin);
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.deviceStatus);
            return writer;
        };

        /**
         * Encodes the specified DeviceInformation message, length delimited. Does not implicitly {@link Authentication.DeviceInformation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Authentication.IDeviceInformation} message DeviceInformation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInformation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceInformation message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.DeviceInformation} DeviceInformation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInformation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.DeviceInformation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.lastLogin = reader.int64();
                    break;
                case 5:
                    message.deviceStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceInformation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.DeviceInformation} DeviceInformation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInformation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceInformation message.
         * @function verify
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceInformation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (!$util.isInteger(message.lastLogin) && !(message.lastLogin && $util.isInteger(message.lastLogin.low) && $util.isInteger(message.lastLogin.high)))
                    return "lastLogin: integer|Long expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceInformation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.DeviceInformation} DeviceInformation
         */
        DeviceInformation.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.DeviceInformation)
                return object;
            let message = new $root.Authentication.DeviceInformation();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.lastLogin != null)
                if ($util.Long)
                    (message.lastLogin = $util.Long.fromValue(object.lastLogin)).unsigned = false;
                else if (typeof object.lastLogin === "string")
                    message.lastLogin = parseInt(object.lastLogin, 10);
                else if (typeof object.lastLogin === "number")
                    message.lastLogin = object.lastLogin;
                else if (typeof object.lastLogin === "object")
                    message.lastLogin = new $util.LongBits(object.lastLogin.low >>> 0, object.lastLogin.high >>> 0).toNumber();
            switch (object.deviceStatus) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.deviceStatus = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.deviceStatus = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceInformation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.DeviceInformation
         * @static
         * @param {Authentication.DeviceInformation} message DeviceInformation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceInformation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.deviceName = "";
                object.clientVersion = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lastLogin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastLogin = options.longs === String ? "0" : 0;
                object.deviceStatus = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.lastLogin != null && message.hasOwnProperty("lastLogin"))
                if (typeof message.lastLogin === "number")
                    object.lastLogin = options.longs === String ? String(message.lastLogin) : message.lastLogin;
                else
                    object.lastLogin = options.longs === String ? $util.Long.prototype.toString.call(message.lastLogin) : options.longs === Number ? new $util.LongBits(message.lastLogin.low >>> 0, message.lastLogin.high >>> 0).toNumber() : message.lastLogin;
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            return object;
        };

        /**
         * Converts this DeviceInformation to JSON.
         * @function toJSON
         * @memberof Authentication.DeviceInformation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceInformation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceInformation;
    })();

    Authentication.UserSetting = (function() {

        /**
         * Properties of a UserSetting.
         * @memberof Authentication
         * @interface IUserSetting
         * @property {string|null} [name] UserSetting name
         * @property {boolean|null} [value] UserSetting value
         */

        /**
         * Constructs a new UserSetting.
         * @memberof Authentication
         * @classdesc Represents a UserSetting.
         * @implements IUserSetting
         * @constructor
         * @param {Authentication.IUserSetting=} [properties] Properties to set
         */
        function UserSetting(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSetting name.
         * @member {string} name
         * @memberof Authentication.UserSetting
         * @instance
         */
        UserSetting.prototype.name = "";

        /**
         * UserSetting value.
         * @member {boolean} value
         * @memberof Authentication.UserSetting
         * @instance
         */
        UserSetting.prototype.value = false;

        /**
         * Creates a new UserSetting instance using the specified properties.
         * @function create
         * @memberof Authentication.UserSetting
         * @static
         * @param {Authentication.IUserSetting=} [properties] Properties to set
         * @returns {Authentication.UserSetting} UserSetting instance
         */
        UserSetting.create = function create(properties) {
            return new UserSetting(properties);
        };

        /**
         * Encodes the specified UserSetting message. Does not implicitly {@link Authentication.UserSetting.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserSetting
         * @static
         * @param {Authentication.IUserSetting} message UserSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetting.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
            return writer;
        };

        /**
         * Encodes the specified UserSetting message, length delimited. Does not implicitly {@link Authentication.UserSetting.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserSetting
         * @static
         * @param {Authentication.IUserSetting} message UserSetting message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSetting.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSetting message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserSetting} UserSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserSetting();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSetting message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserSetting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserSetting} UserSetting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSetting.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSetting message.
         * @function verify
         * @memberof Authentication.UserSetting
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSetting.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "boolean")
                    return "value: boolean expected";
            return null;
        };

        /**
         * Creates a UserSetting message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserSetting
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserSetting} UserSetting
         */
        UserSetting.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserSetting)
                return object;
            let message = new $root.Authentication.UserSetting();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null)
                message.value = Boolean(object.value);
            return message;
        };

        /**
         * Creates a plain object from a UserSetting message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserSetting
         * @static
         * @param {Authentication.UserSetting} message UserSetting
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSetting.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.value = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this UserSetting to JSON.
         * @function toJSON
         * @memberof Authentication.UserSetting
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSetting.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserSetting;
    })();

    Authentication.UserDataKeyRequest = (function() {

        /**
         * Properties of a UserDataKeyRequest.
         * @memberof Authentication
         * @interface IUserDataKeyRequest
         * @property {Array.<number|Long>|null} [enterpriseUserId] UserDataKeyRequest enterpriseUserId
         */

        /**
         * Constructs a new UserDataKeyRequest.
         * @memberof Authentication
         * @classdesc Represents a UserDataKeyRequest.
         * @implements IUserDataKeyRequest
         * @constructor
         * @param {Authentication.IUserDataKeyRequest=} [properties] Properties to set
         */
        function UserDataKeyRequest(properties) {
            this.enterpriseUserId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserDataKeyRequest enterpriseUserId.
         * @member {Array.<number|Long>} enterpriseUserId
         * @memberof Authentication.UserDataKeyRequest
         * @instance
         */
        UserDataKeyRequest.prototype.enterpriseUserId = $util.emptyArray;

        /**
         * Creates a new UserDataKeyRequest instance using the specified properties.
         * @function create
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Authentication.IUserDataKeyRequest=} [properties] Properties to set
         * @returns {Authentication.UserDataKeyRequest} UserDataKeyRequest instance
         */
        UserDataKeyRequest.create = function create(properties) {
            return new UserDataKeyRequest(properties);
        };

        /**
         * Encodes the specified UserDataKeyRequest message. Does not implicitly {@link Authentication.UserDataKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Authentication.IUserDataKeyRequest} message UserDataKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.enterpriseUserId.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.enterpriseUserId.length; ++i)
                    writer.int64(message.enterpriseUserId[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified UserDataKeyRequest message, length delimited. Does not implicitly {@link Authentication.UserDataKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Authentication.IUserDataKeyRequest} message UserDataKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserDataKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserDataKeyRequest} UserDataKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserDataKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.enterpriseUserId && message.enterpriseUserId.length))
                        message.enterpriseUserId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enterpriseUserId.push(reader.int64());
                    } else
                        message.enterpriseUserId.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserDataKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserDataKeyRequest} UserDataKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserDataKeyRequest message.
         * @function verify
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserDataKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId")) {
                if (!Array.isArray(message.enterpriseUserId))
                    return "enterpriseUserId: array expected";
                for (let i = 0; i < message.enterpriseUserId.length; ++i)
                    if (!$util.isInteger(message.enterpriseUserId[i]) && !(message.enterpriseUserId[i] && $util.isInteger(message.enterpriseUserId[i].low) && $util.isInteger(message.enterpriseUserId[i].high)))
                        return "enterpriseUserId: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a UserDataKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserDataKeyRequest} UserDataKeyRequest
         */
        UserDataKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserDataKeyRequest)
                return object;
            let message = new $root.Authentication.UserDataKeyRequest();
            if (object.enterpriseUserId) {
                if (!Array.isArray(object.enterpriseUserId))
                    throw TypeError(".Authentication.UserDataKeyRequest.enterpriseUserId: array expected");
                message.enterpriseUserId = [];
                for (let i = 0; i < object.enterpriseUserId.length; ++i)
                    if ($util.Long)
                        (message.enterpriseUserId[i] = $util.Long.fromValue(object.enterpriseUserId[i])).unsigned = false;
                    else if (typeof object.enterpriseUserId[i] === "string")
                        message.enterpriseUserId[i] = parseInt(object.enterpriseUserId[i], 10);
                    else if (typeof object.enterpriseUserId[i] === "number")
                        message.enterpriseUserId[i] = object.enterpriseUserId[i];
                    else if (typeof object.enterpriseUserId[i] === "object")
                        message.enterpriseUserId[i] = new $util.LongBits(object.enterpriseUserId[i].low >>> 0, object.enterpriseUserId[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a UserDataKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserDataKeyRequest
         * @static
         * @param {Authentication.UserDataKeyRequest} message UserDataKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserDataKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.enterpriseUserId = [];
            if (message.enterpriseUserId && message.enterpriseUserId.length) {
                object.enterpriseUserId = [];
                for (let j = 0; j < message.enterpriseUserId.length; ++j)
                    if (typeof message.enterpriseUserId[j] === "number")
                        object.enterpriseUserId[j] = options.longs === String ? String(message.enterpriseUserId[j]) : message.enterpriseUserId[j];
                    else
                        object.enterpriseUserId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId[j]) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId[j].low >>> 0, message.enterpriseUserId[j].high >>> 0).toNumber() : message.enterpriseUserId[j];
            }
            return object;
        };

        /**
         * Converts this UserDataKeyRequest to JSON.
         * @function toJSON
         * @memberof Authentication.UserDataKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserDataKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserDataKeyRequest;
    })();

    Authentication.EnterpriseUserIdDataKeyPair = (function() {

        /**
         * Properties of an EnterpriseUserIdDataKeyPair.
         * @memberof Authentication
         * @interface IEnterpriseUserIdDataKeyPair
         * @property {number|Long|null} [enterpriseUserId] EnterpriseUserIdDataKeyPair enterpriseUserId
         * @property {Uint8Array|null} [encryptedDataKey] EnterpriseUserIdDataKeyPair encryptedDataKey
         */

        /**
         * Constructs a new EnterpriseUserIdDataKeyPair.
         * @memberof Authentication
         * @classdesc Represents an EnterpriseUserIdDataKeyPair.
         * @implements IEnterpriseUserIdDataKeyPair
         * @constructor
         * @param {Authentication.IEnterpriseUserIdDataKeyPair=} [properties] Properties to set
         */
        function EnterpriseUserIdDataKeyPair(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUserIdDataKeyPair enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @instance
         */
        EnterpriseUserIdDataKeyPair.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterpriseUserIdDataKeyPair encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @instance
         */
        EnterpriseUserIdDataKeyPair.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * Creates a new EnterpriseUserIdDataKeyPair instance using the specified properties.
         * @function create
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Authentication.IEnterpriseUserIdDataKeyPair=} [properties] Properties to set
         * @returns {Authentication.EnterpriseUserIdDataKeyPair} EnterpriseUserIdDataKeyPair instance
         */
        EnterpriseUserIdDataKeyPair.create = function create(properties) {
            return new EnterpriseUserIdDataKeyPair(properties);
        };

        /**
         * Encodes the specified EnterpriseUserIdDataKeyPair message. Does not implicitly {@link Authentication.EnterpriseUserIdDataKeyPair.verify|verify} messages.
         * @function encode
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Authentication.IEnterpriseUserIdDataKeyPair} message EnterpriseUserIdDataKeyPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserIdDataKeyPair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDataKey);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUserIdDataKeyPair message, length delimited. Does not implicitly {@link Authentication.EnterpriseUserIdDataKeyPair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Authentication.IEnterpriseUserIdDataKeyPair} message EnterpriseUserIdDataKeyPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserIdDataKeyPair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUserIdDataKeyPair message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.EnterpriseUserIdDataKeyPair} EnterpriseUserIdDataKeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserIdDataKeyPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.EnterpriseUserIdDataKeyPair();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.encryptedDataKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUserIdDataKeyPair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.EnterpriseUserIdDataKeyPair} EnterpriseUserIdDataKeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserIdDataKeyPair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUserIdDataKeyPair message.
         * @function verify
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUserIdDataKeyPair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            return null;
        };

        /**
         * Creates an EnterpriseUserIdDataKeyPair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.EnterpriseUserIdDataKeyPair} EnterpriseUserIdDataKeyPair
         */
        EnterpriseUserIdDataKeyPair.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.EnterpriseUserIdDataKeyPair)
                return object;
            let message = new $root.Authentication.EnterpriseUserIdDataKeyPair();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUserIdDataKeyPair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @static
         * @param {Authentication.EnterpriseUserIdDataKeyPair} message EnterpriseUserIdDataKeyPair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUserIdDataKeyPair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            return object;
        };

        /**
         * Converts this EnterpriseUserIdDataKeyPair to JSON.
         * @function toJSON
         * @memberof Authentication.EnterpriseUserIdDataKeyPair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUserIdDataKeyPair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUserIdDataKeyPair;
    })();

    Authentication.UserDataKey = (function() {

        /**
         * Properties of a UserDataKey.
         * @memberof Authentication
         * @interface IUserDataKey
         * @property {number|Long|null} [roleId] UserDataKey roleId
         * @property {Uint8Array|null} [roleKey] UserDataKey roleKey
         * @property {string|null} [privateKey] UserDataKey privateKey
         * @property {Array.<Authentication.IEnterpriseUserIdDataKeyPair>|null} [enterpriseUserIdDataKeyPairs] UserDataKey enterpriseUserIdDataKeyPairs
         */

        /**
         * Constructs a new UserDataKey.
         * @memberof Authentication
         * @classdesc Represents a UserDataKey.
         * @implements IUserDataKey
         * @constructor
         * @param {Authentication.IUserDataKey=} [properties] Properties to set
         */
        function UserDataKey(properties) {
            this.enterpriseUserIdDataKeyPairs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserDataKey roleId.
         * @member {number|Long} roleId
         * @memberof Authentication.UserDataKey
         * @instance
         */
        UserDataKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserDataKey roleKey.
         * @member {Uint8Array} roleKey
         * @memberof Authentication.UserDataKey
         * @instance
         */
        UserDataKey.prototype.roleKey = $util.newBuffer([]);

        /**
         * UserDataKey privateKey.
         * @member {string} privateKey
         * @memberof Authentication.UserDataKey
         * @instance
         */
        UserDataKey.prototype.privateKey = "";

        /**
         * UserDataKey enterpriseUserIdDataKeyPairs.
         * @member {Array.<Authentication.IEnterpriseUserIdDataKeyPair>} enterpriseUserIdDataKeyPairs
         * @memberof Authentication.UserDataKey
         * @instance
         */
        UserDataKey.prototype.enterpriseUserIdDataKeyPairs = $util.emptyArray;

        /**
         * Creates a new UserDataKey instance using the specified properties.
         * @function create
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Authentication.IUserDataKey=} [properties] Properties to set
         * @returns {Authentication.UserDataKey} UserDataKey instance
         */
        UserDataKey.create = function create(properties) {
            return new UserDataKey(properties);
        };

        /**
         * Encodes the specified UserDataKey message. Does not implicitly {@link Authentication.UserDataKey.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Authentication.IUserDataKey} message UserDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.roleKey != null && message.hasOwnProperty("roleKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.roleKey);
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.privateKey);
            if (message.enterpriseUserIdDataKeyPairs != null && message.enterpriseUserIdDataKeyPairs.length)
                for (let i = 0; i < message.enterpriseUserIdDataKeyPairs.length; ++i)
                    $root.Authentication.EnterpriseUserIdDataKeyPair.encode(message.enterpriseUserIdDataKeyPairs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UserDataKey message, length delimited. Does not implicitly {@link Authentication.UserDataKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Authentication.IUserDataKey} message UserDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserDataKey message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserDataKey} UserDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserDataKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.roleKey = reader.bytes();
                    break;
                case 3:
                    message.privateKey = reader.string();
                    break;
                case 4:
                    if (!(message.enterpriseUserIdDataKeyPairs && message.enterpriseUserIdDataKeyPairs.length))
                        message.enterpriseUserIdDataKeyPairs = [];
                    message.enterpriseUserIdDataKeyPairs.push($root.Authentication.EnterpriseUserIdDataKeyPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserDataKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserDataKey} UserDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserDataKey message.
         * @function verify
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserDataKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.roleKey != null && message.hasOwnProperty("roleKey"))
                if (!(message.roleKey && typeof message.roleKey.length === "number" || $util.isString(message.roleKey)))
                    return "roleKey: buffer expected";
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!$util.isString(message.privateKey))
                    return "privateKey: string expected";
            if (message.enterpriseUserIdDataKeyPairs != null && message.hasOwnProperty("enterpriseUserIdDataKeyPairs")) {
                if (!Array.isArray(message.enterpriseUserIdDataKeyPairs))
                    return "enterpriseUserIdDataKeyPairs: array expected";
                for (let i = 0; i < message.enterpriseUserIdDataKeyPairs.length; ++i) {
                    let error = $root.Authentication.EnterpriseUserIdDataKeyPair.verify(message.enterpriseUserIdDataKeyPairs[i]);
                    if (error)
                        return "enterpriseUserIdDataKeyPairs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a UserDataKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserDataKey} UserDataKey
         */
        UserDataKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserDataKey)
                return object;
            let message = new $root.Authentication.UserDataKey();
            if (object.roleId != null)
                if ($util.Long)
                    (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
                else if (typeof object.roleId === "string")
                    message.roleId = parseInt(object.roleId, 10);
                else if (typeof object.roleId === "number")
                    message.roleId = object.roleId;
                else if (typeof object.roleId === "object")
                    message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber();
            if (object.roleKey != null)
                if (typeof object.roleKey === "string")
                    $util.base64.decode(object.roleKey, message.roleKey = $util.newBuffer($util.base64.length(object.roleKey)), 0);
                else if (object.roleKey.length)
                    message.roleKey = object.roleKey;
            if (object.privateKey != null)
                message.privateKey = String(object.privateKey);
            if (object.enterpriseUserIdDataKeyPairs) {
                if (!Array.isArray(object.enterpriseUserIdDataKeyPairs))
                    throw TypeError(".Authentication.UserDataKey.enterpriseUserIdDataKeyPairs: array expected");
                message.enterpriseUserIdDataKeyPairs = [];
                for (let i = 0; i < object.enterpriseUserIdDataKeyPairs.length; ++i) {
                    if (typeof object.enterpriseUserIdDataKeyPairs[i] !== "object")
                        throw TypeError(".Authentication.UserDataKey.enterpriseUserIdDataKeyPairs: object expected");
                    message.enterpriseUserIdDataKeyPairs[i] = $root.Authentication.EnterpriseUserIdDataKeyPair.fromObject(object.enterpriseUserIdDataKeyPairs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a UserDataKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserDataKey
         * @static
         * @param {Authentication.UserDataKey} message UserDataKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserDataKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.enterpriseUserIdDataKeyPairs = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roleId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.roleKey = "";
                else {
                    object.roleKey = [];
                    if (options.bytes !== Array)
                        object.roleKey = $util.newBuffer(object.roleKey);
                }
                object.privateKey = "";
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (typeof message.roleId === "number")
                    object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                else
                    object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber() : message.roleId;
            if (message.roleKey != null && message.hasOwnProperty("roleKey"))
                object.roleKey = options.bytes === String ? $util.base64.encode(message.roleKey, 0, message.roleKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.roleKey) : message.roleKey;
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = message.privateKey;
            if (message.enterpriseUserIdDataKeyPairs && message.enterpriseUserIdDataKeyPairs.length) {
                object.enterpriseUserIdDataKeyPairs = [];
                for (let j = 0; j < message.enterpriseUserIdDataKeyPairs.length; ++j)
                    object.enterpriseUserIdDataKeyPairs[j] = $root.Authentication.EnterpriseUserIdDataKeyPair.toObject(message.enterpriseUserIdDataKeyPairs[j], options);
            }
            return object;
        };

        /**
         * Converts this UserDataKey to JSON.
         * @function toJSON
         * @memberof Authentication.UserDataKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserDataKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserDataKey;
    })();

    Authentication.UserDataKeyResponse = (function() {

        /**
         * Properties of a UserDataKeyResponse.
         * @memberof Authentication
         * @interface IUserDataKeyResponse
         * @property {Array.<Authentication.IUserDataKey>|null} [userDataKeys] UserDataKeyResponse userDataKeys
         * @property {Array.<number|Long>|null} [accessDenied] UserDataKeyResponse accessDenied
         * @property {Array.<number|Long>|null} [noEncryptedDataKey] UserDataKeyResponse noEncryptedDataKey
         */

        /**
         * Constructs a new UserDataKeyResponse.
         * @memberof Authentication
         * @classdesc Represents a UserDataKeyResponse.
         * @implements IUserDataKeyResponse
         * @constructor
         * @param {Authentication.IUserDataKeyResponse=} [properties] Properties to set
         */
        function UserDataKeyResponse(properties) {
            this.userDataKeys = [];
            this.accessDenied = [];
            this.noEncryptedDataKey = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserDataKeyResponse userDataKeys.
         * @member {Array.<Authentication.IUserDataKey>} userDataKeys
         * @memberof Authentication.UserDataKeyResponse
         * @instance
         */
        UserDataKeyResponse.prototype.userDataKeys = $util.emptyArray;

        /**
         * UserDataKeyResponse accessDenied.
         * @member {Array.<number|Long>} accessDenied
         * @memberof Authentication.UserDataKeyResponse
         * @instance
         */
        UserDataKeyResponse.prototype.accessDenied = $util.emptyArray;

        /**
         * UserDataKeyResponse noEncryptedDataKey.
         * @member {Array.<number|Long>} noEncryptedDataKey
         * @memberof Authentication.UserDataKeyResponse
         * @instance
         */
        UserDataKeyResponse.prototype.noEncryptedDataKey = $util.emptyArray;

        /**
         * Creates a new UserDataKeyResponse instance using the specified properties.
         * @function create
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Authentication.IUserDataKeyResponse=} [properties] Properties to set
         * @returns {Authentication.UserDataKeyResponse} UserDataKeyResponse instance
         */
        UserDataKeyResponse.create = function create(properties) {
            return new UserDataKeyResponse(properties);
        };

        /**
         * Encodes the specified UserDataKeyResponse message. Does not implicitly {@link Authentication.UserDataKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Authentication.IUserDataKeyResponse} message UserDataKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userDataKeys != null && message.userDataKeys.length)
                for (let i = 0; i < message.userDataKeys.length; ++i)
                    $root.Authentication.UserDataKey.encode(message.userDataKeys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.accessDenied != null && message.accessDenied.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.accessDenied.length; ++i)
                    writer.int64(message.accessDenied[i]);
                writer.ldelim();
            }
            if (message.noEncryptedDataKey != null && message.noEncryptedDataKey.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.noEncryptedDataKey.length; ++i)
                    writer.int64(message.noEncryptedDataKey[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified UserDataKeyResponse message, length delimited. Does not implicitly {@link Authentication.UserDataKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Authentication.IUserDataKeyResponse} message UserDataKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserDataKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserDataKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Authentication.UserDataKeyResponse} UserDataKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Authentication.UserDataKeyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.userDataKeys && message.userDataKeys.length))
                        message.userDataKeys = [];
                    message.userDataKeys.push($root.Authentication.UserDataKey.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.accessDenied && message.accessDenied.length))
                        message.accessDenied = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accessDenied.push(reader.int64());
                    } else
                        message.accessDenied.push(reader.int64());
                    break;
                case 3:
                    if (!(message.noEncryptedDataKey && message.noEncryptedDataKey.length))
                        message.noEncryptedDataKey = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.noEncryptedDataKey.push(reader.int64());
                    } else
                        message.noEncryptedDataKey.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserDataKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Authentication.UserDataKeyResponse} UserDataKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserDataKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserDataKeyResponse message.
         * @function verify
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserDataKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userDataKeys != null && message.hasOwnProperty("userDataKeys")) {
                if (!Array.isArray(message.userDataKeys))
                    return "userDataKeys: array expected";
                for (let i = 0; i < message.userDataKeys.length; ++i) {
                    let error = $root.Authentication.UserDataKey.verify(message.userDataKeys[i]);
                    if (error)
                        return "userDataKeys." + error;
                }
            }
            if (message.accessDenied != null && message.hasOwnProperty("accessDenied")) {
                if (!Array.isArray(message.accessDenied))
                    return "accessDenied: array expected";
                for (let i = 0; i < message.accessDenied.length; ++i)
                    if (!$util.isInteger(message.accessDenied[i]) && !(message.accessDenied[i] && $util.isInteger(message.accessDenied[i].low) && $util.isInteger(message.accessDenied[i].high)))
                        return "accessDenied: integer|Long[] expected";
            }
            if (message.noEncryptedDataKey != null && message.hasOwnProperty("noEncryptedDataKey")) {
                if (!Array.isArray(message.noEncryptedDataKey))
                    return "noEncryptedDataKey: array expected";
                for (let i = 0; i < message.noEncryptedDataKey.length; ++i)
                    if (!$util.isInteger(message.noEncryptedDataKey[i]) && !(message.noEncryptedDataKey[i] && $util.isInteger(message.noEncryptedDataKey[i].low) && $util.isInteger(message.noEncryptedDataKey[i].high)))
                        return "noEncryptedDataKey: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a UserDataKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Authentication.UserDataKeyResponse} UserDataKeyResponse
         */
        UserDataKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Authentication.UserDataKeyResponse)
                return object;
            let message = new $root.Authentication.UserDataKeyResponse();
            if (object.userDataKeys) {
                if (!Array.isArray(object.userDataKeys))
                    throw TypeError(".Authentication.UserDataKeyResponse.userDataKeys: array expected");
                message.userDataKeys = [];
                for (let i = 0; i < object.userDataKeys.length; ++i) {
                    if (typeof object.userDataKeys[i] !== "object")
                        throw TypeError(".Authentication.UserDataKeyResponse.userDataKeys: object expected");
                    message.userDataKeys[i] = $root.Authentication.UserDataKey.fromObject(object.userDataKeys[i]);
                }
            }
            if (object.accessDenied) {
                if (!Array.isArray(object.accessDenied))
                    throw TypeError(".Authentication.UserDataKeyResponse.accessDenied: array expected");
                message.accessDenied = [];
                for (let i = 0; i < object.accessDenied.length; ++i)
                    if ($util.Long)
                        (message.accessDenied[i] = $util.Long.fromValue(object.accessDenied[i])).unsigned = false;
                    else if (typeof object.accessDenied[i] === "string")
                        message.accessDenied[i] = parseInt(object.accessDenied[i], 10);
                    else if (typeof object.accessDenied[i] === "number")
                        message.accessDenied[i] = object.accessDenied[i];
                    else if (typeof object.accessDenied[i] === "object")
                        message.accessDenied[i] = new $util.LongBits(object.accessDenied[i].low >>> 0, object.accessDenied[i].high >>> 0).toNumber();
            }
            if (object.noEncryptedDataKey) {
                if (!Array.isArray(object.noEncryptedDataKey))
                    throw TypeError(".Authentication.UserDataKeyResponse.noEncryptedDataKey: array expected");
                message.noEncryptedDataKey = [];
                for (let i = 0; i < object.noEncryptedDataKey.length; ++i)
                    if ($util.Long)
                        (message.noEncryptedDataKey[i] = $util.Long.fromValue(object.noEncryptedDataKey[i])).unsigned = false;
                    else if (typeof object.noEncryptedDataKey[i] === "string")
                        message.noEncryptedDataKey[i] = parseInt(object.noEncryptedDataKey[i], 10);
                    else if (typeof object.noEncryptedDataKey[i] === "number")
                        message.noEncryptedDataKey[i] = object.noEncryptedDataKey[i];
                    else if (typeof object.noEncryptedDataKey[i] === "object")
                        message.noEncryptedDataKey[i] = new $util.LongBits(object.noEncryptedDataKey[i].low >>> 0, object.noEncryptedDataKey[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a UserDataKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Authentication.UserDataKeyResponse
         * @static
         * @param {Authentication.UserDataKeyResponse} message UserDataKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserDataKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.userDataKeys = [];
                object.accessDenied = [];
                object.noEncryptedDataKey = [];
            }
            if (message.userDataKeys && message.userDataKeys.length) {
                object.userDataKeys = [];
                for (let j = 0; j < message.userDataKeys.length; ++j)
                    object.userDataKeys[j] = $root.Authentication.UserDataKey.toObject(message.userDataKeys[j], options);
            }
            if (message.accessDenied && message.accessDenied.length) {
                object.accessDenied = [];
                for (let j = 0; j < message.accessDenied.length; ++j)
                    if (typeof message.accessDenied[j] === "number")
                        object.accessDenied[j] = options.longs === String ? String(message.accessDenied[j]) : message.accessDenied[j];
                    else
                        object.accessDenied[j] = options.longs === String ? $util.Long.prototype.toString.call(message.accessDenied[j]) : options.longs === Number ? new $util.LongBits(message.accessDenied[j].low >>> 0, message.accessDenied[j].high >>> 0).toNumber() : message.accessDenied[j];
            }
            if (message.noEncryptedDataKey && message.noEncryptedDataKey.length) {
                object.noEncryptedDataKey = [];
                for (let j = 0; j < message.noEncryptedDataKey.length; ++j)
                    if (typeof message.noEncryptedDataKey[j] === "number")
                        object.noEncryptedDataKey[j] = options.longs === String ? String(message.noEncryptedDataKey[j]) : message.noEncryptedDataKey[j];
                    else
                        object.noEncryptedDataKey[j] = options.longs === String ? $util.Long.prototype.toString.call(message.noEncryptedDataKey[j]) : options.longs === Number ? new $util.LongBits(message.noEncryptedDataKey[j].low >>> 0, message.noEncryptedDataKey[j].high >>> 0).toNumber() : message.noEncryptedDataKey[j];
            }
            return object;
        };

        /**
         * Converts this UserDataKeyResponse to JSON.
         * @function toJSON
         * @memberof Authentication.UserDataKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserDataKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserDataKeyResponse;
    })();

    return Authentication;
})();

export const Enterprise = $root.Enterprise = (() => {

    /**
     * Namespace Enterprise.
     * @exports Enterprise
     * @namespace
     */
    const Enterprise = {};

    /**
     * KeyType enum.
     * @name Enterprise.KeyType
     * @enum {string}
     * @property {number} RSA=0 RSA value
     * @property {number} ECC=1 ECC value
     */
    Enterprise.KeyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RSA"] = 0;
        values[valuesById[1] = "ECC"] = 1;
        return values;
    })();

    Enterprise.EnterpriseKeyPairRequest = (function() {

        /**
         * Properties of an EnterpriseKeyPairRequest.
         * @memberof Enterprise
         * @interface IEnterpriseKeyPairRequest
         * @property {Uint8Array|null} [enterprisePublicKey] EnterpriseKeyPairRequest enterprisePublicKey
         * @property {Uint8Array|null} [encryptedEnterprisePrivateKey] EnterpriseKeyPairRequest encryptedEnterprisePrivateKey
         * @property {Enterprise.KeyType|null} [keyType] EnterpriseKeyPairRequest keyType
         */

        /**
         * Constructs a new EnterpriseKeyPairRequest.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseKeyPairRequest.
         * @implements IEnterpriseKeyPairRequest
         * @constructor
         * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
         */
        function EnterpriseKeyPairRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseKeyPairRequest enterprisePublicKey.
         * @member {Uint8Array} enterprisePublicKey
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         */
        EnterpriseKeyPairRequest.prototype.enterprisePublicKey = $util.newBuffer([]);

        /**
         * EnterpriseKeyPairRequest encryptedEnterprisePrivateKey.
         * @member {Uint8Array} encryptedEnterprisePrivateKey
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         */
        EnterpriseKeyPairRequest.prototype.encryptedEnterprisePrivateKey = $util.newBuffer([]);

        /**
         * EnterpriseKeyPairRequest keyType.
         * @member {Enterprise.KeyType} keyType
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         */
        EnterpriseKeyPairRequest.prototype.keyType = 0;

        /**
         * Creates a new EnterpriseKeyPairRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest instance
         */
        EnterpriseKeyPairRequest.create = function create(properties) {
            return new EnterpriseKeyPairRequest(properties);
        };

        /**
         * Encodes the specified EnterpriseKeyPairRequest message. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseKeyPairRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePublicKey);
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedEnterprisePrivateKey);
            if (message.keyType != null && message.hasOwnProperty("keyType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.keyType);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseKeyPairRequest message, length delimited. Does not implicitly {@link Enterprise.EnterpriseKeyPairRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.IEnterpriseKeyPairRequest} message EnterpriseKeyPairRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseKeyPairRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseKeyPairRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseKeyPairRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePublicKey = reader.bytes();
                    break;
                case 2:
                    message.encryptedEnterprisePrivateKey = reader.bytes();
                    break;
                case 3:
                    message.keyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseKeyPairRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseKeyPairRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseKeyPairRequest message.
         * @function verify
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseKeyPairRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                if (!(message.enterprisePublicKey && typeof message.enterprisePublicKey.length === "number" || $util.isString(message.enterprisePublicKey)))
                    return "enterprisePublicKey: buffer expected";
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                if (!(message.encryptedEnterprisePrivateKey && typeof message.encryptedEnterprisePrivateKey.length === "number" || $util.isString(message.encryptedEnterprisePrivateKey)))
                    return "encryptedEnterprisePrivateKey: buffer expected";
            if (message.keyType != null && message.hasOwnProperty("keyType"))
                switch (message.keyType) {
                default:
                    return "keyType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates an EnterpriseKeyPairRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseKeyPairRequest} EnterpriseKeyPairRequest
         */
        EnterpriseKeyPairRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseKeyPairRequest)
                return object;
            let message = new $root.Enterprise.EnterpriseKeyPairRequest();
            if (object.enterprisePublicKey != null)
                if (typeof object.enterprisePublicKey === "string")
                    $util.base64.decode(object.enterprisePublicKey, message.enterprisePublicKey = $util.newBuffer($util.base64.length(object.enterprisePublicKey)), 0);
                else if (object.enterprisePublicKey.length)
                    message.enterprisePublicKey = object.enterprisePublicKey;
            if (object.encryptedEnterprisePrivateKey != null)
                if (typeof object.encryptedEnterprisePrivateKey === "string")
                    $util.base64.decode(object.encryptedEnterprisePrivateKey, message.encryptedEnterprisePrivateKey = $util.newBuffer($util.base64.length(object.encryptedEnterprisePrivateKey)), 0);
                else if (object.encryptedEnterprisePrivateKey.length)
                    message.encryptedEnterprisePrivateKey = object.encryptedEnterprisePrivateKey;
            switch (object.keyType) {
            case "RSA":
            case 0:
                message.keyType = 0;
                break;
            case "ECC":
            case 1:
                message.keyType = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseKeyPairRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @static
         * @param {Enterprise.EnterpriseKeyPairRequest} message EnterpriseKeyPairRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseKeyPairRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.enterprisePublicKey = "";
                else {
                    object.enterprisePublicKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePublicKey = $util.newBuffer(object.enterprisePublicKey);
                }
                if (options.bytes === String)
                    object.encryptedEnterprisePrivateKey = "";
                else {
                    object.encryptedEnterprisePrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedEnterprisePrivateKey = $util.newBuffer(object.encryptedEnterprisePrivateKey);
                }
                object.keyType = options.enums === String ? "RSA" : 0;
            }
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                object.enterprisePublicKey = options.bytes === String ? $util.base64.encode(message.enterprisePublicKey, 0, message.enterprisePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePublicKey) : message.enterprisePublicKey;
            if (message.encryptedEnterprisePrivateKey != null && message.hasOwnProperty("encryptedEnterprisePrivateKey"))
                object.encryptedEnterprisePrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedEnterprisePrivateKey, 0, message.encryptedEnterprisePrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedEnterprisePrivateKey) : message.encryptedEnterprisePrivateKey;
            if (message.keyType != null && message.hasOwnProperty("keyType"))
                object.keyType = options.enums === String ? $root.Enterprise.KeyType[message.keyType] : message.keyType;
            return object;
        };

        /**
         * Converts this EnterpriseKeyPairRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseKeyPairRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseKeyPairRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseKeyPairRequest;
    })();

    Enterprise.GetTeamMemberRequest = (function() {

        /**
         * Properties of a GetTeamMemberRequest.
         * @memberof Enterprise
         * @interface IGetTeamMemberRequest
         * @property {Uint8Array|null} [teamUid] GetTeamMemberRequest teamUid
         */

        /**
         * Constructs a new GetTeamMemberRequest.
         * @memberof Enterprise
         * @classdesc Represents a GetTeamMemberRequest.
         * @implements IGetTeamMemberRequest
         * @constructor
         * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
         */
        function GetTeamMemberRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTeamMemberRequest teamUid.
         * @member {Uint8Array} teamUid
         * @memberof Enterprise.GetTeamMemberRequest
         * @instance
         */
        GetTeamMemberRequest.prototype.teamUid = $util.newBuffer([]);

        /**
         * Creates a new GetTeamMemberRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest=} [properties] Properties to set
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest instance
         */
        GetTeamMemberRequest.create = function create(properties) {
            return new GetTeamMemberRequest(properties);
        };

        /**
         * Encodes the specified GetTeamMemberRequest message. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teamUid);
            return writer;
        };

        /**
         * Encodes the specified GetTeamMemberRequest message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.IGetTeamMemberRequest} message GetTeamMemberRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTeamMemberRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.GetTeamMemberRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTeamMemberRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTeamMemberRequest message.
         * @function verify
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTeamMemberRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                if (!(message.teamUid && typeof message.teamUid.length === "number" || $util.isString(message.teamUid)))
                    return "teamUid: buffer expected";
            return null;
        };

        /**
         * Creates a GetTeamMemberRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.GetTeamMemberRequest} GetTeamMemberRequest
         */
        GetTeamMemberRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.GetTeamMemberRequest)
                return object;
            let message = new $root.Enterprise.GetTeamMemberRequest();
            if (object.teamUid != null)
                if (typeof object.teamUid === "string")
                    $util.base64.decode(object.teamUid, message.teamUid = $util.newBuffer($util.base64.length(object.teamUid)), 0);
                else if (object.teamUid.length)
                    message.teamUid = object.teamUid;
            return message;
        };

        /**
         * Creates a plain object from a GetTeamMemberRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.GetTeamMemberRequest
         * @static
         * @param {Enterprise.GetTeamMemberRequest} message GetTeamMemberRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTeamMemberRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.teamUid = "";
                else {
                    object.teamUid = [];
                    if (options.bytes !== Array)
                        object.teamUid = $util.newBuffer(object.teamUid);
                }
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                object.teamUid = options.bytes === String ? $util.base64.encode(message.teamUid, 0, message.teamUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.teamUid) : message.teamUid;
            return object;
        };

        /**
         * Converts this GetTeamMemberRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.GetTeamMemberRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTeamMemberRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTeamMemberRequest;
    })();

    Enterprise.EnterpriseUser = (function() {

        /**
         * Properties of an EnterpriseUser.
         * @memberof Enterprise
         * @interface IEnterpriseUser
         * @property {number|Long|null} [enterpriseUserId] EnterpriseUser enterpriseUserId
         * @property {string|null} [email] EnterpriseUser email
         * @property {string|null} [enterpriseUsername] EnterpriseUser enterpriseUsername
         */

        /**
         * Constructs a new EnterpriseUser.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseUser.
         * @implements IEnterpriseUser
         * @constructor
         * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
         */
        function EnterpriseUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUser enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterpriseUser email.
         * @member {string} email
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.email = "";

        /**
         * EnterpriseUser enterpriseUsername.
         * @member {string} enterpriseUsername
         * @memberof Enterprise.EnterpriseUser
         * @instance
         */
        EnterpriseUser.prototype.enterpriseUsername = "";

        /**
         * Creates a new EnterpriseUser instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser instance
         */
        EnterpriseUser.create = function create(properties) {
            return new EnterpriseUser(properties);
        };

        /**
         * Encodes the specified EnterpriseUser message. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.enterpriseUsername);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUser message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.IEnterpriseUser} message EnterpriseUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUser message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.enterpriseUsername = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUser message.
         * @function verify
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                if (!$util.isString(message.enterpriseUsername))
                    return "enterpriseUsername: string expected";
            return null;
        };

        /**
         * Creates an EnterpriseUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseUser} EnterpriseUser
         */
        EnterpriseUser.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseUser)
                return object;
            let message = new $root.Enterprise.EnterpriseUser();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.email != null)
                message.email = String(object.email);
            if (object.enterpriseUsername != null)
                message.enterpriseUsername = String(object.enterpriseUsername);
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseUser
         * @static
         * @param {Enterprise.EnterpriseUser} message EnterpriseUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.email = "";
                object.enterpriseUsername = "";
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.enterpriseUsername != null && message.hasOwnProperty("enterpriseUsername"))
                object.enterpriseUsername = message.enterpriseUsername;
            return object;
        };

        /**
         * Converts this EnterpriseUser to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUser;
    })();

    Enterprise.GetTeamMemberResponse = (function() {

        /**
         * Properties of a GetTeamMemberResponse.
         * @memberof Enterprise
         * @interface IGetTeamMemberResponse
         * @property {Array.<Enterprise.IEnterpriseUser>|null} [enterpriseUser] GetTeamMemberResponse enterpriseUser
         */

        /**
         * Constructs a new GetTeamMemberResponse.
         * @memberof Enterprise
         * @classdesc Represents a GetTeamMemberResponse.
         * @implements IGetTeamMemberResponse
         * @constructor
         * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
         */
        function GetTeamMemberResponse(properties) {
            this.enterpriseUser = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTeamMemberResponse enterpriseUser.
         * @member {Array.<Enterprise.IEnterpriseUser>} enterpriseUser
         * @memberof Enterprise.GetTeamMemberResponse
         * @instance
         */
        GetTeamMemberResponse.prototype.enterpriseUser = $util.emptyArray;

        /**
         * Creates a new GetTeamMemberResponse instance using the specified properties.
         * @function create
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse=} [properties] Properties to set
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse instance
         */
        GetTeamMemberResponse.create = function create(properties) {
            return new GetTeamMemberResponse(properties);
        };

        /**
         * Encodes the specified GetTeamMemberResponse message. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUser != null && message.enterpriseUser.length)
                for (let i = 0; i < message.enterpriseUser.length; ++i)
                    $root.Enterprise.EnterpriseUser.encode(message.enterpriseUser[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTeamMemberResponse message, length delimited. Does not implicitly {@link Enterprise.GetTeamMemberResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.IGetTeamMemberResponse} message GetTeamMemberResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTeamMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTeamMemberResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.GetTeamMemberResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.enterpriseUser && message.enterpriseUser.length))
                        message.enterpriseUser = [];
                    message.enterpriseUser.push($root.Enterprise.EnterpriseUser.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTeamMemberResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTeamMemberResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTeamMemberResponse message.
         * @function verify
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTeamMemberResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUser != null && message.hasOwnProperty("enterpriseUser")) {
                if (!Array.isArray(message.enterpriseUser))
                    return "enterpriseUser: array expected";
                for (let i = 0; i < message.enterpriseUser.length; ++i) {
                    let error = $root.Enterprise.EnterpriseUser.verify(message.enterpriseUser[i]);
                    if (error)
                        return "enterpriseUser." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetTeamMemberResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.GetTeamMemberResponse} GetTeamMemberResponse
         */
        GetTeamMemberResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.GetTeamMemberResponse)
                return object;
            let message = new $root.Enterprise.GetTeamMemberResponse();
            if (object.enterpriseUser) {
                if (!Array.isArray(object.enterpriseUser))
                    throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: array expected");
                message.enterpriseUser = [];
                for (let i = 0; i < object.enterpriseUser.length; ++i) {
                    if (typeof object.enterpriseUser[i] !== "object")
                        throw TypeError(".Enterprise.GetTeamMemberResponse.enterpriseUser: object expected");
                    message.enterpriseUser[i] = $root.Enterprise.EnterpriseUser.fromObject(object.enterpriseUser[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetTeamMemberResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.GetTeamMemberResponse
         * @static
         * @param {Enterprise.GetTeamMemberResponse} message GetTeamMemberResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTeamMemberResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.enterpriseUser = [];
            if (message.enterpriseUser && message.enterpriseUser.length) {
                object.enterpriseUser = [];
                for (let j = 0; j < message.enterpriseUser.length; ++j)
                    object.enterpriseUser[j] = $root.Enterprise.EnterpriseUser.toObject(message.enterpriseUser[j], options);
            }
            return object;
        };

        /**
         * Converts this GetTeamMemberResponse to JSON.
         * @function toJSON
         * @memberof Enterprise.GetTeamMemberResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTeamMemberResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTeamMemberResponse;
    })();

    Enterprise.EnterpriseUserIds = (function() {

        /**
         * Properties of an EnterpriseUserIds.
         * @memberof Enterprise
         * @interface IEnterpriseUserIds
         * @property {Array.<number|Long>|null} [enterpriseUserId] EnterpriseUserIds enterpriseUserId
         */

        /**
         * Constructs a new EnterpriseUserIds.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseUserIds.
         * @implements IEnterpriseUserIds
         * @constructor
         * @param {Enterprise.IEnterpriseUserIds=} [properties] Properties to set
         */
        function EnterpriseUserIds(properties) {
            this.enterpriseUserId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUserIds enterpriseUserId.
         * @member {Array.<number|Long>} enterpriseUserId
         * @memberof Enterprise.EnterpriseUserIds
         * @instance
         */
        EnterpriseUserIds.prototype.enterpriseUserId = $util.emptyArray;

        /**
         * Creates a new EnterpriseUserIds instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Enterprise.IEnterpriseUserIds=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds instance
         */
        EnterpriseUserIds.create = function create(properties) {
            return new EnterpriseUserIds(properties);
        };

        /**
         * Encodes the specified EnterpriseUserIds message. Does not implicitly {@link Enterprise.EnterpriseUserIds.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Enterprise.IEnterpriseUserIds} message EnterpriseUserIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserIds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.enterpriseUserId.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.enterpriseUserId.length; ++i)
                    writer.int64(message.enterpriseUserId[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUserIds message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserIds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Enterprise.IEnterpriseUserIds} message EnterpriseUserIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserIds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUserIds message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserIds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseUserIds();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.enterpriseUserId && message.enterpriseUserId.length))
                        message.enterpriseUserId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enterpriseUserId.push(reader.int64());
                    } else
                        message.enterpriseUserId.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUserIds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserIds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUserIds message.
         * @function verify
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUserIds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId")) {
                if (!Array.isArray(message.enterpriseUserId))
                    return "enterpriseUserId: array expected";
                for (let i = 0; i < message.enterpriseUserId.length; ++i)
                    if (!$util.isInteger(message.enterpriseUserId[i]) && !(message.enterpriseUserId[i] && $util.isInteger(message.enterpriseUserId[i].low) && $util.isInteger(message.enterpriseUserId[i].high)))
                        return "enterpriseUserId: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an EnterpriseUserIds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseUserIds} EnterpriseUserIds
         */
        EnterpriseUserIds.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseUserIds)
                return object;
            let message = new $root.Enterprise.EnterpriseUserIds();
            if (object.enterpriseUserId) {
                if (!Array.isArray(object.enterpriseUserId))
                    throw TypeError(".Enterprise.EnterpriseUserIds.enterpriseUserId: array expected");
                message.enterpriseUserId = [];
                for (let i = 0; i < object.enterpriseUserId.length; ++i)
                    if ($util.Long)
                        (message.enterpriseUserId[i] = $util.Long.fromValue(object.enterpriseUserId[i])).unsigned = false;
                    else if (typeof object.enterpriseUserId[i] === "string")
                        message.enterpriseUserId[i] = parseInt(object.enterpriseUserId[i], 10);
                    else if (typeof object.enterpriseUserId[i] === "number")
                        message.enterpriseUserId[i] = object.enterpriseUserId[i];
                    else if (typeof object.enterpriseUserId[i] === "object")
                        message.enterpriseUserId[i] = new $util.LongBits(object.enterpriseUserId[i].low >>> 0, object.enterpriseUserId[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUserIds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseUserIds
         * @static
         * @param {Enterprise.EnterpriseUserIds} message EnterpriseUserIds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUserIds.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.enterpriseUserId = [];
            if (message.enterpriseUserId && message.enterpriseUserId.length) {
                object.enterpriseUserId = [];
                for (let j = 0; j < message.enterpriseUserId.length; ++j)
                    if (typeof message.enterpriseUserId[j] === "number")
                        object.enterpriseUserId[j] = options.longs === String ? String(message.enterpriseUserId[j]) : message.enterpriseUserId[j];
                    else
                        object.enterpriseUserId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId[j]) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId[j].low >>> 0, message.enterpriseUserId[j].high >>> 0).toNumber() : message.enterpriseUserId[j];
            }
            return object;
        };

        /**
         * Converts this EnterpriseUserIds to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseUserIds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUserIds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUserIds;
    })();

    Enterprise.EnterprisePersonalAccount = (function() {

        /**
         * Properties of an EnterprisePersonalAccount.
         * @memberof Enterprise
         * @interface IEnterprisePersonalAccount
         * @property {string|null} [email] EnterprisePersonalAccount email
         * @property {Uint8Array|null} [OBSOLETE_FIELD] EnterprisePersonalAccount OBSOLETE_FIELD
         */

        /**
         * Constructs a new EnterprisePersonalAccount.
         * @memberof Enterprise
         * @classdesc Represents an EnterprisePersonalAccount.
         * @implements IEnterprisePersonalAccount
         * @constructor
         * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
         */
        function EnterprisePersonalAccount(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePersonalAccount email.
         * @member {string} email
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         */
        EnterprisePersonalAccount.prototype.email = "";

        /**
         * EnterprisePersonalAccount OBSOLETE_FIELD.
         * @member {Uint8Array} OBSOLETE_FIELD
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         */
        EnterprisePersonalAccount.prototype.OBSOLETE_FIELD = $util.newBuffer([]);

        /**
         * Creates a new EnterprisePersonalAccount instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount=} [properties] Properties to set
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount instance
         */
        EnterprisePersonalAccount.create = function create(properties) {
            return new EnterprisePersonalAccount(properties);
        };

        /**
         * Encodes the specified EnterprisePersonalAccount message. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.OBSOLETE_FIELD);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePersonalAccount message, length delimited. Does not implicitly {@link Enterprise.EnterprisePersonalAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.IEnterprisePersonalAccount} message EnterprisePersonalAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePersonalAccount message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterprisePersonalAccount();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.OBSOLETE_FIELD = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePersonalAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePersonalAccount message.
         * @function verify
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePersonalAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                if (!(message.OBSOLETE_FIELD && typeof message.OBSOLETE_FIELD.length === "number" || $util.isString(message.OBSOLETE_FIELD)))
                    return "OBSOLETE_FIELD: buffer expected";
            return null;
        };

        /**
         * Creates an EnterprisePersonalAccount message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterprisePersonalAccount} EnterprisePersonalAccount
         */
        EnterprisePersonalAccount.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterprisePersonalAccount)
                return object;
            let message = new $root.Enterprise.EnterprisePersonalAccount();
            if (object.email != null)
                message.email = String(object.email);
            if (object.OBSOLETE_FIELD != null)
                if (typeof object.OBSOLETE_FIELD === "string")
                    $util.base64.decode(object.OBSOLETE_FIELD, message.OBSOLETE_FIELD = $util.newBuffer($util.base64.length(object.OBSOLETE_FIELD)), 0);
                else if (object.OBSOLETE_FIELD.length)
                    message.OBSOLETE_FIELD = object.OBSOLETE_FIELD;
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePersonalAccount message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterprisePersonalAccount
         * @static
         * @param {Enterprise.EnterprisePersonalAccount} message EnterprisePersonalAccount
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePersonalAccount.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                if (options.bytes === String)
                    object.OBSOLETE_FIELD = "";
                else {
                    object.OBSOLETE_FIELD = [];
                    if (options.bytes !== Array)
                        object.OBSOLETE_FIELD = $util.newBuffer(object.OBSOLETE_FIELD);
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.OBSOLETE_FIELD != null && message.hasOwnProperty("OBSOLETE_FIELD"))
                object.OBSOLETE_FIELD = options.bytes === String ? $util.base64.encode(message.OBSOLETE_FIELD, 0, message.OBSOLETE_FIELD.length) : options.bytes === Array ? Array.prototype.slice.call(message.OBSOLETE_FIELD) : message.OBSOLETE_FIELD;
            return object;
        };

        /**
         * Converts this EnterprisePersonalAccount to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterprisePersonalAccount
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePersonalAccount.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePersonalAccount;
    })();

    Enterprise.EncryptedTeamKeyRequest = (function() {

        /**
         * Properties of an EncryptedTeamKeyRequest.
         * @memberof Enterprise
         * @interface IEncryptedTeamKeyRequest
         * @property {Uint8Array|null} [teamUid] EncryptedTeamKeyRequest teamUid
         * @property {Uint8Array|null} [encryptedTeamKey] EncryptedTeamKeyRequest encryptedTeamKey
         * @property {boolean|null} [force] EncryptedTeamKeyRequest force
         */

        /**
         * Constructs a new EncryptedTeamKeyRequest.
         * @memberof Enterprise
         * @classdesc Represents an EncryptedTeamKeyRequest.
         * @implements IEncryptedTeamKeyRequest
         * @constructor
         * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
         */
        function EncryptedTeamKeyRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EncryptedTeamKeyRequest teamUid.
         * @member {Uint8Array} teamUid
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         */
        EncryptedTeamKeyRequest.prototype.teamUid = $util.newBuffer([]);

        /**
         * EncryptedTeamKeyRequest encryptedTeamKey.
         * @member {Uint8Array} encryptedTeamKey
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         */
        EncryptedTeamKeyRequest.prototype.encryptedTeamKey = $util.newBuffer([]);

        /**
         * EncryptedTeamKeyRequest force.
         * @member {boolean} force
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         */
        EncryptedTeamKeyRequest.prototype.force = false;

        /**
         * Creates a new EncryptedTeamKeyRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest=} [properties] Properties to set
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest instance
         */
        EncryptedTeamKeyRequest.create = function create(properties) {
            return new EncryptedTeamKeyRequest(properties);
        };

        /**
         * Encodes the specified EncryptedTeamKeyRequest message. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedTeamKeyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.teamUid);
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedTeamKey);
            if (message.force != null && message.hasOwnProperty("force"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.force);
            return writer;
        };

        /**
         * Encodes the specified EncryptedTeamKeyRequest message, length delimited. Does not implicitly {@link Enterprise.EncryptedTeamKeyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.IEncryptedTeamKeyRequest} message EncryptedTeamKeyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedTeamKeyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedTeamKeyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EncryptedTeamKeyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.teamUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedTeamKey = reader.bytes();
                    break;
                case 3:
                    message.force = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EncryptedTeamKeyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedTeamKeyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EncryptedTeamKeyRequest message.
         * @function verify
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EncryptedTeamKeyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                if (!(message.teamUid && typeof message.teamUid.length === "number" || $util.isString(message.teamUid)))
                    return "teamUid: buffer expected";
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                if (!(message.encryptedTeamKey && typeof message.encryptedTeamKey.length === "number" || $util.isString(message.encryptedTeamKey)))
                    return "encryptedTeamKey: buffer expected";
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            return null;
        };

        /**
         * Creates an EncryptedTeamKeyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EncryptedTeamKeyRequest} EncryptedTeamKeyRequest
         */
        EncryptedTeamKeyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EncryptedTeamKeyRequest)
                return object;
            let message = new $root.Enterprise.EncryptedTeamKeyRequest();
            if (object.teamUid != null)
                if (typeof object.teamUid === "string")
                    $util.base64.decode(object.teamUid, message.teamUid = $util.newBuffer($util.base64.length(object.teamUid)), 0);
                else if (object.teamUid.length)
                    message.teamUid = object.teamUid;
            if (object.encryptedTeamKey != null)
                if (typeof object.encryptedTeamKey === "string")
                    $util.base64.decode(object.encryptedTeamKey, message.encryptedTeamKey = $util.newBuffer($util.base64.length(object.encryptedTeamKey)), 0);
                else if (object.encryptedTeamKey.length)
                    message.encryptedTeamKey = object.encryptedTeamKey;
            if (object.force != null)
                message.force = Boolean(object.force);
            return message;
        };

        /**
         * Creates a plain object from an EncryptedTeamKeyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @static
         * @param {Enterprise.EncryptedTeamKeyRequest} message EncryptedTeamKeyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EncryptedTeamKeyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.teamUid = "";
                else {
                    object.teamUid = [];
                    if (options.bytes !== Array)
                        object.teamUid = $util.newBuffer(object.teamUid);
                }
                if (options.bytes === String)
                    object.encryptedTeamKey = "";
                else {
                    object.encryptedTeamKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTeamKey = $util.newBuffer(object.encryptedTeamKey);
                }
                object.force = false;
            }
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                object.teamUid = options.bytes === String ? $util.base64.encode(message.teamUid, 0, message.teamUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.teamUid) : message.teamUid;
            if (message.encryptedTeamKey != null && message.hasOwnProperty("encryptedTeamKey"))
                object.encryptedTeamKey = options.bytes === String ? $util.base64.encode(message.encryptedTeamKey, 0, message.encryptedTeamKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTeamKey) : message.encryptedTeamKey;
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            return object;
        };

        /**
         * Converts this EncryptedTeamKeyRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.EncryptedTeamKeyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EncryptedTeamKeyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EncryptedTeamKeyRequest;
    })();

    Enterprise.ReEncryptedData = (function() {

        /**
         * Properties of a ReEncryptedData.
         * @memberof Enterprise
         * @interface IReEncryptedData
         * @property {number|Long|null} [id] ReEncryptedData id
         * @property {string|null} [data] ReEncryptedData data
         */

        /**
         * Constructs a new ReEncryptedData.
         * @memberof Enterprise
         * @classdesc Represents a ReEncryptedData.
         * @implements IReEncryptedData
         * @constructor
         * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
         */
        function ReEncryptedData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReEncryptedData id.
         * @member {number|Long} id
         * @memberof Enterprise.ReEncryptedData
         * @instance
         */
        ReEncryptedData.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReEncryptedData data.
         * @member {string} data
         * @memberof Enterprise.ReEncryptedData
         * @instance
         */
        ReEncryptedData.prototype.data = "";

        /**
         * Creates a new ReEncryptedData instance using the specified properties.
         * @function create
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData=} [properties] Properties to set
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData instance
         */
        ReEncryptedData.create = function create(properties) {
            return new ReEncryptedData(properties);
        };

        /**
         * Encodes the specified ReEncryptedData message. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified ReEncryptedData message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.IReEncryptedData} message ReEncryptedData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReEncryptedData message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ReEncryptedData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.int64();
                    break;
                case 2:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReEncryptedData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReEncryptedData message.
         * @function verify
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReEncryptedData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        /**
         * Creates a ReEncryptedData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ReEncryptedData} ReEncryptedData
         */
        ReEncryptedData.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ReEncryptedData)
                return object;
            let message = new $root.Enterprise.ReEncryptedData();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from a ReEncryptedData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ReEncryptedData
         * @static
         * @param {Enterprise.ReEncryptedData} message ReEncryptedData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReEncryptedData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.data = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this ReEncryptedData to JSON.
         * @function toJSON
         * @memberof Enterprise.ReEncryptedData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReEncryptedData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReEncryptedData;
    })();

    Enterprise.ReEncryptedRoleKey = (function() {

        /**
         * Properties of a ReEncryptedRoleKey.
         * @memberof Enterprise
         * @interface IReEncryptedRoleKey
         * @property {number|Long|null} [roleId] ReEncryptedRoleKey roleId
         * @property {Uint8Array|null} [encryptedRoleKey] ReEncryptedRoleKey encryptedRoleKey
         */

        /**
         * Constructs a new ReEncryptedRoleKey.
         * @memberof Enterprise
         * @classdesc Represents a ReEncryptedRoleKey.
         * @implements IReEncryptedRoleKey
         * @constructor
         * @param {Enterprise.IReEncryptedRoleKey=} [properties] Properties to set
         */
        function ReEncryptedRoleKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReEncryptedRoleKey roleId.
         * @member {number|Long} roleId
         * @memberof Enterprise.ReEncryptedRoleKey
         * @instance
         */
        ReEncryptedRoleKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ReEncryptedRoleKey encryptedRoleKey.
         * @member {Uint8Array} encryptedRoleKey
         * @memberof Enterprise.ReEncryptedRoleKey
         * @instance
         */
        ReEncryptedRoleKey.prototype.encryptedRoleKey = $util.newBuffer([]);

        /**
         * Creates a new ReEncryptedRoleKey instance using the specified properties.
         * @function create
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Enterprise.IReEncryptedRoleKey=} [properties] Properties to set
         * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey instance
         */
        ReEncryptedRoleKey.create = function create(properties) {
            return new ReEncryptedRoleKey(properties);
        };

        /**
         * Encodes the specified ReEncryptedRoleKey message. Does not implicitly {@link Enterprise.ReEncryptedRoleKey.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Enterprise.IReEncryptedRoleKey} message ReEncryptedRoleKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedRoleKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.encryptedRoleKey != null && message.hasOwnProperty("encryptedRoleKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedRoleKey);
            return writer;
        };

        /**
         * Encodes the specified ReEncryptedRoleKey message, length delimited. Does not implicitly {@link Enterprise.ReEncryptedRoleKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Enterprise.IReEncryptedRoleKey} message ReEncryptedRoleKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReEncryptedRoleKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReEncryptedRoleKey message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedRoleKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ReEncryptedRoleKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.encryptedRoleKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReEncryptedRoleKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReEncryptedRoleKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReEncryptedRoleKey message.
         * @function verify
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReEncryptedRoleKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.encryptedRoleKey != null && message.hasOwnProperty("encryptedRoleKey"))
                if (!(message.encryptedRoleKey && typeof message.encryptedRoleKey.length === "number" || $util.isString(message.encryptedRoleKey)))
                    return "encryptedRoleKey: buffer expected";
            return null;
        };

        /**
         * Creates a ReEncryptedRoleKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ReEncryptedRoleKey} ReEncryptedRoleKey
         */
        ReEncryptedRoleKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ReEncryptedRoleKey)
                return object;
            let message = new $root.Enterprise.ReEncryptedRoleKey();
            if (object.roleId != null)
                if ($util.Long)
                    (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
                else if (typeof object.roleId === "string")
                    message.roleId = parseInt(object.roleId, 10);
                else if (typeof object.roleId === "number")
                    message.roleId = object.roleId;
                else if (typeof object.roleId === "object")
                    message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber();
            if (object.encryptedRoleKey != null)
                if (typeof object.encryptedRoleKey === "string")
                    $util.base64.decode(object.encryptedRoleKey, message.encryptedRoleKey = $util.newBuffer($util.base64.length(object.encryptedRoleKey)), 0);
                else if (object.encryptedRoleKey.length)
                    message.encryptedRoleKey = object.encryptedRoleKey;
            return message;
        };

        /**
         * Creates a plain object from a ReEncryptedRoleKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ReEncryptedRoleKey
         * @static
         * @param {Enterprise.ReEncryptedRoleKey} message ReEncryptedRoleKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReEncryptedRoleKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roleId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedRoleKey = "";
                else {
                    object.encryptedRoleKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRoleKey = $util.newBuffer(object.encryptedRoleKey);
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (typeof message.roleId === "number")
                    object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                else
                    object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber() : message.roleId;
            if (message.encryptedRoleKey != null && message.hasOwnProperty("encryptedRoleKey"))
                object.encryptedRoleKey = options.bytes === String ? $util.base64.encode(message.encryptedRoleKey, 0, message.encryptedRoleKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRoleKey) : message.encryptedRoleKey;
            return object;
        };

        /**
         * Converts this ReEncryptedRoleKey to JSON.
         * @function toJSON
         * @memberof Enterprise.ReEncryptedRoleKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReEncryptedRoleKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ReEncryptedRoleKey;
    })();

    Enterprise.NodeToManagedCompanyRequest = (function() {

        /**
         * Properties of a NodeToManagedCompanyRequest.
         * @memberof Enterprise
         * @interface INodeToManagedCompanyRequest
         * @property {number|null} [companyId] NodeToManagedCompanyRequest companyId
         * @property {Array.<Enterprise.IReEncryptedData>|null} [nodes] NodeToManagedCompanyRequest nodes
         * @property {Array.<Enterprise.IReEncryptedData>|null} [roles] NodeToManagedCompanyRequest roles
         * @property {Array.<Enterprise.IReEncryptedData>|null} [users] NodeToManagedCompanyRequest users
         * @property {Array.<Enterprise.IReEncryptedRoleKey>|null} [roleKeys] NodeToManagedCompanyRequest roleKeys
         * @property {Array.<Enterprise.IEncryptedTeamKeyRequest>|null} [teamKeys] NodeToManagedCompanyRequest teamKeys
         */

        /**
         * Constructs a new NodeToManagedCompanyRequest.
         * @memberof Enterprise
         * @classdesc Represents a NodeToManagedCompanyRequest.
         * @implements INodeToManagedCompanyRequest
         * @constructor
         * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
         */
        function NodeToManagedCompanyRequest(properties) {
            this.nodes = [];
            this.roles = [];
            this.users = [];
            this.roleKeys = [];
            this.teamKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeToManagedCompanyRequest companyId.
         * @member {number} companyId
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.companyId = 0;

        /**
         * NodeToManagedCompanyRequest nodes.
         * @member {Array.<Enterprise.IReEncryptedData>} nodes
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.nodes = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest roles.
         * @member {Array.<Enterprise.IReEncryptedData>} roles
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.roles = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest users.
         * @member {Array.<Enterprise.IReEncryptedData>} users
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.users = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest roleKeys.
         * @member {Array.<Enterprise.IReEncryptedRoleKey>} roleKeys
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.roleKeys = $util.emptyArray;

        /**
         * NodeToManagedCompanyRequest teamKeys.
         * @member {Array.<Enterprise.IEncryptedTeamKeyRequest>} teamKeys
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         */
        NodeToManagedCompanyRequest.prototype.teamKeys = $util.emptyArray;

        /**
         * Creates a new NodeToManagedCompanyRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest=} [properties] Properties to set
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest instance
         */
        NodeToManagedCompanyRequest.create = function create(properties) {
            return new NodeToManagedCompanyRequest(properties);
        };

        /**
         * Encodes the specified NodeToManagedCompanyRequest message. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeToManagedCompanyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.companyId);
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.nodes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.roles != null && message.roles.length)
                for (let i = 0; i < message.roles.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.roles[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.users != null && message.users.length)
                for (let i = 0; i < message.users.length; ++i)
                    $root.Enterprise.ReEncryptedData.encode(message.users[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.roleKeys != null && message.roleKeys.length)
                for (let i = 0; i < message.roleKeys.length; ++i)
                    $root.Enterprise.ReEncryptedRoleKey.encode(message.roleKeys[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.teamKeys != null && message.teamKeys.length)
                for (let i = 0; i < message.teamKeys.length; ++i)
                    $root.Enterprise.EncryptedTeamKeyRequest.encode(message.teamKeys[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeToManagedCompanyRequest message, length delimited. Does not implicitly {@link Enterprise.NodeToManagedCompanyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.INodeToManagedCompanyRequest} message NodeToManagedCompanyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeToManagedCompanyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeToManagedCompanyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.NodeToManagedCompanyRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.companyId = reader.int32();
                    break;
                case 2:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.roles && message.roles.length))
                        message.roles = [];
                    message.roles.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.users && message.users.length))
                        message.users = [];
                    message.users.push($root.Enterprise.ReEncryptedData.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.roleKeys && message.roleKeys.length))
                        message.roleKeys = [];
                    message.roleKeys.push($root.Enterprise.ReEncryptedRoleKey.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.teamKeys && message.teamKeys.length))
                        message.teamKeys = [];
                    message.teamKeys.push($root.Enterprise.EncryptedTeamKeyRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeToManagedCompanyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeToManagedCompanyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeToManagedCompanyRequest message.
         * @function verify
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeToManagedCompanyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                if (!$util.isInteger(message.companyId))
                    return "companyId: integer expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (let i = 0; i < message.nodes.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            if (message.roles != null && message.hasOwnProperty("roles")) {
                if (!Array.isArray(message.roles))
                    return "roles: array expected";
                for (let i = 0; i < message.roles.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.roles[i]);
                    if (error)
                        return "roles." + error;
                }
            }
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (let i = 0; i < message.users.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedData.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            if (message.roleKeys != null && message.hasOwnProperty("roleKeys")) {
                if (!Array.isArray(message.roleKeys))
                    return "roleKeys: array expected";
                for (let i = 0; i < message.roleKeys.length; ++i) {
                    let error = $root.Enterprise.ReEncryptedRoleKey.verify(message.roleKeys[i]);
                    if (error)
                        return "roleKeys." + error;
                }
            }
            if (message.teamKeys != null && message.hasOwnProperty("teamKeys")) {
                if (!Array.isArray(message.teamKeys))
                    return "teamKeys: array expected";
                for (let i = 0; i < message.teamKeys.length; ++i) {
                    let error = $root.Enterprise.EncryptedTeamKeyRequest.verify(message.teamKeys[i]);
                    if (error)
                        return "teamKeys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeToManagedCompanyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.NodeToManagedCompanyRequest} NodeToManagedCompanyRequest
         */
        NodeToManagedCompanyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.NodeToManagedCompanyRequest)
                return object;
            let message = new $root.Enterprise.NodeToManagedCompanyRequest();
            if (object.companyId != null)
                message.companyId = object.companyId | 0;
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: array expected");
                message.nodes = [];
                for (let i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.nodes: object expected");
                    message.nodes[i] = $root.Enterprise.ReEncryptedData.fromObject(object.nodes[i]);
                }
            }
            if (object.roles) {
                if (!Array.isArray(object.roles))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: array expected");
                message.roles = [];
                for (let i = 0; i < object.roles.length; ++i) {
                    if (typeof object.roles[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roles: object expected");
                    message.roles[i] = $root.Enterprise.ReEncryptedData.fromObject(object.roles[i]);
                }
            }
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: array expected");
                message.users = [];
                for (let i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.users: object expected");
                    message.users[i] = $root.Enterprise.ReEncryptedData.fromObject(object.users[i]);
                }
            }
            if (object.roleKeys) {
                if (!Array.isArray(object.roleKeys))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roleKeys: array expected");
                message.roleKeys = [];
                for (let i = 0; i < object.roleKeys.length; ++i) {
                    if (typeof object.roleKeys[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.roleKeys: object expected");
                    message.roleKeys[i] = $root.Enterprise.ReEncryptedRoleKey.fromObject(object.roleKeys[i]);
                }
            }
            if (object.teamKeys) {
                if (!Array.isArray(object.teamKeys))
                    throw TypeError(".Enterprise.NodeToManagedCompanyRequest.teamKeys: array expected");
                message.teamKeys = [];
                for (let i = 0; i < object.teamKeys.length; ++i) {
                    if (typeof object.teamKeys[i] !== "object")
                        throw TypeError(".Enterprise.NodeToManagedCompanyRequest.teamKeys: object expected");
                    message.teamKeys[i] = $root.Enterprise.EncryptedTeamKeyRequest.fromObject(object.teamKeys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeToManagedCompanyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @static
         * @param {Enterprise.NodeToManagedCompanyRequest} message NodeToManagedCompanyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeToManagedCompanyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodes = [];
                object.roles = [];
                object.users = [];
                object.roleKeys = [];
                object.teamKeys = [];
            }
            if (options.defaults)
                object.companyId = 0;
            if (message.companyId != null && message.hasOwnProperty("companyId"))
                object.companyId = message.companyId;
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (let j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.Enterprise.ReEncryptedData.toObject(message.nodes[j], options);
            }
            if (message.roles && message.roles.length) {
                object.roles = [];
                for (let j = 0; j < message.roles.length; ++j)
                    object.roles[j] = $root.Enterprise.ReEncryptedData.toObject(message.roles[j], options);
            }
            if (message.users && message.users.length) {
                object.users = [];
                for (let j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.Enterprise.ReEncryptedData.toObject(message.users[j], options);
            }
            if (message.roleKeys && message.roleKeys.length) {
                object.roleKeys = [];
                for (let j = 0; j < message.roleKeys.length; ++j)
                    object.roleKeys[j] = $root.Enterprise.ReEncryptedRoleKey.toObject(message.roleKeys[j], options);
            }
            if (message.teamKeys && message.teamKeys.length) {
                object.teamKeys = [];
                for (let j = 0; j < message.teamKeys.length; ++j)
                    object.teamKeys[j] = $root.Enterprise.EncryptedTeamKeyRequest.toObject(message.teamKeys[j], options);
            }
            return object;
        };

        /**
         * Converts this NodeToManagedCompanyRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.NodeToManagedCompanyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeToManagedCompanyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeToManagedCompanyRequest;
    })();

    Enterprise.RoleTeam = (function() {

        /**
         * Properties of a RoleTeam.
         * @memberof Enterprise
         * @interface IRoleTeam
         * @property {number|Long|null} [roleId] RoleTeam roleId
         * @property {Uint8Array|null} [teamUid] RoleTeam teamUid
         */

        /**
         * Constructs a new RoleTeam.
         * @memberof Enterprise
         * @classdesc Represents a RoleTeam.
         * @implements IRoleTeam
         * @constructor
         * @param {Enterprise.IRoleTeam=} [properties] Properties to set
         */
        function RoleTeam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoleTeam roleId.
         * @member {number|Long} roleId
         * @memberof Enterprise.RoleTeam
         * @instance
         */
        RoleTeam.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoleTeam teamUid.
         * @member {Uint8Array} teamUid
         * @memberof Enterprise.RoleTeam
         * @instance
         */
        RoleTeam.prototype.teamUid = $util.newBuffer([]);

        /**
         * Creates a new RoleTeam instance using the specified properties.
         * @function create
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Enterprise.IRoleTeam=} [properties] Properties to set
         * @returns {Enterprise.RoleTeam} RoleTeam instance
         */
        RoleTeam.create = function create(properties) {
            return new RoleTeam(properties);
        };

        /**
         * Encodes the specified RoleTeam message. Does not implicitly {@link Enterprise.RoleTeam.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Enterprise.IRoleTeam} message RoleTeam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleTeam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.teamUid);
            return writer;
        };

        /**
         * Encodes the specified RoleTeam message, length delimited. Does not implicitly {@link Enterprise.RoleTeam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Enterprise.IRoleTeam} message RoleTeam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleTeam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoleTeam message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.RoleTeam} RoleTeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleTeam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.RoleTeam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.teamUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoleTeam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.RoleTeam} RoleTeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleTeam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoleTeam message.
         * @function verify
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoleTeam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                if (!(message.teamUid && typeof message.teamUid.length === "number" || $util.isString(message.teamUid)))
                    return "teamUid: buffer expected";
            return null;
        };

        /**
         * Creates a RoleTeam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.RoleTeam} RoleTeam
         */
        RoleTeam.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.RoleTeam)
                return object;
            let message = new $root.Enterprise.RoleTeam();
            if (object.roleId != null)
                if ($util.Long)
                    (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
                else if (typeof object.roleId === "string")
                    message.roleId = parseInt(object.roleId, 10);
                else if (typeof object.roleId === "number")
                    message.roleId = object.roleId;
                else if (typeof object.roleId === "object")
                    message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber();
            if (object.teamUid != null)
                if (typeof object.teamUid === "string")
                    $util.base64.decode(object.teamUid, message.teamUid = $util.newBuffer($util.base64.length(object.teamUid)), 0);
                else if (object.teamUid.length)
                    message.teamUid = object.teamUid;
            return message;
        };

        /**
         * Creates a plain object from a RoleTeam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.RoleTeam
         * @static
         * @param {Enterprise.RoleTeam} message RoleTeam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoleTeam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roleId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.teamUid = "";
                else {
                    object.teamUid = [];
                    if (options.bytes !== Array)
                        object.teamUid = $util.newBuffer(object.teamUid);
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (typeof message.roleId === "number")
                    object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                else
                    object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber() : message.roleId;
            if (message.teamUid != null && message.hasOwnProperty("teamUid"))
                object.teamUid = options.bytes === String ? $util.base64.encode(message.teamUid, 0, message.teamUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.teamUid) : message.teamUid;
            return object;
        };

        /**
         * Converts this RoleTeam to JSON.
         * @function toJSON
         * @memberof Enterprise.RoleTeam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoleTeam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoleTeam;
    })();

    Enterprise.RoleTeams = (function() {

        /**
         * Properties of a RoleTeams.
         * @memberof Enterprise
         * @interface IRoleTeams
         * @property {Array.<Enterprise.IRoleTeam>|null} [roleTeam] RoleTeams roleTeam
         */

        /**
         * Constructs a new RoleTeams.
         * @memberof Enterprise
         * @classdesc Represents a RoleTeams.
         * @implements IRoleTeams
         * @constructor
         * @param {Enterprise.IRoleTeams=} [properties] Properties to set
         */
        function RoleTeams(properties) {
            this.roleTeam = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoleTeams roleTeam.
         * @member {Array.<Enterprise.IRoleTeam>} roleTeam
         * @memberof Enterprise.RoleTeams
         * @instance
         */
        RoleTeams.prototype.roleTeam = $util.emptyArray;

        /**
         * Creates a new RoleTeams instance using the specified properties.
         * @function create
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Enterprise.IRoleTeams=} [properties] Properties to set
         * @returns {Enterprise.RoleTeams} RoleTeams instance
         */
        RoleTeams.create = function create(properties) {
            return new RoleTeams(properties);
        };

        /**
         * Encodes the specified RoleTeams message. Does not implicitly {@link Enterprise.RoleTeams.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Enterprise.IRoleTeams} message RoleTeams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleTeams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleTeam != null && message.roleTeam.length)
                for (let i = 0; i < message.roleTeam.length; ++i)
                    $root.Enterprise.RoleTeam.encode(message.roleTeam[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RoleTeams message, length delimited. Does not implicitly {@link Enterprise.RoleTeams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Enterprise.IRoleTeams} message RoleTeams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoleTeams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoleTeams message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.RoleTeams} RoleTeams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleTeams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.RoleTeams();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.roleTeam && message.roleTeam.length))
                        message.roleTeam = [];
                    message.roleTeam.push($root.Enterprise.RoleTeam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoleTeams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.RoleTeams} RoleTeams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoleTeams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoleTeams message.
         * @function verify
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoleTeams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleTeam != null && message.hasOwnProperty("roleTeam")) {
                if (!Array.isArray(message.roleTeam))
                    return "roleTeam: array expected";
                for (let i = 0; i < message.roleTeam.length; ++i) {
                    let error = $root.Enterprise.RoleTeam.verify(message.roleTeam[i]);
                    if (error)
                        return "roleTeam." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RoleTeams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.RoleTeams} RoleTeams
         */
        RoleTeams.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.RoleTeams)
                return object;
            let message = new $root.Enterprise.RoleTeams();
            if (object.roleTeam) {
                if (!Array.isArray(object.roleTeam))
                    throw TypeError(".Enterprise.RoleTeams.roleTeam: array expected");
                message.roleTeam = [];
                for (let i = 0; i < object.roleTeam.length; ++i) {
                    if (typeof object.roleTeam[i] !== "object")
                        throw TypeError(".Enterprise.RoleTeams.roleTeam: object expected");
                    message.roleTeam[i] = $root.Enterprise.RoleTeam.fromObject(object.roleTeam[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RoleTeams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.RoleTeams
         * @static
         * @param {Enterprise.RoleTeams} message RoleTeams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoleTeams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.roleTeam = [];
            if (message.roleTeam && message.roleTeam.length) {
                object.roleTeam = [];
                for (let j = 0; j < message.roleTeam.length; ++j)
                    object.roleTeam[j] = $root.Enterprise.RoleTeam.toObject(message.roleTeam[j], options);
            }
            return object;
        };

        /**
         * Converts this RoleTeams to JSON.
         * @function toJSON
         * @memberof Enterprise.RoleTeams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoleTeams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoleTeams;
    })();

    /**
     * EnterpriseType enum.
     * @name Enterprise.EnterpriseType
     * @enum {string}
     * @property {number} ENTERPRISE_STANDARD=0 ENTERPRISE_STANDARD value
     * @property {number} ENTERPRISE_MSP=1 ENTERPRISE_MSP value
     */
    Enterprise.EnterpriseType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ENTERPRISE_STANDARD"] = 0;
        values[valuesById[1] = "ENTERPRISE_MSP"] = 1;
        return values;
    })();

    Enterprise.EnterpriseRegistration = (function() {

        /**
         * Properties of an EnterpriseRegistration.
         * @memberof Enterprise
         * @interface IEnterpriseRegistration
         * @property {Uint8Array|null} [encryptedTreeKey] EnterpriseRegistration encryptedTreeKey
         * @property {string|null} [enterpriseName] EnterpriseRegistration enterpriseName
         * @property {Uint8Array|null} [rootNodeData] EnterpriseRegistration rootNodeData
         * @property {Uint8Array|null} [adminUserData] EnterpriseRegistration adminUserData
         * @property {string|null} [adminName] EnterpriseRegistration adminName
         * @property {Uint8Array|null} [roleData] EnterpriseRegistration roleData
         * @property {Enterprise.IEnterpriseKeyPairRequest|null} [rsaKeyPair] EnterpriseRegistration rsaKeyPair
         * @property {number|null} [numberSeats] EnterpriseRegistration numberSeats
         * @property {Enterprise.EnterpriseType|null} [enterpriseType] EnterpriseRegistration enterpriseType
         * @property {Uint8Array|null} [rolePublicKey] EnterpriseRegistration rolePublicKey
         * @property {Uint8Array|null} [rolePrivateKeyEncryptedWithRoleKey] EnterpriseRegistration rolePrivateKeyEncryptedWithRoleKey
         * @property {Uint8Array|null} [roleKeyEncryptedWithTreeKey] EnterpriseRegistration roleKeyEncryptedWithTreeKey
         * @property {Enterprise.IEnterpriseKeyPairRequest|null} [eccKeyPair] EnterpriseRegistration eccKeyPair
         */

        /**
         * Constructs a new EnterpriseRegistration.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseRegistration.
         * @implements IEnterpriseRegistration
         * @constructor
         * @param {Enterprise.IEnterpriseRegistration=} [properties] Properties to set
         */
        function EnterpriseRegistration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseRegistration encryptedTreeKey.
         * @member {Uint8Array} encryptedTreeKey
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.encryptedTreeKey = $util.newBuffer([]);

        /**
         * EnterpriseRegistration enterpriseName.
         * @member {string} enterpriseName
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.enterpriseName = "";

        /**
         * EnterpriseRegistration rootNodeData.
         * @member {Uint8Array} rootNodeData
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.rootNodeData = $util.newBuffer([]);

        /**
         * EnterpriseRegistration adminUserData.
         * @member {Uint8Array} adminUserData
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.adminUserData = $util.newBuffer([]);

        /**
         * EnterpriseRegistration adminName.
         * @member {string} adminName
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.adminName = "";

        /**
         * EnterpriseRegistration roleData.
         * @member {Uint8Array} roleData
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.roleData = $util.newBuffer([]);

        /**
         * EnterpriseRegistration rsaKeyPair.
         * @member {Enterprise.IEnterpriseKeyPairRequest|null|undefined} rsaKeyPair
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.rsaKeyPair = null;

        /**
         * EnterpriseRegistration numberSeats.
         * @member {number} numberSeats
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.numberSeats = 0;

        /**
         * EnterpriseRegistration enterpriseType.
         * @member {Enterprise.EnterpriseType} enterpriseType
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.enterpriseType = 0;

        /**
         * EnterpriseRegistration rolePublicKey.
         * @member {Uint8Array} rolePublicKey
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.rolePublicKey = $util.newBuffer([]);

        /**
         * EnterpriseRegistration rolePrivateKeyEncryptedWithRoleKey.
         * @member {Uint8Array} rolePrivateKeyEncryptedWithRoleKey
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer([]);

        /**
         * EnterpriseRegistration roleKeyEncryptedWithTreeKey.
         * @member {Uint8Array} roleKeyEncryptedWithTreeKey
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.roleKeyEncryptedWithTreeKey = $util.newBuffer([]);

        /**
         * EnterpriseRegistration eccKeyPair.
         * @member {Enterprise.IEnterpriseKeyPairRequest|null|undefined} eccKeyPair
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         */
        EnterpriseRegistration.prototype.eccKeyPair = null;

        /**
         * Creates a new EnterpriseRegistration instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Enterprise.IEnterpriseRegistration=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration instance
         */
        EnterpriseRegistration.create = function create(properties) {
            return new EnterpriseRegistration(properties);
        };

        /**
         * Encodes the specified EnterpriseRegistration message. Does not implicitly {@link Enterprise.EnterpriseRegistration.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Enterprise.IEnterpriseRegistration} message EnterpriseRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseRegistration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedTreeKey);
            if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.enterpriseName);
            if (message.rootNodeData != null && message.hasOwnProperty("rootNodeData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rootNodeData);
            if (message.adminUserData != null && message.hasOwnProperty("adminUserData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.adminUserData);
            if (message.adminName != null && message.hasOwnProperty("adminName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.adminName);
            if (message.roleData != null && message.hasOwnProperty("roleData"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.roleData);
            if (message.rsaKeyPair != null && message.hasOwnProperty("rsaKeyPair"))
                $root.Enterprise.EnterpriseKeyPairRequest.encode(message.rsaKeyPair, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.numberSeats != null && message.hasOwnProperty("numberSeats"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.numberSeats);
            if (message.enterpriseType != null && message.hasOwnProperty("enterpriseType"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.enterpriseType);
            if (message.rolePublicKey != null && message.hasOwnProperty("rolePublicKey"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.rolePublicKey);
            if (message.rolePrivateKeyEncryptedWithRoleKey != null && message.hasOwnProperty("rolePrivateKeyEncryptedWithRoleKey"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.rolePrivateKeyEncryptedWithRoleKey);
            if (message.roleKeyEncryptedWithTreeKey != null && message.hasOwnProperty("roleKeyEncryptedWithTreeKey"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.roleKeyEncryptedWithTreeKey);
            if (message.eccKeyPair != null && message.hasOwnProperty("eccKeyPair"))
                $root.Enterprise.EnterpriseKeyPairRequest.encode(message.eccKeyPair, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EnterpriseRegistration message, length delimited. Does not implicitly {@link Enterprise.EnterpriseRegistration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Enterprise.IEnterpriseRegistration} message EnterpriseRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseRegistration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseRegistration message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseRegistration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseRegistration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedTreeKey = reader.bytes();
                    break;
                case 2:
                    message.enterpriseName = reader.string();
                    break;
                case 3:
                    message.rootNodeData = reader.bytes();
                    break;
                case 4:
                    message.adminUserData = reader.bytes();
                    break;
                case 5:
                    message.adminName = reader.string();
                    break;
                case 6:
                    message.roleData = reader.bytes();
                    break;
                case 7:
                    message.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.numberSeats = reader.int32();
                    break;
                case 9:
                    message.enterpriseType = reader.int32();
                    break;
                case 10:
                    message.rolePublicKey = reader.bytes();
                    break;
                case 11:
                    message.rolePrivateKeyEncryptedWithRoleKey = reader.bytes();
                    break;
                case 12:
                    message.roleKeyEncryptedWithTreeKey = reader.bytes();
                    break;
                case 13:
                    message.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseRegistration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseRegistration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseRegistration message.
         * @function verify
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseRegistration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                if (!(message.encryptedTreeKey && typeof message.encryptedTreeKey.length === "number" || $util.isString(message.encryptedTreeKey)))
                    return "encryptedTreeKey: buffer expected";
            if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
                if (!$util.isString(message.enterpriseName))
                    return "enterpriseName: string expected";
            if (message.rootNodeData != null && message.hasOwnProperty("rootNodeData"))
                if (!(message.rootNodeData && typeof message.rootNodeData.length === "number" || $util.isString(message.rootNodeData)))
                    return "rootNodeData: buffer expected";
            if (message.adminUserData != null && message.hasOwnProperty("adminUserData"))
                if (!(message.adminUserData && typeof message.adminUserData.length === "number" || $util.isString(message.adminUserData)))
                    return "adminUserData: buffer expected";
            if (message.adminName != null && message.hasOwnProperty("adminName"))
                if (!$util.isString(message.adminName))
                    return "adminName: string expected";
            if (message.roleData != null && message.hasOwnProperty("roleData"))
                if (!(message.roleData && typeof message.roleData.length === "number" || $util.isString(message.roleData)))
                    return "roleData: buffer expected";
            if (message.rsaKeyPair != null && message.hasOwnProperty("rsaKeyPair")) {
                let error = $root.Enterprise.EnterpriseKeyPairRequest.verify(message.rsaKeyPair);
                if (error)
                    return "rsaKeyPair." + error;
            }
            if (message.numberSeats != null && message.hasOwnProperty("numberSeats"))
                if (!$util.isInteger(message.numberSeats))
                    return "numberSeats: integer expected";
            if (message.enterpriseType != null && message.hasOwnProperty("enterpriseType"))
                switch (message.enterpriseType) {
                default:
                    return "enterpriseType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.rolePublicKey != null && message.hasOwnProperty("rolePublicKey"))
                if (!(message.rolePublicKey && typeof message.rolePublicKey.length === "number" || $util.isString(message.rolePublicKey)))
                    return "rolePublicKey: buffer expected";
            if (message.rolePrivateKeyEncryptedWithRoleKey != null && message.hasOwnProperty("rolePrivateKeyEncryptedWithRoleKey"))
                if (!(message.rolePrivateKeyEncryptedWithRoleKey && typeof message.rolePrivateKeyEncryptedWithRoleKey.length === "number" || $util.isString(message.rolePrivateKeyEncryptedWithRoleKey)))
                    return "rolePrivateKeyEncryptedWithRoleKey: buffer expected";
            if (message.roleKeyEncryptedWithTreeKey != null && message.hasOwnProperty("roleKeyEncryptedWithTreeKey"))
                if (!(message.roleKeyEncryptedWithTreeKey && typeof message.roleKeyEncryptedWithTreeKey.length === "number" || $util.isString(message.roleKeyEncryptedWithTreeKey)))
                    return "roleKeyEncryptedWithTreeKey: buffer expected";
            if (message.eccKeyPair != null && message.hasOwnProperty("eccKeyPair")) {
                let error = $root.Enterprise.EnterpriseKeyPairRequest.verify(message.eccKeyPair);
                if (error)
                    return "eccKeyPair." + error;
            }
            return null;
        };

        /**
         * Creates an EnterpriseRegistration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseRegistration} EnterpriseRegistration
         */
        EnterpriseRegistration.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseRegistration)
                return object;
            let message = new $root.Enterprise.EnterpriseRegistration();
            if (object.encryptedTreeKey != null)
                if (typeof object.encryptedTreeKey === "string")
                    $util.base64.decode(object.encryptedTreeKey, message.encryptedTreeKey = $util.newBuffer($util.base64.length(object.encryptedTreeKey)), 0);
                else if (object.encryptedTreeKey.length)
                    message.encryptedTreeKey = object.encryptedTreeKey;
            if (object.enterpriseName != null)
                message.enterpriseName = String(object.enterpriseName);
            if (object.rootNodeData != null)
                if (typeof object.rootNodeData === "string")
                    $util.base64.decode(object.rootNodeData, message.rootNodeData = $util.newBuffer($util.base64.length(object.rootNodeData)), 0);
                else if (object.rootNodeData.length)
                    message.rootNodeData = object.rootNodeData;
            if (object.adminUserData != null)
                if (typeof object.adminUserData === "string")
                    $util.base64.decode(object.adminUserData, message.adminUserData = $util.newBuffer($util.base64.length(object.adminUserData)), 0);
                else if (object.adminUserData.length)
                    message.adminUserData = object.adminUserData;
            if (object.adminName != null)
                message.adminName = String(object.adminName);
            if (object.roleData != null)
                if (typeof object.roleData === "string")
                    $util.base64.decode(object.roleData, message.roleData = $util.newBuffer($util.base64.length(object.roleData)), 0);
                else if (object.roleData.length)
                    message.roleData = object.roleData;
            if (object.rsaKeyPair != null) {
                if (typeof object.rsaKeyPair !== "object")
                    throw TypeError(".Enterprise.EnterpriseRegistration.rsaKeyPair: object expected");
                message.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.fromObject(object.rsaKeyPair);
            }
            if (object.numberSeats != null)
                message.numberSeats = object.numberSeats | 0;
            switch (object.enterpriseType) {
            case "ENTERPRISE_STANDARD":
            case 0:
                message.enterpriseType = 0;
                break;
            case "ENTERPRISE_MSP":
            case 1:
                message.enterpriseType = 1;
                break;
            }
            if (object.rolePublicKey != null)
                if (typeof object.rolePublicKey === "string")
                    $util.base64.decode(object.rolePublicKey, message.rolePublicKey = $util.newBuffer($util.base64.length(object.rolePublicKey)), 0);
                else if (object.rolePublicKey.length)
                    message.rolePublicKey = object.rolePublicKey;
            if (object.rolePrivateKeyEncryptedWithRoleKey != null)
                if (typeof object.rolePrivateKeyEncryptedWithRoleKey === "string")
                    $util.base64.decode(object.rolePrivateKeyEncryptedWithRoleKey, message.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer($util.base64.length(object.rolePrivateKeyEncryptedWithRoleKey)), 0);
                else if (object.rolePrivateKeyEncryptedWithRoleKey.length)
                    message.rolePrivateKeyEncryptedWithRoleKey = object.rolePrivateKeyEncryptedWithRoleKey;
            if (object.roleKeyEncryptedWithTreeKey != null)
                if (typeof object.roleKeyEncryptedWithTreeKey === "string")
                    $util.base64.decode(object.roleKeyEncryptedWithTreeKey, message.roleKeyEncryptedWithTreeKey = $util.newBuffer($util.base64.length(object.roleKeyEncryptedWithTreeKey)), 0);
                else if (object.roleKeyEncryptedWithTreeKey.length)
                    message.roleKeyEncryptedWithTreeKey = object.roleKeyEncryptedWithTreeKey;
            if (object.eccKeyPair != null) {
                if (typeof object.eccKeyPair !== "object")
                    throw TypeError(".Enterprise.EnterpriseRegistration.eccKeyPair: object expected");
                message.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.fromObject(object.eccKeyPair);
            }
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseRegistration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseRegistration
         * @static
         * @param {Enterprise.EnterpriseRegistration} message EnterpriseRegistration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseRegistration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedTreeKey = "";
                else {
                    object.encryptedTreeKey = [];
                    if (options.bytes !== Array)
                        object.encryptedTreeKey = $util.newBuffer(object.encryptedTreeKey);
                }
                object.enterpriseName = "";
                if (options.bytes === String)
                    object.rootNodeData = "";
                else {
                    object.rootNodeData = [];
                    if (options.bytes !== Array)
                        object.rootNodeData = $util.newBuffer(object.rootNodeData);
                }
                if (options.bytes === String)
                    object.adminUserData = "";
                else {
                    object.adminUserData = [];
                    if (options.bytes !== Array)
                        object.adminUserData = $util.newBuffer(object.adminUserData);
                }
                object.adminName = "";
                if (options.bytes === String)
                    object.roleData = "";
                else {
                    object.roleData = [];
                    if (options.bytes !== Array)
                        object.roleData = $util.newBuffer(object.roleData);
                }
                object.rsaKeyPair = null;
                object.numberSeats = 0;
                object.enterpriseType = options.enums === String ? "ENTERPRISE_STANDARD" : 0;
                if (options.bytes === String)
                    object.rolePublicKey = "";
                else {
                    object.rolePublicKey = [];
                    if (options.bytes !== Array)
                        object.rolePublicKey = $util.newBuffer(object.rolePublicKey);
                }
                if (options.bytes === String)
                    object.rolePrivateKeyEncryptedWithRoleKey = "";
                else {
                    object.rolePrivateKeyEncryptedWithRoleKey = [];
                    if (options.bytes !== Array)
                        object.rolePrivateKeyEncryptedWithRoleKey = $util.newBuffer(object.rolePrivateKeyEncryptedWithRoleKey);
                }
                if (options.bytes === String)
                    object.roleKeyEncryptedWithTreeKey = "";
                else {
                    object.roleKeyEncryptedWithTreeKey = [];
                    if (options.bytes !== Array)
                        object.roleKeyEncryptedWithTreeKey = $util.newBuffer(object.roleKeyEncryptedWithTreeKey);
                }
                object.eccKeyPair = null;
            }
            if (message.encryptedTreeKey != null && message.hasOwnProperty("encryptedTreeKey"))
                object.encryptedTreeKey = options.bytes === String ? $util.base64.encode(message.encryptedTreeKey, 0, message.encryptedTreeKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedTreeKey) : message.encryptedTreeKey;
            if (message.enterpriseName != null && message.hasOwnProperty("enterpriseName"))
                object.enterpriseName = message.enterpriseName;
            if (message.rootNodeData != null && message.hasOwnProperty("rootNodeData"))
                object.rootNodeData = options.bytes === String ? $util.base64.encode(message.rootNodeData, 0, message.rootNodeData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rootNodeData) : message.rootNodeData;
            if (message.adminUserData != null && message.hasOwnProperty("adminUserData"))
                object.adminUserData = options.bytes === String ? $util.base64.encode(message.adminUserData, 0, message.adminUserData.length) : options.bytes === Array ? Array.prototype.slice.call(message.adminUserData) : message.adminUserData;
            if (message.adminName != null && message.hasOwnProperty("adminName"))
                object.adminName = message.adminName;
            if (message.roleData != null && message.hasOwnProperty("roleData"))
                object.roleData = options.bytes === String ? $util.base64.encode(message.roleData, 0, message.roleData.length) : options.bytes === Array ? Array.prototype.slice.call(message.roleData) : message.roleData;
            if (message.rsaKeyPair != null && message.hasOwnProperty("rsaKeyPair"))
                object.rsaKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.toObject(message.rsaKeyPair, options);
            if (message.numberSeats != null && message.hasOwnProperty("numberSeats"))
                object.numberSeats = message.numberSeats;
            if (message.enterpriseType != null && message.hasOwnProperty("enterpriseType"))
                object.enterpriseType = options.enums === String ? $root.Enterprise.EnterpriseType[message.enterpriseType] : message.enterpriseType;
            if (message.rolePublicKey != null && message.hasOwnProperty("rolePublicKey"))
                object.rolePublicKey = options.bytes === String ? $util.base64.encode(message.rolePublicKey, 0, message.rolePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rolePublicKey) : message.rolePublicKey;
            if (message.rolePrivateKeyEncryptedWithRoleKey != null && message.hasOwnProperty("rolePrivateKeyEncryptedWithRoleKey"))
                object.rolePrivateKeyEncryptedWithRoleKey = options.bytes === String ? $util.base64.encode(message.rolePrivateKeyEncryptedWithRoleKey, 0, message.rolePrivateKeyEncryptedWithRoleKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.rolePrivateKeyEncryptedWithRoleKey) : message.rolePrivateKeyEncryptedWithRoleKey;
            if (message.roleKeyEncryptedWithTreeKey != null && message.hasOwnProperty("roleKeyEncryptedWithTreeKey"))
                object.roleKeyEncryptedWithTreeKey = options.bytes === String ? $util.base64.encode(message.roleKeyEncryptedWithTreeKey, 0, message.roleKeyEncryptedWithTreeKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.roleKeyEncryptedWithTreeKey) : message.roleKeyEncryptedWithTreeKey;
            if (message.eccKeyPair != null && message.hasOwnProperty("eccKeyPair"))
                object.eccKeyPair = $root.Enterprise.EnterpriseKeyPairRequest.toObject(message.eccKeyPair, options);
            return object;
        };

        /**
         * Converts this EnterpriseRegistration to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseRegistration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseRegistration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseRegistration;
    })();

    Enterprise.DomainPasswordRulesRequest = (function() {

        /**
         * Properties of a DomainPasswordRulesRequest.
         * @memberof Enterprise
         * @interface IDomainPasswordRulesRequest
         * @property {string|null} [username] DomainPasswordRulesRequest username
         */

        /**
         * Constructs a new DomainPasswordRulesRequest.
         * @memberof Enterprise
         * @classdesc Represents a DomainPasswordRulesRequest.
         * @implements IDomainPasswordRulesRequest
         * @constructor
         * @param {Enterprise.IDomainPasswordRulesRequest=} [properties] Properties to set
         */
        function DomainPasswordRulesRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DomainPasswordRulesRequest username.
         * @member {string} username
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @instance
         */
        DomainPasswordRulesRequest.prototype.username = "";

        /**
         * Creates a new DomainPasswordRulesRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Enterprise.IDomainPasswordRulesRequest=} [properties] Properties to set
         * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest instance
         */
        DomainPasswordRulesRequest.create = function create(properties) {
            return new DomainPasswordRulesRequest(properties);
        };

        /**
         * Encodes the specified DomainPasswordRulesRequest message. Does not implicitly {@link Enterprise.DomainPasswordRulesRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Enterprise.IDomainPasswordRulesRequest} message DomainPasswordRulesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified DomainPasswordRulesRequest message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Enterprise.IDomainPasswordRulesRequest} message DomainPasswordRulesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DomainPasswordRulesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.DomainPasswordRulesRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DomainPasswordRulesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DomainPasswordRulesRequest message.
         * @function verify
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DomainPasswordRulesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a DomainPasswordRulesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.DomainPasswordRulesRequest} DomainPasswordRulesRequest
         */
        DomainPasswordRulesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.DomainPasswordRulesRequest)
                return object;
            let message = new $root.Enterprise.DomainPasswordRulesRequest();
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a DomainPasswordRulesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @static
         * @param {Enterprise.DomainPasswordRulesRequest} message DomainPasswordRulesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DomainPasswordRulesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.username = "";
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this DomainPasswordRulesRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.DomainPasswordRulesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DomainPasswordRulesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DomainPasswordRulesRequest;
    })();

    Enterprise.DomainPasswordRulesFields = (function() {

        /**
         * Properties of a DomainPasswordRulesFields.
         * @memberof Enterprise
         * @interface IDomainPasswordRulesFields
         * @property {string|null} [type] DomainPasswordRulesFields type
         * @property {number|null} [minimum] DomainPasswordRulesFields minimum
         * @property {number|null} [maximum] DomainPasswordRulesFields maximum
         * @property {boolean|null} [allowed] DomainPasswordRulesFields allowed
         */

        /**
         * Constructs a new DomainPasswordRulesFields.
         * @memberof Enterprise
         * @classdesc Represents a DomainPasswordRulesFields.
         * @implements IDomainPasswordRulesFields
         * @constructor
         * @param {Enterprise.IDomainPasswordRulesFields=} [properties] Properties to set
         */
        function DomainPasswordRulesFields(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DomainPasswordRulesFields type.
         * @member {string} type
         * @memberof Enterprise.DomainPasswordRulesFields
         * @instance
         */
        DomainPasswordRulesFields.prototype.type = "";

        /**
         * DomainPasswordRulesFields minimum.
         * @member {number} minimum
         * @memberof Enterprise.DomainPasswordRulesFields
         * @instance
         */
        DomainPasswordRulesFields.prototype.minimum = 0;

        /**
         * DomainPasswordRulesFields maximum.
         * @member {number} maximum
         * @memberof Enterprise.DomainPasswordRulesFields
         * @instance
         */
        DomainPasswordRulesFields.prototype.maximum = 0;

        /**
         * DomainPasswordRulesFields allowed.
         * @member {boolean} allowed
         * @memberof Enterprise.DomainPasswordRulesFields
         * @instance
         */
        DomainPasswordRulesFields.prototype.allowed = false;

        /**
         * Creates a new DomainPasswordRulesFields instance using the specified properties.
         * @function create
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Enterprise.IDomainPasswordRulesFields=} [properties] Properties to set
         * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields instance
         */
        DomainPasswordRulesFields.create = function create(properties) {
            return new DomainPasswordRulesFields(properties);
        };

        /**
         * Encodes the specified DomainPasswordRulesFields message. Does not implicitly {@link Enterprise.DomainPasswordRulesFields.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Enterprise.IDomainPasswordRulesFields} message DomainPasswordRulesFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.minimum);
            if (message.maximum != null && message.hasOwnProperty("maximum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maximum);
            if (message.allowed != null && message.hasOwnProperty("allowed"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.allowed);
            return writer;
        };

        /**
         * Encodes the specified DomainPasswordRulesFields message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Enterprise.IDomainPasswordRulesFields} message DomainPasswordRulesFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DomainPasswordRulesFields message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.DomainPasswordRulesFields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.string();
                    break;
                case 2:
                    message.minimum = reader.int32();
                    break;
                case 3:
                    message.maximum = reader.int32();
                    break;
                case 4:
                    message.allowed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DomainPasswordRulesFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DomainPasswordRulesFields message.
         * @function verify
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DomainPasswordRulesFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                if (!$util.isInteger(message.minimum))
                    return "minimum: integer expected";
            if (message.maximum != null && message.hasOwnProperty("maximum"))
                if (!$util.isInteger(message.maximum))
                    return "maximum: integer expected";
            if (message.allowed != null && message.hasOwnProperty("allowed"))
                if (typeof message.allowed !== "boolean")
                    return "allowed: boolean expected";
            return null;
        };

        /**
         * Creates a DomainPasswordRulesFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.DomainPasswordRulesFields} DomainPasswordRulesFields
         */
        DomainPasswordRulesFields.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.DomainPasswordRulesFields)
                return object;
            let message = new $root.Enterprise.DomainPasswordRulesFields();
            if (object.type != null)
                message.type = String(object.type);
            if (object.minimum != null)
                message.minimum = object.minimum | 0;
            if (object.maximum != null)
                message.maximum = object.maximum | 0;
            if (object.allowed != null)
                message.allowed = Boolean(object.allowed);
            return message;
        };

        /**
         * Creates a plain object from a DomainPasswordRulesFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.DomainPasswordRulesFields
         * @static
         * @param {Enterprise.DomainPasswordRulesFields} message DomainPasswordRulesFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DomainPasswordRulesFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = "";
                object.minimum = 0;
                object.maximum = 0;
                object.allowed = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                object.minimum = message.minimum;
            if (message.maximum != null && message.hasOwnProperty("maximum"))
                object.maximum = message.maximum;
            if (message.allowed != null && message.hasOwnProperty("allowed"))
                object.allowed = message.allowed;
            return object;
        };

        /**
         * Converts this DomainPasswordRulesFields to JSON.
         * @function toJSON
         * @memberof Enterprise.DomainPasswordRulesFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DomainPasswordRulesFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DomainPasswordRulesFields;
    })();

    Enterprise.DomainPasswordRulesResponse = (function() {

        /**
         * Properties of a DomainPasswordRulesResponse.
         * @memberof Enterprise
         * @interface IDomainPasswordRulesResponse
         * @property {Array.<Enterprise.IDomainPasswordRulesFields>|null} [domainPasswordRulesFields] DomainPasswordRulesResponse domainPasswordRulesFields
         */

        /**
         * Constructs a new DomainPasswordRulesResponse.
         * @memberof Enterprise
         * @classdesc Represents a DomainPasswordRulesResponse.
         * @implements IDomainPasswordRulesResponse
         * @constructor
         * @param {Enterprise.IDomainPasswordRulesResponse=} [properties] Properties to set
         */
        function DomainPasswordRulesResponse(properties) {
            this.domainPasswordRulesFields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DomainPasswordRulesResponse domainPasswordRulesFields.
         * @member {Array.<Enterprise.IDomainPasswordRulesFields>} domainPasswordRulesFields
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @instance
         */
        DomainPasswordRulesResponse.prototype.domainPasswordRulesFields = $util.emptyArray;

        /**
         * Creates a new DomainPasswordRulesResponse instance using the specified properties.
         * @function create
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Enterprise.IDomainPasswordRulesResponse=} [properties] Properties to set
         * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse instance
         */
        DomainPasswordRulesResponse.create = function create(properties) {
            return new DomainPasswordRulesResponse(properties);
        };

        /**
         * Encodes the specified DomainPasswordRulesResponse message. Does not implicitly {@link Enterprise.DomainPasswordRulesResponse.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Enterprise.IDomainPasswordRulesResponse} message DomainPasswordRulesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domainPasswordRulesFields != null && message.domainPasswordRulesFields.length)
                for (let i = 0; i < message.domainPasswordRulesFields.length; ++i)
                    $root.Enterprise.DomainPasswordRulesFields.encode(message.domainPasswordRulesFields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DomainPasswordRulesResponse message, length delimited. Does not implicitly {@link Enterprise.DomainPasswordRulesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Enterprise.IDomainPasswordRulesResponse} message DomainPasswordRulesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DomainPasswordRulesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DomainPasswordRulesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.DomainPasswordRulesResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.domainPasswordRulesFields && message.domainPasswordRulesFields.length))
                        message.domainPasswordRulesFields = [];
                    message.domainPasswordRulesFields.push($root.Enterprise.DomainPasswordRulesFields.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DomainPasswordRulesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DomainPasswordRulesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DomainPasswordRulesResponse message.
         * @function verify
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DomainPasswordRulesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domainPasswordRulesFields != null && message.hasOwnProperty("domainPasswordRulesFields")) {
                if (!Array.isArray(message.domainPasswordRulesFields))
                    return "domainPasswordRulesFields: array expected";
                for (let i = 0; i < message.domainPasswordRulesFields.length; ++i) {
                    let error = $root.Enterprise.DomainPasswordRulesFields.verify(message.domainPasswordRulesFields[i]);
                    if (error)
                        return "domainPasswordRulesFields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DomainPasswordRulesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.DomainPasswordRulesResponse} DomainPasswordRulesResponse
         */
        DomainPasswordRulesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.DomainPasswordRulesResponse)
                return object;
            let message = new $root.Enterprise.DomainPasswordRulesResponse();
            if (object.domainPasswordRulesFields) {
                if (!Array.isArray(object.domainPasswordRulesFields))
                    throw TypeError(".Enterprise.DomainPasswordRulesResponse.domainPasswordRulesFields: array expected");
                message.domainPasswordRulesFields = [];
                for (let i = 0; i < object.domainPasswordRulesFields.length; ++i) {
                    if (typeof object.domainPasswordRulesFields[i] !== "object")
                        throw TypeError(".Enterprise.DomainPasswordRulesResponse.domainPasswordRulesFields: object expected");
                    message.domainPasswordRulesFields[i] = $root.Enterprise.DomainPasswordRulesFields.fromObject(object.domainPasswordRulesFields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DomainPasswordRulesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @static
         * @param {Enterprise.DomainPasswordRulesResponse} message DomainPasswordRulesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DomainPasswordRulesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.domainPasswordRulesFields = [];
            if (message.domainPasswordRulesFields && message.domainPasswordRulesFields.length) {
                object.domainPasswordRulesFields = [];
                for (let j = 0; j < message.domainPasswordRulesFields.length; ++j)
                    object.domainPasswordRulesFields[j] = $root.Enterprise.DomainPasswordRulesFields.toObject(message.domainPasswordRulesFields[j], options);
            }
            return object;
        };

        /**
         * Converts this DomainPasswordRulesResponse to JSON.
         * @function toJSON
         * @memberof Enterprise.DomainPasswordRulesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DomainPasswordRulesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DomainPasswordRulesResponse;
    })();

    Enterprise.ApproveUserDeviceRequest = (function() {

        /**
         * Properties of an ApproveUserDeviceRequest.
         * @memberof Enterprise
         * @interface IApproveUserDeviceRequest
         * @property {number|Long|null} [enterpriseUserId] ApproveUserDeviceRequest enterpriseUserId
         * @property {Uint8Array|null} [encryptedDeviceToken] ApproveUserDeviceRequest encryptedDeviceToken
         * @property {Uint8Array|null} [encryptedDeviceDataKey] ApproveUserDeviceRequest encryptedDeviceDataKey
         * @property {boolean|null} [denyApproval] ApproveUserDeviceRequest denyApproval
         */

        /**
         * Constructs a new ApproveUserDeviceRequest.
         * @memberof Enterprise
         * @classdesc Represents an ApproveUserDeviceRequest.
         * @implements IApproveUserDeviceRequest
         * @constructor
         * @param {Enterprise.IApproveUserDeviceRequest=} [properties] Properties to set
         */
        function ApproveUserDeviceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveUserDeviceRequest enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @instance
         */
        ApproveUserDeviceRequest.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ApproveUserDeviceRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @instance
         */
        ApproveUserDeviceRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * ApproveUserDeviceRequest encryptedDeviceDataKey.
         * @member {Uint8Array} encryptedDeviceDataKey
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @instance
         */
        ApproveUserDeviceRequest.prototype.encryptedDeviceDataKey = $util.newBuffer([]);

        /**
         * ApproveUserDeviceRequest denyApproval.
         * @member {boolean} denyApproval
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @instance
         */
        ApproveUserDeviceRequest.prototype.denyApproval = false;

        /**
         * Creates a new ApproveUserDeviceRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Enterprise.IApproveUserDeviceRequest=} [properties] Properties to set
         * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest instance
         */
        ApproveUserDeviceRequest.create = function create(properties) {
            return new ApproveUserDeviceRequest(properties);
        };

        /**
         * Encodes the specified ApproveUserDeviceRequest message. Does not implicitly {@link Enterprise.ApproveUserDeviceRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Enterprise.IApproveUserDeviceRequest} message ApproveUserDeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDeviceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedDeviceDataKey);
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.denyApproval);
            return writer;
        };

        /**
         * Encodes the specified ApproveUserDeviceRequest message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDeviceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Enterprise.IApproveUserDeviceRequest} message ApproveUserDeviceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDeviceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveUserDeviceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDeviceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ApproveUserDeviceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 3:
                    message.encryptedDeviceDataKey = reader.bytes();
                    break;
                case 4:
                    message.denyApproval = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveUserDeviceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDeviceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveUserDeviceRequest message.
         * @function verify
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveUserDeviceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                if (!(message.encryptedDeviceDataKey && typeof message.encryptedDeviceDataKey.length === "number" || $util.isString(message.encryptedDeviceDataKey)))
                    return "encryptedDeviceDataKey: buffer expected";
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                if (typeof message.denyApproval !== "boolean")
                    return "denyApproval: boolean expected";
            return null;
        };

        /**
         * Creates an ApproveUserDeviceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ApproveUserDeviceRequest} ApproveUserDeviceRequest
         */
        ApproveUserDeviceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ApproveUserDeviceRequest)
                return object;
            let message = new $root.Enterprise.ApproveUserDeviceRequest();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.encryptedDeviceDataKey != null)
                if (typeof object.encryptedDeviceDataKey === "string")
                    $util.base64.decode(object.encryptedDeviceDataKey, message.encryptedDeviceDataKey = $util.newBuffer($util.base64.length(object.encryptedDeviceDataKey)), 0);
                else if (object.encryptedDeviceDataKey.length)
                    message.encryptedDeviceDataKey = object.encryptedDeviceDataKey;
            if (object.denyApproval != null)
                message.denyApproval = Boolean(object.denyApproval);
            return message;
        };

        /**
         * Creates a plain object from an ApproveUserDeviceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @static
         * @param {Enterprise.ApproveUserDeviceRequest} message ApproveUserDeviceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveUserDeviceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                if (options.bytes === String)
                    object.encryptedDeviceDataKey = "";
                else {
                    object.encryptedDeviceDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceDataKey = $util.newBuffer(object.encryptedDeviceDataKey);
                }
                object.denyApproval = false;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.encryptedDeviceDataKey != null && message.hasOwnProperty("encryptedDeviceDataKey"))
                object.encryptedDeviceDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDeviceDataKey, 0, message.encryptedDeviceDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceDataKey) : message.encryptedDeviceDataKey;
            if (message.denyApproval != null && message.hasOwnProperty("denyApproval"))
                object.denyApproval = message.denyApproval;
            return object;
        };

        /**
         * Converts this ApproveUserDeviceRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.ApproveUserDeviceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveUserDeviceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveUserDeviceRequest;
    })();

    Enterprise.ApproveUserDeviceResponse = (function() {

        /**
         * Properties of an ApproveUserDeviceResponse.
         * @memberof Enterprise
         * @interface IApproveUserDeviceResponse
         * @property {number|Long|null} [enterpriseUserId] ApproveUserDeviceResponse enterpriseUserId
         * @property {Uint8Array|null} [encryptedDeviceToken] ApproveUserDeviceResponse encryptedDeviceToken
         * @property {boolean|null} [failed] ApproveUserDeviceResponse failed
         * @property {string|null} [message] ApproveUserDeviceResponse message
         */

        /**
         * Constructs a new ApproveUserDeviceResponse.
         * @memberof Enterprise
         * @classdesc Represents an ApproveUserDeviceResponse.
         * @implements IApproveUserDeviceResponse
         * @constructor
         * @param {Enterprise.IApproveUserDeviceResponse=} [properties] Properties to set
         */
        function ApproveUserDeviceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveUserDeviceResponse enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @instance
         */
        ApproveUserDeviceResponse.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ApproveUserDeviceResponse encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @instance
         */
        ApproveUserDeviceResponse.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * ApproveUserDeviceResponse failed.
         * @member {boolean} failed
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @instance
         */
        ApproveUserDeviceResponse.prototype.failed = false;

        /**
         * ApproveUserDeviceResponse message.
         * @member {string} message
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @instance
         */
        ApproveUserDeviceResponse.prototype.message = "";

        /**
         * Creates a new ApproveUserDeviceResponse instance using the specified properties.
         * @function create
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Enterprise.IApproveUserDeviceResponse=} [properties] Properties to set
         * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse instance
         */
        ApproveUserDeviceResponse.create = function create(properties) {
            return new ApproveUserDeviceResponse(properties);
        };

        /**
         * Encodes the specified ApproveUserDeviceResponse message. Does not implicitly {@link Enterprise.ApproveUserDeviceResponse.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Enterprise.IApproveUserDeviceResponse} message ApproveUserDeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDeviceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            if (message.failed != null && message.hasOwnProperty("failed"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.failed);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified ApproveUserDeviceResponse message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDeviceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Enterprise.IApproveUserDeviceResponse} message ApproveUserDeviceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDeviceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveUserDeviceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDeviceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ApproveUserDeviceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 3:
                    message.failed = reader.bool();
                    break;
                case 4:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveUserDeviceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDeviceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveUserDeviceResponse message.
         * @function verify
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveUserDeviceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.failed != null && message.hasOwnProperty("failed"))
                if (typeof message.failed !== "boolean")
                    return "failed: boolean expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates an ApproveUserDeviceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ApproveUserDeviceResponse} ApproveUserDeviceResponse
         */
        ApproveUserDeviceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ApproveUserDeviceResponse)
                return object;
            let message = new $root.Enterprise.ApproveUserDeviceResponse();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.failed != null)
                message.failed = Boolean(object.failed);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from an ApproveUserDeviceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @static
         * @param {Enterprise.ApproveUserDeviceResponse} message ApproveUserDeviceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveUserDeviceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.failed = false;
                object.message = "";
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.failed != null && message.hasOwnProperty("failed"))
                object.failed = message.failed;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this ApproveUserDeviceResponse to JSON.
         * @function toJSON
         * @memberof Enterprise.ApproveUserDeviceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveUserDeviceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveUserDeviceResponse;
    })();

    Enterprise.ApproveUserDevicesRequest = (function() {

        /**
         * Properties of an ApproveUserDevicesRequest.
         * @memberof Enterprise
         * @interface IApproveUserDevicesRequest
         * @property {Array.<Enterprise.IApproveUserDeviceRequest>|null} [deviceRequests] ApproveUserDevicesRequest deviceRequests
         */

        /**
         * Constructs a new ApproveUserDevicesRequest.
         * @memberof Enterprise
         * @classdesc Represents an ApproveUserDevicesRequest.
         * @implements IApproveUserDevicesRequest
         * @constructor
         * @param {Enterprise.IApproveUserDevicesRequest=} [properties] Properties to set
         */
        function ApproveUserDevicesRequest(properties) {
            this.deviceRequests = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveUserDevicesRequest deviceRequests.
         * @member {Array.<Enterprise.IApproveUserDeviceRequest>} deviceRequests
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @instance
         */
        ApproveUserDevicesRequest.prototype.deviceRequests = $util.emptyArray;

        /**
         * Creates a new ApproveUserDevicesRequest instance using the specified properties.
         * @function create
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Enterprise.IApproveUserDevicesRequest=} [properties] Properties to set
         * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest instance
         */
        ApproveUserDevicesRequest.create = function create(properties) {
            return new ApproveUserDevicesRequest(properties);
        };

        /**
         * Encodes the specified ApproveUserDevicesRequest message. Does not implicitly {@link Enterprise.ApproveUserDevicesRequest.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Enterprise.IApproveUserDevicesRequest} message ApproveUserDevicesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDevicesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceRequests != null && message.deviceRequests.length)
                for (let i = 0; i < message.deviceRequests.length; ++i)
                    $root.Enterprise.ApproveUserDeviceRequest.encode(message.deviceRequests[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApproveUserDevicesRequest message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDevicesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Enterprise.IApproveUserDevicesRequest} message ApproveUserDevicesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDevicesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveUserDevicesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDevicesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ApproveUserDevicesRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.deviceRequests && message.deviceRequests.length))
                        message.deviceRequests = [];
                    message.deviceRequests.push($root.Enterprise.ApproveUserDeviceRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveUserDevicesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDevicesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveUserDevicesRequest message.
         * @function verify
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveUserDevicesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceRequests != null && message.hasOwnProperty("deviceRequests")) {
                if (!Array.isArray(message.deviceRequests))
                    return "deviceRequests: array expected";
                for (let i = 0; i < message.deviceRequests.length; ++i) {
                    let error = $root.Enterprise.ApproveUserDeviceRequest.verify(message.deviceRequests[i]);
                    if (error)
                        return "deviceRequests." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApproveUserDevicesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ApproveUserDevicesRequest} ApproveUserDevicesRequest
         */
        ApproveUserDevicesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ApproveUserDevicesRequest)
                return object;
            let message = new $root.Enterprise.ApproveUserDevicesRequest();
            if (object.deviceRequests) {
                if (!Array.isArray(object.deviceRequests))
                    throw TypeError(".Enterprise.ApproveUserDevicesRequest.deviceRequests: array expected");
                message.deviceRequests = [];
                for (let i = 0; i < object.deviceRequests.length; ++i) {
                    if (typeof object.deviceRequests[i] !== "object")
                        throw TypeError(".Enterprise.ApproveUserDevicesRequest.deviceRequests: object expected");
                    message.deviceRequests[i] = $root.Enterprise.ApproveUserDeviceRequest.fromObject(object.deviceRequests[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApproveUserDevicesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @static
         * @param {Enterprise.ApproveUserDevicesRequest} message ApproveUserDevicesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveUserDevicesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.deviceRequests = [];
            if (message.deviceRequests && message.deviceRequests.length) {
                object.deviceRequests = [];
                for (let j = 0; j < message.deviceRequests.length; ++j)
                    object.deviceRequests[j] = $root.Enterprise.ApproveUserDeviceRequest.toObject(message.deviceRequests[j], options);
            }
            return object;
        };

        /**
         * Converts this ApproveUserDevicesRequest to JSON.
         * @function toJSON
         * @memberof Enterprise.ApproveUserDevicesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveUserDevicesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveUserDevicesRequest;
    })();

    Enterprise.ApproveUserDevicesResponse = (function() {

        /**
         * Properties of an ApproveUserDevicesResponse.
         * @memberof Enterprise
         * @interface IApproveUserDevicesResponse
         * @property {Array.<Enterprise.IApproveUserDeviceResponse>|null} [deviceResponses] ApproveUserDevicesResponse deviceResponses
         */

        /**
         * Constructs a new ApproveUserDevicesResponse.
         * @memberof Enterprise
         * @classdesc Represents an ApproveUserDevicesResponse.
         * @implements IApproveUserDevicesResponse
         * @constructor
         * @param {Enterprise.IApproveUserDevicesResponse=} [properties] Properties to set
         */
        function ApproveUserDevicesResponse(properties) {
            this.deviceResponses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApproveUserDevicesResponse deviceResponses.
         * @member {Array.<Enterprise.IApproveUserDeviceResponse>} deviceResponses
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @instance
         */
        ApproveUserDevicesResponse.prototype.deviceResponses = $util.emptyArray;

        /**
         * Creates a new ApproveUserDevicesResponse instance using the specified properties.
         * @function create
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Enterprise.IApproveUserDevicesResponse=} [properties] Properties to set
         * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse instance
         */
        ApproveUserDevicesResponse.create = function create(properties) {
            return new ApproveUserDevicesResponse(properties);
        };

        /**
         * Encodes the specified ApproveUserDevicesResponse message. Does not implicitly {@link Enterprise.ApproveUserDevicesResponse.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Enterprise.IApproveUserDevicesResponse} message ApproveUserDevicesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDevicesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceResponses != null && message.deviceResponses.length)
                for (let i = 0; i < message.deviceResponses.length; ++i)
                    $root.Enterprise.ApproveUserDeviceResponse.encode(message.deviceResponses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApproveUserDevicesResponse message, length delimited. Does not implicitly {@link Enterprise.ApproveUserDevicesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Enterprise.IApproveUserDevicesResponse} message ApproveUserDevicesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApproveUserDevicesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApproveUserDevicesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDevicesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.ApproveUserDevicesResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.deviceResponses && message.deviceResponses.length))
                        message.deviceResponses = [];
                    message.deviceResponses.push($root.Enterprise.ApproveUserDeviceResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApproveUserDevicesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApproveUserDevicesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApproveUserDevicesResponse message.
         * @function verify
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApproveUserDevicesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceResponses != null && message.hasOwnProperty("deviceResponses")) {
                if (!Array.isArray(message.deviceResponses))
                    return "deviceResponses: array expected";
                for (let i = 0; i < message.deviceResponses.length; ++i) {
                    let error = $root.Enterprise.ApproveUserDeviceResponse.verify(message.deviceResponses[i]);
                    if (error)
                        return "deviceResponses." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ApproveUserDevicesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.ApproveUserDevicesResponse} ApproveUserDevicesResponse
         */
        ApproveUserDevicesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.ApproveUserDevicesResponse)
                return object;
            let message = new $root.Enterprise.ApproveUserDevicesResponse();
            if (object.deviceResponses) {
                if (!Array.isArray(object.deviceResponses))
                    throw TypeError(".Enterprise.ApproveUserDevicesResponse.deviceResponses: array expected");
                message.deviceResponses = [];
                for (let i = 0; i < object.deviceResponses.length; ++i) {
                    if (typeof object.deviceResponses[i] !== "object")
                        throw TypeError(".Enterprise.ApproveUserDevicesResponse.deviceResponses: object expected");
                    message.deviceResponses[i] = $root.Enterprise.ApproveUserDeviceResponse.fromObject(object.deviceResponses[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ApproveUserDevicesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @static
         * @param {Enterprise.ApproveUserDevicesResponse} message ApproveUserDevicesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApproveUserDevicesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.deviceResponses = [];
            if (message.deviceResponses && message.deviceResponses.length) {
                object.deviceResponses = [];
                for (let j = 0; j < message.deviceResponses.length; ++j)
                    object.deviceResponses[j] = $root.Enterprise.ApproveUserDeviceResponse.toObject(message.deviceResponses[j], options);
            }
            return object;
        };

        /**
         * Converts this ApproveUserDevicesResponse to JSON.
         * @function toJSON
         * @memberof Enterprise.ApproveUserDevicesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApproveUserDevicesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApproveUserDevicesResponse;
    })();

    Enterprise.EnterpriseUserDataKey = (function() {

        /**
         * Properties of an EnterpriseUserDataKey.
         * @memberof Enterprise
         * @interface IEnterpriseUserDataKey
         * @property {number|Long|null} [enterpriseUserId] EnterpriseUserDataKey enterpriseUserId
         * @property {Uint8Array|null} [userEncryptedDataKey] EnterpriseUserDataKey userEncryptedDataKey
         * @property {number|null} [keyTypeId] EnterpriseUserDataKey keyTypeId
         */

        /**
         * Constructs a new EnterpriseUserDataKey.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseUserDataKey.
         * @implements IEnterpriseUserDataKey
         * @constructor
         * @param {Enterprise.IEnterpriseUserDataKey=} [properties] Properties to set
         */
        function EnterpriseUserDataKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUserDataKey enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Enterprise.EnterpriseUserDataKey
         * @instance
         */
        EnterpriseUserDataKey.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterpriseUserDataKey userEncryptedDataKey.
         * @member {Uint8Array} userEncryptedDataKey
         * @memberof Enterprise.EnterpriseUserDataKey
         * @instance
         */
        EnterpriseUserDataKey.prototype.userEncryptedDataKey = $util.newBuffer([]);

        /**
         * EnterpriseUserDataKey keyTypeId.
         * @member {number} keyTypeId
         * @memberof Enterprise.EnterpriseUserDataKey
         * @instance
         */
        EnterpriseUserDataKey.prototype.keyTypeId = 0;

        /**
         * Creates a new EnterpriseUserDataKey instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Enterprise.IEnterpriseUserDataKey=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey instance
         */
        EnterpriseUserDataKey.create = function create(properties) {
            return new EnterpriseUserDataKey(properties);
        };

        /**
         * Encodes the specified EnterpriseUserDataKey message. Does not implicitly {@link Enterprise.EnterpriseUserDataKey.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Enterprise.IEnterpriseUserDataKey} message EnterpriseUserDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserDataKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.userEncryptedDataKey);
            if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.keyTypeId);
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUserDataKey message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Enterprise.IEnterpriseUserDataKey} message EnterpriseUserDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserDataKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUserDataKey message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserDataKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseUserDataKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.userEncryptedDataKey = reader.bytes();
                    break;
                case 3:
                    message.keyTypeId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUserDataKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserDataKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUserDataKey message.
         * @function verify
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUserDataKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
                if (!(message.userEncryptedDataKey && typeof message.userEncryptedDataKey.length === "number" || $util.isString(message.userEncryptedDataKey)))
                    return "userEncryptedDataKey: buffer expected";
            if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
                if (!$util.isInteger(message.keyTypeId))
                    return "keyTypeId: integer expected";
            return null;
        };

        /**
         * Creates an EnterpriseUserDataKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseUserDataKey} EnterpriseUserDataKey
         */
        EnterpriseUserDataKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseUserDataKey)
                return object;
            let message = new $root.Enterprise.EnterpriseUserDataKey();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.userEncryptedDataKey != null)
                if (typeof object.userEncryptedDataKey === "string")
                    $util.base64.decode(object.userEncryptedDataKey, message.userEncryptedDataKey = $util.newBuffer($util.base64.length(object.userEncryptedDataKey)), 0);
                else if (object.userEncryptedDataKey.length)
                    message.userEncryptedDataKey = object.userEncryptedDataKey;
            if (object.keyTypeId != null)
                message.keyTypeId = object.keyTypeId | 0;
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUserDataKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseUserDataKey
         * @static
         * @param {Enterprise.EnterpriseUserDataKey} message EnterpriseUserDataKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUserDataKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.userEncryptedDataKey = "";
                else {
                    object.userEncryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.userEncryptedDataKey = $util.newBuffer(object.userEncryptedDataKey);
                }
                object.keyTypeId = 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.userEncryptedDataKey != null && message.hasOwnProperty("userEncryptedDataKey"))
                object.userEncryptedDataKey = options.bytes === String ? $util.base64.encode(message.userEncryptedDataKey, 0, message.userEncryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.userEncryptedDataKey) : message.userEncryptedDataKey;
            if (message.keyTypeId != null && message.hasOwnProperty("keyTypeId"))
                object.keyTypeId = message.keyTypeId;
            return object;
        };

        /**
         * Converts this EnterpriseUserDataKey to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseUserDataKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUserDataKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUserDataKey;
    })();

    Enterprise.EnterpriseUserDataKeys = (function() {

        /**
         * Properties of an EnterpriseUserDataKeys.
         * @memberof Enterprise
         * @interface IEnterpriseUserDataKeys
         * @property {Array.<Enterprise.IEnterpriseUserDataKey>|null} [keys] EnterpriseUserDataKeys keys
         */

        /**
         * Constructs a new EnterpriseUserDataKeys.
         * @memberof Enterprise
         * @classdesc Represents an EnterpriseUserDataKeys.
         * @implements IEnterpriseUserDataKeys
         * @constructor
         * @param {Enterprise.IEnterpriseUserDataKeys=} [properties] Properties to set
         */
        function EnterpriseUserDataKeys(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterpriseUserDataKeys keys.
         * @member {Array.<Enterprise.IEnterpriseUserDataKey>} keys
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @instance
         */
        EnterpriseUserDataKeys.prototype.keys = $util.emptyArray;

        /**
         * Creates a new EnterpriseUserDataKeys instance using the specified properties.
         * @function create
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Enterprise.IEnterpriseUserDataKeys=} [properties] Properties to set
         * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys instance
         */
        EnterpriseUserDataKeys.create = function create(properties) {
            return new EnterpriseUserDataKeys(properties);
        };

        /**
         * Encodes the specified EnterpriseUserDataKeys message. Does not implicitly {@link Enterprise.EnterpriseUserDataKeys.verify|verify} messages.
         * @function encode
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Enterprise.IEnterpriseUserDataKeys} message EnterpriseUserDataKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserDataKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keys != null && message.keys.length)
                for (let i = 0; i < message.keys.length; ++i)
                    $root.Enterprise.EnterpriseUserDataKey.encode(message.keys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EnterpriseUserDataKeys message, length delimited. Does not implicitly {@link Enterprise.EnterpriseUserDataKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Enterprise.IEnterpriseUserDataKeys} message EnterpriseUserDataKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterpriseUserDataKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterpriseUserDataKeys message from the specified reader or buffer.
         * @function decode
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserDataKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Enterprise.EnterpriseUserDataKeys();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.Enterprise.EnterpriseUserDataKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterpriseUserDataKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterpriseUserDataKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterpriseUserDataKeys message.
         * @function verify
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterpriseUserDataKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (let i = 0; i < message.keys.length; ++i) {
                    let error = $root.Enterprise.EnterpriseUserDataKey.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates an EnterpriseUserDataKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Enterprise.EnterpriseUserDataKeys} EnterpriseUserDataKeys
         */
        EnterpriseUserDataKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.Enterprise.EnterpriseUserDataKeys)
                return object;
            let message = new $root.Enterprise.EnterpriseUserDataKeys();
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".Enterprise.EnterpriseUserDataKeys.keys: array expected");
                message.keys = [];
                for (let i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".Enterprise.EnterpriseUserDataKeys.keys: object expected");
                    message.keys[i] = $root.Enterprise.EnterpriseUserDataKey.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an EnterpriseUserDataKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @static
         * @param {Enterprise.EnterpriseUserDataKeys} message EnterpriseUserDataKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterpriseUserDataKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (let j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.Enterprise.EnterpriseUserDataKey.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this EnterpriseUserDataKeys to JSON.
         * @function toJSON
         * @memberof Enterprise.EnterpriseUserDataKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterpriseUserDataKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterpriseUserDataKeys;
    })();

    return Enterprise;
})();

export const AccountSummary = $root.AccountSummary = (() => {

    /**
     * Namespace AccountSummary.
     * @exports AccountSummary
     * @namespace
     */
    const AccountSummary = {};

    AccountSummary.AccountSummaryRequest = (function() {

        /**
         * Properties of an AccountSummaryRequest.
         * @memberof AccountSummary
         * @interface IAccountSummaryRequest
         * @property {number|null} [summaryVersion] AccountSummaryRequest summaryVersion
         */

        /**
         * Constructs a new AccountSummaryRequest.
         * @memberof AccountSummary
         * @classdesc Represents an AccountSummaryRequest.
         * @implements IAccountSummaryRequest
         * @constructor
         * @param {AccountSummary.IAccountSummaryRequest=} [properties] Properties to set
         */
        function AccountSummaryRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSummaryRequest summaryVersion.
         * @member {number} summaryVersion
         * @memberof AccountSummary.AccountSummaryRequest
         * @instance
         */
        AccountSummaryRequest.prototype.summaryVersion = 0;

        /**
         * Creates a new AccountSummaryRequest instance using the specified properties.
         * @function create
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {AccountSummary.IAccountSummaryRequest=} [properties] Properties to set
         * @returns {AccountSummary.AccountSummaryRequest} AccountSummaryRequest instance
         */
        AccountSummaryRequest.create = function create(properties) {
            return new AccountSummaryRequest(properties);
        };

        /**
         * Encodes the specified AccountSummaryRequest message. Does not implicitly {@link AccountSummary.AccountSummaryRequest.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {AccountSummary.IAccountSummaryRequest} message AccountSummaryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.summaryVersion != null && message.hasOwnProperty("summaryVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.summaryVersion);
            return writer;
        };

        /**
         * Encodes the specified AccountSummaryRequest message, length delimited. Does not implicitly {@link AccountSummary.AccountSummaryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {AccountSummary.IAccountSummaryRequest} message AccountSummaryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSummaryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.AccountSummaryRequest} AccountSummaryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.AccountSummaryRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.summaryVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSummaryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.AccountSummaryRequest} AccountSummaryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSummaryRequest message.
         * @function verify
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSummaryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.summaryVersion != null && message.hasOwnProperty("summaryVersion"))
                if (!$util.isInteger(message.summaryVersion))
                    return "summaryVersion: integer expected";
            return null;
        };

        /**
         * Creates an AccountSummaryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.AccountSummaryRequest} AccountSummaryRequest
         */
        AccountSummaryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.AccountSummaryRequest)
                return object;
            let message = new $root.AccountSummary.AccountSummaryRequest();
            if (object.summaryVersion != null)
                message.summaryVersion = object.summaryVersion | 0;
            return message;
        };

        /**
         * Creates a plain object from an AccountSummaryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.AccountSummaryRequest
         * @static
         * @param {AccountSummary.AccountSummaryRequest} message AccountSummaryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSummaryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.summaryVersion = 0;
            if (message.summaryVersion != null && message.hasOwnProperty("summaryVersion"))
                object.summaryVersion = message.summaryVersion;
            return object;
        };

        /**
         * Converts this AccountSummaryRequest to JSON.
         * @function toJSON
         * @memberof AccountSummary.AccountSummaryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSummaryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountSummaryRequest;
    })();

    AccountSummary.AccountSummaryElements = (function() {

        /**
         * Properties of an AccountSummaryElements.
         * @memberof AccountSummary
         * @interface IAccountSummaryElements
         * @property {Uint8Array|null} [clientKey] AccountSummaryElements clientKey
         * @property {AccountSummary.ISettings|null} [settings] AccountSummaryElements settings
         * @property {AccountSummary.IKeysInfo|null} [keysInfo] AccountSummaryElements keysInfo
         * @property {Array.<AccountSummary.ISyncLog>|null} [syncLogs] AccountSummaryElements syncLogs
         * @property {boolean|null} [isEnterpriseAdmin] AccountSummaryElements isEnterpriseAdmin
         * @property {AccountSummary.ILicense|null} [license] AccountSummaryElements license
         * @property {AccountSummary.IGroup|null} [group] AccountSummaryElements group
         * @property {AccountSummary.IEnforcements|null} [Enforcements] AccountSummaryElements Enforcements
         * @property {Array.<AccountSummary.IKeyValue>|null} [Images] AccountSummaryElements Images
         * @property {AccountSummary.ILicense|null} [personalLicense] AccountSummaryElements personalLicense
         * @property {boolean|null} [fixSharedFolderRecords] AccountSummaryElements fixSharedFolderRecords
         * @property {Array.<string>|null} [usernames] AccountSummaryElements usernames
         * @property {Array.<AccountSummary.IDeviceInfo>|null} [devices] AccountSummaryElements devices
         */

        /**
         * Constructs a new AccountSummaryElements.
         * @memberof AccountSummary
         * @classdesc Represents an AccountSummaryElements.
         * @implements IAccountSummaryElements
         * @constructor
         * @param {AccountSummary.IAccountSummaryElements=} [properties] Properties to set
         */
        function AccountSummaryElements(properties) {
            this.syncLogs = [];
            this.Images = [];
            this.usernames = [];
            this.devices = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSummaryElements clientKey.
         * @member {Uint8Array} clientKey
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.clientKey = $util.newBuffer([]);

        /**
         * AccountSummaryElements settings.
         * @member {AccountSummary.ISettings|null|undefined} settings
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.settings = null;

        /**
         * AccountSummaryElements keysInfo.
         * @member {AccountSummary.IKeysInfo|null|undefined} keysInfo
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.keysInfo = null;

        /**
         * AccountSummaryElements syncLogs.
         * @member {Array.<AccountSummary.ISyncLog>} syncLogs
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.syncLogs = $util.emptyArray;

        /**
         * AccountSummaryElements isEnterpriseAdmin.
         * @member {boolean} isEnterpriseAdmin
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.isEnterpriseAdmin = false;

        /**
         * AccountSummaryElements license.
         * @member {AccountSummary.ILicense|null|undefined} license
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.license = null;

        /**
         * AccountSummaryElements group.
         * @member {AccountSummary.IGroup|null|undefined} group
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.group = null;

        /**
         * AccountSummaryElements Enforcements.
         * @member {AccountSummary.IEnforcements|null|undefined} Enforcements
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.Enforcements = null;

        /**
         * AccountSummaryElements Images.
         * @member {Array.<AccountSummary.IKeyValue>} Images
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.Images = $util.emptyArray;

        /**
         * AccountSummaryElements personalLicense.
         * @member {AccountSummary.ILicense|null|undefined} personalLicense
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.personalLicense = null;

        /**
         * AccountSummaryElements fixSharedFolderRecords.
         * @member {boolean} fixSharedFolderRecords
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.fixSharedFolderRecords = false;

        /**
         * AccountSummaryElements usernames.
         * @member {Array.<string>} usernames
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.usernames = $util.emptyArray;

        /**
         * AccountSummaryElements devices.
         * @member {Array.<AccountSummary.IDeviceInfo>} devices
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         */
        AccountSummaryElements.prototype.devices = $util.emptyArray;

        /**
         * Creates a new AccountSummaryElements instance using the specified properties.
         * @function create
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements=} [properties] Properties to set
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements instance
         */
        AccountSummaryElements.create = function create(properties) {
            return new AccountSummaryElements(properties);
        };

        /**
         * Encodes the specified AccountSummaryElements message. Does not implicitly {@link AccountSummary.AccountSummaryElements.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements} message AccountSummaryElements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryElements.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.clientKey);
            if (message.settings != null && message.hasOwnProperty("settings"))
                $root.AccountSummary.Settings.encode(message.settings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo"))
                $root.AccountSummary.KeysInfo.encode(message.keysInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.syncLogs != null && message.syncLogs.length)
                for (let i = 0; i < message.syncLogs.length; ++i)
                    $root.AccountSummary.SyncLog.encode(message.syncLogs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isEnterpriseAdmin);
            if (message.license != null && message.hasOwnProperty("license"))
                $root.AccountSummary.License.encode(message.license, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.group != null && message.hasOwnProperty("group"))
                $root.AccountSummary.Group.encode(message.group, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.Enforcements != null && message.hasOwnProperty("Enforcements"))
                $root.AccountSummary.Enforcements.encode(message.Enforcements, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.Images != null && message.Images.length)
                for (let i = 0; i < message.Images.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.Images[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.personalLicense != null && message.hasOwnProperty("personalLicense"))
                $root.AccountSummary.License.encode(message.personalLicense, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.fixSharedFolderRecords != null && message.hasOwnProperty("fixSharedFolderRecords"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.fixSharedFolderRecords);
            if (message.usernames != null && message.usernames.length)
                for (let i = 0; i < message.usernames.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.usernames[i]);
            if (message.devices != null && message.devices.length)
                for (let i = 0; i < message.devices.length; ++i)
                    $root.AccountSummary.DeviceInfo.encode(message.devices[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountSummaryElements message, length delimited. Does not implicitly {@link AccountSummary.AccountSummaryElements.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.IAccountSummaryElements} message AccountSummaryElements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSummaryElements.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSummaryElements message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryElements.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.AccountSummaryElements();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.clientKey = reader.bytes();
                    break;
                case 2:
                    message.settings = $root.AccountSummary.Settings.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.keysInfo = $root.AccountSummary.KeysInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.syncLogs && message.syncLogs.length))
                        message.syncLogs = [];
                    message.syncLogs.push($root.AccountSummary.SyncLog.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.isEnterpriseAdmin = reader.bool();
                    break;
                case 6:
                    message.license = $root.AccountSummary.License.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.group = $root.AccountSummary.Group.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.Enforcements = $root.AccountSummary.Enforcements.decode(reader, reader.uint32());
                    break;
                case 9:
                    if (!(message.Images && message.Images.length))
                        message.Images = [];
                    message.Images.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.personalLicense = $root.AccountSummary.License.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.fixSharedFolderRecords = reader.bool();
                    break;
                case 12:
                    if (!(message.usernames && message.usernames.length))
                        message.usernames = [];
                    message.usernames.push(reader.string());
                    break;
                case 13:
                    if (!(message.devices && message.devices.length))
                        message.devices = [];
                    message.devices.push($root.AccountSummary.DeviceInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSummaryElements message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSummaryElements.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSummaryElements message.
         * @function verify
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSummaryElements.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                if (!(message.clientKey && typeof message.clientKey.length === "number" || $util.isString(message.clientKey)))
                    return "clientKey: buffer expected";
            if (message.settings != null && message.hasOwnProperty("settings")) {
                let error = $root.AccountSummary.Settings.verify(message.settings);
                if (error)
                    return "settings." + error;
            }
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo")) {
                let error = $root.AccountSummary.KeysInfo.verify(message.keysInfo);
                if (error)
                    return "keysInfo." + error;
            }
            if (message.syncLogs != null && message.hasOwnProperty("syncLogs")) {
                if (!Array.isArray(message.syncLogs))
                    return "syncLogs: array expected";
                for (let i = 0; i < message.syncLogs.length; ++i) {
                    let error = $root.AccountSummary.SyncLog.verify(message.syncLogs[i]);
                    if (error)
                        return "syncLogs." + error;
                }
            }
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                if (typeof message.isEnterpriseAdmin !== "boolean")
                    return "isEnterpriseAdmin: boolean expected";
            if (message.license != null && message.hasOwnProperty("license")) {
                let error = $root.AccountSummary.License.verify(message.license);
                if (error)
                    return "license." + error;
            }
            if (message.group != null && message.hasOwnProperty("group")) {
                let error = $root.AccountSummary.Group.verify(message.group);
                if (error)
                    return "group." + error;
            }
            if (message.Enforcements != null && message.hasOwnProperty("Enforcements")) {
                let error = $root.AccountSummary.Enforcements.verify(message.Enforcements);
                if (error)
                    return "Enforcements." + error;
            }
            if (message.Images != null && message.hasOwnProperty("Images")) {
                if (!Array.isArray(message.Images))
                    return "Images: array expected";
                for (let i = 0; i < message.Images.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.Images[i]);
                    if (error)
                        return "Images." + error;
                }
            }
            if (message.personalLicense != null && message.hasOwnProperty("personalLicense")) {
                let error = $root.AccountSummary.License.verify(message.personalLicense);
                if (error)
                    return "personalLicense." + error;
            }
            if (message.fixSharedFolderRecords != null && message.hasOwnProperty("fixSharedFolderRecords"))
                if (typeof message.fixSharedFolderRecords !== "boolean")
                    return "fixSharedFolderRecords: boolean expected";
            if (message.usernames != null && message.hasOwnProperty("usernames")) {
                if (!Array.isArray(message.usernames))
                    return "usernames: array expected";
                for (let i = 0; i < message.usernames.length; ++i)
                    if (!$util.isString(message.usernames[i]))
                        return "usernames: string[] expected";
            }
            if (message.devices != null && message.hasOwnProperty("devices")) {
                if (!Array.isArray(message.devices))
                    return "devices: array expected";
                for (let i = 0; i < message.devices.length; ++i) {
                    let error = $root.AccountSummary.DeviceInfo.verify(message.devices[i]);
                    if (error)
                        return "devices." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountSummaryElements message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.AccountSummaryElements} AccountSummaryElements
         */
        AccountSummaryElements.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.AccountSummaryElements)
                return object;
            let message = new $root.AccountSummary.AccountSummaryElements();
            if (object.clientKey != null)
                if (typeof object.clientKey === "string")
                    $util.base64.decode(object.clientKey, message.clientKey = $util.newBuffer($util.base64.length(object.clientKey)), 0);
                else if (object.clientKey.length)
                    message.clientKey = object.clientKey;
            if (object.settings != null) {
                if (typeof object.settings !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.settings: object expected");
                message.settings = $root.AccountSummary.Settings.fromObject(object.settings);
            }
            if (object.keysInfo != null) {
                if (typeof object.keysInfo !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.keysInfo: object expected");
                message.keysInfo = $root.AccountSummary.KeysInfo.fromObject(object.keysInfo);
            }
            if (object.syncLogs) {
                if (!Array.isArray(object.syncLogs))
                    throw TypeError(".AccountSummary.AccountSummaryElements.syncLogs: array expected");
                message.syncLogs = [];
                for (let i = 0; i < object.syncLogs.length; ++i) {
                    if (typeof object.syncLogs[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.syncLogs: object expected");
                    message.syncLogs[i] = $root.AccountSummary.SyncLog.fromObject(object.syncLogs[i]);
                }
            }
            if (object.isEnterpriseAdmin != null)
                message.isEnterpriseAdmin = Boolean(object.isEnterpriseAdmin);
            if (object.license != null) {
                if (typeof object.license !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.license: object expected");
                message.license = $root.AccountSummary.License.fromObject(object.license);
            }
            if (object.group != null) {
                if (typeof object.group !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.group: object expected");
                message.group = $root.AccountSummary.Group.fromObject(object.group);
            }
            if (object.Enforcements != null) {
                if (typeof object.Enforcements !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.Enforcements: object expected");
                message.Enforcements = $root.AccountSummary.Enforcements.fromObject(object.Enforcements);
            }
            if (object.Images) {
                if (!Array.isArray(object.Images))
                    throw TypeError(".AccountSummary.AccountSummaryElements.Images: array expected");
                message.Images = [];
                for (let i = 0; i < object.Images.length; ++i) {
                    if (typeof object.Images[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.Images: object expected");
                    message.Images[i] = $root.AccountSummary.KeyValue.fromObject(object.Images[i]);
                }
            }
            if (object.personalLicense != null) {
                if (typeof object.personalLicense !== "object")
                    throw TypeError(".AccountSummary.AccountSummaryElements.personalLicense: object expected");
                message.personalLicense = $root.AccountSummary.License.fromObject(object.personalLicense);
            }
            if (object.fixSharedFolderRecords != null)
                message.fixSharedFolderRecords = Boolean(object.fixSharedFolderRecords);
            if (object.usernames) {
                if (!Array.isArray(object.usernames))
                    throw TypeError(".AccountSummary.AccountSummaryElements.usernames: array expected");
                message.usernames = [];
                for (let i = 0; i < object.usernames.length; ++i)
                    message.usernames[i] = String(object.usernames[i]);
            }
            if (object.devices) {
                if (!Array.isArray(object.devices))
                    throw TypeError(".AccountSummary.AccountSummaryElements.devices: array expected");
                message.devices = [];
                for (let i = 0; i < object.devices.length; ++i) {
                    if (typeof object.devices[i] !== "object")
                        throw TypeError(".AccountSummary.AccountSummaryElements.devices: object expected");
                    message.devices[i] = $root.AccountSummary.DeviceInfo.fromObject(object.devices[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountSummaryElements message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.AccountSummaryElements
         * @static
         * @param {AccountSummary.AccountSummaryElements} message AccountSummaryElements
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSummaryElements.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.syncLogs = [];
                object.Images = [];
                object.usernames = [];
                object.devices = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.clientKey = "";
                else {
                    object.clientKey = [];
                    if (options.bytes !== Array)
                        object.clientKey = $util.newBuffer(object.clientKey);
                }
                object.settings = null;
                object.keysInfo = null;
                object.isEnterpriseAdmin = false;
                object.license = null;
                object.group = null;
                object.Enforcements = null;
                object.personalLicense = null;
                object.fixSharedFolderRecords = false;
            }
            if (message.clientKey != null && message.hasOwnProperty("clientKey"))
                object.clientKey = options.bytes === String ? $util.base64.encode(message.clientKey, 0, message.clientKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.clientKey) : message.clientKey;
            if (message.settings != null && message.hasOwnProperty("settings"))
                object.settings = $root.AccountSummary.Settings.toObject(message.settings, options);
            if (message.keysInfo != null && message.hasOwnProperty("keysInfo"))
                object.keysInfo = $root.AccountSummary.KeysInfo.toObject(message.keysInfo, options);
            if (message.syncLogs && message.syncLogs.length) {
                object.syncLogs = [];
                for (let j = 0; j < message.syncLogs.length; ++j)
                    object.syncLogs[j] = $root.AccountSummary.SyncLog.toObject(message.syncLogs[j], options);
            }
            if (message.isEnterpriseAdmin != null && message.hasOwnProperty("isEnterpriseAdmin"))
                object.isEnterpriseAdmin = message.isEnterpriseAdmin;
            if (message.license != null && message.hasOwnProperty("license"))
                object.license = $root.AccountSummary.License.toObject(message.license, options);
            if (message.group != null && message.hasOwnProperty("group"))
                object.group = $root.AccountSummary.Group.toObject(message.group, options);
            if (message.Enforcements != null && message.hasOwnProperty("Enforcements"))
                object.Enforcements = $root.AccountSummary.Enforcements.toObject(message.Enforcements, options);
            if (message.Images && message.Images.length) {
                object.Images = [];
                for (let j = 0; j < message.Images.length; ++j)
                    object.Images[j] = $root.AccountSummary.KeyValue.toObject(message.Images[j], options);
            }
            if (message.personalLicense != null && message.hasOwnProperty("personalLicense"))
                object.personalLicense = $root.AccountSummary.License.toObject(message.personalLicense, options);
            if (message.fixSharedFolderRecords != null && message.hasOwnProperty("fixSharedFolderRecords"))
                object.fixSharedFolderRecords = message.fixSharedFolderRecords;
            if (message.usernames && message.usernames.length) {
                object.usernames = [];
                for (let j = 0; j < message.usernames.length; ++j)
                    object.usernames[j] = message.usernames[j];
            }
            if (message.devices && message.devices.length) {
                object.devices = [];
                for (let j = 0; j < message.devices.length; ++j)
                    object.devices[j] = $root.AccountSummary.DeviceInfo.toObject(message.devices[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountSummaryElements to JSON.
         * @function toJSON
         * @memberof AccountSummary.AccountSummaryElements
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSummaryElements.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountSummaryElements;
    })();

    AccountSummary.DeviceInfo = (function() {

        /**
         * Properties of a DeviceInfo.
         * @memberof AccountSummary
         * @interface IDeviceInfo
         * @property {Uint8Array|null} [encryptedDeviceToken] DeviceInfo encryptedDeviceToken
         * @property {string|null} [deviceName] DeviceInfo deviceName
         * @property {Authentication.DeviceStatus|null} [deviceStatus] DeviceInfo deviceStatus
         * @property {Uint8Array|null} [devicePublicKey] DeviceInfo devicePublicKey
         * @property {Uint8Array|null} [encryptedDataKeyDoNotUse] DeviceInfo encryptedDataKeyDoNotUse
         * @property {string|null} [clientVersion] DeviceInfo clientVersion
         * @property {string|null} [username] DeviceInfo username
         * @property {string|null} [ipAddress] DeviceInfo ipAddress
         * @property {number|Long|null} [approveRequestTime] DeviceInfo approveRequestTime
         * @property {boolean|null} [encryptedDataKeyPresent] DeviceInfo encryptedDataKeyPresent
         * @property {number|Long|null} [groupId] DeviceInfo groupId
         */

        /**
         * Constructs a new DeviceInfo.
         * @memberof AccountSummary
         * @classdesc Represents a DeviceInfo.
         * @implements IDeviceInfo
         * @constructor
         * @param {AccountSummary.IDeviceInfo=} [properties] Properties to set
         */
        function DeviceInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceInfo encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * DeviceInfo deviceName.
         * @member {string} deviceName
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.deviceName = "";

        /**
         * DeviceInfo deviceStatus.
         * @member {Authentication.DeviceStatus} deviceStatus
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.deviceStatus = 0;

        /**
         * DeviceInfo devicePublicKey.
         * @member {Uint8Array} devicePublicKey
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.devicePublicKey = $util.newBuffer([]);

        /**
         * DeviceInfo encryptedDataKeyDoNotUse.
         * @member {Uint8Array} encryptedDataKeyDoNotUse
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.encryptedDataKeyDoNotUse = $util.newBuffer([]);

        /**
         * DeviceInfo clientVersion.
         * @member {string} clientVersion
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.clientVersion = "";

        /**
         * DeviceInfo username.
         * @member {string} username
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.username = "";

        /**
         * DeviceInfo ipAddress.
         * @member {string} ipAddress
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.ipAddress = "";

        /**
         * DeviceInfo approveRequestTime.
         * @member {number|Long} approveRequestTime
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.approveRequestTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceInfo encryptedDataKeyPresent.
         * @member {boolean} encryptedDataKeyPresent
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.encryptedDataKeyPresent = false;

        /**
         * DeviceInfo groupId.
         * @member {number|Long} groupId
         * @memberof AccountSummary.DeviceInfo
         * @instance
         */
        DeviceInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeviceInfo instance using the specified properties.
         * @function create
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {AccountSummary.IDeviceInfo=} [properties] Properties to set
         * @returns {AccountSummary.DeviceInfo} DeviceInfo instance
         */
        DeviceInfo.create = function create(properties) {
            return new DeviceInfo(properties);
        };

        /**
         * Encodes the specified DeviceInfo message. Does not implicitly {@link AccountSummary.DeviceInfo.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {AccountSummary.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.deviceStatus);
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.devicePublicKey);
            if (message.encryptedDataKeyDoNotUse != null && message.hasOwnProperty("encryptedDataKeyDoNotUse"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedDataKeyDoNotUse);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.clientVersion);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.username);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipAddress);
            if (message.approveRequestTime != null && message.hasOwnProperty("approveRequestTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.approveRequestTime);
            if (message.encryptedDataKeyPresent != null && message.hasOwnProperty("encryptedDataKeyPresent"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.encryptedDataKeyPresent);
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.groupId);
            return writer;
        };

        /**
         * Encodes the specified DeviceInfo message, length delimited. Does not implicitly {@link AccountSummary.DeviceInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {AccountSummary.IDeviceInfo} message DeviceInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.DeviceInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                case 3:
                    message.deviceStatus = reader.int32();
                    break;
                case 4:
                    message.devicePublicKey = reader.bytes();
                    break;
                case 5:
                    message.encryptedDataKeyDoNotUse = reader.bytes();
                    break;
                case 6:
                    message.clientVersion = reader.string();
                    break;
                case 7:
                    message.username = reader.string();
                    break;
                case 8:
                    message.ipAddress = reader.string();
                    break;
                case 9:
                    message.approveRequestTime = reader.int64();
                    break;
                case 10:
                    message.encryptedDataKeyPresent = reader.bool();
                    break;
                case 11:
                    message.groupId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.DeviceInfo} DeviceInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceInfo message.
         * @function verify
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                switch (message.deviceStatus) {
                default:
                    return "deviceStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                if (!(message.devicePublicKey && typeof message.devicePublicKey.length === "number" || $util.isString(message.devicePublicKey)))
                    return "devicePublicKey: buffer expected";
            if (message.encryptedDataKeyDoNotUse != null && message.hasOwnProperty("encryptedDataKeyDoNotUse"))
                if (!(message.encryptedDataKeyDoNotUse && typeof message.encryptedDataKeyDoNotUse.length === "number" || $util.isString(message.encryptedDataKeyDoNotUse)))
                    return "encryptedDataKeyDoNotUse: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.approveRequestTime != null && message.hasOwnProperty("approveRequestTime"))
                if (!$util.isInteger(message.approveRequestTime) && !(message.approveRequestTime && $util.isInteger(message.approveRequestTime.low) && $util.isInteger(message.approveRequestTime.high)))
                    return "approveRequestTime: integer|Long expected";
            if (message.encryptedDataKeyPresent != null && message.hasOwnProperty("encryptedDataKeyPresent"))
                if (typeof message.encryptedDataKeyPresent !== "boolean")
                    return "encryptedDataKeyPresent: boolean expected";
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                    return "groupId: integer|Long expected";
            return null;
        };

        /**
         * Creates a DeviceInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.DeviceInfo} DeviceInfo
         */
        DeviceInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.DeviceInfo)
                return object;
            let message = new $root.AccountSummary.DeviceInfo();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            switch (object.deviceStatus) {
            case "DEVICE_NEEDS_APPROVAL":
            case 0:
                message.deviceStatus = 0;
                break;
            case "DEVICE_OK":
            case 1:
                message.deviceStatus = 1;
                break;
            case "DEVICE_DISABLED_BY_USER":
            case 2:
                message.deviceStatus = 2;
                break;
            case "DEVICE_LOCKED_BY_ADMIN":
            case 3:
                message.deviceStatus = 3;
                break;
            }
            if (object.devicePublicKey != null)
                if (typeof object.devicePublicKey === "string")
                    $util.base64.decode(object.devicePublicKey, message.devicePublicKey = $util.newBuffer($util.base64.length(object.devicePublicKey)), 0);
                else if (object.devicePublicKey.length)
                    message.devicePublicKey = object.devicePublicKey;
            if (object.encryptedDataKeyDoNotUse != null)
                if (typeof object.encryptedDataKeyDoNotUse === "string")
                    $util.base64.decode(object.encryptedDataKeyDoNotUse, message.encryptedDataKeyDoNotUse = $util.newBuffer($util.base64.length(object.encryptedDataKeyDoNotUse)), 0);
                else if (object.encryptedDataKeyDoNotUse.length)
                    message.encryptedDataKeyDoNotUse = object.encryptedDataKeyDoNotUse;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.username != null)
                message.username = String(object.username);
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.approveRequestTime != null)
                if ($util.Long)
                    (message.approveRequestTime = $util.Long.fromValue(object.approveRequestTime)).unsigned = false;
                else if (typeof object.approveRequestTime === "string")
                    message.approveRequestTime = parseInt(object.approveRequestTime, 10);
                else if (typeof object.approveRequestTime === "number")
                    message.approveRequestTime = object.approveRequestTime;
                else if (typeof object.approveRequestTime === "object")
                    message.approveRequestTime = new $util.LongBits(object.approveRequestTime.low >>> 0, object.approveRequestTime.high >>> 0).toNumber();
            if (object.encryptedDataKeyPresent != null)
                message.encryptedDataKeyPresent = Boolean(object.encryptedDataKeyPresent);
            if (object.groupId != null)
                if ($util.Long)
                    (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = false;
                else if (typeof object.groupId === "string")
                    message.groupId = parseInt(object.groupId, 10);
                else if (typeof object.groupId === "number")
                    message.groupId = object.groupId;
                else if (typeof object.groupId === "object")
                    message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DeviceInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.DeviceInfo
         * @static
         * @param {AccountSummary.DeviceInfo} message DeviceInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.deviceName = "";
                object.deviceStatus = options.enums === String ? "DEVICE_NEEDS_APPROVAL" : 0;
                if (options.bytes === String)
                    object.devicePublicKey = "";
                else {
                    object.devicePublicKey = [];
                    if (options.bytes !== Array)
                        object.devicePublicKey = $util.newBuffer(object.devicePublicKey);
                }
                if (options.bytes === String)
                    object.encryptedDataKeyDoNotUse = "";
                else {
                    object.encryptedDataKeyDoNotUse = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKeyDoNotUse = $util.newBuffer(object.encryptedDataKeyDoNotUse);
                }
                object.clientVersion = "";
                object.username = "";
                object.ipAddress = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.approveRequestTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.approveRequestTime = options.longs === String ? "0" : 0;
                object.encryptedDataKeyPresent = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.groupId = options.longs === String ? "0" : 0;
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.deviceStatus != null && message.hasOwnProperty("deviceStatus"))
                object.deviceStatus = options.enums === String ? $root.Authentication.DeviceStatus[message.deviceStatus] : message.deviceStatus;
            if (message.devicePublicKey != null && message.hasOwnProperty("devicePublicKey"))
                object.devicePublicKey = options.bytes === String ? $util.base64.encode(message.devicePublicKey, 0, message.devicePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.devicePublicKey) : message.devicePublicKey;
            if (message.encryptedDataKeyDoNotUse != null && message.hasOwnProperty("encryptedDataKeyDoNotUse"))
                object.encryptedDataKeyDoNotUse = options.bytes === String ? $util.base64.encode(message.encryptedDataKeyDoNotUse, 0, message.encryptedDataKeyDoNotUse.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKeyDoNotUse) : message.encryptedDataKeyDoNotUse;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.approveRequestTime != null && message.hasOwnProperty("approveRequestTime"))
                if (typeof message.approveRequestTime === "number")
                    object.approveRequestTime = options.longs === String ? String(message.approveRequestTime) : message.approveRequestTime;
                else
                    object.approveRequestTime = options.longs === String ? $util.Long.prototype.toString.call(message.approveRequestTime) : options.longs === Number ? new $util.LongBits(message.approveRequestTime.low >>> 0, message.approveRequestTime.high >>> 0).toNumber() : message.approveRequestTime;
            if (message.encryptedDataKeyPresent != null && message.hasOwnProperty("encryptedDataKeyPresent"))
                object.encryptedDataKeyPresent = message.encryptedDataKeyPresent;
            if (message.groupId != null && message.hasOwnProperty("groupId"))
                if (typeof message.groupId === "number")
                    object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                else
                    object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber() : message.groupId;
            return object;
        };

        /**
         * Converts this DeviceInfo to JSON.
         * @function toJSON
         * @memberof AccountSummary.DeviceInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceInfo;
    })();

    AccountSummary.KeysInfo = (function() {

        /**
         * Properties of a KeysInfo.
         * @memberof AccountSummary
         * @interface IKeysInfo
         * @property {Uint8Array|null} [encryptionParams] KeysInfo encryptionParams
         * @property {Uint8Array|null} [encryptedDataKey] KeysInfo encryptedDataKey
         * @property {number|null} [dataKeyBackupDate] KeysInfo dataKeyBackupDate
         * @property {Uint8Array|null} [userAuthUid] KeysInfo userAuthUid
         * @property {Uint8Array|null} [encryptedPrivateKey] KeysInfo encryptedPrivateKey
         */

        /**
         * Constructs a new KeysInfo.
         * @memberof AccountSummary
         * @classdesc Represents a KeysInfo.
         * @implements IKeysInfo
         * @constructor
         * @param {AccountSummary.IKeysInfo=} [properties] Properties to set
         */
        function KeysInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeysInfo encryptionParams.
         * @member {Uint8Array} encryptionParams
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.encryptionParams = $util.newBuffer([]);

        /**
         * KeysInfo encryptedDataKey.
         * @member {Uint8Array} encryptedDataKey
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.encryptedDataKey = $util.newBuffer([]);

        /**
         * KeysInfo dataKeyBackupDate.
         * @member {number} dataKeyBackupDate
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.dataKeyBackupDate = 0;

        /**
         * KeysInfo userAuthUid.
         * @member {Uint8Array} userAuthUid
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.userAuthUid = $util.newBuffer([]);

        /**
         * KeysInfo encryptedPrivateKey.
         * @member {Uint8Array} encryptedPrivateKey
         * @memberof AccountSummary.KeysInfo
         * @instance
         */
        KeysInfo.prototype.encryptedPrivateKey = $util.newBuffer([]);

        /**
         * Creates a new KeysInfo instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo=} [properties] Properties to set
         * @returns {AccountSummary.KeysInfo} KeysInfo instance
         */
        KeysInfo.create = function create(properties) {
            return new KeysInfo(properties);
        };

        /**
         * Encodes the specified KeysInfo message. Does not implicitly {@link AccountSummary.KeysInfo.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo} message KeysInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeysInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptionParams);
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDataKey);
            if (message.dataKeyBackupDate != null && message.hasOwnProperty("dataKeyBackupDate"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.dataKeyBackupDate);
            if (message.userAuthUid != null && message.hasOwnProperty("userAuthUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.userAuthUid);
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedPrivateKey);
            return writer;
        };

        /**
         * Encodes the specified KeysInfo message, length delimited. Does not implicitly {@link AccountSummary.KeysInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.IKeysInfo} message KeysInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeysInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeysInfo message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeysInfo} KeysInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeysInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeysInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptionParams = reader.bytes();
                    break;
                case 2:
                    message.encryptedDataKey = reader.bytes();
                    break;
                case 3:
                    message.dataKeyBackupDate = reader.double();
                    break;
                case 4:
                    message.userAuthUid = reader.bytes();
                    break;
                case 5:
                    message.encryptedPrivateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeysInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeysInfo} KeysInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeysInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeysInfo message.
         * @function verify
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeysInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                if (!(message.encryptionParams && typeof message.encryptionParams.length === "number" || $util.isString(message.encryptionParams)))
                    return "encryptionParams: buffer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                if (!(message.encryptedDataKey && typeof message.encryptedDataKey.length === "number" || $util.isString(message.encryptedDataKey)))
                    return "encryptedDataKey: buffer expected";
            if (message.dataKeyBackupDate != null && message.hasOwnProperty("dataKeyBackupDate"))
                if (typeof message.dataKeyBackupDate !== "number")
                    return "dataKeyBackupDate: number expected";
            if (message.userAuthUid != null && message.hasOwnProperty("userAuthUid"))
                if (!(message.userAuthUid && typeof message.userAuthUid.length === "number" || $util.isString(message.userAuthUid)))
                    return "userAuthUid: buffer expected";
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                if (!(message.encryptedPrivateKey && typeof message.encryptedPrivateKey.length === "number" || $util.isString(message.encryptedPrivateKey)))
                    return "encryptedPrivateKey: buffer expected";
            return null;
        };

        /**
         * Creates a KeysInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeysInfo} KeysInfo
         */
        KeysInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeysInfo)
                return object;
            let message = new $root.AccountSummary.KeysInfo();
            if (object.encryptionParams != null)
                if (typeof object.encryptionParams === "string")
                    $util.base64.decode(object.encryptionParams, message.encryptionParams = $util.newBuffer($util.base64.length(object.encryptionParams)), 0);
                else if (object.encryptionParams.length)
                    message.encryptionParams = object.encryptionParams;
            if (object.encryptedDataKey != null)
                if (typeof object.encryptedDataKey === "string")
                    $util.base64.decode(object.encryptedDataKey, message.encryptedDataKey = $util.newBuffer($util.base64.length(object.encryptedDataKey)), 0);
                else if (object.encryptedDataKey.length)
                    message.encryptedDataKey = object.encryptedDataKey;
            if (object.dataKeyBackupDate != null)
                message.dataKeyBackupDate = Number(object.dataKeyBackupDate);
            if (object.userAuthUid != null)
                if (typeof object.userAuthUid === "string")
                    $util.base64.decode(object.userAuthUid, message.userAuthUid = $util.newBuffer($util.base64.length(object.userAuthUid)), 0);
                else if (object.userAuthUid.length)
                    message.userAuthUid = object.userAuthUid;
            if (object.encryptedPrivateKey != null)
                if (typeof object.encryptedPrivateKey === "string")
                    $util.base64.decode(object.encryptedPrivateKey, message.encryptedPrivateKey = $util.newBuffer($util.base64.length(object.encryptedPrivateKey)), 0);
                else if (object.encryptedPrivateKey.length)
                    message.encryptedPrivateKey = object.encryptedPrivateKey;
            return message;
        };

        /**
         * Creates a plain object from a KeysInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeysInfo
         * @static
         * @param {AccountSummary.KeysInfo} message KeysInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeysInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptionParams = "";
                else {
                    object.encryptionParams = [];
                    if (options.bytes !== Array)
                        object.encryptionParams = $util.newBuffer(object.encryptionParams);
                }
                if (options.bytes === String)
                    object.encryptedDataKey = "";
                else {
                    object.encryptedDataKey = [];
                    if (options.bytes !== Array)
                        object.encryptedDataKey = $util.newBuffer(object.encryptedDataKey);
                }
                object.dataKeyBackupDate = 0;
                if (options.bytes === String)
                    object.userAuthUid = "";
                else {
                    object.userAuthUid = [];
                    if (options.bytes !== Array)
                        object.userAuthUid = $util.newBuffer(object.userAuthUid);
                }
                if (options.bytes === String)
                    object.encryptedPrivateKey = "";
                else {
                    object.encryptedPrivateKey = [];
                    if (options.bytes !== Array)
                        object.encryptedPrivateKey = $util.newBuffer(object.encryptedPrivateKey);
                }
            }
            if (message.encryptionParams != null && message.hasOwnProperty("encryptionParams"))
                object.encryptionParams = options.bytes === String ? $util.base64.encode(message.encryptionParams, 0, message.encryptionParams.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptionParams) : message.encryptionParams;
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey"))
                object.encryptedDataKey = options.bytes === String ? $util.base64.encode(message.encryptedDataKey, 0, message.encryptedDataKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDataKey) : message.encryptedDataKey;
            if (message.dataKeyBackupDate != null && message.hasOwnProperty("dataKeyBackupDate"))
                object.dataKeyBackupDate = options.json && !isFinite(message.dataKeyBackupDate) ? String(message.dataKeyBackupDate) : message.dataKeyBackupDate;
            if (message.userAuthUid != null && message.hasOwnProperty("userAuthUid"))
                object.userAuthUid = options.bytes === String ? $util.base64.encode(message.userAuthUid, 0, message.userAuthUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.userAuthUid) : message.userAuthUid;
            if (message.encryptedPrivateKey != null && message.hasOwnProperty("encryptedPrivateKey"))
                object.encryptedPrivateKey = options.bytes === String ? $util.base64.encode(message.encryptedPrivateKey, 0, message.encryptedPrivateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedPrivateKey) : message.encryptedPrivateKey;
            return object;
        };

        /**
         * Converts this KeysInfo to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeysInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeysInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeysInfo;
    })();

    AccountSummary.SyncLog = (function() {

        /**
         * Properties of a SyncLog.
         * @memberof AccountSummary
         * @interface ISyncLog
         * @property {string|null} [countryName] SyncLog countryName
         * @property {number|Long|null} [secondsAgo] SyncLog secondsAgo
         * @property {string|null} [deviceName] SyncLog deviceName
         * @property {string|null} [countryCode] SyncLog countryCode
         * @property {Uint8Array|null} [deviceUID] SyncLog deviceUID
         * @property {string|null} [ipAddress] SyncLog ipAddress
         */

        /**
         * Constructs a new SyncLog.
         * @memberof AccountSummary
         * @classdesc Represents a SyncLog.
         * @implements ISyncLog
         * @constructor
         * @param {AccountSummary.ISyncLog=} [properties] Properties to set
         */
        function SyncLog(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncLog countryName.
         * @member {string} countryName
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.countryName = "";

        /**
         * SyncLog secondsAgo.
         * @member {number|Long} secondsAgo
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.secondsAgo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SyncLog deviceName.
         * @member {string} deviceName
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.deviceName = "";

        /**
         * SyncLog countryCode.
         * @member {string} countryCode
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.countryCode = "";

        /**
         * SyncLog deviceUID.
         * @member {Uint8Array} deviceUID
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.deviceUID = $util.newBuffer([]);

        /**
         * SyncLog ipAddress.
         * @member {string} ipAddress
         * @memberof AccountSummary.SyncLog
         * @instance
         */
        SyncLog.prototype.ipAddress = "";

        /**
         * Creates a new SyncLog instance using the specified properties.
         * @function create
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog=} [properties] Properties to set
         * @returns {AccountSummary.SyncLog} SyncLog instance
         */
        SyncLog.create = function create(properties) {
            return new SyncLog(properties);
        };

        /**
         * Encodes the specified SyncLog message. Does not implicitly {@link AccountSummary.SyncLog.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog} message SyncLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.countryName);
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.secondsAgo);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.deviceName);
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.countryCode);
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.deviceUID);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ipAddress);
            return writer;
        };

        /**
         * Encodes the specified SyncLog message, length delimited. Does not implicitly {@link AccountSummary.SyncLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.ISyncLog} message SyncLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncLog message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.SyncLog} SyncLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.SyncLog();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.countryName = reader.string();
                    break;
                case 2:
                    message.secondsAgo = reader.int64();
                    break;
                case 3:
                    message.deviceName = reader.string();
                    break;
                case 4:
                    message.countryCode = reader.string();
                    break;
                case 5:
                    message.deviceUID = reader.bytes();
                    break;
                case 6:
                    message.ipAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.SyncLog} SyncLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncLog message.
         * @function verify
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                if (!$util.isString(message.countryName))
                    return "countryName: string expected";
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                if (!$util.isInteger(message.secondsAgo) && !(message.secondsAgo && $util.isInteger(message.secondsAgo.low) && $util.isInteger(message.secondsAgo.high)))
                    return "secondsAgo: integer|Long expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isString(message.countryCode))
                    return "countryCode: string expected";
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                if (!(message.deviceUID && typeof message.deviceUID.length === "number" || $util.isString(message.deviceUID)))
                    return "deviceUID: buffer expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            return null;
        };

        /**
         * Creates a SyncLog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.SyncLog} SyncLog
         */
        SyncLog.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.SyncLog)
                return object;
            let message = new $root.AccountSummary.SyncLog();
            if (object.countryName != null)
                message.countryName = String(object.countryName);
            if (object.secondsAgo != null)
                if ($util.Long)
                    (message.secondsAgo = $util.Long.fromValue(object.secondsAgo)).unsigned = false;
                else if (typeof object.secondsAgo === "string")
                    message.secondsAgo = parseInt(object.secondsAgo, 10);
                else if (typeof object.secondsAgo === "number")
                    message.secondsAgo = object.secondsAgo;
                else if (typeof object.secondsAgo === "object")
                    message.secondsAgo = new $util.LongBits(object.secondsAgo.low >>> 0, object.secondsAgo.high >>> 0).toNumber();
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.countryCode != null)
                message.countryCode = String(object.countryCode);
            if (object.deviceUID != null)
                if (typeof object.deviceUID === "string")
                    $util.base64.decode(object.deviceUID, message.deviceUID = $util.newBuffer($util.base64.length(object.deviceUID)), 0);
                else if (object.deviceUID.length)
                    message.deviceUID = object.deviceUID;
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            return message;
        };

        /**
         * Creates a plain object from a SyncLog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.SyncLog
         * @static
         * @param {AccountSummary.SyncLog} message SyncLog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SyncLog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.countryName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsAgo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsAgo = options.longs === String ? "0" : 0;
                object.deviceName = "";
                object.countryCode = "";
                if (options.bytes === String)
                    object.deviceUID = "";
                else {
                    object.deviceUID = [];
                    if (options.bytes !== Array)
                        object.deviceUID = $util.newBuffer(object.deviceUID);
                }
                object.ipAddress = "";
            }
            if (message.countryName != null && message.hasOwnProperty("countryName"))
                object.countryName = message.countryName;
            if (message.secondsAgo != null && message.hasOwnProperty("secondsAgo"))
                if (typeof message.secondsAgo === "number")
                    object.secondsAgo = options.longs === String ? String(message.secondsAgo) : message.secondsAgo;
                else
                    object.secondsAgo = options.longs === String ? $util.Long.prototype.toString.call(message.secondsAgo) : options.longs === Number ? new $util.LongBits(message.secondsAgo.low >>> 0, message.secondsAgo.high >>> 0).toNumber() : message.secondsAgo;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            if (message.deviceUID != null && message.hasOwnProperty("deviceUID"))
                object.deviceUID = options.bytes === String ? $util.base64.encode(message.deviceUID, 0, message.deviceUID.length) : options.bytes === Array ? Array.prototype.slice.call(message.deviceUID) : message.deviceUID;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            return object;
        };

        /**
         * Converts this SyncLog to JSON.
         * @function toJSON
         * @memberof AccountSummary.SyncLog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SyncLog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SyncLog;
    })();

    AccountSummary.License = (function() {

        /**
         * Properties of a License.
         * @memberof AccountSummary
         * @interface ILicense
         * @property {string|null} [subscriptionCode] License subscriptionCode
         * @property {number|null} [productTypeId] License productTypeId
         * @property {string|null} [productTypeName] License productTypeName
         * @property {string|null} [expirationDate] License expirationDate
         * @property {number|Long|null} [secondsUntilExpiration] License secondsUntilExpiration
         * @property {number|null} [maxDevices] License maxDevices
         * @property {number|null} [filePlanType] License filePlanType
         * @property {number|Long|null} [bytesUsed] License bytesUsed
         * @property {number|Long|null} [bytesTotal] License bytesTotal
         * @property {number|Long|null} [secondsUntilStorageExpiration] License secondsUntilStorageExpiration
         * @property {string|null} [storageExpirationDate] License storageExpirationDate
         * @property {boolean|null} [hasAutoRenewableAppstoreSubscription] License hasAutoRenewableAppstoreSubscription
         * @property {number|null} [accountType] License accountType
         * @property {number|null} [uploadsRemaining] License uploadsRemaining
         * @property {number|null} [enterpriseId] License enterpriseId
         * @property {boolean|null} [chatEnabled] License chatEnabled
         * @property {boolean|null} [auditAndReportingEnabled] License auditAndReportingEnabled
         * @property {boolean|null} [breachWatchFeatureDisable] License breachWatchFeatureDisable
         * @property {Uint8Array|null} [accountUid] License accountUid
         * @property {boolean|null} [allowPersonalLicense] License allowPersonalLicense
         * @property {string|null} [licensedBy] License licensedBy
         * @property {string|null} [email] License email
         * @property {boolean|null} [breachWatchEnabled] License breachWatchEnabled
         * @property {boolean|null} [breachWatchScanned] License breachWatchScanned
         * @property {number|Long|null} [breachWatchExpiration] License breachWatchExpiration
         * @property {number|Long|null} [breachWatchDateCreated] License breachWatchDateCreated
         * @property {AccountSummary.IResult|null} [error] License error
         */

        /**
         * Constructs a new License.
         * @memberof AccountSummary
         * @classdesc Represents a License.
         * @implements ILicense
         * @constructor
         * @param {AccountSummary.ILicense=} [properties] Properties to set
         */
        function License(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * License subscriptionCode.
         * @member {string} subscriptionCode
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.subscriptionCode = "";

        /**
         * License productTypeId.
         * @member {number} productTypeId
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.productTypeId = 0;

        /**
         * License productTypeName.
         * @member {string} productTypeName
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.productTypeName = "";

        /**
         * License expirationDate.
         * @member {string} expirationDate
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.expirationDate = "";

        /**
         * License secondsUntilExpiration.
         * @member {number|Long} secondsUntilExpiration
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.secondsUntilExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License maxDevices.
         * @member {number} maxDevices
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.maxDevices = 0;

        /**
         * License filePlanType.
         * @member {number} filePlanType
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.filePlanType = 0;

        /**
         * License bytesUsed.
         * @member {number|Long} bytesUsed
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.bytesUsed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License bytesTotal.
         * @member {number|Long} bytesTotal
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.bytesTotal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License secondsUntilStorageExpiration.
         * @member {number|Long} secondsUntilStorageExpiration
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.secondsUntilStorageExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License storageExpirationDate.
         * @member {string} storageExpirationDate
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.storageExpirationDate = "";

        /**
         * License hasAutoRenewableAppstoreSubscription.
         * @member {boolean} hasAutoRenewableAppstoreSubscription
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.hasAutoRenewableAppstoreSubscription = false;

        /**
         * License accountType.
         * @member {number} accountType
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.accountType = 0;

        /**
         * License uploadsRemaining.
         * @member {number} uploadsRemaining
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.uploadsRemaining = 0;

        /**
         * License enterpriseId.
         * @member {number} enterpriseId
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.enterpriseId = 0;

        /**
         * License chatEnabled.
         * @member {boolean} chatEnabled
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.chatEnabled = false;

        /**
         * License auditAndReportingEnabled.
         * @member {boolean} auditAndReportingEnabled
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.auditAndReportingEnabled = false;

        /**
         * License breachWatchFeatureDisable.
         * @member {boolean} breachWatchFeatureDisable
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.breachWatchFeatureDisable = false;

        /**
         * License accountUid.
         * @member {Uint8Array} accountUid
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.accountUid = $util.newBuffer([]);

        /**
         * License allowPersonalLicense.
         * @member {boolean} allowPersonalLicense
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.allowPersonalLicense = false;

        /**
         * License licensedBy.
         * @member {string} licensedBy
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.licensedBy = "";

        /**
         * License email.
         * @member {string} email
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.email = "";

        /**
         * License breachWatchEnabled.
         * @member {boolean} breachWatchEnabled
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.breachWatchEnabled = false;

        /**
         * License breachWatchScanned.
         * @member {boolean} breachWatchScanned
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.breachWatchScanned = false;

        /**
         * License breachWatchExpiration.
         * @member {number|Long} breachWatchExpiration
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.breachWatchExpiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License breachWatchDateCreated.
         * @member {number|Long} breachWatchDateCreated
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.breachWatchDateCreated = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * License error.
         * @member {AccountSummary.IResult|null|undefined} error
         * @memberof AccountSummary.License
         * @instance
         */
        License.prototype.error = null;

        /**
         * Creates a new License instance using the specified properties.
         * @function create
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense=} [properties] Properties to set
         * @returns {AccountSummary.License} License instance
         */
        License.create = function create(properties) {
            return new License(properties);
        };

        /**
         * Encodes the specified License message. Does not implicitly {@link AccountSummary.License.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.subscriptionCode);
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.productTypeId);
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.productTypeName);
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.expirationDate);
            if (message.secondsUntilExpiration != null && message.hasOwnProperty("secondsUntilExpiration"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.secondsUntilExpiration);
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxDevices);
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.filePlanType);
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.bytesUsed);
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.bytesTotal);
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.secondsUntilStorageExpiration);
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.storageExpirationDate);
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.hasAutoRenewableAppstoreSubscription);
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.accountType);
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.uploadsRemaining);
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.enterpriseId);
            if (message.chatEnabled != null && message.hasOwnProperty("chatEnabled"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.chatEnabled);
            if (message.auditAndReportingEnabled != null && message.hasOwnProperty("auditAndReportingEnabled"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.auditAndReportingEnabled);
            if (message.breachWatchFeatureDisable != null && message.hasOwnProperty("breachWatchFeatureDisable"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.breachWatchFeatureDisable);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 19, wireType 2 =*/154).bytes(message.accountUid);
            if (message.allowPersonalLicense != null && message.hasOwnProperty("allowPersonalLicense"))
                writer.uint32(/* id 20, wireType 0 =*/160).bool(message.allowPersonalLicense);
            if (message.licensedBy != null && message.hasOwnProperty("licensedBy"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.licensedBy);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 22, wireType 2 =*/178).string(message.email);
            if (message.breachWatchEnabled != null && message.hasOwnProperty("breachWatchEnabled"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.breachWatchEnabled);
            if (message.breachWatchScanned != null && message.hasOwnProperty("breachWatchScanned"))
                writer.uint32(/* id 24, wireType 0 =*/192).bool(message.breachWatchScanned);
            if (message.breachWatchExpiration != null && message.hasOwnProperty("breachWatchExpiration"))
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.breachWatchExpiration);
            if (message.breachWatchDateCreated != null && message.hasOwnProperty("breachWatchDateCreated"))
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.breachWatchDateCreated);
            if (message.error != null && message.hasOwnProperty("error"))
                $root.AccountSummary.Result.encode(message.error, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified License message, length delimited. Does not implicitly {@link AccountSummary.License.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.ILicense} message License message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        License.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a License message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.License();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subscriptionCode = reader.string();
                    break;
                case 2:
                    message.productTypeId = reader.int32();
                    break;
                case 3:
                    message.productTypeName = reader.string();
                    break;
                case 4:
                    message.expirationDate = reader.string();
                    break;
                case 5:
                    message.secondsUntilExpiration = reader.int64();
                    break;
                case 6:
                    message.maxDevices = reader.int32();
                    break;
                case 7:
                    message.filePlanType = reader.int32();
                    break;
                case 8:
                    message.bytesUsed = reader.int64();
                    break;
                case 9:
                    message.bytesTotal = reader.int64();
                    break;
                case 10:
                    message.secondsUntilStorageExpiration = reader.int64();
                    break;
                case 11:
                    message.storageExpirationDate = reader.string();
                    break;
                case 12:
                    message.hasAutoRenewableAppstoreSubscription = reader.bool();
                    break;
                case 13:
                    message.accountType = reader.int32();
                    break;
                case 14:
                    message.uploadsRemaining = reader.int32();
                    break;
                case 15:
                    message.enterpriseId = reader.int32();
                    break;
                case 16:
                    message.chatEnabled = reader.bool();
                    break;
                case 17:
                    message.auditAndReportingEnabled = reader.bool();
                    break;
                case 18:
                    message.breachWatchFeatureDisable = reader.bool();
                    break;
                case 19:
                    message.accountUid = reader.bytes();
                    break;
                case 20:
                    message.allowPersonalLicense = reader.bool();
                    break;
                case 21:
                    message.licensedBy = reader.string();
                    break;
                case 22:
                    message.email = reader.string();
                    break;
                case 23:
                    message.breachWatchEnabled = reader.bool();
                    break;
                case 24:
                    message.breachWatchScanned = reader.bool();
                    break;
                case 25:
                    message.breachWatchExpiration = reader.int64();
                    break;
                case 26:
                    message.breachWatchDateCreated = reader.int64();
                    break;
                case 27:
                    message.error = $root.AccountSummary.Result.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a License message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.License
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.License} License
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        License.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a License message.
         * @function verify
         * @memberof AccountSummary.License
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        License.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                if (!$util.isString(message.subscriptionCode))
                    return "subscriptionCode: string expected";
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                if (!$util.isInteger(message.productTypeId))
                    return "productTypeId: integer expected";
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                if (!$util.isString(message.productTypeName))
                    return "productTypeName: string expected";
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (!$util.isString(message.expirationDate))
                    return "expirationDate: string expected";
            if (message.secondsUntilExpiration != null && message.hasOwnProperty("secondsUntilExpiration"))
                if (!$util.isInteger(message.secondsUntilExpiration) && !(message.secondsUntilExpiration && $util.isInteger(message.secondsUntilExpiration.low) && $util.isInteger(message.secondsUntilExpiration.high)))
                    return "secondsUntilExpiration: integer|Long expected";
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                if (!$util.isInteger(message.maxDevices))
                    return "maxDevices: integer expected";
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                if (!$util.isInteger(message.filePlanType))
                    return "filePlanType: integer expected";
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (!$util.isInteger(message.bytesUsed) && !(message.bytesUsed && $util.isInteger(message.bytesUsed.low) && $util.isInteger(message.bytesUsed.high)))
                    return "bytesUsed: integer|Long expected";
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                if (!$util.isInteger(message.bytesTotal) && !(message.bytesTotal && $util.isInteger(message.bytesTotal.low) && $util.isInteger(message.bytesTotal.high)))
                    return "bytesTotal: integer|Long expected";
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                if (!$util.isInteger(message.secondsUntilStorageExpiration) && !(message.secondsUntilStorageExpiration && $util.isInteger(message.secondsUntilStorageExpiration.low) && $util.isInteger(message.secondsUntilStorageExpiration.high)))
                    return "secondsUntilStorageExpiration: integer|Long expected";
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                if (!$util.isString(message.storageExpirationDate))
                    return "storageExpirationDate: string expected";
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                if (typeof message.hasAutoRenewableAppstoreSubscription !== "boolean")
                    return "hasAutoRenewableAppstoreSubscription: boolean expected";
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                if (!$util.isInteger(message.accountType))
                    return "accountType: integer expected";
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                if (!$util.isInteger(message.uploadsRemaining))
                    return "uploadsRemaining: integer expected";
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (!$util.isInteger(message.enterpriseId))
                    return "enterpriseId: integer expected";
            if (message.chatEnabled != null && message.hasOwnProperty("chatEnabled"))
                if (typeof message.chatEnabled !== "boolean")
                    return "chatEnabled: boolean expected";
            if (message.auditAndReportingEnabled != null && message.hasOwnProperty("auditAndReportingEnabled"))
                if (typeof message.auditAndReportingEnabled !== "boolean")
                    return "auditAndReportingEnabled: boolean expected";
            if (message.breachWatchFeatureDisable != null && message.hasOwnProperty("breachWatchFeatureDisable"))
                if (typeof message.breachWatchFeatureDisable !== "boolean")
                    return "breachWatchFeatureDisable: boolean expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.allowPersonalLicense != null && message.hasOwnProperty("allowPersonalLicense"))
                if (typeof message.allowPersonalLicense !== "boolean")
                    return "allowPersonalLicense: boolean expected";
            if (message.licensedBy != null && message.hasOwnProperty("licensedBy"))
                if (!$util.isString(message.licensedBy))
                    return "licensedBy: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.breachWatchEnabled != null && message.hasOwnProperty("breachWatchEnabled"))
                if (typeof message.breachWatchEnabled !== "boolean")
                    return "breachWatchEnabled: boolean expected";
            if (message.breachWatchScanned != null && message.hasOwnProperty("breachWatchScanned"))
                if (typeof message.breachWatchScanned !== "boolean")
                    return "breachWatchScanned: boolean expected";
            if (message.breachWatchExpiration != null && message.hasOwnProperty("breachWatchExpiration"))
                if (!$util.isInteger(message.breachWatchExpiration) && !(message.breachWatchExpiration && $util.isInteger(message.breachWatchExpiration.low) && $util.isInteger(message.breachWatchExpiration.high)))
                    return "breachWatchExpiration: integer|Long expected";
            if (message.breachWatchDateCreated != null && message.hasOwnProperty("breachWatchDateCreated"))
                if (!$util.isInteger(message.breachWatchDateCreated) && !(message.breachWatchDateCreated && $util.isInteger(message.breachWatchDateCreated.low) && $util.isInteger(message.breachWatchDateCreated.high)))
                    return "breachWatchDateCreated: integer|Long expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                let error = $root.AccountSummary.Result.verify(message.error);
                if (error)
                    return "error." + error;
            }
            return null;
        };

        /**
         * Creates a License message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.License
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.License} License
         */
        License.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.License)
                return object;
            let message = new $root.AccountSummary.License();
            if (object.subscriptionCode != null)
                message.subscriptionCode = String(object.subscriptionCode);
            if (object.productTypeId != null)
                message.productTypeId = object.productTypeId | 0;
            if (object.productTypeName != null)
                message.productTypeName = String(object.productTypeName);
            if (object.expirationDate != null)
                message.expirationDate = String(object.expirationDate);
            if (object.secondsUntilExpiration != null)
                if ($util.Long)
                    (message.secondsUntilExpiration = $util.Long.fromValue(object.secondsUntilExpiration)).unsigned = false;
                else if (typeof object.secondsUntilExpiration === "string")
                    message.secondsUntilExpiration = parseInt(object.secondsUntilExpiration, 10);
                else if (typeof object.secondsUntilExpiration === "number")
                    message.secondsUntilExpiration = object.secondsUntilExpiration;
                else if (typeof object.secondsUntilExpiration === "object")
                    message.secondsUntilExpiration = new $util.LongBits(object.secondsUntilExpiration.low >>> 0, object.secondsUntilExpiration.high >>> 0).toNumber();
            if (object.maxDevices != null)
                message.maxDevices = object.maxDevices | 0;
            if (object.filePlanType != null)
                message.filePlanType = object.filePlanType | 0;
            if (object.bytesUsed != null)
                if ($util.Long)
                    (message.bytesUsed = $util.Long.fromValue(object.bytesUsed)).unsigned = false;
                else if (typeof object.bytesUsed === "string")
                    message.bytesUsed = parseInt(object.bytesUsed, 10);
                else if (typeof object.bytesUsed === "number")
                    message.bytesUsed = object.bytesUsed;
                else if (typeof object.bytesUsed === "object")
                    message.bytesUsed = new $util.LongBits(object.bytesUsed.low >>> 0, object.bytesUsed.high >>> 0).toNumber();
            if (object.bytesTotal != null)
                if ($util.Long)
                    (message.bytesTotal = $util.Long.fromValue(object.bytesTotal)).unsigned = false;
                else if (typeof object.bytesTotal === "string")
                    message.bytesTotal = parseInt(object.bytesTotal, 10);
                else if (typeof object.bytesTotal === "number")
                    message.bytesTotal = object.bytesTotal;
                else if (typeof object.bytesTotal === "object")
                    message.bytesTotal = new $util.LongBits(object.bytesTotal.low >>> 0, object.bytesTotal.high >>> 0).toNumber();
            if (object.secondsUntilStorageExpiration != null)
                if ($util.Long)
                    (message.secondsUntilStorageExpiration = $util.Long.fromValue(object.secondsUntilStorageExpiration)).unsigned = false;
                else if (typeof object.secondsUntilStorageExpiration === "string")
                    message.secondsUntilStorageExpiration = parseInt(object.secondsUntilStorageExpiration, 10);
                else if (typeof object.secondsUntilStorageExpiration === "number")
                    message.secondsUntilStorageExpiration = object.secondsUntilStorageExpiration;
                else if (typeof object.secondsUntilStorageExpiration === "object")
                    message.secondsUntilStorageExpiration = new $util.LongBits(object.secondsUntilStorageExpiration.low >>> 0, object.secondsUntilStorageExpiration.high >>> 0).toNumber();
            if (object.storageExpirationDate != null)
                message.storageExpirationDate = String(object.storageExpirationDate);
            if (object.hasAutoRenewableAppstoreSubscription != null)
                message.hasAutoRenewableAppstoreSubscription = Boolean(object.hasAutoRenewableAppstoreSubscription);
            if (object.accountType != null)
                message.accountType = object.accountType | 0;
            if (object.uploadsRemaining != null)
                message.uploadsRemaining = object.uploadsRemaining | 0;
            if (object.enterpriseId != null)
                message.enterpriseId = object.enterpriseId | 0;
            if (object.chatEnabled != null)
                message.chatEnabled = Boolean(object.chatEnabled);
            if (object.auditAndReportingEnabled != null)
                message.auditAndReportingEnabled = Boolean(object.auditAndReportingEnabled);
            if (object.breachWatchFeatureDisable != null)
                message.breachWatchFeatureDisable = Boolean(object.breachWatchFeatureDisable);
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            if (object.allowPersonalLicense != null)
                message.allowPersonalLicense = Boolean(object.allowPersonalLicense);
            if (object.licensedBy != null)
                message.licensedBy = String(object.licensedBy);
            if (object.email != null)
                message.email = String(object.email);
            if (object.breachWatchEnabled != null)
                message.breachWatchEnabled = Boolean(object.breachWatchEnabled);
            if (object.breachWatchScanned != null)
                message.breachWatchScanned = Boolean(object.breachWatchScanned);
            if (object.breachWatchExpiration != null)
                if ($util.Long)
                    (message.breachWatchExpiration = $util.Long.fromValue(object.breachWatchExpiration)).unsigned = false;
                else if (typeof object.breachWatchExpiration === "string")
                    message.breachWatchExpiration = parseInt(object.breachWatchExpiration, 10);
                else if (typeof object.breachWatchExpiration === "number")
                    message.breachWatchExpiration = object.breachWatchExpiration;
                else if (typeof object.breachWatchExpiration === "object")
                    message.breachWatchExpiration = new $util.LongBits(object.breachWatchExpiration.low >>> 0, object.breachWatchExpiration.high >>> 0).toNumber();
            if (object.breachWatchDateCreated != null)
                if ($util.Long)
                    (message.breachWatchDateCreated = $util.Long.fromValue(object.breachWatchDateCreated)).unsigned = false;
                else if (typeof object.breachWatchDateCreated === "string")
                    message.breachWatchDateCreated = parseInt(object.breachWatchDateCreated, 10);
                else if (typeof object.breachWatchDateCreated === "number")
                    message.breachWatchDateCreated = object.breachWatchDateCreated;
                else if (typeof object.breachWatchDateCreated === "object")
                    message.breachWatchDateCreated = new $util.LongBits(object.breachWatchDateCreated.low >>> 0, object.breachWatchDateCreated.high >>> 0).toNumber();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".AccountSummary.License.error: object expected");
                message.error = $root.AccountSummary.Result.fromObject(object.error);
            }
            return message;
        };

        /**
         * Creates a plain object from a License message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.License
         * @static
         * @param {AccountSummary.License} message License
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        License.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.subscriptionCode = "";
                object.productTypeId = 0;
                object.productTypeName = "";
                object.expirationDate = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsUntilExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsUntilExpiration = options.longs === String ? "0" : 0;
                object.maxDevices = 0;
                object.filePlanType = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bytesUsed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesUsed = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bytesTotal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesTotal = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.secondsUntilStorageExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.secondsUntilStorageExpiration = options.longs === String ? "0" : 0;
                object.storageExpirationDate = "";
                object.hasAutoRenewableAppstoreSubscription = false;
                object.accountType = 0;
                object.uploadsRemaining = 0;
                object.enterpriseId = 0;
                object.chatEnabled = false;
                object.auditAndReportingEnabled = false;
                object.breachWatchFeatureDisable = false;
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                object.allowPersonalLicense = false;
                object.licensedBy = "";
                object.email = "";
                object.breachWatchEnabled = false;
                object.breachWatchScanned = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.breachWatchExpiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.breachWatchExpiration = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.breachWatchDateCreated = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.breachWatchDateCreated = options.longs === String ? "0" : 0;
                object.error = null;
            }
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                object.subscriptionCode = message.subscriptionCode;
            if (message.productTypeId != null && message.hasOwnProperty("productTypeId"))
                object.productTypeId = message.productTypeId;
            if (message.productTypeName != null && message.hasOwnProperty("productTypeName"))
                object.productTypeName = message.productTypeName;
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                object.expirationDate = message.expirationDate;
            if (message.secondsUntilExpiration != null && message.hasOwnProperty("secondsUntilExpiration"))
                if (typeof message.secondsUntilExpiration === "number")
                    object.secondsUntilExpiration = options.longs === String ? String(message.secondsUntilExpiration) : message.secondsUntilExpiration;
                else
                    object.secondsUntilExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.secondsUntilExpiration) : options.longs === Number ? new $util.LongBits(message.secondsUntilExpiration.low >>> 0, message.secondsUntilExpiration.high >>> 0).toNumber() : message.secondsUntilExpiration;
            if (message.maxDevices != null && message.hasOwnProperty("maxDevices"))
                object.maxDevices = message.maxDevices;
            if (message.filePlanType != null && message.hasOwnProperty("filePlanType"))
                object.filePlanType = message.filePlanType;
            if (message.bytesUsed != null && message.hasOwnProperty("bytesUsed"))
                if (typeof message.bytesUsed === "number")
                    object.bytesUsed = options.longs === String ? String(message.bytesUsed) : message.bytesUsed;
                else
                    object.bytesUsed = options.longs === String ? $util.Long.prototype.toString.call(message.bytesUsed) : options.longs === Number ? new $util.LongBits(message.bytesUsed.low >>> 0, message.bytesUsed.high >>> 0).toNumber() : message.bytesUsed;
            if (message.bytesTotal != null && message.hasOwnProperty("bytesTotal"))
                if (typeof message.bytesTotal === "number")
                    object.bytesTotal = options.longs === String ? String(message.bytesTotal) : message.bytesTotal;
                else
                    object.bytesTotal = options.longs === String ? $util.Long.prototype.toString.call(message.bytesTotal) : options.longs === Number ? new $util.LongBits(message.bytesTotal.low >>> 0, message.bytesTotal.high >>> 0).toNumber() : message.bytesTotal;
            if (message.secondsUntilStorageExpiration != null && message.hasOwnProperty("secondsUntilStorageExpiration"))
                if (typeof message.secondsUntilStorageExpiration === "number")
                    object.secondsUntilStorageExpiration = options.longs === String ? String(message.secondsUntilStorageExpiration) : message.secondsUntilStorageExpiration;
                else
                    object.secondsUntilStorageExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.secondsUntilStorageExpiration) : options.longs === Number ? new $util.LongBits(message.secondsUntilStorageExpiration.low >>> 0, message.secondsUntilStorageExpiration.high >>> 0).toNumber() : message.secondsUntilStorageExpiration;
            if (message.storageExpirationDate != null && message.hasOwnProperty("storageExpirationDate"))
                object.storageExpirationDate = message.storageExpirationDate;
            if (message.hasAutoRenewableAppstoreSubscription != null && message.hasOwnProperty("hasAutoRenewableAppstoreSubscription"))
                object.hasAutoRenewableAppstoreSubscription = message.hasAutoRenewableAppstoreSubscription;
            if (message.accountType != null && message.hasOwnProperty("accountType"))
                object.accountType = message.accountType;
            if (message.uploadsRemaining != null && message.hasOwnProperty("uploadsRemaining"))
                object.uploadsRemaining = message.uploadsRemaining;
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                object.enterpriseId = message.enterpriseId;
            if (message.chatEnabled != null && message.hasOwnProperty("chatEnabled"))
                object.chatEnabled = message.chatEnabled;
            if (message.auditAndReportingEnabled != null && message.hasOwnProperty("auditAndReportingEnabled"))
                object.auditAndReportingEnabled = message.auditAndReportingEnabled;
            if (message.breachWatchFeatureDisable != null && message.hasOwnProperty("breachWatchFeatureDisable"))
                object.breachWatchFeatureDisable = message.breachWatchFeatureDisable;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.allowPersonalLicense != null && message.hasOwnProperty("allowPersonalLicense"))
                object.allowPersonalLicense = message.allowPersonalLicense;
            if (message.licensedBy != null && message.hasOwnProperty("licensedBy"))
                object.licensedBy = message.licensedBy;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.breachWatchEnabled != null && message.hasOwnProperty("breachWatchEnabled"))
                object.breachWatchEnabled = message.breachWatchEnabled;
            if (message.breachWatchScanned != null && message.hasOwnProperty("breachWatchScanned"))
                object.breachWatchScanned = message.breachWatchScanned;
            if (message.breachWatchExpiration != null && message.hasOwnProperty("breachWatchExpiration"))
                if (typeof message.breachWatchExpiration === "number")
                    object.breachWatchExpiration = options.longs === String ? String(message.breachWatchExpiration) : message.breachWatchExpiration;
                else
                    object.breachWatchExpiration = options.longs === String ? $util.Long.prototype.toString.call(message.breachWatchExpiration) : options.longs === Number ? new $util.LongBits(message.breachWatchExpiration.low >>> 0, message.breachWatchExpiration.high >>> 0).toNumber() : message.breachWatchExpiration;
            if (message.breachWatchDateCreated != null && message.hasOwnProperty("breachWatchDateCreated"))
                if (typeof message.breachWatchDateCreated === "number")
                    object.breachWatchDateCreated = options.longs === String ? String(message.breachWatchDateCreated) : message.breachWatchDateCreated;
                else
                    object.breachWatchDateCreated = options.longs === String ? $util.Long.prototype.toString.call(message.breachWatchDateCreated) : options.longs === Number ? new $util.LongBits(message.breachWatchDateCreated.low >>> 0, message.breachWatchDateCreated.high >>> 0).toNumber() : message.breachWatchDateCreated;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.AccountSummary.Result.toObject(message.error, options);
            return object;
        };

        /**
         * Converts this License to JSON.
         * @function toJSON
         * @memberof AccountSummary.License
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        License.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return License;
    })();

    AccountSummary.AddOn = (function() {

        /**
         * Properties of an AddOn.
         * @memberof AccountSummary
         * @interface IAddOn
         * @property {number|null} [licenseKeyId] AddOn licenseKeyId
         * @property {string|null} [name] AddOn name
         * @property {number|Long|null} [expirationDate] AddOn expirationDate
         * @property {number|Long|null} [createdDate] AddOn createdDate
         * @property {boolean|null} [isTrial] AddOn isTrial
         * @property {boolean|null} [enabled] AddOn enabled
         * @property {boolean|null} [scanned] AddOn scanned
         * @property {boolean|null} [featureDisable] AddOn featureDisable
         */

        /**
         * Constructs a new AddOn.
         * @memberof AccountSummary
         * @classdesc Represents an AddOn.
         * @implements IAddOn
         * @constructor
         * @param {AccountSummary.IAddOn=} [properties] Properties to set
         */
        function AddOn(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddOn licenseKeyId.
         * @member {number} licenseKeyId
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.licenseKeyId = 0;

        /**
         * AddOn name.
         * @member {string} name
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.name = "";

        /**
         * AddOn expirationDate.
         * @member {number|Long} expirationDate
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.expirationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AddOn createdDate.
         * @member {number|Long} createdDate
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.createdDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AddOn isTrial.
         * @member {boolean} isTrial
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.isTrial = false;

        /**
         * AddOn enabled.
         * @member {boolean} enabled
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.enabled = false;

        /**
         * AddOn scanned.
         * @member {boolean} scanned
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.scanned = false;

        /**
         * AddOn featureDisable.
         * @member {boolean} featureDisable
         * @memberof AccountSummary.AddOn
         * @instance
         */
        AddOn.prototype.featureDisable = false;

        /**
         * Creates a new AddOn instance using the specified properties.
         * @function create
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn=} [properties] Properties to set
         * @returns {AccountSummary.AddOn} AddOn instance
         */
        AddOn.create = function create(properties) {
            return new AddOn(properties);
        };

        /**
         * Encodes the specified AddOn message. Does not implicitly {@link AccountSummary.AddOn.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn} message AddOn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOn.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.licenseKeyId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.expirationDate);
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.createdDate);
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isTrial);
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enabled);
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.scanned);
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.featureDisable);
            return writer;
        };

        /**
         * Encodes the specified AddOn message, length delimited. Does not implicitly {@link AccountSummary.AddOn.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.IAddOn} message AddOn message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddOn.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddOn message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.AddOn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.AddOn} AddOn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOn.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.AddOn();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.licenseKeyId = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.expirationDate = reader.int64();
                    break;
                case 4:
                    message.createdDate = reader.int64();
                    break;
                case 5:
                    message.isTrial = reader.bool();
                    break;
                case 6:
                    message.enabled = reader.bool();
                    break;
                case 7:
                    message.scanned = reader.bool();
                    break;
                case 8:
                    message.featureDisable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddOn message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.AddOn
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.AddOn} AddOn
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddOn.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddOn message.
         * @function verify
         * @memberof AccountSummary.AddOn
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddOn.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                if (!$util.isInteger(message.licenseKeyId))
                    return "licenseKeyId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (!$util.isInteger(message.expirationDate) && !(message.expirationDate && $util.isInteger(message.expirationDate.low) && $util.isInteger(message.expirationDate.high)))
                    return "expirationDate: integer|Long expected";
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                if (!$util.isInteger(message.createdDate) && !(message.createdDate && $util.isInteger(message.createdDate.low) && $util.isInteger(message.createdDate.high)))
                    return "createdDate: integer|Long expected";
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                if (typeof message.isTrial !== "boolean")
                    return "isTrial: boolean expected";
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                if (typeof message.enabled !== "boolean")
                    return "enabled: boolean expected";
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                if (typeof message.scanned !== "boolean")
                    return "scanned: boolean expected";
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                if (typeof message.featureDisable !== "boolean")
                    return "featureDisable: boolean expected";
            return null;
        };

        /**
         * Creates an AddOn message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.AddOn
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.AddOn} AddOn
         */
        AddOn.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.AddOn)
                return object;
            let message = new $root.AccountSummary.AddOn();
            if (object.licenseKeyId != null)
                message.licenseKeyId = object.licenseKeyId | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.expirationDate != null)
                if ($util.Long)
                    (message.expirationDate = $util.Long.fromValue(object.expirationDate)).unsigned = false;
                else if (typeof object.expirationDate === "string")
                    message.expirationDate = parseInt(object.expirationDate, 10);
                else if (typeof object.expirationDate === "number")
                    message.expirationDate = object.expirationDate;
                else if (typeof object.expirationDate === "object")
                    message.expirationDate = new $util.LongBits(object.expirationDate.low >>> 0, object.expirationDate.high >>> 0).toNumber();
            if (object.createdDate != null)
                if ($util.Long)
                    (message.createdDate = $util.Long.fromValue(object.createdDate)).unsigned = false;
                else if (typeof object.createdDate === "string")
                    message.createdDate = parseInt(object.createdDate, 10);
                else if (typeof object.createdDate === "number")
                    message.createdDate = object.createdDate;
                else if (typeof object.createdDate === "object")
                    message.createdDate = new $util.LongBits(object.createdDate.low >>> 0, object.createdDate.high >>> 0).toNumber();
            if (object.isTrial != null)
                message.isTrial = Boolean(object.isTrial);
            if (object.enabled != null)
                message.enabled = Boolean(object.enabled);
            if (object.scanned != null)
                message.scanned = Boolean(object.scanned);
            if (object.featureDisable != null)
                message.featureDisable = Boolean(object.featureDisable);
            return message;
        };

        /**
         * Creates a plain object from an AddOn message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.AddOn
         * @static
         * @param {AccountSummary.AddOn} message AddOn
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddOn.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.licenseKeyId = 0;
                object.name = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expirationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expirationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.createdDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.createdDate = options.longs === String ? "0" : 0;
                object.isTrial = false;
                object.enabled = false;
                object.scanned = false;
                object.featureDisable = false;
            }
            if (message.licenseKeyId != null && message.hasOwnProperty("licenseKeyId"))
                object.licenseKeyId = message.licenseKeyId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (typeof message.expirationDate === "number")
                    object.expirationDate = options.longs === String ? String(message.expirationDate) : message.expirationDate;
                else
                    object.expirationDate = options.longs === String ? $util.Long.prototype.toString.call(message.expirationDate) : options.longs === Number ? new $util.LongBits(message.expirationDate.low >>> 0, message.expirationDate.high >>> 0).toNumber() : message.expirationDate;
            if (message.createdDate != null && message.hasOwnProperty("createdDate"))
                if (typeof message.createdDate === "number")
                    object.createdDate = options.longs === String ? String(message.createdDate) : message.createdDate;
                else
                    object.createdDate = options.longs === String ? $util.Long.prototype.toString.call(message.createdDate) : options.longs === Number ? new $util.LongBits(message.createdDate.low >>> 0, message.createdDate.high >>> 0).toNumber() : message.createdDate;
            if (message.isTrial != null && message.hasOwnProperty("isTrial"))
                object.isTrial = message.isTrial;
            if (message.enabled != null && message.hasOwnProperty("enabled"))
                object.enabled = message.enabled;
            if (message.scanned != null && message.hasOwnProperty("scanned"))
                object.scanned = message.scanned;
            if (message.featureDisable != null && message.hasOwnProperty("featureDisable"))
                object.featureDisable = message.featureDisable;
            return object;
        };

        /**
         * Converts this AddOn to JSON.
         * @function toJSON
         * @memberof AccountSummary.AddOn
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddOn.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddOn;
    })();

    AccountSummary.Settings = (function() {

        /**
         * Properties of a Settings.
         * @memberof AccountSummary
         * @interface ISettings
         * @property {boolean|null} [audit] Settings audit
         * @property {number|Long|null} [mustPerformAccountShareBy] Settings mustPerformAccountShareBy
         * @property {Array.<AccountSummary.IMissingAccountShareKey>|null} [shareAccountTo] Settings shareAccountTo
         * @property {Array.<AccountSummary.IPasswordRule>|null} [rules] Settings rules
         * @property {string|null} [passwordRulesIntro] Settings passwordRulesIntro
         * @property {number|null} [autoBackupDays] Settings autoBackupDays
         * @property {string|null} [theme] Settings theme
         * @property {string|null} [channel] Settings channel
         * @property {string|null} [channelValue] Settings channelValue
         * @property {boolean|null} [rsaConfigured] Settings rsaConfigured
         * @property {boolean|null} [emailVerified] Settings emailVerified
         * @property {number|null} [masterPasswordLastModified] Settings masterPasswordLastModified
         * @property {Uint8Array|null} [accountFolderKey] Settings accountFolderKey
         * @property {Array.<AccountSummary.ISecurityKey>|null} [securityKeys] Settings securityKeys
         * @property {Array.<AccountSummary.IKeyValue>|null} [keyValues] ?????
         * @property {boolean|null} [ssoUser] Settings ssoUser
         * @property {boolean|null} [onlineAccessOnly] Settings onlineAccessOnly
         * @property {number|null} [masterPasswordExpiry] Settings masterPasswordExpiry
         * @property {boolean|null} [twoFactorRequired] Settings twoFactorRequired
         * @property {boolean|null} [disallowExport] Settings disallowExport
         * @property {boolean|null} [restrictFiles] Settings restrictFiles
         * @property {boolean|null} [restrictAllSharing] Settings restrictAllSharing
         * @property {boolean|null} [restrictSharing] Settings restrictSharing
         * @property {boolean|null} [restrictSharingIncomingAll] Settings restrictSharingIncomingAll
         * @property {boolean|null} [restrictSharingIncomingEnterprise] Settings restrictSharingIncomingEnterprise
         * @property {number|Long|null} [logoutTimer] Settings logoutTimer
         * @property {boolean|null} [persistentLogin] Settings persistentLogin
         * @property {boolean|null} [ipDisableAutoApprove] Settings ipDisableAutoApprove
         * @property {boolean|null} [shareDataKeyWithEccPublicKey] Settings shareDataKeyWithEccPublicKey
         * @property {boolean|null} [shareDataKeyWithDevicePublicKey] Settings shareDataKeyWithDevicePublicKey
         */

        /**
         * Constructs a new Settings.
         * @memberof AccountSummary
         * @classdesc Represents a Settings.
         * @implements ISettings
         * @constructor
         * @param {AccountSummary.ISettings=} [properties] Properties to set
         */
        function Settings(properties) {
            this.shareAccountTo = [];
            this.rules = [];
            this.securityKeys = [];
            this.keyValues = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Settings audit.
         * @member {boolean} audit
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.audit = false;

        /**
         * Settings mustPerformAccountShareBy.
         * @member {number|Long} mustPerformAccountShareBy
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.mustPerformAccountShareBy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Settings shareAccountTo.
         * @member {Array.<AccountSummary.IMissingAccountShareKey>} shareAccountTo
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.shareAccountTo = $util.emptyArray;

        /**
         * Settings rules.
         * @member {Array.<AccountSummary.IPasswordRule>} rules
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.rules = $util.emptyArray;

        /**
         * Settings passwordRulesIntro.
         * @member {string} passwordRulesIntro
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.passwordRulesIntro = "";

        /**
         * Settings autoBackupDays.
         * @member {number} autoBackupDays
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.autoBackupDays = 0;

        /**
         * Settings theme.
         * @member {string} theme
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.theme = "";

        /**
         * Settings channel.
         * @member {string} channel
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.channel = "";

        /**
         * Settings channelValue.
         * @member {string} channelValue
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.channelValue = "";

        /**
         * Settings rsaConfigured.
         * @member {boolean} rsaConfigured
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.rsaConfigured = false;

        /**
         * Settings emailVerified.
         * @member {boolean} emailVerified
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.emailVerified = false;

        /**
         * Settings masterPasswordLastModified.
         * @member {number} masterPasswordLastModified
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.masterPasswordLastModified = 0;

        /**
         * Settings accountFolderKey.
         * @member {Uint8Array} accountFolderKey
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.accountFolderKey = $util.newBuffer([]);

        /**
         * Settings securityKeys.
         * @member {Array.<AccountSummary.ISecurityKey>} securityKeys
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.securityKeys = $util.emptyArray;

        /**
         * ?????
         * @member {Array.<AccountSummary.IKeyValue>} keyValues
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.keyValues = $util.emptyArray;

        /**
         * Settings ssoUser.
         * @member {boolean} ssoUser
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.ssoUser = false;

        /**
         * Settings onlineAccessOnly.
         * @member {boolean} onlineAccessOnly
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.onlineAccessOnly = false;

        /**
         * Settings masterPasswordExpiry.
         * @member {number} masterPasswordExpiry
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.masterPasswordExpiry = 0;

        /**
         * Settings twoFactorRequired.
         * @member {boolean} twoFactorRequired
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.twoFactorRequired = false;

        /**
         * Settings disallowExport.
         * @member {boolean} disallowExport
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.disallowExport = false;

        /**
         * Settings restrictFiles.
         * @member {boolean} restrictFiles
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.restrictFiles = false;

        /**
         * Settings restrictAllSharing.
         * @member {boolean} restrictAllSharing
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.restrictAllSharing = false;

        /**
         * Settings restrictSharing.
         * @member {boolean} restrictSharing
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.restrictSharing = false;

        /**
         * Settings restrictSharingIncomingAll.
         * @member {boolean} restrictSharingIncomingAll
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.restrictSharingIncomingAll = false;

        /**
         * Settings restrictSharingIncomingEnterprise.
         * @member {boolean} restrictSharingIncomingEnterprise
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.restrictSharingIncomingEnterprise = false;

        /**
         * Settings logoutTimer.
         * @member {number|Long} logoutTimer
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.logoutTimer = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Settings persistentLogin.
         * @member {boolean} persistentLogin
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.persistentLogin = false;

        /**
         * Settings ipDisableAutoApprove.
         * @member {boolean} ipDisableAutoApprove
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.ipDisableAutoApprove = false;

        /**
         * Settings shareDataKeyWithEccPublicKey.
         * @member {boolean} shareDataKeyWithEccPublicKey
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.shareDataKeyWithEccPublicKey = false;

        /**
         * Settings shareDataKeyWithDevicePublicKey.
         * @member {boolean} shareDataKeyWithDevicePublicKey
         * @memberof AccountSummary.Settings
         * @instance
         */
        Settings.prototype.shareDataKeyWithDevicePublicKey = false;

        /**
         * Creates a new Settings instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings=} [properties] Properties to set
         * @returns {AccountSummary.Settings} Settings instance
         */
        Settings.create = function create(properties) {
            return new Settings(properties);
        };

        /**
         * Encodes the specified Settings message. Does not implicitly {@link AccountSummary.Settings.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings} message Settings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Settings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.audit != null && message.hasOwnProperty("audit"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.audit);
            if (message.mustPerformAccountShareBy != null && message.hasOwnProperty("mustPerformAccountShareBy"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.mustPerformAccountShareBy);
            if (message.shareAccountTo != null && message.shareAccountTo.length)
                for (let i = 0; i < message.shareAccountTo.length; ++i)
                    $root.AccountSummary.MissingAccountShareKey.encode(message.shareAccountTo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.rules != null && message.rules.length)
                for (let i = 0; i < message.rules.length; ++i)
                    $root.AccountSummary.PasswordRule.encode(message.rules[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.passwordRulesIntro);
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.autoBackupDays);
            if (message.theme != null && message.hasOwnProperty("theme"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.theme);
            if (message.channel != null && message.hasOwnProperty("channel"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.channel);
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.channelValue);
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.rsaConfigured);
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.emailVerified);
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.masterPasswordLastModified);
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.accountFolderKey);
            if (message.securityKeys != null && message.securityKeys.length)
                for (let i = 0; i < message.securityKeys.length; ++i)
                    $root.AccountSummary.SecurityKey.encode(message.securityKeys[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.keyValues != null && message.keyValues.length)
                for (let i = 0; i < message.keyValues.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.keyValues[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.ssoUser != null && message.hasOwnProperty("ssoUser"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ssoUser);
            if (message.onlineAccessOnly != null && message.hasOwnProperty("onlineAccessOnly"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.onlineAccessOnly);
            if (message.masterPasswordExpiry != null && message.hasOwnProperty("masterPasswordExpiry"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.masterPasswordExpiry);
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.twoFactorRequired);
            if (message.disallowExport != null && message.hasOwnProperty("disallowExport"))
                writer.uint32(/* id 20, wireType 0 =*/160).bool(message.disallowExport);
            if (message.restrictFiles != null && message.hasOwnProperty("restrictFiles"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.restrictFiles);
            if (message.restrictAllSharing != null && message.hasOwnProperty("restrictAllSharing"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.restrictAllSharing);
            if (message.restrictSharing != null && message.hasOwnProperty("restrictSharing"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.restrictSharing);
            if (message.restrictSharingIncomingAll != null && message.hasOwnProperty("restrictSharingIncomingAll"))
                writer.uint32(/* id 24, wireType 0 =*/192).bool(message.restrictSharingIncomingAll);
            if (message.restrictSharingIncomingEnterprise != null && message.hasOwnProperty("restrictSharingIncomingEnterprise"))
                writer.uint32(/* id 25, wireType 0 =*/200).bool(message.restrictSharingIncomingEnterprise);
            if (message.logoutTimer != null && message.hasOwnProperty("logoutTimer"))
                writer.uint32(/* id 26, wireType 0 =*/208).int64(message.logoutTimer);
            if (message.persistentLogin != null && message.hasOwnProperty("persistentLogin"))
                writer.uint32(/* id 27, wireType 0 =*/216).bool(message.persistentLogin);
            if (message.ipDisableAutoApprove != null && message.hasOwnProperty("ipDisableAutoApprove"))
                writer.uint32(/* id 28, wireType 0 =*/224).bool(message.ipDisableAutoApprove);
            if (message.shareDataKeyWithEccPublicKey != null && message.hasOwnProperty("shareDataKeyWithEccPublicKey"))
                writer.uint32(/* id 29, wireType 0 =*/232).bool(message.shareDataKeyWithEccPublicKey);
            if (message.shareDataKeyWithDevicePublicKey != null && message.hasOwnProperty("shareDataKeyWithDevicePublicKey"))
                writer.uint32(/* id 30, wireType 0 =*/240).bool(message.shareDataKeyWithDevicePublicKey);
            return writer;
        };

        /**
         * Encodes the specified Settings message, length delimited. Does not implicitly {@link AccountSummary.Settings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.ISettings} message Settings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Settings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Settings message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Settings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Settings} Settings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Settings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Settings();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.audit = reader.bool();
                    break;
                case 2:
                    message.mustPerformAccountShareBy = reader.int64();
                    break;
                case 3:
                    if (!(message.shareAccountTo && message.shareAccountTo.length))
                        message.shareAccountTo = [];
                    message.shareAccountTo.push($root.AccountSummary.MissingAccountShareKey.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.rules && message.rules.length))
                        message.rules = [];
                    message.rules.push($root.AccountSummary.PasswordRule.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.passwordRulesIntro = reader.string();
                    break;
                case 6:
                    message.autoBackupDays = reader.int32();
                    break;
                case 7:
                    message.theme = reader.string();
                    break;
                case 8:
                    message.channel = reader.string();
                    break;
                case 9:
                    message.channelValue = reader.string();
                    break;
                case 10:
                    message.rsaConfigured = reader.bool();
                    break;
                case 11:
                    message.emailVerified = reader.bool();
                    break;
                case 12:
                    message.masterPasswordLastModified = reader.double();
                    break;
                case 13:
                    message.accountFolderKey = reader.bytes();
                    break;
                case 14:
                    if (!(message.securityKeys && message.securityKeys.length))
                        message.securityKeys = [];
                    message.securityKeys.push($root.AccountSummary.SecurityKey.decode(reader, reader.uint32()));
                    break;
                case 15:
                    if (!(message.keyValues && message.keyValues.length))
                        message.keyValues = [];
                    message.keyValues.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.ssoUser = reader.bool();
                    break;
                case 17:
                    message.onlineAccessOnly = reader.bool();
                    break;
                case 18:
                    message.masterPasswordExpiry = reader.int32();
                    break;
                case 19:
                    message.twoFactorRequired = reader.bool();
                    break;
                case 20:
                    message.disallowExport = reader.bool();
                    break;
                case 21:
                    message.restrictFiles = reader.bool();
                    break;
                case 22:
                    message.restrictAllSharing = reader.bool();
                    break;
                case 23:
                    message.restrictSharing = reader.bool();
                    break;
                case 24:
                    message.restrictSharingIncomingAll = reader.bool();
                    break;
                case 25:
                    message.restrictSharingIncomingEnterprise = reader.bool();
                    break;
                case 26:
                    message.logoutTimer = reader.int64();
                    break;
                case 27:
                    message.persistentLogin = reader.bool();
                    break;
                case 28:
                    message.ipDisableAutoApprove = reader.bool();
                    break;
                case 29:
                    message.shareDataKeyWithEccPublicKey = reader.bool();
                    break;
                case 30:
                    message.shareDataKeyWithDevicePublicKey = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Settings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Settings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Settings} Settings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Settings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Settings message.
         * @function verify
         * @memberof AccountSummary.Settings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Settings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.audit != null && message.hasOwnProperty("audit"))
                if (typeof message.audit !== "boolean")
                    return "audit: boolean expected";
            if (message.mustPerformAccountShareBy != null && message.hasOwnProperty("mustPerformAccountShareBy"))
                if (!$util.isInteger(message.mustPerformAccountShareBy) && !(message.mustPerformAccountShareBy && $util.isInteger(message.mustPerformAccountShareBy.low) && $util.isInteger(message.mustPerformAccountShareBy.high)))
                    return "mustPerformAccountShareBy: integer|Long expected";
            if (message.shareAccountTo != null && message.hasOwnProperty("shareAccountTo")) {
                if (!Array.isArray(message.shareAccountTo))
                    return "shareAccountTo: array expected";
                for (let i = 0; i < message.shareAccountTo.length; ++i) {
                    let error = $root.AccountSummary.MissingAccountShareKey.verify(message.shareAccountTo[i]);
                    if (error)
                        return "shareAccountTo." + error;
                }
            }
            if (message.rules != null && message.hasOwnProperty("rules")) {
                if (!Array.isArray(message.rules))
                    return "rules: array expected";
                for (let i = 0; i < message.rules.length; ++i) {
                    let error = $root.AccountSummary.PasswordRule.verify(message.rules[i]);
                    if (error)
                        return "rules." + error;
                }
            }
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                if (!$util.isString(message.passwordRulesIntro))
                    return "passwordRulesIntro: string expected";
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                if (!$util.isInteger(message.autoBackupDays))
                    return "autoBackupDays: integer expected";
            if (message.theme != null && message.hasOwnProperty("theme"))
                if (!$util.isString(message.theme))
                    return "theme: string expected";
            if (message.channel != null && message.hasOwnProperty("channel"))
                if (!$util.isString(message.channel))
                    return "channel: string expected";
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                if (!$util.isString(message.channelValue))
                    return "channelValue: string expected";
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                if (typeof message.rsaConfigured !== "boolean")
                    return "rsaConfigured: boolean expected";
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                if (typeof message.emailVerified !== "boolean")
                    return "emailVerified: boolean expected";
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                if (typeof message.masterPasswordLastModified !== "number")
                    return "masterPasswordLastModified: number expected";
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                if (!(message.accountFolderKey && typeof message.accountFolderKey.length === "number" || $util.isString(message.accountFolderKey)))
                    return "accountFolderKey: buffer expected";
            if (message.securityKeys != null && message.hasOwnProperty("securityKeys")) {
                if (!Array.isArray(message.securityKeys))
                    return "securityKeys: array expected";
                for (let i = 0; i < message.securityKeys.length; ++i) {
                    let error = $root.AccountSummary.SecurityKey.verify(message.securityKeys[i]);
                    if (error)
                        return "securityKeys." + error;
                }
            }
            if (message.keyValues != null && message.hasOwnProperty("keyValues")) {
                if (!Array.isArray(message.keyValues))
                    return "keyValues: array expected";
                for (let i = 0; i < message.keyValues.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.keyValues[i]);
                    if (error)
                        return "keyValues." + error;
                }
            }
            if (message.ssoUser != null && message.hasOwnProperty("ssoUser"))
                if (typeof message.ssoUser !== "boolean")
                    return "ssoUser: boolean expected";
            if (message.onlineAccessOnly != null && message.hasOwnProperty("onlineAccessOnly"))
                if (typeof message.onlineAccessOnly !== "boolean")
                    return "onlineAccessOnly: boolean expected";
            if (message.masterPasswordExpiry != null && message.hasOwnProperty("masterPasswordExpiry"))
                if (!$util.isInteger(message.masterPasswordExpiry))
                    return "masterPasswordExpiry: integer expected";
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                if (typeof message.twoFactorRequired !== "boolean")
                    return "twoFactorRequired: boolean expected";
            if (message.disallowExport != null && message.hasOwnProperty("disallowExport"))
                if (typeof message.disallowExport !== "boolean")
                    return "disallowExport: boolean expected";
            if (message.restrictFiles != null && message.hasOwnProperty("restrictFiles"))
                if (typeof message.restrictFiles !== "boolean")
                    return "restrictFiles: boolean expected";
            if (message.restrictAllSharing != null && message.hasOwnProperty("restrictAllSharing"))
                if (typeof message.restrictAllSharing !== "boolean")
                    return "restrictAllSharing: boolean expected";
            if (message.restrictSharing != null && message.hasOwnProperty("restrictSharing"))
                if (typeof message.restrictSharing !== "boolean")
                    return "restrictSharing: boolean expected";
            if (message.restrictSharingIncomingAll != null && message.hasOwnProperty("restrictSharingIncomingAll"))
                if (typeof message.restrictSharingIncomingAll !== "boolean")
                    return "restrictSharingIncomingAll: boolean expected";
            if (message.restrictSharingIncomingEnterprise != null && message.hasOwnProperty("restrictSharingIncomingEnterprise"))
                if (typeof message.restrictSharingIncomingEnterprise !== "boolean")
                    return "restrictSharingIncomingEnterprise: boolean expected";
            if (message.logoutTimer != null && message.hasOwnProperty("logoutTimer"))
                if (!$util.isInteger(message.logoutTimer) && !(message.logoutTimer && $util.isInteger(message.logoutTimer.low) && $util.isInteger(message.logoutTimer.high)))
                    return "logoutTimer: integer|Long expected";
            if (message.persistentLogin != null && message.hasOwnProperty("persistentLogin"))
                if (typeof message.persistentLogin !== "boolean")
                    return "persistentLogin: boolean expected";
            if (message.ipDisableAutoApprove != null && message.hasOwnProperty("ipDisableAutoApprove"))
                if (typeof message.ipDisableAutoApprove !== "boolean")
                    return "ipDisableAutoApprove: boolean expected";
            if (message.shareDataKeyWithEccPublicKey != null && message.hasOwnProperty("shareDataKeyWithEccPublicKey"))
                if (typeof message.shareDataKeyWithEccPublicKey !== "boolean")
                    return "shareDataKeyWithEccPublicKey: boolean expected";
            if (message.shareDataKeyWithDevicePublicKey != null && message.hasOwnProperty("shareDataKeyWithDevicePublicKey"))
                if (typeof message.shareDataKeyWithDevicePublicKey !== "boolean")
                    return "shareDataKeyWithDevicePublicKey: boolean expected";
            return null;
        };

        /**
         * Creates a Settings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Settings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Settings} Settings
         */
        Settings.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Settings)
                return object;
            let message = new $root.AccountSummary.Settings();
            if (object.audit != null)
                message.audit = Boolean(object.audit);
            if (object.mustPerformAccountShareBy != null)
                if ($util.Long)
                    (message.mustPerformAccountShareBy = $util.Long.fromValue(object.mustPerformAccountShareBy)).unsigned = false;
                else if (typeof object.mustPerformAccountShareBy === "string")
                    message.mustPerformAccountShareBy = parseInt(object.mustPerformAccountShareBy, 10);
                else if (typeof object.mustPerformAccountShareBy === "number")
                    message.mustPerformAccountShareBy = object.mustPerformAccountShareBy;
                else if (typeof object.mustPerformAccountShareBy === "object")
                    message.mustPerformAccountShareBy = new $util.LongBits(object.mustPerformAccountShareBy.low >>> 0, object.mustPerformAccountShareBy.high >>> 0).toNumber();
            if (object.shareAccountTo) {
                if (!Array.isArray(object.shareAccountTo))
                    throw TypeError(".AccountSummary.Settings.shareAccountTo: array expected");
                message.shareAccountTo = [];
                for (let i = 0; i < object.shareAccountTo.length; ++i) {
                    if (typeof object.shareAccountTo[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.shareAccountTo: object expected");
                    message.shareAccountTo[i] = $root.AccountSummary.MissingAccountShareKey.fromObject(object.shareAccountTo[i]);
                }
            }
            if (object.rules) {
                if (!Array.isArray(object.rules))
                    throw TypeError(".AccountSummary.Settings.rules: array expected");
                message.rules = [];
                for (let i = 0; i < object.rules.length; ++i) {
                    if (typeof object.rules[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.rules: object expected");
                    message.rules[i] = $root.AccountSummary.PasswordRule.fromObject(object.rules[i]);
                }
            }
            if (object.passwordRulesIntro != null)
                message.passwordRulesIntro = String(object.passwordRulesIntro);
            if (object.autoBackupDays != null)
                message.autoBackupDays = object.autoBackupDays | 0;
            if (object.theme != null)
                message.theme = String(object.theme);
            if (object.channel != null)
                message.channel = String(object.channel);
            if (object.channelValue != null)
                message.channelValue = String(object.channelValue);
            if (object.rsaConfigured != null)
                message.rsaConfigured = Boolean(object.rsaConfigured);
            if (object.emailVerified != null)
                message.emailVerified = Boolean(object.emailVerified);
            if (object.masterPasswordLastModified != null)
                message.masterPasswordLastModified = Number(object.masterPasswordLastModified);
            if (object.accountFolderKey != null)
                if (typeof object.accountFolderKey === "string")
                    $util.base64.decode(object.accountFolderKey, message.accountFolderKey = $util.newBuffer($util.base64.length(object.accountFolderKey)), 0);
                else if (object.accountFolderKey.length)
                    message.accountFolderKey = object.accountFolderKey;
            if (object.securityKeys) {
                if (!Array.isArray(object.securityKeys))
                    throw TypeError(".AccountSummary.Settings.securityKeys: array expected");
                message.securityKeys = [];
                for (let i = 0; i < object.securityKeys.length; ++i) {
                    if (typeof object.securityKeys[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.securityKeys: object expected");
                    message.securityKeys[i] = $root.AccountSummary.SecurityKey.fromObject(object.securityKeys[i]);
                }
            }
            if (object.keyValues) {
                if (!Array.isArray(object.keyValues))
                    throw TypeError(".AccountSummary.Settings.keyValues: array expected");
                message.keyValues = [];
                for (let i = 0; i < object.keyValues.length; ++i) {
                    if (typeof object.keyValues[i] !== "object")
                        throw TypeError(".AccountSummary.Settings.keyValues: object expected");
                    message.keyValues[i] = $root.AccountSummary.KeyValue.fromObject(object.keyValues[i]);
                }
            }
            if (object.ssoUser != null)
                message.ssoUser = Boolean(object.ssoUser);
            if (object.onlineAccessOnly != null)
                message.onlineAccessOnly = Boolean(object.onlineAccessOnly);
            if (object.masterPasswordExpiry != null)
                message.masterPasswordExpiry = object.masterPasswordExpiry | 0;
            if (object.twoFactorRequired != null)
                message.twoFactorRequired = Boolean(object.twoFactorRequired);
            if (object.disallowExport != null)
                message.disallowExport = Boolean(object.disallowExport);
            if (object.restrictFiles != null)
                message.restrictFiles = Boolean(object.restrictFiles);
            if (object.restrictAllSharing != null)
                message.restrictAllSharing = Boolean(object.restrictAllSharing);
            if (object.restrictSharing != null)
                message.restrictSharing = Boolean(object.restrictSharing);
            if (object.restrictSharingIncomingAll != null)
                message.restrictSharingIncomingAll = Boolean(object.restrictSharingIncomingAll);
            if (object.restrictSharingIncomingEnterprise != null)
                message.restrictSharingIncomingEnterprise = Boolean(object.restrictSharingIncomingEnterprise);
            if (object.logoutTimer != null)
                if ($util.Long)
                    (message.logoutTimer = $util.Long.fromValue(object.logoutTimer)).unsigned = false;
                else if (typeof object.logoutTimer === "string")
                    message.logoutTimer = parseInt(object.logoutTimer, 10);
                else if (typeof object.logoutTimer === "number")
                    message.logoutTimer = object.logoutTimer;
                else if (typeof object.logoutTimer === "object")
                    message.logoutTimer = new $util.LongBits(object.logoutTimer.low >>> 0, object.logoutTimer.high >>> 0).toNumber();
            if (object.persistentLogin != null)
                message.persistentLogin = Boolean(object.persistentLogin);
            if (object.ipDisableAutoApprove != null)
                message.ipDisableAutoApprove = Boolean(object.ipDisableAutoApprove);
            if (object.shareDataKeyWithEccPublicKey != null)
                message.shareDataKeyWithEccPublicKey = Boolean(object.shareDataKeyWithEccPublicKey);
            if (object.shareDataKeyWithDevicePublicKey != null)
                message.shareDataKeyWithDevicePublicKey = Boolean(object.shareDataKeyWithDevicePublicKey);
            return message;
        };

        /**
         * Creates a plain object from a Settings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Settings
         * @static
         * @param {AccountSummary.Settings} message Settings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Settings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.shareAccountTo = [];
                object.rules = [];
                object.securityKeys = [];
                object.keyValues = [];
            }
            if (options.defaults) {
                object.audit = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.mustPerformAccountShareBy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.mustPerformAccountShareBy = options.longs === String ? "0" : 0;
                object.passwordRulesIntro = "";
                object.autoBackupDays = 0;
                object.theme = "";
                object.channel = "";
                object.channelValue = "";
                object.rsaConfigured = false;
                object.emailVerified = false;
                object.masterPasswordLastModified = 0;
                if (options.bytes === String)
                    object.accountFolderKey = "";
                else {
                    object.accountFolderKey = [];
                    if (options.bytes !== Array)
                        object.accountFolderKey = $util.newBuffer(object.accountFolderKey);
                }
                object.ssoUser = false;
                object.onlineAccessOnly = false;
                object.masterPasswordExpiry = 0;
                object.twoFactorRequired = false;
                object.disallowExport = false;
                object.restrictFiles = false;
                object.restrictAllSharing = false;
                object.restrictSharing = false;
                object.restrictSharingIncomingAll = false;
                object.restrictSharingIncomingEnterprise = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.logoutTimer = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.logoutTimer = options.longs === String ? "0" : 0;
                object.persistentLogin = false;
                object.ipDisableAutoApprove = false;
                object.shareDataKeyWithEccPublicKey = false;
                object.shareDataKeyWithDevicePublicKey = false;
            }
            if (message.audit != null && message.hasOwnProperty("audit"))
                object.audit = message.audit;
            if (message.mustPerformAccountShareBy != null && message.hasOwnProperty("mustPerformAccountShareBy"))
                if (typeof message.mustPerformAccountShareBy === "number")
                    object.mustPerformAccountShareBy = options.longs === String ? String(message.mustPerformAccountShareBy) : message.mustPerformAccountShareBy;
                else
                    object.mustPerformAccountShareBy = options.longs === String ? $util.Long.prototype.toString.call(message.mustPerformAccountShareBy) : options.longs === Number ? new $util.LongBits(message.mustPerformAccountShareBy.low >>> 0, message.mustPerformAccountShareBy.high >>> 0).toNumber() : message.mustPerformAccountShareBy;
            if (message.shareAccountTo && message.shareAccountTo.length) {
                object.shareAccountTo = [];
                for (let j = 0; j < message.shareAccountTo.length; ++j)
                    object.shareAccountTo[j] = $root.AccountSummary.MissingAccountShareKey.toObject(message.shareAccountTo[j], options);
            }
            if (message.rules && message.rules.length) {
                object.rules = [];
                for (let j = 0; j < message.rules.length; ++j)
                    object.rules[j] = $root.AccountSummary.PasswordRule.toObject(message.rules[j], options);
            }
            if (message.passwordRulesIntro != null && message.hasOwnProperty("passwordRulesIntro"))
                object.passwordRulesIntro = message.passwordRulesIntro;
            if (message.autoBackupDays != null && message.hasOwnProperty("autoBackupDays"))
                object.autoBackupDays = message.autoBackupDays;
            if (message.theme != null && message.hasOwnProperty("theme"))
                object.theme = message.theme;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.channelValue != null && message.hasOwnProperty("channelValue"))
                object.channelValue = message.channelValue;
            if (message.rsaConfigured != null && message.hasOwnProperty("rsaConfigured"))
                object.rsaConfigured = message.rsaConfigured;
            if (message.emailVerified != null && message.hasOwnProperty("emailVerified"))
                object.emailVerified = message.emailVerified;
            if (message.masterPasswordLastModified != null && message.hasOwnProperty("masterPasswordLastModified"))
                object.masterPasswordLastModified = options.json && !isFinite(message.masterPasswordLastModified) ? String(message.masterPasswordLastModified) : message.masterPasswordLastModified;
            if (message.accountFolderKey != null && message.hasOwnProperty("accountFolderKey"))
                object.accountFolderKey = options.bytes === String ? $util.base64.encode(message.accountFolderKey, 0, message.accountFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountFolderKey) : message.accountFolderKey;
            if (message.securityKeys && message.securityKeys.length) {
                object.securityKeys = [];
                for (let j = 0; j < message.securityKeys.length; ++j)
                    object.securityKeys[j] = $root.AccountSummary.SecurityKey.toObject(message.securityKeys[j], options);
            }
            if (message.keyValues && message.keyValues.length) {
                object.keyValues = [];
                for (let j = 0; j < message.keyValues.length; ++j)
                    object.keyValues[j] = $root.AccountSummary.KeyValue.toObject(message.keyValues[j], options);
            }
            if (message.ssoUser != null && message.hasOwnProperty("ssoUser"))
                object.ssoUser = message.ssoUser;
            if (message.onlineAccessOnly != null && message.hasOwnProperty("onlineAccessOnly"))
                object.onlineAccessOnly = message.onlineAccessOnly;
            if (message.masterPasswordExpiry != null && message.hasOwnProperty("masterPasswordExpiry"))
                object.masterPasswordExpiry = message.masterPasswordExpiry;
            if (message.twoFactorRequired != null && message.hasOwnProperty("twoFactorRequired"))
                object.twoFactorRequired = message.twoFactorRequired;
            if (message.disallowExport != null && message.hasOwnProperty("disallowExport"))
                object.disallowExport = message.disallowExport;
            if (message.restrictFiles != null && message.hasOwnProperty("restrictFiles"))
                object.restrictFiles = message.restrictFiles;
            if (message.restrictAllSharing != null && message.hasOwnProperty("restrictAllSharing"))
                object.restrictAllSharing = message.restrictAllSharing;
            if (message.restrictSharing != null && message.hasOwnProperty("restrictSharing"))
                object.restrictSharing = message.restrictSharing;
            if (message.restrictSharingIncomingAll != null && message.hasOwnProperty("restrictSharingIncomingAll"))
                object.restrictSharingIncomingAll = message.restrictSharingIncomingAll;
            if (message.restrictSharingIncomingEnterprise != null && message.hasOwnProperty("restrictSharingIncomingEnterprise"))
                object.restrictSharingIncomingEnterprise = message.restrictSharingIncomingEnterprise;
            if (message.logoutTimer != null && message.hasOwnProperty("logoutTimer"))
                if (typeof message.logoutTimer === "number")
                    object.logoutTimer = options.longs === String ? String(message.logoutTimer) : message.logoutTimer;
                else
                    object.logoutTimer = options.longs === String ? $util.Long.prototype.toString.call(message.logoutTimer) : options.longs === Number ? new $util.LongBits(message.logoutTimer.low >>> 0, message.logoutTimer.high >>> 0).toNumber() : message.logoutTimer;
            if (message.persistentLogin != null && message.hasOwnProperty("persistentLogin"))
                object.persistentLogin = message.persistentLogin;
            if (message.ipDisableAutoApprove != null && message.hasOwnProperty("ipDisableAutoApprove"))
                object.ipDisableAutoApprove = message.ipDisableAutoApprove;
            if (message.shareDataKeyWithEccPublicKey != null && message.hasOwnProperty("shareDataKeyWithEccPublicKey"))
                object.shareDataKeyWithEccPublicKey = message.shareDataKeyWithEccPublicKey;
            if (message.shareDataKeyWithDevicePublicKey != null && message.hasOwnProperty("shareDataKeyWithDevicePublicKey"))
                object.shareDataKeyWithDevicePublicKey = message.shareDataKeyWithDevicePublicKey;
            return object;
        };

        /**
         * Converts this Settings to JSON.
         * @function toJSON
         * @memberof AccountSummary.Settings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Settings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Settings;
    })();

    AccountSummary.KeyValue = (function() {

        /**
         * Properties of a KeyValue.
         * @memberof AccountSummary
         * @interface IKeyValue
         * @property {string|null} [key] KeyValue key
         * @property {string|null} [value] KeyValue value
         */

        /**
         * Constructs a new KeyValue.
         * @memberof AccountSummary
         * @classdesc Represents a KeyValue.
         * @implements IKeyValue
         * @constructor
         * @param {AccountSummary.IKeyValue=} [properties] Properties to set
         */
        function KeyValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValue key.
         * @member {string} key
         * @memberof AccountSummary.KeyValue
         * @instance
         */
        KeyValue.prototype.key = "";

        /**
         * KeyValue value.
         * @member {string} value
         * @memberof AccountSummary.KeyValue
         * @instance
         */
        KeyValue.prototype.value = "";

        /**
         * Creates a new KeyValue instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue=} [properties] Properties to set
         * @returns {AccountSummary.KeyValue} KeyValue instance
         */
        KeyValue.create = function create(properties) {
            return new KeyValue(properties);
        };

        /**
         * Encodes the specified KeyValue message. Does not implicitly {@link AccountSummary.KeyValue.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue} message KeyValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link AccountSummary.KeyValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.IKeyValue} message KeyValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyValue message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeyValue} KeyValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeyValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeyValue} KeyValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyValue message.
         * @function verify
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeyValue} KeyValue
         */
        KeyValue.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeyValue)
                return object;
            let message = new $root.AccountSummary.KeyValue();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeyValue
         * @static
         * @param {AccountSummary.KeyValue} message KeyValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this KeyValue to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeyValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyValue;
    })();

    AccountSummary.KeyValueBoolean = (function() {

        /**
         * Properties of a KeyValueBoolean.
         * @memberof AccountSummary
         * @interface IKeyValueBoolean
         * @property {string|null} [key] KeyValueBoolean key
         * @property {boolean|null} [value] KeyValueBoolean value
         */

        /**
         * Constructs a new KeyValueBoolean.
         * @memberof AccountSummary
         * @classdesc Represents a KeyValueBoolean.
         * @implements IKeyValueBoolean
         * @constructor
         * @param {AccountSummary.IKeyValueBoolean=} [properties] Properties to set
         */
        function KeyValueBoolean(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValueBoolean key.
         * @member {string} key
         * @memberof AccountSummary.KeyValueBoolean
         * @instance
         */
        KeyValueBoolean.prototype.key = "";

        /**
         * KeyValueBoolean value.
         * @member {boolean} value
         * @memberof AccountSummary.KeyValueBoolean
         * @instance
         */
        KeyValueBoolean.prototype.value = false;

        /**
         * Creates a new KeyValueBoolean instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {AccountSummary.IKeyValueBoolean=} [properties] Properties to set
         * @returns {AccountSummary.KeyValueBoolean} KeyValueBoolean instance
         */
        KeyValueBoolean.create = function create(properties) {
            return new KeyValueBoolean(properties);
        };

        /**
         * Encodes the specified KeyValueBoolean message. Does not implicitly {@link AccountSummary.KeyValueBoolean.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {AccountSummary.IKeyValueBoolean} message KeyValueBoolean message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValueBoolean.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
            return writer;
        };

        /**
         * Encodes the specified KeyValueBoolean message, length delimited. Does not implicitly {@link AccountSummary.KeyValueBoolean.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {AccountSummary.IKeyValueBoolean} message KeyValueBoolean message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValueBoolean.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyValueBoolean message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeyValueBoolean} KeyValueBoolean
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueBoolean.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeyValueBoolean();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValueBoolean message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeyValueBoolean} KeyValueBoolean
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueBoolean.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyValueBoolean message.
         * @function verify
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyValueBoolean.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "boolean")
                    return "value: boolean expected";
            return null;
        };

        /**
         * Creates a KeyValueBoolean message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeyValueBoolean} KeyValueBoolean
         */
        KeyValueBoolean.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeyValueBoolean)
                return object;
            let message = new $root.AccountSummary.KeyValueBoolean();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = Boolean(object.value);
            return message;
        };

        /**
         * Creates a plain object from a KeyValueBoolean message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeyValueBoolean
         * @static
         * @param {AccountSummary.KeyValueBoolean} message KeyValueBoolean
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyValueBoolean.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = false;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this KeyValueBoolean to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeyValueBoolean
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyValueBoolean.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyValueBoolean;
    })();

    AccountSummary.KeyValueLong = (function() {

        /**
         * Properties of a KeyValueLong.
         * @memberof AccountSummary
         * @interface IKeyValueLong
         * @property {string|null} [key] KeyValueLong key
         * @property {number|Long|null} [value] KeyValueLong value
         */

        /**
         * Constructs a new KeyValueLong.
         * @memberof AccountSummary
         * @classdesc Represents a KeyValueLong.
         * @implements IKeyValueLong
         * @constructor
         * @param {AccountSummary.IKeyValueLong=} [properties] Properties to set
         */
        function KeyValueLong(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValueLong key.
         * @member {string} key
         * @memberof AccountSummary.KeyValueLong
         * @instance
         */
        KeyValueLong.prototype.key = "";

        /**
         * KeyValueLong value.
         * @member {number|Long} value
         * @memberof AccountSummary.KeyValueLong
         * @instance
         */
        KeyValueLong.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new KeyValueLong instance using the specified properties.
         * @function create
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {AccountSummary.IKeyValueLong=} [properties] Properties to set
         * @returns {AccountSummary.KeyValueLong} KeyValueLong instance
         */
        KeyValueLong.create = function create(properties) {
            return new KeyValueLong(properties);
        };

        /**
         * Encodes the specified KeyValueLong message. Does not implicitly {@link AccountSummary.KeyValueLong.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {AccountSummary.IKeyValueLong} message KeyValueLong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValueLong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
            return writer;
        };

        /**
         * Encodes the specified KeyValueLong message, length delimited. Does not implicitly {@link AccountSummary.KeyValueLong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {AccountSummary.IKeyValueLong} message KeyValueLong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValueLong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyValueLong message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.KeyValueLong} KeyValueLong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueLong.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.KeyValueLong();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValueLong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.KeyValueLong} KeyValueLong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValueLong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyValueLong message.
         * @function verify
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyValueLong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            return null;
        };

        /**
         * Creates a KeyValueLong message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.KeyValueLong} KeyValueLong
         */
        KeyValueLong.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.KeyValueLong)
                return object;
            let message = new $root.AccountSummary.KeyValueLong();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a KeyValueLong message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.KeyValueLong
         * @static
         * @param {AccountSummary.KeyValueLong} message KeyValueLong
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyValueLong.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            return object;
        };

        /**
         * Converts this KeyValueLong to JSON.
         * @function toJSON
         * @memberof AccountSummary.KeyValueLong
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyValueLong.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KeyValueLong;
    })();

    AccountSummary.Result = (function() {

        /**
         * Properties of a Result.
         * @memberof AccountSummary
         * @interface IResult
         * @property {string|null} [resultCode] Result resultCode
         * @property {string|null} [message] Result message
         * @property {string|null} [result] Result result
         */

        /**
         * Constructs a new Result.
         * @memberof AccountSummary
         * @classdesc Represents a Result.
         * @implements IResult
         * @constructor
         * @param {AccountSummary.IResult=} [properties] Properties to set
         */
        function Result(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Result resultCode.
         * @member {string} resultCode
         * @memberof AccountSummary.Result
         * @instance
         */
        Result.prototype.resultCode = "";

        /**
         * Result message.
         * @member {string} message
         * @memberof AccountSummary.Result
         * @instance
         */
        Result.prototype.message = "";

        /**
         * Result result.
         * @member {string} result
         * @memberof AccountSummary.Result
         * @instance
         */
        Result.prototype.result = "";

        /**
         * Creates a new Result instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Result
         * @static
         * @param {AccountSummary.IResult=} [properties] Properties to set
         * @returns {AccountSummary.Result} Result instance
         */
        Result.create = function create(properties) {
            return new Result(properties);
        };

        /**
         * Encodes the specified Result message. Does not implicitly {@link AccountSummary.Result.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Result
         * @static
         * @param {AccountSummary.IResult} message Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Result.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.resultCode != null && message.hasOwnProperty("resultCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.resultCode);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.result);
            return writer;
        };

        /**
         * Encodes the specified Result message, length delimited. Does not implicitly {@link AccountSummary.Result.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Result
         * @static
         * @param {AccountSummary.IResult} message Result message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Result.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Result message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Result} Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Result.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Result();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.resultCode = reader.string();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.result = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Result message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Result
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Result} Result
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Result.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Result message.
         * @function verify
         * @memberof AccountSummary.Result
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Result.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.resultCode != null && message.hasOwnProperty("resultCode"))
                if (!$util.isString(message.resultCode))
                    return "resultCode: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isString(message.result))
                    return "result: string expected";
            return null;
        };

        /**
         * Creates a Result message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Result
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Result} Result
         */
        Result.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Result)
                return object;
            let message = new $root.AccountSummary.Result();
            if (object.resultCode != null)
                message.resultCode = String(object.resultCode);
            if (object.message != null)
                message.message = String(object.message);
            if (object.result != null)
                message.result = String(object.result);
            return message;
        };

        /**
         * Creates a plain object from a Result message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Result
         * @static
         * @param {AccountSummary.Result} message Result
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Result.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.resultCode = "";
                object.message = "";
                object.result = "";
            }
            if (message.resultCode != null && message.hasOwnProperty("resultCode"))
                object.resultCode = message.resultCode;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };

        /**
         * Converts this Result to JSON.
         * @function toJSON
         * @memberof AccountSummary.Result
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Result.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Result;
    })();

    AccountSummary.Enforcements = (function() {

        /**
         * Properties of an Enforcements.
         * @memberof AccountSummary
         * @interface IEnforcements
         * @property {Array.<AccountSummary.IKeyValue>|null} [strings] Enforcements strings
         * @property {Array.<AccountSummary.IKeyValueBoolean>|null} [booleans] Enforcements booleans
         * @property {Array.<AccountSummary.IKeyValueLong>|null} [longs] Enforcements longs
         * @property {Array.<AccountSummary.IKeyValue>|null} [jsons] Enforcements jsons
         */

        /**
         * Constructs a new Enforcements.
         * @memberof AccountSummary
         * @classdesc Represents an Enforcements.
         * @implements IEnforcements
         * @constructor
         * @param {AccountSummary.IEnforcements=} [properties] Properties to set
         */
        function Enforcements(properties) {
            this.strings = [];
            this.booleans = [];
            this.longs = [];
            this.jsons = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Enforcements strings.
         * @member {Array.<AccountSummary.IKeyValue>} strings
         * @memberof AccountSummary.Enforcements
         * @instance
         */
        Enforcements.prototype.strings = $util.emptyArray;

        /**
         * Enforcements booleans.
         * @member {Array.<AccountSummary.IKeyValueBoolean>} booleans
         * @memberof AccountSummary.Enforcements
         * @instance
         */
        Enforcements.prototype.booleans = $util.emptyArray;

        /**
         * Enforcements longs.
         * @member {Array.<AccountSummary.IKeyValueLong>} longs
         * @memberof AccountSummary.Enforcements
         * @instance
         */
        Enforcements.prototype.longs = $util.emptyArray;

        /**
         * Enforcements jsons.
         * @member {Array.<AccountSummary.IKeyValue>} jsons
         * @memberof AccountSummary.Enforcements
         * @instance
         */
        Enforcements.prototype.jsons = $util.emptyArray;

        /**
         * Creates a new Enforcements instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {AccountSummary.IEnforcements=} [properties] Properties to set
         * @returns {AccountSummary.Enforcements} Enforcements instance
         */
        Enforcements.create = function create(properties) {
            return new Enforcements(properties);
        };

        /**
         * Encodes the specified Enforcements message. Does not implicitly {@link AccountSummary.Enforcements.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {AccountSummary.IEnforcements} message Enforcements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Enforcements.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.strings != null && message.strings.length)
                for (let i = 0; i < message.strings.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.strings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.booleans != null && message.booleans.length)
                for (let i = 0; i < message.booleans.length; ++i)
                    $root.AccountSummary.KeyValueBoolean.encode(message.booleans[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.longs != null && message.longs.length)
                for (let i = 0; i < message.longs.length; ++i)
                    $root.AccountSummary.KeyValueLong.encode(message.longs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.jsons != null && message.jsons.length)
                for (let i = 0; i < message.jsons.length; ++i)
                    $root.AccountSummary.KeyValue.encode(message.jsons[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Enforcements message, length delimited. Does not implicitly {@link AccountSummary.Enforcements.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {AccountSummary.IEnforcements} message Enforcements message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Enforcements.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Enforcements message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Enforcements} Enforcements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Enforcements.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Enforcements();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.strings && message.strings.length))
                        message.strings = [];
                    message.strings.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.booleans && message.booleans.length))
                        message.booleans = [];
                    message.booleans.push($root.AccountSummary.KeyValueBoolean.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.longs && message.longs.length))
                        message.longs = [];
                    message.longs.push($root.AccountSummary.KeyValueLong.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.jsons && message.jsons.length))
                        message.jsons = [];
                    message.jsons.push($root.AccountSummary.KeyValue.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Enforcements message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Enforcements} Enforcements
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Enforcements.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Enforcements message.
         * @function verify
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Enforcements.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.strings != null && message.hasOwnProperty("strings")) {
                if (!Array.isArray(message.strings))
                    return "strings: array expected";
                for (let i = 0; i < message.strings.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.strings[i]);
                    if (error)
                        return "strings." + error;
                }
            }
            if (message.booleans != null && message.hasOwnProperty("booleans")) {
                if (!Array.isArray(message.booleans))
                    return "booleans: array expected";
                for (let i = 0; i < message.booleans.length; ++i) {
                    let error = $root.AccountSummary.KeyValueBoolean.verify(message.booleans[i]);
                    if (error)
                        return "booleans." + error;
                }
            }
            if (message.longs != null && message.hasOwnProperty("longs")) {
                if (!Array.isArray(message.longs))
                    return "longs: array expected";
                for (let i = 0; i < message.longs.length; ++i) {
                    let error = $root.AccountSummary.KeyValueLong.verify(message.longs[i]);
                    if (error)
                        return "longs." + error;
                }
            }
            if (message.jsons != null && message.hasOwnProperty("jsons")) {
                if (!Array.isArray(message.jsons))
                    return "jsons: array expected";
                for (let i = 0; i < message.jsons.length; ++i) {
                    let error = $root.AccountSummary.KeyValue.verify(message.jsons[i]);
                    if (error)
                        return "jsons." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Enforcements message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Enforcements} Enforcements
         */
        Enforcements.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Enforcements)
                return object;
            let message = new $root.AccountSummary.Enforcements();
            if (object.strings) {
                if (!Array.isArray(object.strings))
                    throw TypeError(".AccountSummary.Enforcements.strings: array expected");
                message.strings = [];
                for (let i = 0; i < object.strings.length; ++i) {
                    if (typeof object.strings[i] !== "object")
                        throw TypeError(".AccountSummary.Enforcements.strings: object expected");
                    message.strings[i] = $root.AccountSummary.KeyValue.fromObject(object.strings[i]);
                }
            }
            if (object.booleans) {
                if (!Array.isArray(object.booleans))
                    throw TypeError(".AccountSummary.Enforcements.booleans: array expected");
                message.booleans = [];
                for (let i = 0; i < object.booleans.length; ++i) {
                    if (typeof object.booleans[i] !== "object")
                        throw TypeError(".AccountSummary.Enforcements.booleans: object expected");
                    message.booleans[i] = $root.AccountSummary.KeyValueBoolean.fromObject(object.booleans[i]);
                }
            }
            if (object.longs) {
                if (!Array.isArray(object.longs))
                    throw TypeError(".AccountSummary.Enforcements.longs: array expected");
                message.longs = [];
                for (let i = 0; i < object.longs.length; ++i) {
                    if (typeof object.longs[i] !== "object")
                        throw TypeError(".AccountSummary.Enforcements.longs: object expected");
                    message.longs[i] = $root.AccountSummary.KeyValueLong.fromObject(object.longs[i]);
                }
            }
            if (object.jsons) {
                if (!Array.isArray(object.jsons))
                    throw TypeError(".AccountSummary.Enforcements.jsons: array expected");
                message.jsons = [];
                for (let i = 0; i < object.jsons.length; ++i) {
                    if (typeof object.jsons[i] !== "object")
                        throw TypeError(".AccountSummary.Enforcements.jsons: object expected");
                    message.jsons[i] = $root.AccountSummary.KeyValue.fromObject(object.jsons[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Enforcements message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Enforcements
         * @static
         * @param {AccountSummary.Enforcements} message Enforcements
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Enforcements.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.strings = [];
                object.booleans = [];
                object.longs = [];
                object.jsons = [];
            }
            if (message.strings && message.strings.length) {
                object.strings = [];
                for (let j = 0; j < message.strings.length; ++j)
                    object.strings[j] = $root.AccountSummary.KeyValue.toObject(message.strings[j], options);
            }
            if (message.booleans && message.booleans.length) {
                object.booleans = [];
                for (let j = 0; j < message.booleans.length; ++j)
                    object.booleans[j] = $root.AccountSummary.KeyValueBoolean.toObject(message.booleans[j], options);
            }
            if (message.longs && message.longs.length) {
                object.longs = [];
                for (let j = 0; j < message.longs.length; ++j)
                    object.longs[j] = $root.AccountSummary.KeyValueLong.toObject(message.longs[j], options);
            }
            if (message.jsons && message.jsons.length) {
                object.jsons = [];
                for (let j = 0; j < message.jsons.length; ++j)
                    object.jsons[j] = $root.AccountSummary.KeyValue.toObject(message.jsons[j], options);
            }
            return object;
        };

        /**
         * Converts this Enforcements to JSON.
         * @function toJSON
         * @memberof AccountSummary.Enforcements
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Enforcements.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Enforcements;
    })();

    AccountSummary.MissingAccountShareKey = (function() {

        /**
         * Properties of a MissingAccountShareKey.
         * @memberof AccountSummary
         * @interface IMissingAccountShareKey
         * @property {number|Long|null} [roleId] MissingAccountShareKey roleId
         * @property {Uint8Array|null} [publicKey] MissingAccountShareKey publicKey
         */

        /**
         * Constructs a new MissingAccountShareKey.
         * @memberof AccountSummary
         * @classdesc Represents a MissingAccountShareKey.
         * @implements IMissingAccountShareKey
         * @constructor
         * @param {AccountSummary.IMissingAccountShareKey=} [properties] Properties to set
         */
        function MissingAccountShareKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MissingAccountShareKey roleId.
         * @member {number|Long} roleId
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         */
        MissingAccountShareKey.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MissingAccountShareKey publicKey.
         * @member {Uint8Array} publicKey
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         */
        MissingAccountShareKey.prototype.publicKey = $util.newBuffer([]);

        /**
         * Creates a new MissingAccountShareKey instance using the specified properties.
         * @function create
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey=} [properties] Properties to set
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey instance
         */
        MissingAccountShareKey.create = function create(properties) {
            return new MissingAccountShareKey(properties);
        };

        /**
         * Encodes the specified MissingAccountShareKey message. Does not implicitly {@link AccountSummary.MissingAccountShareKey.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey} message MissingAccountShareKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAccountShareKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            return writer;
        };

        /**
         * Encodes the specified MissingAccountShareKey message, length delimited. Does not implicitly {@link AccountSummary.MissingAccountShareKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.IMissingAccountShareKey} message MissingAccountShareKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissingAccountShareKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissingAccountShareKey message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAccountShareKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.MissingAccountShareKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissingAccountShareKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissingAccountShareKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissingAccountShareKey message.
         * @function verify
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissingAccountShareKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            return null;
        };

        /**
         * Creates a MissingAccountShareKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.MissingAccountShareKey} MissingAccountShareKey
         */
        MissingAccountShareKey.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.MissingAccountShareKey)
                return object;
            let message = new $root.AccountSummary.MissingAccountShareKey();
            if (object.roleId != null)
                if ($util.Long)
                    (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = false;
                else if (typeof object.roleId === "string")
                    message.roleId = parseInt(object.roleId, 10);
                else if (typeof object.roleId === "number")
                    message.roleId = object.roleId;
                else if (typeof object.roleId === "object")
                    message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber();
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };

        /**
         * Creates a plain object from a MissingAccountShareKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.MissingAccountShareKey
         * @static
         * @param {AccountSummary.MissingAccountShareKey} message MissingAccountShareKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MissingAccountShareKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.roleId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (typeof message.roleId === "number")
                    object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                else
                    object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber() : message.roleId;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };

        /**
         * Converts this MissingAccountShareKey to JSON.
         * @function toJSON
         * @memberof AccountSummary.MissingAccountShareKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MissingAccountShareKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MissingAccountShareKey;
    })();

    AccountSummary.PasswordRule = (function() {

        /**
         * Properties of a PasswordRule.
         * @memberof AccountSummary
         * @interface IPasswordRule
         * @property {string|null} [ruleType] PasswordRule ruleType
         * @property {string|null} [pattern] PasswordRule pattern
         * @property {boolean|null} [match] PasswordRule match
         * @property {number|null} [minimum] PasswordRule minimum
         * @property {string|null} [description] PasswordRule description
         * @property {string|null} [value] PasswordRule value
         */

        /**
         * Constructs a new PasswordRule.
         * @memberof AccountSummary
         * @classdesc Represents a PasswordRule.
         * @implements IPasswordRule
         * @constructor
         * @param {AccountSummary.IPasswordRule=} [properties] Properties to set
         */
        function PasswordRule(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PasswordRule ruleType.
         * @member {string} ruleType
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.ruleType = "";

        /**
         * PasswordRule pattern.
         * @member {string} pattern
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.pattern = "";

        /**
         * PasswordRule match.
         * @member {boolean} match
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.match = false;

        /**
         * PasswordRule minimum.
         * @member {number} minimum
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.minimum = 0;

        /**
         * PasswordRule description.
         * @member {string} description
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.description = "";

        /**
         * PasswordRule value.
         * @member {string} value
         * @memberof AccountSummary.PasswordRule
         * @instance
         */
        PasswordRule.prototype.value = "";

        /**
         * Creates a new PasswordRule instance using the specified properties.
         * @function create
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule=} [properties] Properties to set
         * @returns {AccountSummary.PasswordRule} PasswordRule instance
         */
        PasswordRule.create = function create(properties) {
            return new PasswordRule(properties);
        };

        /**
         * Encodes the specified PasswordRule message. Does not implicitly {@link AccountSummary.PasswordRule.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule} message PasswordRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasswordRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ruleType);
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pattern);
            if (message.match != null && message.hasOwnProperty("match"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.match);
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minimum);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified PasswordRule message, length delimited. Does not implicitly {@link AccountSummary.PasswordRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.IPasswordRule} message PasswordRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PasswordRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PasswordRule message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.PasswordRule} PasswordRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasswordRule.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.PasswordRule();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ruleType = reader.string();
                    break;
                case 2:
                    message.pattern = reader.string();
                    break;
                case 3:
                    message.match = reader.bool();
                    break;
                case 4:
                    message.minimum = reader.int32();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                case 6:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PasswordRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.PasswordRule} PasswordRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PasswordRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PasswordRule message.
         * @function verify
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PasswordRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                if (!$util.isString(message.ruleType))
                    return "ruleType: string expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.match != null && message.hasOwnProperty("match"))
                if (typeof message.match !== "boolean")
                    return "match: boolean expected";
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                if (!$util.isInteger(message.minimum))
                    return "minimum: integer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a PasswordRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.PasswordRule} PasswordRule
         */
        PasswordRule.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.PasswordRule)
                return object;
            let message = new $root.AccountSummary.PasswordRule();
            if (object.ruleType != null)
                message.ruleType = String(object.ruleType);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.match != null)
                message.match = Boolean(object.match);
            if (object.minimum != null)
                message.minimum = object.minimum | 0;
            if (object.description != null)
                message.description = String(object.description);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a PasswordRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.PasswordRule
         * @static
         * @param {AccountSummary.PasswordRule} message PasswordRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PasswordRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ruleType = "";
                object.pattern = "";
                object.match = false;
                object.minimum = 0;
                object.description = "";
                object.value = "";
            }
            if (message.ruleType != null && message.hasOwnProperty("ruleType"))
                object.ruleType = message.ruleType;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.match != null && message.hasOwnProperty("match"))
                object.match = message.match;
            if (message.minimum != null && message.hasOwnProperty("minimum"))
                object.minimum = message.minimum;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this PasswordRule to JSON.
         * @function toJSON
         * @memberof AccountSummary.PasswordRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PasswordRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PasswordRule;
    })();

    AccountSummary.SecurityKey = (function() {

        /**
         * Properties of a SecurityKey.
         * @memberof AccountSummary
         * @interface ISecurityKey
         * @property {number|Long|null} [deviceId] SecurityKey deviceId
         * @property {string|null} [deviceName] SecurityKey deviceName
         * @property {number|Long|null} [dateAdded] SecurityKey dateAdded
         * @property {boolean|null} [isValid] SecurityKey isValid
         * @property {AccountSummary.IDeviceRegistration|null} [deviceRegistration] SecurityKey deviceRegistration
         */

        /**
         * Constructs a new SecurityKey.
         * @memberof AccountSummary
         * @classdesc Represents a SecurityKey.
         * @implements ISecurityKey
         * @constructor
         * @param {AccountSummary.ISecurityKey=} [properties] Properties to set
         */
        function SecurityKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SecurityKey deviceId.
         * @member {number|Long} deviceId
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityKey deviceName.
         * @member {string} deviceName
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceName = "";

        /**
         * SecurityKey dateAdded.
         * @member {number|Long} dateAdded
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.dateAdded = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SecurityKey isValid.
         * @member {boolean} isValid
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.isValid = false;

        /**
         * SecurityKey deviceRegistration.
         * @member {AccountSummary.IDeviceRegistration|null|undefined} deviceRegistration
         * @memberof AccountSummary.SecurityKey
         * @instance
         */
        SecurityKey.prototype.deviceRegistration = null;

        /**
         * Creates a new SecurityKey instance using the specified properties.
         * @function create
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey=} [properties] Properties to set
         * @returns {AccountSummary.SecurityKey} SecurityKey instance
         */
        SecurityKey.create = function create(properties) {
            return new SecurityKey(properties);
        };

        /**
         * Encodes the specified SecurityKey message. Does not implicitly {@link AccountSummary.SecurityKey.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey} message SecurityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.deviceName);
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.dateAdded);
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isValid);
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration"))
                $root.AccountSummary.DeviceRegistration.encode(message.deviceRegistration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SecurityKey message, length delimited. Does not implicitly {@link AccountSummary.SecurityKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.ISecurityKey} message SecurityKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SecurityKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SecurityKey message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.SecurityKey} SecurityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.SecurityKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.deviceName = reader.string();
                    break;
                case 3:
                    message.dateAdded = reader.int64();
                    break;
                case 4:
                    message.isValid = reader.bool();
                    break;
                case 5:
                    message.deviceRegistration = $root.AccountSummary.DeviceRegistration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SecurityKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.SecurityKey} SecurityKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SecurityKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SecurityKey message.
         * @function verify
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SecurityKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                if (!$util.isString(message.deviceName))
                    return "deviceName: string expected";
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                if (!$util.isInteger(message.dateAdded) && !(message.dateAdded && $util.isInteger(message.dateAdded.low) && $util.isInteger(message.dateAdded.high)))
                    return "dateAdded: integer|Long expected";
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                if (typeof message.isValid !== "boolean")
                    return "isValid: boolean expected";
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration")) {
                let error = $root.AccountSummary.DeviceRegistration.verify(message.deviceRegistration);
                if (error)
                    return "deviceRegistration." + error;
            }
            return null;
        };

        /**
         * Creates a SecurityKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.SecurityKey} SecurityKey
         */
        SecurityKey.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.SecurityKey)
                return object;
            let message = new $root.AccountSummary.SecurityKey();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.deviceName != null)
                message.deviceName = String(object.deviceName);
            if (object.dateAdded != null)
                if ($util.Long)
                    (message.dateAdded = $util.Long.fromValue(object.dateAdded)).unsigned = false;
                else if (typeof object.dateAdded === "string")
                    message.dateAdded = parseInt(object.dateAdded, 10);
                else if (typeof object.dateAdded === "number")
                    message.dateAdded = object.dateAdded;
                else if (typeof object.dateAdded === "object")
                    message.dateAdded = new $util.LongBits(object.dateAdded.low >>> 0, object.dateAdded.high >>> 0).toNumber();
            if (object.isValid != null)
                message.isValid = Boolean(object.isValid);
            if (object.deviceRegistration != null) {
                if (typeof object.deviceRegistration !== "object")
                    throw TypeError(".AccountSummary.SecurityKey.deviceRegistration: object expected");
                message.deviceRegistration = $root.AccountSummary.DeviceRegistration.fromObject(object.deviceRegistration);
            }
            return message;
        };

        /**
         * Creates a plain object from a SecurityKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.SecurityKey
         * @static
         * @param {AccountSummary.SecurityKey} message SecurityKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SecurityKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.deviceName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.dateAdded = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dateAdded = options.longs === String ? "0" : 0;
                object.isValid = false;
                object.deviceRegistration = null;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.deviceName != null && message.hasOwnProperty("deviceName"))
                object.deviceName = message.deviceName;
            if (message.dateAdded != null && message.hasOwnProperty("dateAdded"))
                if (typeof message.dateAdded === "number")
                    object.dateAdded = options.longs === String ? String(message.dateAdded) : message.dateAdded;
                else
                    object.dateAdded = options.longs === String ? $util.Long.prototype.toString.call(message.dateAdded) : options.longs === Number ? new $util.LongBits(message.dateAdded.low >>> 0, message.dateAdded.high >>> 0).toNumber() : message.dateAdded;
            if (message.isValid != null && message.hasOwnProperty("isValid"))
                object.isValid = message.isValid;
            if (message.deviceRegistration != null && message.hasOwnProperty("deviceRegistration"))
                object.deviceRegistration = $root.AccountSummary.DeviceRegistration.toObject(message.deviceRegistration, options);
            return object;
        };

        /**
         * Converts this SecurityKey to JSON.
         * @function toJSON
         * @memberof AccountSummary.SecurityKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SecurityKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SecurityKey;
    })();

    AccountSummary.DeviceRegistration = (function() {

        /**
         * Properties of a DeviceRegistration.
         * @memberof AccountSummary
         * @interface IDeviceRegistration
         * @property {string|null} [keyHandle] DeviceRegistration keyHandle
         * @property {Uint8Array|null} [publicKey] DeviceRegistration publicKey
         * @property {string|null} [attestationCert] DeviceRegistration attestationCert
         * @property {number|Long|null} [counter] DeviceRegistration counter
         * @property {boolean|null} [compromised] DeviceRegistration compromised
         */

        /**
         * Constructs a new DeviceRegistration.
         * @memberof AccountSummary
         * @classdesc Represents a DeviceRegistration.
         * @implements IDeviceRegistration
         * @constructor
         * @param {AccountSummary.IDeviceRegistration=} [properties] Properties to set
         */
        function DeviceRegistration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceRegistration keyHandle.
         * @member {string} keyHandle
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.keyHandle = "";

        /**
         * DeviceRegistration publicKey.
         * @member {Uint8Array} publicKey
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.publicKey = $util.newBuffer([]);

        /**
         * DeviceRegistration attestationCert.
         * @member {string} attestationCert
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.attestationCert = "";

        /**
         * DeviceRegistration counter.
         * @member {number|Long} counter
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.counter = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceRegistration compromised.
         * @member {boolean} compromised
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         */
        DeviceRegistration.prototype.compromised = false;

        /**
         * Creates a new DeviceRegistration instance using the specified properties.
         * @function create
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration=} [properties] Properties to set
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration instance
         */
        DeviceRegistration.create = function create(properties) {
            return new DeviceRegistration(properties);
        };

        /**
         * Encodes the specified DeviceRegistration message. Does not implicitly {@link AccountSummary.DeviceRegistration.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration} message DeviceRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.keyHandle);
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.attestationCert);
            if (message.counter != null && message.hasOwnProperty("counter"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.counter);
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.compromised);
            return writer;
        };

        /**
         * Encodes the specified DeviceRegistration message, length delimited. Does not implicitly {@link AccountSummary.DeviceRegistration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.IDeviceRegistration} message DeviceRegistration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceRegistration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceRegistration message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.DeviceRegistration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.keyHandle = reader.string();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                case 3:
                    message.attestationCert = reader.string();
                    break;
                case 4:
                    message.counter = reader.int64();
                    break;
                case 5:
                    message.compromised = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceRegistration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceRegistration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceRegistration message.
         * @function verify
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceRegistration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                if (!$util.isString(message.keyHandle))
                    return "keyHandle: string expected";
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                    return "publicKey: buffer expected";
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                if (!$util.isString(message.attestationCert))
                    return "attestationCert: string expected";
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (!$util.isInteger(message.counter) && !(message.counter && $util.isInteger(message.counter.low) && $util.isInteger(message.counter.high)))
                    return "counter: integer|Long expected";
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                if (typeof message.compromised !== "boolean")
                    return "compromised: boolean expected";
            return null;
        };

        /**
         * Creates a DeviceRegistration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.DeviceRegistration} DeviceRegistration
         */
        DeviceRegistration.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.DeviceRegistration)
                return object;
            let message = new $root.AccountSummary.DeviceRegistration();
            if (object.keyHandle != null)
                message.keyHandle = String(object.keyHandle);
            if (object.publicKey != null)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            if (object.attestationCert != null)
                message.attestationCert = String(object.attestationCert);
            if (object.counter != null)
                if ($util.Long)
                    (message.counter = $util.Long.fromValue(object.counter)).unsigned = false;
                else if (typeof object.counter === "string")
                    message.counter = parseInt(object.counter, 10);
                else if (typeof object.counter === "number")
                    message.counter = object.counter;
                else if (typeof object.counter === "object")
                    message.counter = new $util.LongBits(object.counter.low >>> 0, object.counter.high >>> 0).toNumber();
            if (object.compromised != null)
                message.compromised = Boolean(object.compromised);
            return message;
        };

        /**
         * Creates a plain object from a DeviceRegistration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.DeviceRegistration
         * @static
         * @param {AccountSummary.DeviceRegistration} message DeviceRegistration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceRegistration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.keyHandle = "";
                if (options.bytes === String)
                    object.publicKey = "";
                else {
                    object.publicKey = [];
                    if (options.bytes !== Array)
                        object.publicKey = $util.newBuffer(object.publicKey);
                }
                object.attestationCert = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.counter = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.counter = options.longs === String ? "0" : 0;
                object.compromised = false;
            }
            if (message.keyHandle != null && message.hasOwnProperty("keyHandle"))
                object.keyHandle = message.keyHandle;
            if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            if (message.attestationCert != null && message.hasOwnProperty("attestationCert"))
                object.attestationCert = message.attestationCert;
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (typeof message.counter === "number")
                    object.counter = options.longs === String ? String(message.counter) : message.counter;
                else
                    object.counter = options.longs === String ? $util.Long.prototype.toString.call(message.counter) : options.longs === Number ? new $util.LongBits(message.counter.low >>> 0, message.counter.high >>> 0).toNumber() : message.counter;
            if (message.compromised != null && message.hasOwnProperty("compromised"))
                object.compromised = message.compromised;
            return object;
        };

        /**
         * Converts this DeviceRegistration to JSON.
         * @function toJSON
         * @memberof AccountSummary.DeviceRegistration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceRegistration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceRegistration;
    })();

    AccountSummary.Group = (function() {

        /**
         * Properties of a Group.
         * @memberof AccountSummary
         * @interface IGroup
         * @property {boolean|null} [admin] Group admin
         * @property {string|null} [groupVerificationCode] Group groupVerificationCode
         * @property {AccountSummary.IAdministrator|null} [administrator] Group administrator
         */

        /**
         * Constructs a new Group.
         * @memberof AccountSummary
         * @classdesc Represents a Group.
         * @implements IGroup
         * @constructor
         * @param {AccountSummary.IGroup=} [properties] Properties to set
         */
        function Group(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Group admin.
         * @member {boolean} admin
         * @memberof AccountSummary.Group
         * @instance
         */
        Group.prototype.admin = false;

        /**
         * Group groupVerificationCode.
         * @member {string} groupVerificationCode
         * @memberof AccountSummary.Group
         * @instance
         */
        Group.prototype.groupVerificationCode = "";

        /**
         * Group administrator.
         * @member {AccountSummary.IAdministrator|null|undefined} administrator
         * @memberof AccountSummary.Group
         * @instance
         */
        Group.prototype.administrator = null;

        /**
         * Creates a new Group instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Group
         * @static
         * @param {AccountSummary.IGroup=} [properties] Properties to set
         * @returns {AccountSummary.Group} Group instance
         */
        Group.create = function create(properties) {
            return new Group(properties);
        };

        /**
         * Encodes the specified Group message. Does not implicitly {@link AccountSummary.Group.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Group
         * @static
         * @param {AccountSummary.IGroup} message Group message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Group.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.admin != null && message.hasOwnProperty("admin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.admin);
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupVerificationCode);
            if (message.administrator != null && message.hasOwnProperty("administrator"))
                $root.AccountSummary.Administrator.encode(message.administrator, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Group message, length delimited. Does not implicitly {@link AccountSummary.Group.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Group
         * @static
         * @param {AccountSummary.IGroup} message Group message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Group.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Group message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Group();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.admin = reader.bool();
                    break;
                case 2:
                    message.groupVerificationCode = reader.string();
                    break;
                case 4:
                    message.administrator = $root.AccountSummary.Administrator.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Group message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Group
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Group} Group
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Group.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Group message.
         * @function verify
         * @memberof AccountSummary.Group
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Group.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.admin != null && message.hasOwnProperty("admin"))
                if (typeof message.admin !== "boolean")
                    return "admin: boolean expected";
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                if (!$util.isString(message.groupVerificationCode))
                    return "groupVerificationCode: string expected";
            if (message.administrator != null && message.hasOwnProperty("administrator")) {
                let error = $root.AccountSummary.Administrator.verify(message.administrator);
                if (error)
                    return "administrator." + error;
            }
            return null;
        };

        /**
         * Creates a Group message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Group
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Group} Group
         */
        Group.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Group)
                return object;
            let message = new $root.AccountSummary.Group();
            if (object.admin != null)
                message.admin = Boolean(object.admin);
            if (object.groupVerificationCode != null)
                message.groupVerificationCode = String(object.groupVerificationCode);
            if (object.administrator != null) {
                if (typeof object.administrator !== "object")
                    throw TypeError(".AccountSummary.Group.administrator: object expected");
                message.administrator = $root.AccountSummary.Administrator.fromObject(object.administrator);
            }
            return message;
        };

        /**
         * Creates a plain object from a Group message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Group
         * @static
         * @param {AccountSummary.Group} message Group
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Group.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.admin = false;
                object.groupVerificationCode = "";
                object.administrator = null;
            }
            if (message.admin != null && message.hasOwnProperty("admin"))
                object.admin = message.admin;
            if (message.groupVerificationCode != null && message.hasOwnProperty("groupVerificationCode"))
                object.groupVerificationCode = message.groupVerificationCode;
            if (message.administrator != null && message.hasOwnProperty("administrator"))
                object.administrator = $root.AccountSummary.Administrator.toObject(message.administrator, options);
            return object;
        };

        /**
         * Converts this Group to JSON.
         * @function toJSON
         * @memberof AccountSummary.Group
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Group.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Group;
    })();

    AccountSummary.Administrator = (function() {

        /**
         * Properties of an Administrator.
         * @memberof AccountSummary
         * @interface IAdministrator
         * @property {string|null} [firstName] Administrator firstName
         * @property {string|null} [lastName] Administrator lastName
         * @property {string|null} [email] Administrator email
         * @property {number|null} [currentNumberOfUsers] Administrator currentNumberOfUsers
         * @property {number|null} [numberOfUsers] Administrator numberOfUsers
         * @property {string|null} [subscriptionCode] Administrator subscriptionCode
         * @property {string|null} [expirationDate] Administrator expirationDate
         * @property {string|null} [purchaseDate] Administrator purchaseDate
         */

        /**
         * Constructs a new Administrator.
         * @memberof AccountSummary
         * @classdesc Represents an Administrator.
         * @implements IAdministrator
         * @constructor
         * @param {AccountSummary.IAdministrator=} [properties] Properties to set
         */
        function Administrator(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Administrator firstName.
         * @member {string} firstName
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.firstName = "";

        /**
         * Administrator lastName.
         * @member {string} lastName
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.lastName = "";

        /**
         * Administrator email.
         * @member {string} email
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.email = "";

        /**
         * Administrator currentNumberOfUsers.
         * @member {number} currentNumberOfUsers
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.currentNumberOfUsers = 0;

        /**
         * Administrator numberOfUsers.
         * @member {number} numberOfUsers
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.numberOfUsers = 0;

        /**
         * Administrator subscriptionCode.
         * @member {string} subscriptionCode
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.subscriptionCode = "";

        /**
         * Administrator expirationDate.
         * @member {string} expirationDate
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.expirationDate = "";

        /**
         * Administrator purchaseDate.
         * @member {string} purchaseDate
         * @memberof AccountSummary.Administrator
         * @instance
         */
        Administrator.prototype.purchaseDate = "";

        /**
         * Creates a new Administrator instance using the specified properties.
         * @function create
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator=} [properties] Properties to set
         * @returns {AccountSummary.Administrator} Administrator instance
         */
        Administrator.create = function create(properties) {
            return new Administrator(properties);
        };

        /**
         * Encodes the specified Administrator message. Does not implicitly {@link AccountSummary.Administrator.verify|verify} messages.
         * @function encode
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator} message Administrator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Administrator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.firstName);
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.lastName);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.currentNumberOfUsers);
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.numberOfUsers);
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.subscriptionCode);
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.expirationDate);
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.purchaseDate);
            return writer;
        };

        /**
         * Encodes the specified Administrator message, length delimited. Does not implicitly {@link AccountSummary.Administrator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.IAdministrator} message Administrator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Administrator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Administrator message from the specified reader or buffer.
         * @function decode
         * @memberof AccountSummary.Administrator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountSummary.Administrator} Administrator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Administrator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountSummary.Administrator();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.firstName = reader.string();
                    break;
                case 2:
                    message.lastName = reader.string();
                    break;
                case 3:
                    message.email = reader.string();
                    break;
                case 4:
                    message.currentNumberOfUsers = reader.int32();
                    break;
                case 5:
                    message.numberOfUsers = reader.int32();
                    break;
                case 7:
                    message.subscriptionCode = reader.string();
                    break;
                case 8:
                    message.expirationDate = reader.string();
                    break;
                case 9:
                    message.purchaseDate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Administrator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountSummary.Administrator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountSummary.Administrator} Administrator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Administrator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Administrator message.
         * @function verify
         * @memberof AccountSummary.Administrator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Administrator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                if (!$util.isString(message.firstName))
                    return "firstName: string expected";
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                if (!$util.isString(message.lastName))
                    return "lastName: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                if (!$util.isInteger(message.currentNumberOfUsers))
                    return "currentNumberOfUsers: integer expected";
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                if (!$util.isInteger(message.numberOfUsers))
                    return "numberOfUsers: integer expected";
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                if (!$util.isString(message.subscriptionCode))
                    return "subscriptionCode: string expected";
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                if (!$util.isString(message.expirationDate))
                    return "expirationDate: string expected";
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                if (!$util.isString(message.purchaseDate))
                    return "purchaseDate: string expected";
            return null;
        };

        /**
         * Creates an Administrator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountSummary.Administrator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountSummary.Administrator} Administrator
         */
        Administrator.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountSummary.Administrator)
                return object;
            let message = new $root.AccountSummary.Administrator();
            if (object.firstName != null)
                message.firstName = String(object.firstName);
            if (object.lastName != null)
                message.lastName = String(object.lastName);
            if (object.email != null)
                message.email = String(object.email);
            if (object.currentNumberOfUsers != null)
                message.currentNumberOfUsers = object.currentNumberOfUsers | 0;
            if (object.numberOfUsers != null)
                message.numberOfUsers = object.numberOfUsers | 0;
            if (object.subscriptionCode != null)
                message.subscriptionCode = String(object.subscriptionCode);
            if (object.expirationDate != null)
                message.expirationDate = String(object.expirationDate);
            if (object.purchaseDate != null)
                message.purchaseDate = String(object.purchaseDate);
            return message;
        };

        /**
         * Creates a plain object from an Administrator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountSummary.Administrator
         * @static
         * @param {AccountSummary.Administrator} message Administrator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Administrator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.firstName = "";
                object.lastName = "";
                object.email = "";
                object.currentNumberOfUsers = 0;
                object.numberOfUsers = 0;
                object.subscriptionCode = "";
                object.expirationDate = "";
                object.purchaseDate = "";
            }
            if (message.firstName != null && message.hasOwnProperty("firstName"))
                object.firstName = message.firstName;
            if (message.lastName != null && message.hasOwnProperty("lastName"))
                object.lastName = message.lastName;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.currentNumberOfUsers != null && message.hasOwnProperty("currentNumberOfUsers"))
                object.currentNumberOfUsers = message.currentNumberOfUsers;
            if (message.numberOfUsers != null && message.hasOwnProperty("numberOfUsers"))
                object.numberOfUsers = message.numberOfUsers;
            if (message.subscriptionCode != null && message.hasOwnProperty("subscriptionCode"))
                object.subscriptionCode = message.subscriptionCode;
            if (message.expirationDate != null && message.hasOwnProperty("expirationDate"))
                object.expirationDate = message.expirationDate;
            if (message.purchaseDate != null && message.hasOwnProperty("purchaseDate"))
                object.purchaseDate = message.purchaseDate;
            return object;
        };

        /**
         * Converts this Administrator to JSON.
         * @function toJSON
         * @memberof AccountSummary.Administrator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Administrator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Administrator;
    })();

    return AccountSummary;
})();

export const BreachWatch = $root.BreachWatch = (() => {

    /**
     * Namespace BreachWatch.
     * @exports BreachWatch
     * @namespace
     */
    const BreachWatch = {};

    /**
     * BreachWatchInfoType enum.
     * @name BreachWatch.BreachWatchInfoType
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} ALTERNATE_PASSWORD=1 ALTERNATE_PASSWORD value
     */
    BreachWatch.BreachWatchInfoType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "ALTERNATE_PASSWORD"] = 1;
        return values;
    })();

    BreachWatch.BreachWatchRecordRequest = (function() {

        /**
         * Properties of a BreachWatchRecordRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchRecordRequest
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordRequest recordUid
         * @property {Uint8Array|null} [encryptedData] BreachWatchRecordRequest encryptedData
         * @property {BreachWatch.BreachWatchInfoType|null} [breachWatchInfoType] BreachWatchRecordRequest breachWatchInfoType
         * @property {boolean|null} [updateUserWhoScanned] BreachWatchRecordRequest updateUserWhoScanned
         */

        /**
         * Constructs a new BreachWatchRecordRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchRecordRequest.
         * @implements IBreachWatchRecordRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchRecordRequest=} [properties] Properties to set
         */
        function BreachWatchRecordRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest breachWatchInfoType.
         * @member {BreachWatch.BreachWatchInfoType} breachWatchInfoType
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.breachWatchInfoType = 0;

        /**
         * BreachWatchRecordRequest updateUserWhoScanned.
         * @member {boolean} updateUserWhoScanned
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.updateUserWhoScanned = false;

        /**
         * Creates a new BreachWatchRecordRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest instance
         */
        BreachWatchRecordRequest.create = function create(properties) {
            return new BreachWatchRecordRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message. Does not implicitly {@link BreachWatch.BreachWatchRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.breachWatchInfoType);
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateUserWhoScanned);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                case 3:
                    message.breachWatchInfoType = reader.int32();
                    break;
                case 4:
                    message.updateUserWhoScanned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                switch (message.breachWatchInfoType) {
                default:
                    return "breachWatchInfoType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                if (typeof message.updateUserWhoScanned !== "boolean")
                    return "updateUserWhoScanned: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchRecordRequest} BreachWatchRecordRequest
         */
        BreachWatchRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchRecordRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchRecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            switch (object.breachWatchInfoType) {
            case "RECORD":
            case 0:
                message.breachWatchInfoType = 0;
                break;
            case "ALTERNATE_PASSWORD":
            case 1:
                message.breachWatchInfoType = 1;
                break;
            }
            if (object.updateUserWhoScanned != null)
                message.updateUserWhoScanned = Boolean(object.updateUserWhoScanned);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @static
         * @param {BreachWatch.BreachWatchRecordRequest} message BreachWatchRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
                object.breachWatchInfoType = options.enums === String ? "RECORD" : 0;
                object.updateUserWhoScanned = false;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                object.breachWatchInfoType = options.enums === String ? $root.BreachWatch.BreachWatchInfoType[message.breachWatchInfoType] : message.breachWatchInfoType;
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                object.updateUserWhoScanned = message.updateUserWhoScanned;
            return object;
        };

        /**
         * Converts this BreachWatchRecordRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordRequest;
    })();

    BreachWatch.BreachWatchUpdateRequest = (function() {

        /**
         * Properties of a BreachWatchUpdateRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchUpdateRequest
         * @property {Array.<BreachWatch.IBreachWatchRecordRequest>|null} [breachWatchRecordRequest] BreachWatchUpdateRequest breachWatchRecordRequest
         * @property {Uint8Array|null} [encryptedData] BreachWatchUpdateRequest encryptedData
         */

        /**
         * Constructs a new BreachWatchUpdateRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchUpdateRequest.
         * @implements IBreachWatchUpdateRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchUpdateRequest=} [properties] Properties to set
         */
        function BreachWatchUpdateRequest(properties) {
            this.breachWatchRecordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateRequest breachWatchRecordRequest.
         * @member {Array.<BreachWatch.IBreachWatchRecordRequest>} breachWatchRecordRequest
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.breachWatchRecordRequest = $util.emptyArray;

        /**
         * BreachWatchUpdateRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchUpdateRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest instance
         */
        BreachWatchUpdateRequest.create = function create(properties) {
            return new BreachWatchUpdateRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message. Does not implicitly {@link BreachWatch.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordRequest != null && message.breachWatchRecordRequest.length)
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i)
                    $root.BreachWatch.BreachWatchRecordRequest.encode(message.breachWatchRecordRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordRequest && message.breachWatchRecordRequest.length))
                        message.breachWatchRecordRequest = [];
                    message.breachWatchRecordRequest.push($root.BreachWatch.BreachWatchRecordRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordRequest != null && message.hasOwnProperty("breachWatchRecordRequest")) {
                if (!Array.isArray(message.breachWatchRecordRequest))
                    return "breachWatchRecordRequest: array expected";
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i) {
                    let error = $root.BreachWatch.BreachWatchRecordRequest.verify(message.breachWatchRecordRequest[i]);
                    if (error)
                        return "breachWatchRecordRequest." + error;
                }
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         */
        BreachWatchUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchUpdateRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchUpdateRequest();
            if (object.breachWatchRecordRequest) {
                if (!Array.isArray(object.breachWatchRecordRequest))
                    throw TypeError(".BreachWatch.BreachWatchUpdateRequest.breachWatchRecordRequest: array expected");
                message.breachWatchRecordRequest = [];
                for (let i = 0; i < object.breachWatchRecordRequest.length; ++i) {
                    if (typeof object.breachWatchRecordRequest[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchUpdateRequest.breachWatchRecordRequest: object expected");
                    message.breachWatchRecordRequest[i] = $root.BreachWatch.BreachWatchRecordRequest.fromObject(object.breachWatchRecordRequest[i]);
                }
            }
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @static
         * @param {BreachWatch.BreachWatchUpdateRequest} message BreachWatchUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordRequest = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
            if (message.breachWatchRecordRequest && message.breachWatchRecordRequest.length) {
                object.breachWatchRecordRequest = [];
                for (let j = 0; j < message.breachWatchRecordRequest.length; ++j)
                    object.breachWatchRecordRequest[j] = $root.BreachWatch.BreachWatchRecordRequest.toObject(message.breachWatchRecordRequest[j], options);
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            return object;
        };

        /**
         * Converts this BreachWatchUpdateRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateRequest;
    })();

    BreachWatch.BreachWatchRecordStatus = (function() {

        /**
         * Properties of a BreachWatchRecordStatus.
         * @memberof BreachWatch
         * @interface IBreachWatchRecordStatus
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordStatus recordUid
         * @property {string|null} [status] BreachWatchRecordStatus status
         * @property {string|null} [reason] BreachWatchRecordStatus reason
         */

        /**
         * Constructs a new BreachWatchRecordStatus.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchRecordStatus.
         * @implements IBreachWatchRecordStatus
         * @constructor
         * @param {BreachWatch.IBreachWatchRecordStatus=} [properties] Properties to set
         */
        function BreachWatchRecordStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordStatus recordUid.
         * @member {Uint8Array} recordUid
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordStatus status.
         * @member {string} status
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.status = "";

        /**
         * BreachWatchRecordStatus reason.
         * @member {string} reason
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         */
        BreachWatchRecordStatus.prototype.reason = "";

        /**
         * Creates a new BreachWatchRecordStatus instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus instance
         */
        BreachWatchRecordStatus.create = function create(properties) {
            return new BreachWatchRecordStatus(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordStatus message. Does not implicitly {@link BreachWatch.BreachWatchRecordStatus.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus} message BreachWatchRecordStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.status);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordStatus message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchRecordStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.IBreachWatchRecordStatus} message BreachWatchRecordStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordStatus message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchRecordStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.status = reader.string();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordStatus message.
         * @function verify
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchRecordStatus} BreachWatchRecordStatus
         */
        BreachWatchRecordStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchRecordStatus)
                return object;
            let message = new $root.BreachWatch.BreachWatchRecordStatus();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.status != null)
                message.status = String(object.status);
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @static
         * @param {BreachWatch.BreachWatchRecordStatus} message BreachWatchRecordStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.status = "";
                object.reason = "";
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this BreachWatchRecordStatus to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchRecordStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordStatus;
    })();

    BreachWatch.BreachWatchUpdateResponse = (function() {

        /**
         * Properties of a BreachWatchUpdateResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchUpdateResponse
         * @property {Array.<BreachWatch.IBreachWatchRecordStatus>|null} [breachWatchRecordStatus] BreachWatchUpdateResponse breachWatchRecordStatus
         */

        /**
         * Constructs a new BreachWatchUpdateResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchUpdateResponse.
         * @implements IBreachWatchUpdateResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchUpdateResponse=} [properties] Properties to set
         */
        function BreachWatchUpdateResponse(properties) {
            this.breachWatchRecordStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateResponse breachWatchRecordStatus.
         * @member {Array.<BreachWatch.IBreachWatchRecordStatus>} breachWatchRecordStatus
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @instance
         */
        BreachWatchUpdateResponse.prototype.breachWatchRecordStatus = $util.emptyArray;

        /**
         * Creates a new BreachWatchUpdateResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse instance
         */
        BreachWatchUpdateResponse.create = function create(properties) {
            return new BreachWatchUpdateResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateResponse message. Does not implicitly {@link BreachWatch.BreachWatchUpdateResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse} message BreachWatchUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordStatus != null && message.breachWatchRecordStatus.length)
                for (let i = 0; i < message.breachWatchRecordStatus.length; ++i)
                    $root.BreachWatch.BreachWatchRecordStatus.encode(message.breachWatchRecordStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchUpdateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.IBreachWatchUpdateResponse} message BreachWatchUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchUpdateResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordStatus && message.breachWatchRecordStatus.length))
                        message.breachWatchRecordStatus = [];
                    message.breachWatchRecordStatus.push($root.BreachWatch.BreachWatchRecordStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordStatus != null && message.hasOwnProperty("breachWatchRecordStatus")) {
                if (!Array.isArray(message.breachWatchRecordStatus))
                    return "breachWatchRecordStatus: array expected";
                for (let i = 0; i < message.breachWatchRecordStatus.length; ++i) {
                    let error = $root.BreachWatch.BreachWatchRecordStatus.verify(message.breachWatchRecordStatus[i]);
                    if (error)
                        return "breachWatchRecordStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchUpdateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchUpdateResponse} BreachWatchUpdateResponse
         */
        BreachWatchUpdateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchUpdateResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchUpdateResponse();
            if (object.breachWatchRecordStatus) {
                if (!Array.isArray(object.breachWatchRecordStatus))
                    throw TypeError(".BreachWatch.BreachWatchUpdateResponse.breachWatchRecordStatus: array expected");
                message.breachWatchRecordStatus = [];
                for (let i = 0; i < object.breachWatchRecordStatus.length; ++i) {
                    if (typeof object.breachWatchRecordStatus[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchUpdateResponse.breachWatchRecordStatus: object expected");
                    message.breachWatchRecordStatus[i] = $root.BreachWatch.BreachWatchRecordStatus.fromObject(object.breachWatchRecordStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @static
         * @param {BreachWatch.BreachWatchUpdateResponse} message BreachWatchUpdateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordStatus = [];
            if (message.breachWatchRecordStatus && message.breachWatchRecordStatus.length) {
                object.breachWatchRecordStatus = [];
                for (let j = 0; j < message.breachWatchRecordStatus.length; ++j)
                    object.breachWatchRecordStatus[j] = $root.BreachWatch.BreachWatchRecordStatus.toObject(message.breachWatchRecordStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchUpdateResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchUpdateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateResponse;
    })();

    BreachWatch.BreachWatchTokenRequest = (function() {

        /**
         * Properties of a BreachWatchTokenRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchTokenRequest
         * @property {Uint8Array|null} [breachWatchToken] BreachWatchTokenRequest breachWatchToken
         */

        /**
         * Constructs a new BreachWatchTokenRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchTokenRequest.
         * @implements IBreachWatchTokenRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchTokenRequest=} [properties] Properties to set
         */
        function BreachWatchTokenRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchTokenRequest breachWatchToken.
         * @member {Uint8Array} breachWatchToken
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @instance
         */
        BreachWatchTokenRequest.prototype.breachWatchToken = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchTokenRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest instance
         */
        BreachWatchTokenRequest.create = function create(properties) {
            return new BreachWatchTokenRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchTokenRequest message. Does not implicitly {@link BreachWatch.BreachWatchTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest} message BreachWatchTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.breachWatchToken);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchTokenRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.IBreachWatchTokenRequest} message BreachWatchTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchTokenRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.breachWatchToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchTokenRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                if (!(message.breachWatchToken && typeof message.breachWatchToken.length === "number" || $util.isString(message.breachWatchToken)))
                    return "breachWatchToken: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchTokenRequest} BreachWatchTokenRequest
         */
        BreachWatchTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchTokenRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchTokenRequest();
            if (object.breachWatchToken != null)
                if (typeof object.breachWatchToken === "string")
                    $util.base64.decode(object.breachWatchToken, message.breachWatchToken = $util.newBuffer($util.base64.length(object.breachWatchToken)), 0);
                else if (object.breachWatchToken.length)
                    message.breachWatchToken = object.breachWatchToken;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @static
         * @param {BreachWatch.BreachWatchTokenRequest} message BreachWatchTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.breachWatchToken = "";
                else {
                    object.breachWatchToken = [];
                    if (options.bytes !== Array)
                        object.breachWatchToken = $util.newBuffer(object.breachWatchToken);
                }
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                object.breachWatchToken = options.bytes === String ? $util.base64.encode(message.breachWatchToken, 0, message.breachWatchToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.breachWatchToken) : message.breachWatchToken;
            return object;
        };

        /**
         * Converts this BreachWatchTokenRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchTokenRequest;
    })();

    BreachWatch.BreachWatchTokenResponse = (function() {

        /**
         * Properties of a BreachWatchTokenResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchTokenResponse
         * @property {Uint8Array|null} [breachWatchToken] BreachWatchTokenResponse breachWatchToken
         * @property {boolean|null} [clientEncrypted] BreachWatchTokenResponse clientEncrypted
         */

        /**
         * Constructs a new BreachWatchTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchTokenResponse.
         * @implements IBreachWatchTokenResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchTokenResponse=} [properties] Properties to set
         */
        function BreachWatchTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchTokenResponse breachWatchToken.
         * @member {Uint8Array} breachWatchToken
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         */
        BreachWatchTokenResponse.prototype.breachWatchToken = $util.newBuffer([]);

        /**
         * BreachWatchTokenResponse clientEncrypted.
         * @member {boolean} clientEncrypted
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         */
        BreachWatchTokenResponse.prototype.clientEncrypted = false;

        /**
         * Creates a new BreachWatchTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse instance
         */
        BreachWatchTokenResponse.create = function create(properties) {
            return new BreachWatchTokenResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchTokenResponse message. Does not implicitly {@link BreachWatch.BreachWatchTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse} message BreachWatchTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.breachWatchToken);
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.clientEncrypted);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.IBreachWatchTokenResponse} message BreachWatchTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.breachWatchToken = reader.bytes();
                    break;
                case 2:
                    message.clientEncrypted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchTokenResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                if (!(message.breachWatchToken && typeof message.breachWatchToken.length === "number" || $util.isString(message.breachWatchToken)))
                    return "breachWatchToken: buffer expected";
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                if (typeof message.clientEncrypted !== "boolean")
                    return "clientEncrypted: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchTokenResponse} BreachWatchTokenResponse
         */
        BreachWatchTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchTokenResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchTokenResponse();
            if (object.breachWatchToken != null)
                if (typeof object.breachWatchToken === "string")
                    $util.base64.decode(object.breachWatchToken, message.breachWatchToken = $util.newBuffer($util.base64.length(object.breachWatchToken)), 0);
                else if (object.breachWatchToken.length)
                    message.breachWatchToken = object.breachWatchToken;
            if (object.clientEncrypted != null)
                message.clientEncrypted = Boolean(object.clientEncrypted);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @static
         * @param {BreachWatch.BreachWatchTokenResponse} message BreachWatchTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.breachWatchToken = "";
                else {
                    object.breachWatchToken = [];
                    if (options.bytes !== Array)
                        object.breachWatchToken = $util.newBuffer(object.breachWatchToken);
                }
                object.clientEncrypted = false;
            }
            if (message.breachWatchToken != null && message.hasOwnProperty("breachWatchToken"))
                object.breachWatchToken = options.bytes === String ? $util.base64.encode(message.breachWatchToken, 0, message.breachWatchToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.breachWatchToken) : message.breachWatchToken;
            if (message.clientEncrypted != null && message.hasOwnProperty("clientEncrypted"))
                object.clientEncrypted = message.clientEncrypted;
            return object;
        };

        /**
         * Converts this BreachWatchTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchTokenResponse;
    })();

    BreachWatch.AnonymizedTokenResponse = (function() {

        /**
         * Properties of an AnonymizedTokenResponse.
         * @memberof BreachWatch
         * @interface IAnonymizedTokenResponse
         * @property {Uint8Array|null} [domainToken] AnonymizedTokenResponse domainToken
         * @property {Uint8Array|null} [emailToken] AnonymizedTokenResponse emailToken
         * @property {Uint8Array|null} [passwordToken] AnonymizedTokenResponse passwordToken
         */

        /**
         * Constructs a new AnonymizedTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents an AnonymizedTokenResponse.
         * @implements IAnonymizedTokenResponse
         * @constructor
         * @param {BreachWatch.IAnonymizedTokenResponse=} [properties] Properties to set
         */
        function AnonymizedTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnonymizedTokenResponse domainToken.
         * @member {Uint8Array} domainToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.domainToken = $util.newBuffer([]);

        /**
         * AnonymizedTokenResponse emailToken.
         * @member {Uint8Array} emailToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.emailToken = $util.newBuffer([]);

        /**
         * AnonymizedTokenResponse passwordToken.
         * @member {Uint8Array} passwordToken
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         */
        AnonymizedTokenResponse.prototype.passwordToken = $util.newBuffer([]);

        /**
         * Creates a new AnonymizedTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse instance
         */
        AnonymizedTokenResponse.create = function create(properties) {
            return new AnonymizedTokenResponse(properties);
        };

        /**
         * Encodes the specified AnonymizedTokenResponse message. Does not implicitly {@link BreachWatch.AnonymizedTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse} message AnonymizedTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.domainToken);
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.emailToken);
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.passwordToken);
            return writer;
        };

        /**
         * Encodes the specified AnonymizedTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.AnonymizedTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.IAnonymizedTokenResponse} message AnonymizedTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnonymizedTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.AnonymizedTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.domainToken = reader.bytes();
                    break;
                case 2:
                    message.emailToken = reader.bytes();
                    break;
                case 3:
                    message.passwordToken = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnonymizedTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnonymizedTokenResponse message.
         * @function verify
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnonymizedTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                if (!(message.domainToken && typeof message.domainToken.length === "number" || $util.isString(message.domainToken)))
                    return "domainToken: buffer expected";
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                if (!(message.emailToken && typeof message.emailToken.length === "number" || $util.isString(message.emailToken)))
                    return "emailToken: buffer expected";
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                if (!(message.passwordToken && typeof message.passwordToken.length === "number" || $util.isString(message.passwordToken)))
                    return "passwordToken: buffer expected";
            return null;
        };

        /**
         * Creates an AnonymizedTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.AnonymizedTokenResponse} AnonymizedTokenResponse
         */
        AnonymizedTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.AnonymizedTokenResponse)
                return object;
            let message = new $root.BreachWatch.AnonymizedTokenResponse();
            if (object.domainToken != null)
                if (typeof object.domainToken === "string")
                    $util.base64.decode(object.domainToken, message.domainToken = $util.newBuffer($util.base64.length(object.domainToken)), 0);
                else if (object.domainToken.length)
                    message.domainToken = object.domainToken;
            if (object.emailToken != null)
                if (typeof object.emailToken === "string")
                    $util.base64.decode(object.emailToken, message.emailToken = $util.newBuffer($util.base64.length(object.emailToken)), 0);
                else if (object.emailToken.length)
                    message.emailToken = object.emailToken;
            if (object.passwordToken != null)
                if (typeof object.passwordToken === "string")
                    $util.base64.decode(object.passwordToken, message.passwordToken = $util.newBuffer($util.base64.length(object.passwordToken)), 0);
                else if (object.passwordToken.length)
                    message.passwordToken = object.passwordToken;
            return message;
        };

        /**
         * Creates a plain object from an AnonymizedTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @static
         * @param {BreachWatch.AnonymizedTokenResponse} message AnonymizedTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnonymizedTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.domainToken = "";
                else {
                    object.domainToken = [];
                    if (options.bytes !== Array)
                        object.domainToken = $util.newBuffer(object.domainToken);
                }
                if (options.bytes === String)
                    object.emailToken = "";
                else {
                    object.emailToken = [];
                    if (options.bytes !== Array)
                        object.emailToken = $util.newBuffer(object.emailToken);
                }
                if (options.bytes === String)
                    object.passwordToken = "";
                else {
                    object.passwordToken = [];
                    if (options.bytes !== Array)
                        object.passwordToken = $util.newBuffer(object.passwordToken);
                }
            }
            if (message.domainToken != null && message.hasOwnProperty("domainToken"))
                object.domainToken = options.bytes === String ? $util.base64.encode(message.domainToken, 0, message.domainToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.domainToken) : message.domainToken;
            if (message.emailToken != null && message.hasOwnProperty("emailToken"))
                object.emailToken = options.bytes === String ? $util.base64.encode(message.emailToken, 0, message.emailToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.emailToken) : message.emailToken;
            if (message.passwordToken != null && message.hasOwnProperty("passwordToken"))
                object.passwordToken = options.bytes === String ? $util.base64.encode(message.passwordToken, 0, message.passwordToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.passwordToken) : message.passwordToken;
            return object;
        };

        /**
         * Converts this AnonymizedTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.AnonymizedTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnonymizedTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnonymizedTokenResponse;
    })();

    BreachWatch.HashCheck = (function() {

        /**
         * Properties of a HashCheck.
         * @memberof BreachWatch
         * @interface IHashCheck
         * @property {Uint8Array|null} [hash1] HashCheck hash1
         * @property {Uint8Array|null} [euid] HashCheck euid
         */

        /**
         * Constructs a new HashCheck.
         * @memberof BreachWatch
         * @classdesc Represents a HashCheck.
         * @implements IHashCheck
         * @constructor
         * @param {BreachWatch.IHashCheck=} [properties] Properties to set
         */
        function HashCheck(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashCheck hash1.
         * @member {Uint8Array} hash1
         * @memberof BreachWatch.HashCheck
         * @instance
         */
        HashCheck.prototype.hash1 = $util.newBuffer([]);

        /**
         * HashCheck euid.
         * @member {Uint8Array} euid
         * @memberof BreachWatch.HashCheck
         * @instance
         */
        HashCheck.prototype.euid = $util.newBuffer([]);

        /**
         * Creates a new HashCheck instance using the specified properties.
         * @function create
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck=} [properties] Properties to set
         * @returns {BreachWatch.HashCheck} HashCheck instance
         */
        HashCheck.create = function create(properties) {
            return new HashCheck(properties);
        };

        /**
         * Encodes the specified HashCheck message. Does not implicitly {@link BreachWatch.HashCheck.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck} message HashCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashCheck.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash1);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.euid);
            return writer;
        };

        /**
         * Encodes the specified HashCheck message, length delimited. Does not implicitly {@link BreachWatch.HashCheck.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.IHashCheck} message HashCheck message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashCheck.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashCheck message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.HashCheck} HashCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashCheck.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.HashCheck();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash1 = reader.bytes();
                    break;
                case 2:
                    message.euid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashCheck message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.HashCheck} HashCheck
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashCheck.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashCheck message.
         * @function verify
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashCheck.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                if (!(message.hash1 && typeof message.hash1.length === "number" || $util.isString(message.hash1)))
                    return "hash1: buffer expected";
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            return null;
        };

        /**
         * Creates a HashCheck message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.HashCheck} HashCheck
         */
        HashCheck.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.HashCheck)
                return object;
            let message = new $root.BreachWatch.HashCheck();
            if (object.hash1 != null)
                if (typeof object.hash1 === "string")
                    $util.base64.decode(object.hash1, message.hash1 = $util.newBuffer($util.base64.length(object.hash1)), 0);
                else if (object.hash1.length)
                    message.hash1 = object.hash1;
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            return message;
        };

        /**
         * Creates a plain object from a HashCheck message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.HashCheck
         * @static
         * @param {BreachWatch.HashCheck} message HashCheck
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashCheck.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash1 = "";
                else {
                    object.hash1 = [];
                    if (options.bytes !== Array)
                        object.hash1 = $util.newBuffer(object.hash1);
                }
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
            }
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                object.hash1 = options.bytes === String ? $util.base64.encode(message.hash1, 0, message.hash1.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash1) : message.hash1;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            return object;
        };

        /**
         * Converts this HashCheck to JSON.
         * @function toJSON
         * @memberof BreachWatch.HashCheck
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashCheck.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashCheck;
    })();

    BreachWatch.BreachWatchStatusRequest = (function() {

        /**
         * Properties of a BreachWatchStatusRequest.
         * @memberof BreachWatch
         * @interface IBreachWatchStatusRequest
         * @property {Uint8Array|null} [anonymizedToken] BreachWatchStatusRequest anonymizedToken
         * @property {Array.<BreachWatch.IHashCheck>|null} [hashCheck] BreachWatchStatusRequest hashCheck
         * @property {Array.<Uint8Array>|null} [removedEuid] BreachWatchStatusRequest removedEuid
         */

        /**
         * Constructs a new BreachWatchStatusRequest.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchStatusRequest.
         * @implements IBreachWatchStatusRequest
         * @constructor
         * @param {BreachWatch.IBreachWatchStatusRequest=} [properties] Properties to set
         */
        function BreachWatchStatusRequest(properties) {
            this.hashCheck = [];
            this.removedEuid = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchStatusRequest anonymizedToken.
         * @member {Uint8Array} anonymizedToken
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.anonymizedToken = $util.newBuffer([]);

        /**
         * BreachWatchStatusRequest hashCheck.
         * @member {Array.<BreachWatch.IHashCheck>} hashCheck
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.hashCheck = $util.emptyArray;

        /**
         * BreachWatchStatusRequest removedEuid.
         * @member {Array.<Uint8Array>} removedEuid
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         */
        BreachWatchStatusRequest.prototype.removedEuid = $util.emptyArray;

        /**
         * Creates a new BreachWatchStatusRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest instance
         */
        BreachWatchStatusRequest.create = function create(properties) {
            return new BreachWatchStatusRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchStatusRequest message. Does not implicitly {@link BreachWatch.BreachWatchStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest} message BreachWatchStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.anonymizedToken);
            if (message.hashCheck != null && message.hashCheck.length)
                for (let i = 0; i < message.hashCheck.length; ++i)
                    $root.BreachWatch.HashCheck.encode(message.hashCheck[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.removedEuid != null && message.removedEuid.length)
                for (let i = 0; i < message.removedEuid.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.removedEuid[i]);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchStatusRequest message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.IBreachWatchStatusRequest} message BreachWatchStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchStatusRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anonymizedToken = reader.bytes();
                    break;
                case 2:
                    if (!(message.hashCheck && message.hashCheck.length))
                        message.hashCheck = [];
                    message.hashCheck.push($root.BreachWatch.HashCheck.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.removedEuid && message.removedEuid.length))
                        message.removedEuid = [];
                    message.removedEuid.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchStatusRequest message.
         * @function verify
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                if (!(message.anonymizedToken && typeof message.anonymizedToken.length === "number" || $util.isString(message.anonymizedToken)))
                    return "anonymizedToken: buffer expected";
            if (message.hashCheck != null && message.hasOwnProperty("hashCheck")) {
                if (!Array.isArray(message.hashCheck))
                    return "hashCheck: array expected";
                for (let i = 0; i < message.hashCheck.length; ++i) {
                    let error = $root.BreachWatch.HashCheck.verify(message.hashCheck[i]);
                    if (error)
                        return "hashCheck." + error;
                }
            }
            if (message.removedEuid != null && message.hasOwnProperty("removedEuid")) {
                if (!Array.isArray(message.removedEuid))
                    return "removedEuid: array expected";
                for (let i = 0; i < message.removedEuid.length; ++i)
                    if (!(message.removedEuid[i] && typeof message.removedEuid[i].length === "number" || $util.isString(message.removedEuid[i])))
                        return "removedEuid: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a BreachWatchStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchStatusRequest} BreachWatchStatusRequest
         */
        BreachWatchStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchStatusRequest)
                return object;
            let message = new $root.BreachWatch.BreachWatchStatusRequest();
            if (object.anonymizedToken != null)
                if (typeof object.anonymizedToken === "string")
                    $util.base64.decode(object.anonymizedToken, message.anonymizedToken = $util.newBuffer($util.base64.length(object.anonymizedToken)), 0);
                else if (object.anonymizedToken.length)
                    message.anonymizedToken = object.anonymizedToken;
            if (object.hashCheck) {
                if (!Array.isArray(object.hashCheck))
                    throw TypeError(".BreachWatch.BreachWatchStatusRequest.hashCheck: array expected");
                message.hashCheck = [];
                for (let i = 0; i < object.hashCheck.length; ++i) {
                    if (typeof object.hashCheck[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchStatusRequest.hashCheck: object expected");
                    message.hashCheck[i] = $root.BreachWatch.HashCheck.fromObject(object.hashCheck[i]);
                }
            }
            if (object.removedEuid) {
                if (!Array.isArray(object.removedEuid))
                    throw TypeError(".BreachWatch.BreachWatchStatusRequest.removedEuid: array expected");
                message.removedEuid = [];
                for (let i = 0; i < object.removedEuid.length; ++i)
                    if (typeof object.removedEuid[i] === "string")
                        $util.base64.decode(object.removedEuid[i], message.removedEuid[i] = $util.newBuffer($util.base64.length(object.removedEuid[i])), 0);
                    else if (object.removedEuid[i].length)
                        message.removedEuid[i] = object.removedEuid[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @static
         * @param {BreachWatch.BreachWatchStatusRequest} message BreachWatchStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.hashCheck = [];
                object.removedEuid = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.anonymizedToken = "";
                else {
                    object.anonymizedToken = [];
                    if (options.bytes !== Array)
                        object.anonymizedToken = $util.newBuffer(object.anonymizedToken);
                }
            if (message.anonymizedToken != null && message.hasOwnProperty("anonymizedToken"))
                object.anonymizedToken = options.bytes === String ? $util.base64.encode(message.anonymizedToken, 0, message.anonymizedToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.anonymizedToken) : message.anonymizedToken;
            if (message.hashCheck && message.hashCheck.length) {
                object.hashCheck = [];
                for (let j = 0; j < message.hashCheck.length; ++j)
                    object.hashCheck[j] = $root.BreachWatch.HashCheck.toObject(message.hashCheck[j], options);
            }
            if (message.removedEuid && message.removedEuid.length) {
                object.removedEuid = [];
                for (let j = 0; j < message.removedEuid.length; ++j)
                    object.removedEuid[j] = options.bytes === String ? $util.base64.encode(message.removedEuid[j], 0, message.removedEuid[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.removedEuid[j]) : message.removedEuid[j];
            }
            return object;
        };

        /**
         * Converts this BreachWatchStatusRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchStatusRequest;
    })();

    BreachWatch.HashStatus = (function() {

        /**
         * Properties of a HashStatus.
         * @memberof BreachWatch
         * @interface IHashStatus
         * @property {Uint8Array|null} [hash1] HashStatus hash1
         * @property {Uint8Array|null} [euid] HashStatus euid
         * @property {boolean|null} [breachDetected] HashStatus breachDetected
         */

        /**
         * Constructs a new HashStatus.
         * @memberof BreachWatch
         * @classdesc Represents a HashStatus.
         * @implements IHashStatus
         * @constructor
         * @param {BreachWatch.IHashStatus=} [properties] Properties to set
         */
        function HashStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HashStatus hash1.
         * @member {Uint8Array} hash1
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.hash1 = $util.newBuffer([]);

        /**
         * HashStatus euid.
         * @member {Uint8Array} euid
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.euid = $util.newBuffer([]);

        /**
         * HashStatus breachDetected.
         * @member {boolean} breachDetected
         * @memberof BreachWatch.HashStatus
         * @instance
         */
        HashStatus.prototype.breachDetected = false;

        /**
         * Creates a new HashStatus instance using the specified properties.
         * @function create
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus=} [properties] Properties to set
         * @returns {BreachWatch.HashStatus} HashStatus instance
         */
        HashStatus.create = function create(properties) {
            return new HashStatus(properties);
        };

        /**
         * Encodes the specified HashStatus message. Does not implicitly {@link BreachWatch.HashStatus.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus} message HashStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash1);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.euid);
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.breachDetected);
            return writer;
        };

        /**
         * Encodes the specified HashStatus message, length delimited. Does not implicitly {@link BreachWatch.HashStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.IHashStatus} message HashStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HashStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HashStatus message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.HashStatus} HashStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.HashStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash1 = reader.bytes();
                    break;
                case 2:
                    message.euid = reader.bytes();
                    break;
                case 3:
                    message.breachDetected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HashStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.HashStatus} HashStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HashStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HashStatus message.
         * @function verify
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HashStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                if (!(message.hash1 && typeof message.hash1.length === "number" || $util.isString(message.hash1)))
                    return "hash1: buffer expected";
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                if (typeof message.breachDetected !== "boolean")
                    return "breachDetected: boolean expected";
            return null;
        };

        /**
         * Creates a HashStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.HashStatus} HashStatus
         */
        HashStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.HashStatus)
                return object;
            let message = new $root.BreachWatch.HashStatus();
            if (object.hash1 != null)
                if (typeof object.hash1 === "string")
                    $util.base64.decode(object.hash1, message.hash1 = $util.newBuffer($util.base64.length(object.hash1)), 0);
                else if (object.hash1.length)
                    message.hash1 = object.hash1;
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            if (object.breachDetected != null)
                message.breachDetected = Boolean(object.breachDetected);
            return message;
        };

        /**
         * Creates a plain object from a HashStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.HashStatus
         * @static
         * @param {BreachWatch.HashStatus} message HashStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HashStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash1 = "";
                else {
                    object.hash1 = [];
                    if (options.bytes !== Array)
                        object.hash1 = $util.newBuffer(object.hash1);
                }
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
                object.breachDetected = false;
            }
            if (message.hash1 != null && message.hasOwnProperty("hash1"))
                object.hash1 = options.bytes === String ? $util.base64.encode(message.hash1, 0, message.hash1.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash1) : message.hash1;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            if (message.breachDetected != null && message.hasOwnProperty("breachDetected"))
                object.breachDetected = message.breachDetected;
            return object;
        };

        /**
         * Converts this HashStatus to JSON.
         * @function toJSON
         * @memberof BreachWatch.HashStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HashStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HashStatus;
    })();

    BreachWatch.BreachWatchStatusResponse = (function() {

        /**
         * Properties of a BreachWatchStatusResponse.
         * @memberof BreachWatch
         * @interface IBreachWatchStatusResponse
         * @property {Array.<BreachWatch.IHashStatus>|null} [hashStatus] BreachWatchStatusResponse hashStatus
         */

        /**
         * Constructs a new BreachWatchStatusResponse.
         * @memberof BreachWatch
         * @classdesc Represents a BreachWatchStatusResponse.
         * @implements IBreachWatchStatusResponse
         * @constructor
         * @param {BreachWatch.IBreachWatchStatusResponse=} [properties] Properties to set
         */
        function BreachWatchStatusResponse(properties) {
            this.hashStatus = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchStatusResponse hashStatus.
         * @member {Array.<BreachWatch.IHashStatus>} hashStatus
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @instance
         */
        BreachWatchStatusResponse.prototype.hashStatus = $util.emptyArray;

        /**
         * Creates a new BreachWatchStatusResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse=} [properties] Properties to set
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse instance
         */
        BreachWatchStatusResponse.create = function create(properties) {
            return new BreachWatchStatusResponse(properties);
        };

        /**
         * Encodes the specified BreachWatchStatusResponse message. Does not implicitly {@link BreachWatch.BreachWatchStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse} message BreachWatchStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashStatus != null && message.hashStatus.length)
                for (let i = 0; i < message.hashStatus.length; ++i)
                    $root.BreachWatch.HashStatus.encode(message.hashStatus[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchStatusResponse message, length delimited. Does not implicitly {@link BreachWatch.BreachWatchStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.IBreachWatchStatusResponse} message BreachWatchStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachWatchStatusResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    if (!(message.hashStatus && message.hashStatus.length))
                        message.hashStatus = [];
                    message.hashStatus.push($root.BreachWatch.HashStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchStatusResponse message.
         * @function verify
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashStatus != null && message.hasOwnProperty("hashStatus")) {
                if (!Array.isArray(message.hashStatus))
                    return "hashStatus: array expected";
                for (let i = 0; i < message.hashStatus.length; ++i) {
                    let error = $root.BreachWatch.HashStatus.verify(message.hashStatus[i]);
                    if (error)
                        return "hashStatus." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachWatchStatusResponse} BreachWatchStatusResponse
         */
        BreachWatchStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachWatchStatusResponse)
                return object;
            let message = new $root.BreachWatch.BreachWatchStatusResponse();
            if (object.hashStatus) {
                if (!Array.isArray(object.hashStatus))
                    throw TypeError(".BreachWatch.BreachWatchStatusResponse.hashStatus: array expected");
                message.hashStatus = [];
                for (let i = 0; i < object.hashStatus.length; ++i) {
                    if (typeof object.hashStatus[i] !== "object")
                        throw TypeError(".BreachWatch.BreachWatchStatusResponse.hashStatus: object expected");
                    message.hashStatus[i] = $root.BreachWatch.HashStatus.fromObject(object.hashStatus[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @static
         * @param {BreachWatch.BreachWatchStatusResponse} message BreachWatchStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchStatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hashStatus = [];
            if (message.hashStatus && message.hashStatus.length) {
                object.hashStatus = [];
                for (let j = 0; j < message.hashStatus.length; ++j)
                    object.hashStatus[j] = $root.BreachWatch.HashStatus.toObject(message.hashStatus[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchStatusResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachWatchStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchStatusResponse;
    })();

    BreachWatch.EnterprisePublicKeyResponse = (function() {

        /**
         * Properties of an EnterprisePublicKeyResponse.
         * @memberof BreachWatch
         * @interface IEnterprisePublicKeyResponse
         * @property {Uint8Array|null} [enterprisePublicKey] EnterprisePublicKeyResponse enterprisePublicKey
         * @property {Uint8Array|null} [enterpriseECCPublicKey] EnterprisePublicKeyResponse enterpriseECCPublicKey
         */

        /**
         * Constructs a new EnterprisePublicKeyResponse.
         * @memberof BreachWatch
         * @classdesc Represents an EnterprisePublicKeyResponse.
         * @implements IEnterprisePublicKeyResponse
         * @constructor
         * @param {BreachWatch.IEnterprisePublicKeyResponse=} [properties] Properties to set
         */
        function EnterprisePublicKeyResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePublicKeyResponse enterprisePublicKey.
         * @member {Uint8Array} enterprisePublicKey
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @instance
         */
        EnterprisePublicKeyResponse.prototype.enterprisePublicKey = $util.newBuffer([]);

        /**
         * EnterprisePublicKeyResponse enterpriseECCPublicKey.
         * @member {Uint8Array} enterpriseECCPublicKey
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @instance
         */
        EnterprisePublicKeyResponse.prototype.enterpriseECCPublicKey = $util.newBuffer([]);

        /**
         * Creates a new EnterprisePublicKeyResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse=} [properties] Properties to set
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse instance
         */
        EnterprisePublicKeyResponse.create = function create(properties) {
            return new EnterprisePublicKeyResponse(properties);
        };

        /**
         * Encodes the specified EnterprisePublicKeyResponse message. Does not implicitly {@link BreachWatch.EnterprisePublicKeyResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse} message EnterprisePublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePublicKeyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.enterprisePublicKey);
            if (message.enterpriseECCPublicKey != null && message.hasOwnProperty("enterpriseECCPublicKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.enterpriseECCPublicKey);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePublicKeyResponse message, length delimited. Does not implicitly {@link BreachWatch.EnterprisePublicKeyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.IEnterprisePublicKeyResponse} message EnterprisePublicKeyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePublicKeyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePublicKeyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePublicKeyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.EnterprisePublicKeyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterprisePublicKey = reader.bytes();
                    break;
                case 2:
                    message.enterpriseECCPublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePublicKeyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePublicKeyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePublicKeyResponse message.
         * @function verify
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePublicKeyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                if (!(message.enterprisePublicKey && typeof message.enterprisePublicKey.length === "number" || $util.isString(message.enterprisePublicKey)))
                    return "enterprisePublicKey: buffer expected";
            if (message.enterpriseECCPublicKey != null && message.hasOwnProperty("enterpriseECCPublicKey"))
                if (!(message.enterpriseECCPublicKey && typeof message.enterpriseECCPublicKey.length === "number" || $util.isString(message.enterpriseECCPublicKey)))
                    return "enterpriseECCPublicKey: buffer expected";
            return null;
        };

        /**
         * Creates an EnterprisePublicKeyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.EnterprisePublicKeyResponse} EnterprisePublicKeyResponse
         */
        EnterprisePublicKeyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.EnterprisePublicKeyResponse)
                return object;
            let message = new $root.BreachWatch.EnterprisePublicKeyResponse();
            if (object.enterprisePublicKey != null)
                if (typeof object.enterprisePublicKey === "string")
                    $util.base64.decode(object.enterprisePublicKey, message.enterprisePublicKey = $util.newBuffer($util.base64.length(object.enterprisePublicKey)), 0);
                else if (object.enterprisePublicKey.length)
                    message.enterprisePublicKey = object.enterprisePublicKey;
            if (object.enterpriseECCPublicKey != null)
                if (typeof object.enterpriseECCPublicKey === "string")
                    $util.base64.decode(object.enterpriseECCPublicKey, message.enterpriseECCPublicKey = $util.newBuffer($util.base64.length(object.enterpriseECCPublicKey)), 0);
                else if (object.enterpriseECCPublicKey.length)
                    message.enterpriseECCPublicKey = object.enterpriseECCPublicKey;
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePublicKeyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @static
         * @param {BreachWatch.EnterprisePublicKeyResponse} message EnterprisePublicKeyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePublicKeyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.enterprisePublicKey = "";
                else {
                    object.enterprisePublicKey = [];
                    if (options.bytes !== Array)
                        object.enterprisePublicKey = $util.newBuffer(object.enterprisePublicKey);
                }
                if (options.bytes === String)
                    object.enterpriseECCPublicKey = "";
                else {
                    object.enterpriseECCPublicKey = [];
                    if (options.bytes !== Array)
                        object.enterpriseECCPublicKey = $util.newBuffer(object.enterpriseECCPublicKey);
                }
            }
            if (message.enterprisePublicKey != null && message.hasOwnProperty("enterprisePublicKey"))
                object.enterprisePublicKey = options.bytes === String ? $util.base64.encode(message.enterprisePublicKey, 0, message.enterprisePublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterprisePublicKey) : message.enterprisePublicKey;
            if (message.enterpriseECCPublicKey != null && message.hasOwnProperty("enterpriseECCPublicKey"))
                object.enterpriseECCPublicKey = options.bytes === String ? $util.base64.encode(message.enterpriseECCPublicKey, 0, message.enterpriseECCPublicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.enterpriseECCPublicKey) : message.enterpriseECCPublicKey;
            return object;
        };

        /**
         * Converts this EnterprisePublicKeyResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.EnterprisePublicKeyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePublicKeyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePublicKeyResponse;
    })();

    BreachWatch.FreeScanRequest = (function() {

        /**
         * Properties of a FreeScanRequest.
         * @memberof BreachWatch
         * @interface IFreeScanRequest
         * @property {Uint8Array|null} [hashedEmail] FreeScanRequest hashedEmail
         */

        /**
         * Constructs a new FreeScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a FreeScanRequest.
         * @implements IFreeScanRequest
         * @constructor
         * @param {BreachWatch.IFreeScanRequest=} [properties] Properties to set
         */
        function FreeScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreeScanRequest hashedEmail.
         * @member {Uint8Array} hashedEmail
         * @memberof BreachWatch.FreeScanRequest
         * @instance
         */
        FreeScanRequest.prototype.hashedEmail = $util.newBuffer([]);

        /**
         * Creates a new FreeScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest instance
         */
        FreeScanRequest.create = function create(properties) {
            return new FreeScanRequest(properties);
        };

        /**
         * Encodes the specified FreeScanRequest message. Does not implicitly {@link BreachWatch.FreeScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest} message FreeScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hashedEmail);
            return writer;
        };

        /**
         * Encodes the specified FreeScanRequest message, length delimited. Does not implicitly {@link BreachWatch.FreeScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.IFreeScanRequest} message FreeScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreeScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreeScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashedEmail = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreeScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreeScanRequest message.
         * @function verify
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreeScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                if (!(message.hashedEmail && typeof message.hashedEmail.length === "number" || $util.isString(message.hashedEmail)))
                    return "hashedEmail: buffer expected";
            return null;
        };

        /**
         * Creates a FreeScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreeScanRequest} FreeScanRequest
         */
        FreeScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreeScanRequest)
                return object;
            let message = new $root.BreachWatch.FreeScanRequest();
            if (object.hashedEmail != null)
                if (typeof object.hashedEmail === "string")
                    $util.base64.decode(object.hashedEmail, message.hashedEmail = $util.newBuffer($util.base64.length(object.hashedEmail)), 0);
                else if (object.hashedEmail.length)
                    message.hashedEmail = object.hashedEmail;
            return message;
        };

        /**
         * Creates a plain object from a FreeScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreeScanRequest
         * @static
         * @param {BreachWatch.FreeScanRequest} message FreeScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreeScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hashedEmail = "";
                else {
                    object.hashedEmail = [];
                    if (options.bytes !== Array)
                        object.hashedEmail = $util.newBuffer(object.hashedEmail);
                }
            if (message.hashedEmail != null && message.hasOwnProperty("hashedEmail"))
                object.hashedEmail = options.bytes === String ? $util.base64.encode(message.hashedEmail, 0, message.hashedEmail.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashedEmail) : message.hashedEmail;
            return object;
        };

        /**
         * Converts this FreeScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreeScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreeScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreeScanRequest;
    })();

    BreachWatch.FreeScanResponse = (function() {

        /**
         * Properties of a FreeScanResponse.
         * @memberof BreachWatch
         * @interface IFreeScanResponse
         * @property {number|null} [emailBreaches] FreeScanResponse emailBreaches
         * @property {number|null} [passwordBreaches] FreeScanResponse passwordBreaches
         */

        /**
         * Constructs a new FreeScanResponse.
         * @memberof BreachWatch
         * @classdesc Represents a FreeScanResponse.
         * @implements IFreeScanResponse
         * @constructor
         * @param {BreachWatch.IFreeScanResponse=} [properties] Properties to set
         */
        function FreeScanResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreeScanResponse emailBreaches.
         * @member {number} emailBreaches
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         */
        FreeScanResponse.prototype.emailBreaches = 0;

        /**
         * FreeScanResponse passwordBreaches.
         * @member {number} passwordBreaches
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         */
        FreeScanResponse.prototype.passwordBreaches = 0;

        /**
         * Creates a new FreeScanResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse=} [properties] Properties to set
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse instance
         */
        FreeScanResponse.create = function create(properties) {
            return new FreeScanResponse(properties);
        };

        /**
         * Encodes the specified FreeScanResponse message. Does not implicitly {@link BreachWatch.FreeScanResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse} message FreeScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.emailBreaches);
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passwordBreaches);
            return writer;
        };

        /**
         * Encodes the specified FreeScanResponse message, length delimited. Does not implicitly {@link BreachWatch.FreeScanResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.IFreeScanResponse} message FreeScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreeScanResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreeScanResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreeScanResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailBreaches = reader.int32();
                    break;
                case 2:
                    message.passwordBreaches = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreeScanResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreeScanResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreeScanResponse message.
         * @function verify
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreeScanResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                if (!$util.isInteger(message.emailBreaches))
                    return "emailBreaches: integer expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches))
                    return "passwordBreaches: integer expected";
            return null;
        };

        /**
         * Creates a FreeScanResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreeScanResponse} FreeScanResponse
         */
        FreeScanResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreeScanResponse)
                return object;
            let message = new $root.BreachWatch.FreeScanResponse();
            if (object.emailBreaches != null)
                message.emailBreaches = object.emailBreaches | 0;
            if (object.passwordBreaches != null)
                message.passwordBreaches = object.passwordBreaches | 0;
            return message;
        };

        /**
         * Creates a plain object from a FreeScanResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreeScanResponse
         * @static
         * @param {BreachWatch.FreeScanResponse} message FreeScanResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreeScanResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.emailBreaches = 0;
                object.passwordBreaches = 0;
            }
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                object.emailBreaches = message.emailBreaches;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                object.passwordBreaches = message.passwordBreaches;
            return object;
        };

        /**
         * Converts this FreeScanResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreeScanResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreeScanResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreeScanResponse;
    })();

    BreachWatch.PaidUserRequest = (function() {

        /**
         * Properties of a PaidUserRequest.
         * @memberof BreachWatch
         * @interface IPaidUserRequest
         * @property {string|null} [email] PaidUserRequest email
         */

        /**
         * Constructs a new PaidUserRequest.
         * @memberof BreachWatch
         * @classdesc Represents a PaidUserRequest.
         * @implements IPaidUserRequest
         * @constructor
         * @param {BreachWatch.IPaidUserRequest=} [properties] Properties to set
         */
        function PaidUserRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaidUserRequest email.
         * @member {string} email
         * @memberof BreachWatch.PaidUserRequest
         * @instance
         */
        PaidUserRequest.prototype.email = "";

        /**
         * Creates a new PaidUserRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest=} [properties] Properties to set
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest instance
         */
        PaidUserRequest.create = function create(properties) {
            return new PaidUserRequest(properties);
        };

        /**
         * Encodes the specified PaidUserRequest message. Does not implicitly {@link BreachWatch.PaidUserRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest} message PaidUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified PaidUserRequest message, length delimited. Does not implicitly {@link BreachWatch.PaidUserRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.IPaidUserRequest} message PaidUserRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaidUserRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.PaidUserRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaidUserRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaidUserRequest message.
         * @function verify
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaidUserRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a PaidUserRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.PaidUserRequest} PaidUserRequest
         */
        PaidUserRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.PaidUserRequest)
                return object;
            let message = new $root.BreachWatch.PaidUserRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a PaidUserRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.PaidUserRequest
         * @static
         * @param {BreachWatch.PaidUserRequest} message PaidUserRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaidUserRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this PaidUserRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.PaidUserRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaidUserRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaidUserRequest;
    })();

    BreachWatch.PaidUserResponse = (function() {

        /**
         * Properties of a PaidUserResponse.
         * @memberof BreachWatch
         * @interface IPaidUserResponse
         * @property {boolean|null} [paidUser] PaidUserResponse paidUser
         */

        /**
         * Constructs a new PaidUserResponse.
         * @memberof BreachWatch
         * @classdesc Represents a PaidUserResponse.
         * @implements IPaidUserResponse
         * @constructor
         * @param {BreachWatch.IPaidUserResponse=} [properties] Properties to set
         */
        function PaidUserResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PaidUserResponse paidUser.
         * @member {boolean} paidUser
         * @memberof BreachWatch.PaidUserResponse
         * @instance
         */
        PaidUserResponse.prototype.paidUser = false;

        /**
         * Creates a new PaidUserResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse=} [properties] Properties to set
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse instance
         */
        PaidUserResponse.create = function create(properties) {
            return new PaidUserResponse(properties);
        };

        /**
         * Encodes the specified PaidUserResponse message. Does not implicitly {@link BreachWatch.PaidUserResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse} message PaidUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.paidUser);
            return writer;
        };

        /**
         * Encodes the specified PaidUserResponse message, length delimited. Does not implicitly {@link BreachWatch.PaidUserResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.IPaidUserResponse} message PaidUserResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaidUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaidUserResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.PaidUserResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paidUser = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaidUserResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaidUserResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaidUserResponse message.
         * @function verify
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaidUserResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                if (typeof message.paidUser !== "boolean")
                    return "paidUser: boolean expected";
            return null;
        };

        /**
         * Creates a PaidUserResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.PaidUserResponse} PaidUserResponse
         */
        PaidUserResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.PaidUserResponse)
                return object;
            let message = new $root.BreachWatch.PaidUserResponse();
            if (object.paidUser != null)
                message.paidUser = Boolean(object.paidUser);
            return message;
        };

        /**
         * Creates a plain object from a PaidUserResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.PaidUserResponse
         * @static
         * @param {BreachWatch.PaidUserResponse} message PaidUserResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaidUserResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.paidUser = false;
            if (message.paidUser != null && message.hasOwnProperty("paidUser"))
                object.paidUser = message.paidUser;
            return object;
        };

        /**
         * Converts this PaidUserResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.PaidUserResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaidUserResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaidUserResponse;
    })();

    BreachWatch.DetailedScanRequest = (function() {

        /**
         * Properties of a DetailedScanRequest.
         * @memberof BreachWatch
         * @interface IDetailedScanRequest
         * @property {string|null} [email] DetailedScanRequest email
         */

        /**
         * Constructs a new DetailedScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a DetailedScanRequest.
         * @implements IDetailedScanRequest
         * @constructor
         * @param {BreachWatch.IDetailedScanRequest=} [properties] Properties to set
         */
        function DetailedScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DetailedScanRequest email.
         * @member {string} email
         * @memberof BreachWatch.DetailedScanRequest
         * @instance
         */
        DetailedScanRequest.prototype.email = "";

        /**
         * Creates a new DetailedScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest instance
         */
        DetailedScanRequest.create = function create(properties) {
            return new DetailedScanRequest(properties);
        };

        /**
         * Encodes the specified DetailedScanRequest message. Does not implicitly {@link BreachWatch.DetailedScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest} message DetailedScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailedScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified DetailedScanRequest message, length delimited. Does not implicitly {@link BreachWatch.DetailedScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.IDetailedScanRequest} message DetailedScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DetailedScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DetailedScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailedScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.DetailedScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DetailedScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DetailedScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DetailedScanRequest message.
         * @function verify
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DetailedScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a DetailedScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.DetailedScanRequest} DetailedScanRequest
         */
        DetailedScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.DetailedScanRequest)
                return object;
            let message = new $root.BreachWatch.DetailedScanRequest();
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a DetailedScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.DetailedScanRequest
         * @static
         * @param {BreachWatch.DetailedScanRequest} message DetailedScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DetailedScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.email = "";
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this DetailedScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.DetailedScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DetailedScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DetailedScanRequest;
    })();

    BreachWatch.UseOneTimeTokenRequest = (function() {

        /**
         * Properties of a UseOneTimeTokenRequest.
         * @memberof BreachWatch
         * @interface IUseOneTimeTokenRequest
         * @property {Uint8Array|null} [token] UseOneTimeTokenRequest token
         */

        /**
         * Constructs a new UseOneTimeTokenRequest.
         * @memberof BreachWatch
         * @classdesc Represents a UseOneTimeTokenRequest.
         * @implements IUseOneTimeTokenRequest
         * @constructor
         * @param {BreachWatch.IUseOneTimeTokenRequest=} [properties] Properties to set
         */
        function UseOneTimeTokenRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UseOneTimeTokenRequest token.
         * @member {Uint8Array} token
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @instance
         */
        UseOneTimeTokenRequest.prototype.token = $util.newBuffer([]);

        /**
         * Creates a new UseOneTimeTokenRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest=} [properties] Properties to set
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest instance
         */
        UseOneTimeTokenRequest.create = function create(properties) {
            return new UseOneTimeTokenRequest(properties);
        };

        /**
         * Encodes the specified UseOneTimeTokenRequest message. Does not implicitly {@link BreachWatch.UseOneTimeTokenRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest} message UseOneTimeTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.token != null && message.hasOwnProperty("token"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.token);
            return writer;
        };

        /**
         * Encodes the specified UseOneTimeTokenRequest message, length delimited. Does not implicitly {@link BreachWatch.UseOneTimeTokenRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.IUseOneTimeTokenRequest} message UseOneTimeTokenRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UseOneTimeTokenRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.UseOneTimeTokenRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.token = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UseOneTimeTokenRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UseOneTimeTokenRequest message.
         * @function verify
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UseOneTimeTokenRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.token != null && message.hasOwnProperty("token"))
                if (!(message.token && typeof message.token.length === "number" || $util.isString(message.token)))
                    return "token: buffer expected";
            return null;
        };

        /**
         * Creates a UseOneTimeTokenRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.UseOneTimeTokenRequest} UseOneTimeTokenRequest
         */
        UseOneTimeTokenRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.UseOneTimeTokenRequest)
                return object;
            let message = new $root.BreachWatch.UseOneTimeTokenRequest();
            if (object.token != null)
                if (typeof object.token === "string")
                    $util.base64.decode(object.token, message.token = $util.newBuffer($util.base64.length(object.token)), 0);
                else if (object.token.length)
                    message.token = object.token;
            return message;
        };

        /**
         * Creates a plain object from a UseOneTimeTokenRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @static
         * @param {BreachWatch.UseOneTimeTokenRequest} message UseOneTimeTokenRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UseOneTimeTokenRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.token = "";
                else {
                    object.token = [];
                    if (options.bytes !== Array)
                        object.token = $util.newBuffer(object.token);
                }
            if (message.token != null && message.hasOwnProperty("token"))
                object.token = options.bytes === String ? $util.base64.encode(message.token, 0, message.token.length) : options.bytes === Array ? Array.prototype.slice.call(message.token) : message.token;
            return object;
        };

        /**
         * Converts this UseOneTimeTokenRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.UseOneTimeTokenRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UseOneTimeTokenRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UseOneTimeTokenRequest;
    })();

    BreachWatch.BreachEvent = (function() {

        /**
         * Properties of a BreachEvent.
         * @memberof BreachWatch
         * @interface IBreachEvent
         * @property {string|null} [site] BreachEvent site
         * @property {string|null} [email] BreachEvent email
         * @property {boolean|null} [passwordInBreach] BreachEvent passwordInBreach
         * @property {string|null} [date] BreachEvent date
         * @property {string|null} [description] BreachEvent description
         */

        /**
         * Constructs a new BreachEvent.
         * @memberof BreachWatch
         * @classdesc Represents a BreachEvent.
         * @implements IBreachEvent
         * @constructor
         * @param {BreachWatch.IBreachEvent=} [properties] Properties to set
         */
        function BreachEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachEvent site.
         * @member {string} site
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.site = "";

        /**
         * BreachEvent email.
         * @member {string} email
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.email = "";

        /**
         * BreachEvent passwordInBreach.
         * @member {boolean} passwordInBreach
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.passwordInBreach = false;

        /**
         * BreachEvent date.
         * @member {string} date
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.date = "";

        /**
         * BreachEvent description.
         * @member {string} description
         * @memberof BreachWatch.BreachEvent
         * @instance
         */
        BreachEvent.prototype.description = "";

        /**
         * Creates a new BreachEvent instance using the specified properties.
         * @function create
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent=} [properties] Properties to set
         * @returns {BreachWatch.BreachEvent} BreachEvent instance
         */
        BreachEvent.create = function create(properties) {
            return new BreachEvent(properties);
        };

        /**
         * Encodes the specified BreachEvent message. Does not implicitly {@link BreachWatch.BreachEvent.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent} message BreachEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.site != null && message.hasOwnProperty("site"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.site);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.passwordInBreach);
            if (message.date != null && message.hasOwnProperty("date"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.date);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            return writer;
        };

        /**
         * Encodes the specified BreachEvent message, length delimited. Does not implicitly {@link BreachWatch.BreachEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.IBreachEvent} message BreachEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachEvent message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.BreachEvent} BreachEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.BreachEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.site = reader.string();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.passwordInBreach = reader.bool();
                    break;
                case 4:
                    message.date = reader.string();
                    break;
                case 5:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.BreachEvent} BreachEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachEvent message.
         * @function verify
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.site != null && message.hasOwnProperty("site"))
                if (!$util.isString(message.site))
                    return "site: string expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                if (typeof message.passwordInBreach !== "boolean")
                    return "passwordInBreach: boolean expected";
            if (message.date != null && message.hasOwnProperty("date"))
                if (!$util.isString(message.date))
                    return "date: string expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a BreachEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.BreachEvent} BreachEvent
         */
        BreachEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.BreachEvent)
                return object;
            let message = new $root.BreachWatch.BreachEvent();
            if (object.site != null)
                message.site = String(object.site);
            if (object.email != null)
                message.email = String(object.email);
            if (object.passwordInBreach != null)
                message.passwordInBreach = Boolean(object.passwordInBreach);
            if (object.date != null)
                message.date = String(object.date);
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a BreachEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.BreachEvent
         * @static
         * @param {BreachWatch.BreachEvent} message BreachEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.site = "";
                object.email = "";
                object.passwordInBreach = false;
                object.date = "";
                object.description = "";
            }
            if (message.site != null && message.hasOwnProperty("site"))
                object.site = message.site;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.passwordInBreach != null && message.hasOwnProperty("passwordInBreach"))
                object.passwordInBreach = message.passwordInBreach;
            if (message.date != null && message.hasOwnProperty("date"))
                object.date = message.date;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            return object;
        };

        /**
         * Converts this BreachEvent to JSON.
         * @function toJSON
         * @memberof BreachWatch.BreachEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachEvent;
    })();

    BreachWatch.UseOneTimeTokenResponse = (function() {

        /**
         * Properties of a UseOneTimeTokenResponse.
         * @memberof BreachWatch
         * @interface IUseOneTimeTokenResponse
         * @property {number|null} [emailBreaches] UseOneTimeTokenResponse emailBreaches
         * @property {number|null} [passwordBreaches] UseOneTimeTokenResponse passwordBreaches
         * @property {Array.<BreachWatch.IBreachEvent>|null} [breachEvents] UseOneTimeTokenResponse breachEvents
         * @property {string|null} [email] UseOneTimeTokenResponse email
         */

        /**
         * Constructs a new UseOneTimeTokenResponse.
         * @memberof BreachWatch
         * @classdesc Represents a UseOneTimeTokenResponse.
         * @implements IUseOneTimeTokenResponse
         * @constructor
         * @param {BreachWatch.IUseOneTimeTokenResponse=} [properties] Properties to set
         */
        function UseOneTimeTokenResponse(properties) {
            this.breachEvents = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UseOneTimeTokenResponse emailBreaches.
         * @member {number} emailBreaches
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.emailBreaches = 0;

        /**
         * UseOneTimeTokenResponse passwordBreaches.
         * @member {number} passwordBreaches
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.passwordBreaches = 0;

        /**
         * UseOneTimeTokenResponse breachEvents.
         * @member {Array.<BreachWatch.IBreachEvent>} breachEvents
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.breachEvents = $util.emptyArray;

        /**
         * UseOneTimeTokenResponse email.
         * @member {string} email
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         */
        UseOneTimeTokenResponse.prototype.email = "";

        /**
         * Creates a new UseOneTimeTokenResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse=} [properties] Properties to set
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse instance
         */
        UseOneTimeTokenResponse.create = function create(properties) {
            return new UseOneTimeTokenResponse(properties);
        };

        /**
         * Encodes the specified UseOneTimeTokenResponse message. Does not implicitly {@link BreachWatch.UseOneTimeTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse} message UseOneTimeTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.emailBreaches);
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.passwordBreaches);
            if (message.breachEvents != null && message.breachEvents.length)
                for (let i = 0; i < message.breachEvents.length; ++i)
                    $root.BreachWatch.BreachEvent.encode(message.breachEvents[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.email);
            return writer;
        };

        /**
         * Encodes the specified UseOneTimeTokenResponse message, length delimited. Does not implicitly {@link BreachWatch.UseOneTimeTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.IUseOneTimeTokenResponse} message UseOneTimeTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UseOneTimeTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UseOneTimeTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.UseOneTimeTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.emailBreaches = reader.int32();
                    break;
                case 2:
                    message.passwordBreaches = reader.int32();
                    break;
                case 3:
                    if (!(message.breachEvents && message.breachEvents.length))
                        message.breachEvents = [];
                    message.breachEvents.push($root.BreachWatch.BreachEvent.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.email = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UseOneTimeTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UseOneTimeTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UseOneTimeTokenResponse message.
         * @function verify
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UseOneTimeTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                if (!$util.isInteger(message.emailBreaches))
                    return "emailBreaches: integer expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches))
                    return "passwordBreaches: integer expected";
            if (message.breachEvents != null && message.hasOwnProperty("breachEvents")) {
                if (!Array.isArray(message.breachEvents))
                    return "breachEvents: array expected";
                for (let i = 0; i < message.breachEvents.length; ++i) {
                    let error = $root.BreachWatch.BreachEvent.verify(message.breachEvents[i]);
                    if (error)
                        return "breachEvents." + error;
                }
            }
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            return null;
        };

        /**
         * Creates a UseOneTimeTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.UseOneTimeTokenResponse} UseOneTimeTokenResponse
         */
        UseOneTimeTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.UseOneTimeTokenResponse)
                return object;
            let message = new $root.BreachWatch.UseOneTimeTokenResponse();
            if (object.emailBreaches != null)
                message.emailBreaches = object.emailBreaches | 0;
            if (object.passwordBreaches != null)
                message.passwordBreaches = object.passwordBreaches | 0;
            if (object.breachEvents) {
                if (!Array.isArray(object.breachEvents))
                    throw TypeError(".BreachWatch.UseOneTimeTokenResponse.breachEvents: array expected");
                message.breachEvents = [];
                for (let i = 0; i < object.breachEvents.length; ++i) {
                    if (typeof object.breachEvents[i] !== "object")
                        throw TypeError(".BreachWatch.UseOneTimeTokenResponse.breachEvents: object expected");
                    message.breachEvents[i] = $root.BreachWatch.BreachEvent.fromObject(object.breachEvents[i]);
                }
            }
            if (object.email != null)
                message.email = String(object.email);
            return message;
        };

        /**
         * Creates a plain object from a UseOneTimeTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @static
         * @param {BreachWatch.UseOneTimeTokenResponse} message UseOneTimeTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UseOneTimeTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachEvents = [];
            if (options.defaults) {
                object.emailBreaches = 0;
                object.passwordBreaches = 0;
                object.email = "";
            }
            if (message.emailBreaches != null && message.hasOwnProperty("emailBreaches"))
                object.emailBreaches = message.emailBreaches;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                object.passwordBreaches = message.passwordBreaches;
            if (message.breachEvents && message.breachEvents.length) {
                object.breachEvents = [];
                for (let j = 0; j < message.breachEvents.length; ++j)
                    object.breachEvents[j] = $root.BreachWatch.BreachEvent.toObject(message.breachEvents[j], options);
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            return object;
        };

        /**
         * Converts this UseOneTimeTokenResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.UseOneTimeTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UseOneTimeTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UseOneTimeTokenResponse;
    })();

    BreachWatch.OneTimeUseToken = (function() {

        /**
         * Properties of an OneTimeUseToken.
         * @memberof BreachWatch
         * @interface IOneTimeUseToken
         * @property {string|null} [email] OneTimeUseToken email
         * @property {string|null} [pad] OneTimeUseToken pad
         */

        /**
         * Constructs a new OneTimeUseToken.
         * @memberof BreachWatch
         * @classdesc Represents an OneTimeUseToken.
         * @implements IOneTimeUseToken
         * @constructor
         * @param {BreachWatch.IOneTimeUseToken=} [properties] Properties to set
         */
        function OneTimeUseToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OneTimeUseToken email.
         * @member {string} email
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         */
        OneTimeUseToken.prototype.email = "";

        /**
         * OneTimeUseToken pad.
         * @member {string} pad
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         */
        OneTimeUseToken.prototype.pad = "";

        /**
         * Creates a new OneTimeUseToken instance using the specified properties.
         * @function create
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken=} [properties] Properties to set
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken instance
         */
        OneTimeUseToken.create = function create(properties) {
            return new OneTimeUseToken(properties);
        };

        /**
         * Encodes the specified OneTimeUseToken message. Does not implicitly {@link BreachWatch.OneTimeUseToken.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken} message OneTimeUseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneTimeUseToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.pad != null && message.hasOwnProperty("pad"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pad);
            return writer;
        };

        /**
         * Encodes the specified OneTimeUseToken message, length delimited. Does not implicitly {@link BreachWatch.OneTimeUseToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.IOneTimeUseToken} message OneTimeUseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OneTimeUseToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OneTimeUseToken message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneTimeUseToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.OneTimeUseToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.pad = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OneTimeUseToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OneTimeUseToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OneTimeUseToken message.
         * @function verify
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OneTimeUseToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.pad != null && message.hasOwnProperty("pad"))
                if (!$util.isString(message.pad))
                    return "pad: string expected";
            return null;
        };

        /**
         * Creates an OneTimeUseToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.OneTimeUseToken} OneTimeUseToken
         */
        OneTimeUseToken.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.OneTimeUseToken)
                return object;
            let message = new $root.BreachWatch.OneTimeUseToken();
            if (object.email != null)
                message.email = String(object.email);
            if (object.pad != null)
                message.pad = String(object.pad);
            return message;
        };

        /**
         * Creates a plain object from an OneTimeUseToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.OneTimeUseToken
         * @static
         * @param {BreachWatch.OneTimeUseToken} message OneTimeUseToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OneTimeUseToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.pad = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.pad != null && message.hasOwnProperty("pad"))
                object.pad = message.pad;
            return object;
        };

        /**
         * Converts this OneTimeUseToken to JSON.
         * @function toJSON
         * @memberof BreachWatch.OneTimeUseToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OneTimeUseToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OneTimeUseToken;
    })();

    BreachWatch.FreePasswordScanRequest = (function() {

        /**
         * Properties of a FreePasswordScanRequest.
         * @memberof BreachWatch
         * @interface IFreePasswordScanRequest
         * @property {Uint8Array|null} [hashedPassword] FreePasswordScanRequest hashedPassword
         */

        /**
         * Constructs a new FreePasswordScanRequest.
         * @memberof BreachWatch
         * @classdesc Represents a FreePasswordScanRequest.
         * @implements IFreePasswordScanRequest
         * @constructor
         * @param {BreachWatch.IFreePasswordScanRequest=} [properties] Properties to set
         */
        function FreePasswordScanRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreePasswordScanRequest hashedPassword.
         * @member {Uint8Array} hashedPassword
         * @memberof BreachWatch.FreePasswordScanRequest
         * @instance
         */
        FreePasswordScanRequest.prototype.hashedPassword = $util.newBuffer([]);

        /**
         * Creates a new FreePasswordScanRequest instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest=} [properties] Properties to set
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest instance
         */
        FreePasswordScanRequest.create = function create(properties) {
            return new FreePasswordScanRequest(properties);
        };

        /**
         * Encodes the specified FreePasswordScanRequest message. Does not implicitly {@link BreachWatch.FreePasswordScanRequest.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest} message FreePasswordScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hashedPassword);
            return writer;
        };

        /**
         * Encodes the specified FreePasswordScanRequest message, length delimited. Does not implicitly {@link BreachWatch.FreePasswordScanRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.IFreePasswordScanRequest} message FreePasswordScanRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreePasswordScanRequest message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreePasswordScanRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hashedPassword = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreePasswordScanRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreePasswordScanRequest message.
         * @function verify
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreePasswordScanRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                if (!(message.hashedPassword && typeof message.hashedPassword.length === "number" || $util.isString(message.hashedPassword)))
                    return "hashedPassword: buffer expected";
            return null;
        };

        /**
         * Creates a FreePasswordScanRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreePasswordScanRequest} FreePasswordScanRequest
         */
        FreePasswordScanRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreePasswordScanRequest)
                return object;
            let message = new $root.BreachWatch.FreePasswordScanRequest();
            if (object.hashedPassword != null)
                if (typeof object.hashedPassword === "string")
                    $util.base64.decode(object.hashedPassword, message.hashedPassword = $util.newBuffer($util.base64.length(object.hashedPassword)), 0);
                else if (object.hashedPassword.length)
                    message.hashedPassword = object.hashedPassword;
            return message;
        };

        /**
         * Creates a plain object from a FreePasswordScanRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreePasswordScanRequest
         * @static
         * @param {BreachWatch.FreePasswordScanRequest} message FreePasswordScanRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreePasswordScanRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.hashedPassword = "";
                else {
                    object.hashedPassword = [];
                    if (options.bytes !== Array)
                        object.hashedPassword = $util.newBuffer(object.hashedPassword);
                }
            if (message.hashedPassword != null && message.hasOwnProperty("hashedPassword"))
                object.hashedPassword = options.bytes === String ? $util.base64.encode(message.hashedPassword, 0, message.hashedPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashedPassword) : message.hashedPassword;
            return object;
        };

        /**
         * Converts this FreePasswordScanRequest to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreePasswordScanRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreePasswordScanRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreePasswordScanRequest;
    })();

    BreachWatch.FreePasswordScanResponse = (function() {

        /**
         * Properties of a FreePasswordScanResponse.
         * @memberof BreachWatch
         * @interface IFreePasswordScanResponse
         * @property {number|Long|null} [passwordBreaches] FreePasswordScanResponse passwordBreaches
         */

        /**
         * Constructs a new FreePasswordScanResponse.
         * @memberof BreachWatch
         * @classdesc Represents a FreePasswordScanResponse.
         * @implements IFreePasswordScanResponse
         * @constructor
         * @param {BreachWatch.IFreePasswordScanResponse=} [properties] Properties to set
         */
        function FreePasswordScanResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreePasswordScanResponse passwordBreaches.
         * @member {number|Long} passwordBreaches
         * @memberof BreachWatch.FreePasswordScanResponse
         * @instance
         */
        FreePasswordScanResponse.prototype.passwordBreaches = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FreePasswordScanResponse instance using the specified properties.
         * @function create
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse=} [properties] Properties to set
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse instance
         */
        FreePasswordScanResponse.create = function create(properties) {
            return new FreePasswordScanResponse(properties);
        };

        /**
         * Encodes the specified FreePasswordScanResponse message. Does not implicitly {@link BreachWatch.FreePasswordScanResponse.verify|verify} messages.
         * @function encode
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse} message FreePasswordScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.passwordBreaches);
            return writer;
        };

        /**
         * Encodes the specified FreePasswordScanResponse message, length delimited. Does not implicitly {@link BreachWatch.FreePasswordScanResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.IFreePasswordScanResponse} message FreePasswordScanResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreePasswordScanResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreePasswordScanResponse message from the specified reader or buffer.
         * @function decode
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.BreachWatch.FreePasswordScanResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.passwordBreaches = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreePasswordScanResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreePasswordScanResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreePasswordScanResponse message.
         * @function verify
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreePasswordScanResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (!$util.isInteger(message.passwordBreaches) && !(message.passwordBreaches && $util.isInteger(message.passwordBreaches.low) && $util.isInteger(message.passwordBreaches.high)))
                    return "passwordBreaches: integer|Long expected";
            return null;
        };

        /**
         * Creates a FreePasswordScanResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {BreachWatch.FreePasswordScanResponse} FreePasswordScanResponse
         */
        FreePasswordScanResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.BreachWatch.FreePasswordScanResponse)
                return object;
            let message = new $root.BreachWatch.FreePasswordScanResponse();
            if (object.passwordBreaches != null)
                if ($util.Long)
                    (message.passwordBreaches = $util.Long.fromValue(object.passwordBreaches)).unsigned = false;
                else if (typeof object.passwordBreaches === "string")
                    message.passwordBreaches = parseInt(object.passwordBreaches, 10);
                else if (typeof object.passwordBreaches === "number")
                    message.passwordBreaches = object.passwordBreaches;
                else if (typeof object.passwordBreaches === "object")
                    message.passwordBreaches = new $util.LongBits(object.passwordBreaches.low >>> 0, object.passwordBreaches.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FreePasswordScanResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof BreachWatch.FreePasswordScanResponse
         * @static
         * @param {BreachWatch.FreePasswordScanResponse} message FreePasswordScanResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreePasswordScanResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.passwordBreaches = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.passwordBreaches = options.longs === String ? "0" : 0;
            if (message.passwordBreaches != null && message.hasOwnProperty("passwordBreaches"))
                if (typeof message.passwordBreaches === "number")
                    object.passwordBreaches = options.longs === String ? String(message.passwordBreaches) : message.passwordBreaches;
                else
                    object.passwordBreaches = options.longs === String ? $util.Long.prototype.toString.call(message.passwordBreaches) : options.longs === Number ? new $util.LongBits(message.passwordBreaches.low >>> 0, message.passwordBreaches.high >>> 0).toNumber() : message.passwordBreaches;
            return object;
        };

        /**
         * Converts this FreePasswordScanResponse to JSON.
         * @function toJSON
         * @memberof BreachWatch.FreePasswordScanResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreePasswordScanResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreePasswordScanResponse;
    })();

    return BreachWatch;
})();

export const Tokens = $root.Tokens = (() => {

    /**
     * Namespace Tokens.
     * @exports Tokens
     * @namespace
     */
    const Tokens = {};

    Tokens.BreachWatchUpdateRequest = (function() {

        /**
         * Properties of a BreachWatchUpdateRequest.
         * @memberof Tokens
         * @interface IBreachWatchUpdateRequest
         * @property {Array.<Tokens.IBreachWatchRecordRequest>|null} [breachWatchRecordRequest] BreachWatchUpdateRequest breachWatchRecordRequest
         * @property {Uint8Array|null} [encryptedData] BreachWatchUpdateRequest encryptedData
         */

        /**
         * Constructs a new BreachWatchUpdateRequest.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchUpdateRequest.
         * @implements IBreachWatchUpdateRequest
         * @constructor
         * @param {Tokens.IBreachWatchUpdateRequest=} [properties] Properties to set
         */
        function BreachWatchUpdateRequest(properties) {
            this.breachWatchRecordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchUpdateRequest breachWatchRecordRequest.
         * @member {Array.<Tokens.IBreachWatchRecordRequest>} breachWatchRecordRequest
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.breachWatchRecordRequest = $util.emptyArray;

        /**
         * BreachWatchUpdateRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         */
        BreachWatchUpdateRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest=} [properties] Properties to set
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest instance
         */
        BreachWatchUpdateRequest.create = function create(properties) {
            return new BreachWatchUpdateRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message. Does not implicitly {@link Tokens.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.breachWatchRecordRequest != null && message.breachWatchRecordRequest.length)
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i)
                    $root.Tokens.BreachWatchRecordRequest.encode(message.breachWatchRecordRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchUpdateRequest message, length delimited. Does not implicitly {@link Tokens.BreachWatchUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.IBreachWatchUpdateRequest} message BreachWatchUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.breachWatchRecordRequest && message.breachWatchRecordRequest.length))
                        message.breachWatchRecordRequest = [];
                    message.breachWatchRecordRequest.push($root.Tokens.BreachWatchRecordRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchUpdateRequest message.
         * @function verify
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.breachWatchRecordRequest != null && message.hasOwnProperty("breachWatchRecordRequest")) {
                if (!Array.isArray(message.breachWatchRecordRequest))
                    return "breachWatchRecordRequest: array expected";
                for (let i = 0; i < message.breachWatchRecordRequest.length; ++i) {
                    let error = $root.Tokens.BreachWatchRecordRequest.verify(message.breachWatchRecordRequest[i]);
                    if (error)
                        return "breachWatchRecordRequest." + error;
                }
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchUpdateRequest} BreachWatchUpdateRequest
         */
        BreachWatchUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchUpdateRequest)
                return object;
            let message = new $root.Tokens.BreachWatchUpdateRequest();
            if (object.breachWatchRecordRequest) {
                if (!Array.isArray(object.breachWatchRecordRequest))
                    throw TypeError(".Tokens.BreachWatchUpdateRequest.breachWatchRecordRequest: array expected");
                message.breachWatchRecordRequest = [];
                for (let i = 0; i < object.breachWatchRecordRequest.length; ++i) {
                    if (typeof object.breachWatchRecordRequest[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchUpdateRequest.breachWatchRecordRequest: object expected");
                    message.breachWatchRecordRequest[i] = $root.Tokens.BreachWatchRecordRequest.fromObject(object.breachWatchRecordRequest[i]);
                }
            }
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchUpdateRequest
         * @static
         * @param {Tokens.BreachWatchUpdateRequest} message BreachWatchUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.breachWatchRecordRequest = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
            if (message.breachWatchRecordRequest && message.breachWatchRecordRequest.length) {
                object.breachWatchRecordRequest = [];
                for (let j = 0; j < message.breachWatchRecordRequest.length; ++j)
                    object.breachWatchRecordRequest[j] = $root.Tokens.BreachWatchRecordRequest.toObject(message.breachWatchRecordRequest[j], options);
            }
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            return object;
        };

        /**
         * Converts this BreachWatchUpdateRequest to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchUpdateRequest;
    })();

    Tokens.BreachWatchRecordRequest = (function() {

        /**
         * Properties of a BreachWatchRecordRequest.
         * @memberof Tokens
         * @interface IBreachWatchRecordRequest
         * @property {Uint8Array|null} [recordUid] BreachWatchRecordRequest recordUid
         * @property {Uint8Array|null} [encryptedData] BreachWatchRecordRequest encryptedData
         * @property {Tokens.BreachWatchInfoType|null} [breachWatchInfoType] BreachWatchRecordRequest breachWatchInfoType
         * @property {boolean|null} [updateUserWhoScanned] BreachWatchRecordRequest updateUserWhoScanned
         */

        /**
         * Constructs a new BreachWatchRecordRequest.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchRecordRequest.
         * @implements IBreachWatchRecordRequest
         * @constructor
         * @param {Tokens.IBreachWatchRecordRequest=} [properties] Properties to set
         */
        function BreachWatchRecordRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchRecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest encryptedData.
         * @member {Uint8Array} encryptedData
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.encryptedData = $util.newBuffer([]);

        /**
         * BreachWatchRecordRequest breachWatchInfoType.
         * @member {Tokens.BreachWatchInfoType} breachWatchInfoType
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.breachWatchInfoType = 0;

        /**
         * BreachWatchRecordRequest updateUserWhoScanned.
         * @member {boolean} updateUserWhoScanned
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         */
        BreachWatchRecordRequest.prototype.updateUserWhoScanned = false;

        /**
         * Creates a new BreachWatchRecordRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest=} [properties] Properties to set
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest instance
         */
        BreachWatchRecordRequest.create = function create(properties) {
            return new BreachWatchRecordRequest(properties);
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message. Does not implicitly {@link Tokens.BreachWatchRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedData);
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.breachWatchInfoType);
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateUserWhoScanned);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchRecordRequest message, length delimited. Does not implicitly {@link Tokens.BreachWatchRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.IBreachWatchRecordRequest} message BreachWatchRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedData = reader.bytes();
                    break;
                case 3:
                    message.breachWatchInfoType = reader.int32();
                    break;
                case 4:
                    message.updateUserWhoScanned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchRecordRequest message.
         * @function verify
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                if (!(message.encryptedData && typeof message.encryptedData.length === "number" || $util.isString(message.encryptedData)))
                    return "encryptedData: buffer expected";
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                switch (message.breachWatchInfoType) {
                default:
                    return "breachWatchInfoType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                if (typeof message.updateUserWhoScanned !== "boolean")
                    return "updateUserWhoScanned: boolean expected";
            return null;
        };

        /**
         * Creates a BreachWatchRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchRecordRequest} BreachWatchRecordRequest
         */
        BreachWatchRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchRecordRequest)
                return object;
            let message = new $root.Tokens.BreachWatchRecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedData != null)
                if (typeof object.encryptedData === "string")
                    $util.base64.decode(object.encryptedData, message.encryptedData = $util.newBuffer($util.base64.length(object.encryptedData)), 0);
                else if (object.encryptedData.length)
                    message.encryptedData = object.encryptedData;
            switch (object.breachWatchInfoType) {
            case "RECORD":
            case 0:
                message.breachWatchInfoType = 0;
                break;
            case "ALTERNATE_PASSWORD":
            case 1:
                message.breachWatchInfoType = 1;
                break;
            }
            if (object.updateUserWhoScanned != null)
                message.updateUserWhoScanned = Boolean(object.updateUserWhoScanned);
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchRecordRequest
         * @static
         * @param {Tokens.BreachWatchRecordRequest} message BreachWatchRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedData = "";
                else {
                    object.encryptedData = [];
                    if (options.bytes !== Array)
                        object.encryptedData = $util.newBuffer(object.encryptedData);
                }
                object.breachWatchInfoType = options.enums === String ? "RECORD" : 0;
                object.updateUserWhoScanned = false;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedData != null && message.hasOwnProperty("encryptedData"))
                object.encryptedData = options.bytes === String ? $util.base64.encode(message.encryptedData, 0, message.encryptedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedData) : message.encryptedData;
            if (message.breachWatchInfoType != null && message.hasOwnProperty("breachWatchInfoType"))
                object.breachWatchInfoType = options.enums === String ? $root.Tokens.BreachWatchInfoType[message.breachWatchInfoType] : message.breachWatchInfoType;
            if (message.updateUserWhoScanned != null && message.hasOwnProperty("updateUserWhoScanned"))
                object.updateUserWhoScanned = message.updateUserWhoScanned;
            return object;
        };

        /**
         * Converts this BreachWatchRecordRequest to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchRecordRequest;
    })();

    /**
     * BreachWatchInfoType enum.
     * @name Tokens.BreachWatchInfoType
     * @enum {string}
     * @property {number} RECORD=0 RECORD value
     * @property {number} ALTERNATE_PASSWORD=1 ALTERNATE_PASSWORD value
     */
    Tokens.BreachWatchInfoType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RECORD"] = 0;
        values[valuesById[1] = "ALTERNATE_PASSWORD"] = 1;
        return values;
    })();

    Tokens.BreachWatchData = (function() {

        /**
         * Properties of a BreachWatchData.
         * @memberof Tokens
         * @interface IBreachWatchData
         * @property {Array.<Tokens.IBWPassword>|null} [passwords] BreachWatchData passwords
         * @property {Array.<Tokens.IBWPassword>|null} [emails] BreachWatchData emails
         * @property {Array.<Tokens.IBWPassword>|null} [domains] BreachWatchData domains
         */

        /**
         * Constructs a new BreachWatchData.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchData.
         * @implements IBreachWatchData
         * @constructor
         * @param {Tokens.IBreachWatchData=} [properties] Properties to set
         */
        function BreachWatchData(properties) {
            this.passwords = [];
            this.emails = [];
            this.domains = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchData passwords.
         * @member {Array.<Tokens.IBWPassword>} passwords
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.passwords = $util.emptyArray;

        /**
         * BreachWatchData emails.
         * @member {Array.<Tokens.IBWPassword>} emails
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.emails = $util.emptyArray;

        /**
         * BreachWatchData domains.
         * @member {Array.<Tokens.IBWPassword>} domains
         * @memberof Tokens.BreachWatchData
         * @instance
         */
        BreachWatchData.prototype.domains = $util.emptyArray;

        /**
         * Creates a new BreachWatchData instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData=} [properties] Properties to set
         * @returns {Tokens.BreachWatchData} BreachWatchData instance
         */
        BreachWatchData.create = function create(properties) {
            return new BreachWatchData(properties);
        };

        /**
         * Encodes the specified BreachWatchData message. Does not implicitly {@link Tokens.BreachWatchData.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData} message BreachWatchData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.passwords != null && message.passwords.length)
                for (let i = 0; i < message.passwords.length; ++i)
                    $root.Tokens.BWPassword.encode(message.passwords[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.emails != null && message.emails.length)
                for (let i = 0; i < message.emails.length; ++i)
                    $root.Tokens.BWPassword.encode(message.emails[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.domains != null && message.domains.length)
                for (let i = 0; i < message.domains.length; ++i)
                    $root.Tokens.BWPassword.encode(message.domains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BreachWatchData message, length delimited. Does not implicitly {@link Tokens.BreachWatchData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.IBreachWatchData} message BreachWatchData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchData message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchData} BreachWatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.passwords && message.passwords.length))
                        message.passwords = [];
                    message.passwords.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.emails && message.emails.length))
                        message.emails = [];
                    message.emails.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.domains && message.domains.length))
                        message.domains = [];
                    message.domains.push($root.Tokens.BWPassword.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchData} BreachWatchData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchData message.
         * @function verify
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.passwords != null && message.hasOwnProperty("passwords")) {
                if (!Array.isArray(message.passwords))
                    return "passwords: array expected";
                for (let i = 0; i < message.passwords.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.passwords[i]);
                    if (error)
                        return "passwords." + error;
                }
            }
            if (message.emails != null && message.hasOwnProperty("emails")) {
                if (!Array.isArray(message.emails))
                    return "emails: array expected";
                for (let i = 0; i < message.emails.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.emails[i]);
                    if (error)
                        return "emails." + error;
                }
            }
            if (message.domains != null && message.hasOwnProperty("domains")) {
                if (!Array.isArray(message.domains))
                    return "domains: array expected";
                for (let i = 0; i < message.domains.length; ++i) {
                    let error = $root.Tokens.BWPassword.verify(message.domains[i]);
                    if (error)
                        return "domains." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BreachWatchData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchData} BreachWatchData
         */
        BreachWatchData.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchData)
                return object;
            let message = new $root.Tokens.BreachWatchData();
            if (object.passwords) {
                if (!Array.isArray(object.passwords))
                    throw TypeError(".Tokens.BreachWatchData.passwords: array expected");
                message.passwords = [];
                for (let i = 0; i < object.passwords.length; ++i) {
                    if (typeof object.passwords[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.passwords: object expected");
                    message.passwords[i] = $root.Tokens.BWPassword.fromObject(object.passwords[i]);
                }
            }
            if (object.emails) {
                if (!Array.isArray(object.emails))
                    throw TypeError(".Tokens.BreachWatchData.emails: array expected");
                message.emails = [];
                for (let i = 0; i < object.emails.length; ++i) {
                    if (typeof object.emails[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.emails: object expected");
                    message.emails[i] = $root.Tokens.BWPassword.fromObject(object.emails[i]);
                }
            }
            if (object.domains) {
                if (!Array.isArray(object.domains))
                    throw TypeError(".Tokens.BreachWatchData.domains: array expected");
                message.domains = [];
                for (let i = 0; i < object.domains.length; ++i) {
                    if (typeof object.domains[i] !== "object")
                        throw TypeError(".Tokens.BreachWatchData.domains: object expected");
                    message.domains[i] = $root.Tokens.BWPassword.fromObject(object.domains[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchData
         * @static
         * @param {Tokens.BreachWatchData} message BreachWatchData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.passwords = [];
                object.emails = [];
                object.domains = [];
            }
            if (message.passwords && message.passwords.length) {
                object.passwords = [];
                for (let j = 0; j < message.passwords.length; ++j)
                    object.passwords[j] = $root.Tokens.BWPassword.toObject(message.passwords[j], options);
            }
            if (message.emails && message.emails.length) {
                object.emails = [];
                for (let j = 0; j < message.emails.length; ++j)
                    object.emails[j] = $root.Tokens.BWPassword.toObject(message.emails[j], options);
            }
            if (message.domains && message.domains.length) {
                object.domains = [];
                for (let j = 0; j < message.domains.length; ++j)
                    object.domains[j] = $root.Tokens.BWPassword.toObject(message.domains[j], options);
            }
            return object;
        };

        /**
         * Converts this BreachWatchData to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchData;
    })();

    Tokens.BWPassword = (function() {

        /**
         * Properties of a BWPassword.
         * @memberof Tokens
         * @interface IBWPassword
         * @property {string|null} [value] BWPassword value
         * @property {number|Long|null} [resolved] BWPassword resolved
         * @property {Tokens.BWStatus|null} [status] BWPassword status
         * @property {Uint8Array|null} [euid] BWPassword euid
         */

        /**
         * Constructs a new BWPassword.
         * @memberof Tokens
         * @classdesc Represents a BWPassword.
         * @implements IBWPassword
         * @constructor
         * @param {Tokens.IBWPassword=} [properties] Properties to set
         */
        function BWPassword(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BWPassword value.
         * @member {string} value
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.value = "";

        /**
         * BWPassword resolved.
         * @member {number|Long} resolved
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.resolved = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BWPassword status.
         * @member {Tokens.BWStatus} status
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.status = 0;

        /**
         * BWPassword euid.
         * @member {Uint8Array} euid
         * @memberof Tokens.BWPassword
         * @instance
         */
        BWPassword.prototype.euid = $util.newBuffer([]);

        /**
         * Creates a new BWPassword instance using the specified properties.
         * @function create
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword=} [properties] Properties to set
         * @returns {Tokens.BWPassword} BWPassword instance
         */
        BWPassword.create = function create(properties) {
            return new BWPassword(properties);
        };

        /**
         * Encodes the specified BWPassword message. Does not implicitly {@link Tokens.BWPassword.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword} message BWPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BWPassword.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.resolved);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.euid != null && message.hasOwnProperty("euid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.euid);
            return writer;
        };

        /**
         * Encodes the specified BWPassword message, length delimited. Does not implicitly {@link Tokens.BWPassword.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.IBWPassword} message BWPassword message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BWPassword.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BWPassword message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BWPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BWPassword} BWPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BWPassword.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BWPassword();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                case 2:
                    message.resolved = reader.uint64();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.euid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BWPassword message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BWPassword
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BWPassword} BWPassword
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BWPassword.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BWPassword message.
         * @function verify
         * @memberof Tokens.BWPassword
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BWPassword.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (!$util.isInteger(message.resolved) && !(message.resolved && $util.isInteger(message.resolved.low) && $util.isInteger(message.resolved.high)))
                    return "resolved: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.euid != null && message.hasOwnProperty("euid"))
                if (!(message.euid && typeof message.euid.length === "number" || $util.isString(message.euid)))
                    return "euid: buffer expected";
            return null;
        };

        /**
         * Creates a BWPassword message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BWPassword
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BWPassword} BWPassword
         */
        BWPassword.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BWPassword)
                return object;
            let message = new $root.Tokens.BWPassword();
            if (object.value != null)
                message.value = String(object.value);
            if (object.resolved != null)
                if ($util.Long)
                    (message.resolved = $util.Long.fromValue(object.resolved)).unsigned = true;
                else if (typeof object.resolved === "string")
                    message.resolved = parseInt(object.resolved, 10);
                else if (typeof object.resolved === "number")
                    message.resolved = object.resolved;
                else if (typeof object.resolved === "object")
                    message.resolved = new $util.LongBits(object.resolved.low >>> 0, object.resolved.high >>> 0).toNumber(true);
            switch (object.status) {
            case "GOOD":
            case 0:
                message.status = 0;
                break;
            case "CHANGED":
            case 1:
                message.status = 1;
                break;
            case "WEAK":
            case 2:
                message.status = 2;
                break;
            case "BREACHED":
            case 3:
                message.status = 3;
                break;
            case "IGNORE":
            case 4:
                message.status = 4;
                break;
            }
            if (object.euid != null)
                if (typeof object.euid === "string")
                    $util.base64.decode(object.euid, message.euid = $util.newBuffer($util.base64.length(object.euid)), 0);
                else if (object.euid.length)
                    message.euid = object.euid;
            return message;
        };

        /**
         * Creates a plain object from a BWPassword message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BWPassword
         * @static
         * @param {Tokens.BWPassword} message BWPassword
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BWPassword.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.resolved = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resolved = options.longs === String ? "0" : 0;
                object.status = options.enums === String ? "GOOD" : 0;
                if (options.bytes === String)
                    object.euid = "";
                else {
                    object.euid = [];
                    if (options.bytes !== Array)
                        object.euid = $util.newBuffer(object.euid);
                }
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.resolved != null && message.hasOwnProperty("resolved"))
                if (typeof message.resolved === "number")
                    object.resolved = options.longs === String ? String(message.resolved) : message.resolved;
                else
                    object.resolved = options.longs === String ? $util.Long.prototype.toString.call(message.resolved) : options.longs === Number ? new $util.LongBits(message.resolved.low >>> 0, message.resolved.high >>> 0).toNumber(true) : message.resolved;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Tokens.BWStatus[message.status] : message.status;
            if (message.euid != null && message.hasOwnProperty("euid"))
                object.euid = options.bytes === String ? $util.base64.encode(message.euid, 0, message.euid.length) : options.bytes === Array ? Array.prototype.slice.call(message.euid) : message.euid;
            return object;
        };

        /**
         * Converts this BWPassword to JSON.
         * @function toJSON
         * @memberof Tokens.BWPassword
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BWPassword.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BWPassword;
    })();

    /**
     * BWStatus enum.
     * @name Tokens.BWStatus
     * @enum {string}
     * @property {number} GOOD=0 GOOD value
     * @property {number} CHANGED=1 CHANGED value
     * @property {number} WEAK=2 WEAK value
     * @property {number} BREACHED=3 BREACHED value
     * @property {number} IGNORE=4 IGNORE value
     */
    Tokens.BWStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GOOD"] = 0;
        values[valuesById[1] = "CHANGED"] = 1;
        values[valuesById[2] = "WEAK"] = 2;
        values[valuesById[3] = "BREACHED"] = 3;
        values[valuesById[4] = "IGNORE"] = 4;
        return values;
    })();

    Tokens.DeviceToken = (function() {

        /**
         * Properties of a DeviceToken.
         * @memberof Tokens
         * @interface IDeviceToken
         * @property {number|Long|null} [deviceId] DeviceToken deviceId
         * @property {number|null} [region] DeviceToken region
         */

        /**
         * Constructs a new DeviceToken.
         * @memberof Tokens
         * @classdesc Represents a DeviceToken.
         * @implements IDeviceToken
         * @constructor
         * @param {Tokens.IDeviceToken=} [properties] Properties to set
         */
        function DeviceToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.DeviceToken
         * @instance
         */
        DeviceToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceToken region.
         * @member {number} region
         * @memberof Tokens.DeviceToken
         * @instance
         */
        DeviceToken.prototype.region = 0;

        /**
         * Creates a new DeviceToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken=} [properties] Properties to set
         * @returns {Tokens.DeviceToken} DeviceToken instance
         */
        DeviceToken.create = function create(properties) {
            return new DeviceToken(properties);
        };

        /**
         * Encodes the specified DeviceToken message. Does not implicitly {@link Tokens.DeviceToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.region != null && message.hasOwnProperty("region"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.region);
            return writer;
        };

        /**
         * Encodes the specified DeviceToken message, length delimited. Does not implicitly {@link Tokens.DeviceToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.IDeviceToken} message DeviceToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeviceToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.region = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeviceToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeviceToken} DeviceToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceToken message.
         * @function verify
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isInteger(message.region))
                    return "region: integer expected";
            return null;
        };

        /**
         * Creates a DeviceToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeviceToken} DeviceToken
         */
        DeviceToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeviceToken)
                return object;
            let message = new $root.Tokens.DeviceToken();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.region != null)
                message.region = object.region | 0;
            return message;
        };

        /**
         * Creates a plain object from a DeviceToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeviceToken
         * @static
         * @param {Tokens.DeviceToken} message DeviceToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.region = 0;
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            return object;
        };

        /**
         * Converts this DeviceToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeviceToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceToken;
    })();

    Tokens.SSOLoginToken = (function() {

        /**
         * Properties of a SSOLoginToken.
         * @memberof Tokens
         * @interface ISSOLoginToken
         * @property {number|Long|null} [ssoServiceProviderId] SSOLoginToken ssoServiceProviderId
         * @property {string|null} [username] SSOLoginToken username
         * @property {string|null} [alias] SSOLoginToken alias
         * @property {string|null} [displayname] SSOLoginToken displayname
         */

        /**
         * Constructs a new SSOLoginToken.
         * @memberof Tokens
         * @classdesc Represents a SSOLoginToken.
         * @implements ISSOLoginToken
         * @constructor
         * @param {Tokens.ISSOLoginToken=} [properties] Properties to set
         */
        function SSOLoginToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSOLoginToken ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof Tokens.SSOLoginToken
         * @instance
         */
        SSOLoginToken.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SSOLoginToken username.
         * @member {string} username
         * @memberof Tokens.SSOLoginToken
         * @instance
         */
        SSOLoginToken.prototype.username = "";

        /**
         * SSOLoginToken alias.
         * @member {string} alias
         * @memberof Tokens.SSOLoginToken
         * @instance
         */
        SSOLoginToken.prototype.alias = "";

        /**
         * SSOLoginToken displayname.
         * @member {string} displayname
         * @memberof Tokens.SSOLoginToken
         * @instance
         */
        SSOLoginToken.prototype.displayname = "";

        /**
         * Creates a new SSOLoginToken instance using the specified properties.
         * @function create
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Tokens.ISSOLoginToken=} [properties] Properties to set
         * @returns {Tokens.SSOLoginToken} SSOLoginToken instance
         */
        SSOLoginToken.create = function create(properties) {
            return new SSOLoginToken(properties);
        };

        /**
         * Encodes the specified SSOLoginToken message. Does not implicitly {@link Tokens.SSOLoginToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Tokens.ISSOLoginToken} message SSOLoginToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSOLoginToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.ssoServiceProviderId);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            if (message.displayname != null && message.hasOwnProperty("displayname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.displayname);
            return writer;
        };

        /**
         * Encodes the specified SSOLoginToken message, length delimited. Does not implicitly {@link Tokens.SSOLoginToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Tokens.ISSOLoginToken} message SSOLoginToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSOLoginToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSOLoginToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.SSOLoginToken} SSOLoginToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSOLoginToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.SSOLoginToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.int64();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                case 4:
                    message.displayname = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SSOLoginToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.SSOLoginToken} SSOLoginToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSOLoginToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSOLoginToken message.
         * @function verify
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSOLoginToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.displayname != null && message.hasOwnProperty("displayname"))
                if (!$util.isString(message.displayname))
                    return "displayname: string expected";
            return null;
        };

        /**
         * Creates a SSOLoginToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.SSOLoginToken} SSOLoginToken
         */
        SSOLoginToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.SSOLoginToken)
                return object;
            let message = new $root.Tokens.SSOLoginToken();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = false;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber();
            if (object.username != null)
                message.username = String(object.username);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.displayname != null)
                message.displayname = String(object.displayname);
            return message;
        };

        /**
         * Creates a plain object from a SSOLoginToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.SSOLoginToken
         * @static
         * @param {Tokens.SSOLoginToken} message SSOLoginToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSOLoginToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                object.username = "";
                object.alias = "";
                object.displayname = "";
            }
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber() : message.ssoServiceProviderId;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.displayname != null && message.hasOwnProperty("displayname"))
                object.displayname = message.displayname;
            return object;
        };

        /**
         * Converts this SSOLoginToken to JSON.
         * @function toJSON
         * @memberof Tokens.SSOLoginToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSOLoginToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SSOLoginToken;
    })();

    Tokens.LoginToken = (function() {

        /**
         * Properties of a LoginToken.
         * @memberof Tokens
         * @interface ILoginToken
         * @property {number|Long|null} [loginSessionId] LoginToken loginSessionId
         * @property {number|Long|null} [deviceId] LoginToken deviceId
         * @property {Uint8Array|null} [accountUid] LoginToken accountUid
         * @property {Uint8Array|null} [messageSessionUid] LoginToken messageSessionUid
         * @property {Authentication.LoginState|null} [loginState] LoginToken loginState
         * @property {Authentication.LoginMethod|null} [loginMethod] LoginToken loginMethod
         * @property {number|Long|null} [creation] LoginToken creation
         * @property {number|null} [userId] LoginToken userId
         * @property {number|Long|null} [enterpriseUserId] LoginToken enterpriseUserId
         * @property {number|null} [clientVersionId] LoginToken clientVersionId
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] LoginToken supportedLanguage
         * @property {Tokens.ISSOLoginToken|null} [ssoLoginToken] LoginToken ssoLoginToken
         * @property {string|null} [username] LoginToken username
         * @property {boolean|null} [relogin] LoginToken relogin
         * @property {Authentication.LoginType|null} [loginType] LoginToken loginType
         */

        /**
         * Constructs a new LoginToken.
         * @memberof Tokens
         * @classdesc Represents a LoginToken.
         * @implements ILoginToken
         * @constructor
         * @param {Tokens.ILoginToken=} [properties] Properties to set
         */
        function LoginToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginToken loginSessionId.
         * @member {number|Long} loginSessionId
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.loginSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginToken accountUid.
         * @member {Uint8Array} accountUid
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.accountUid = $util.newBuffer([]);

        /**
         * LoginToken messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * LoginToken loginState.
         * @member {Authentication.LoginState} loginState
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.loginState = 0;

        /**
         * LoginToken loginMethod.
         * @member {Authentication.LoginMethod} loginMethod
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.loginMethod = 0;

        /**
         * LoginToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginToken userId.
         * @member {number} userId
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.userId = 0;

        /**
         * LoginToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.clientVersionId = 0;

        /**
         * LoginToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.supportedLanguage = 0;

        /**
         * LoginToken ssoLoginToken.
         * @member {Tokens.ISSOLoginToken|null|undefined} ssoLoginToken
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.ssoLoginToken = null;

        /**
         * LoginToken username.
         * @member {string} username
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.username = "";

        /**
         * LoginToken relogin.
         * @member {boolean} relogin
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.relogin = false;

        /**
         * LoginToken loginType.
         * @member {Authentication.LoginType} loginType
         * @memberof Tokens.LoginToken
         * @instance
         */
        LoginToken.prototype.loginType = 0;

        /**
         * Creates a new LoginToken instance using the specified properties.
         * @function create
         * @memberof Tokens.LoginToken
         * @static
         * @param {Tokens.ILoginToken=} [properties] Properties to set
         * @returns {Tokens.LoginToken} LoginToken instance
         */
        LoginToken.create = function create(properties) {
            return new LoginToken(properties);
        };

        /**
         * Encodes the specified LoginToken message. Does not implicitly {@link Tokens.LoginToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.LoginToken
         * @static
         * @param {Tokens.ILoginToken} message LoginToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.loginSessionId);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.deviceId);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.accountUid);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.messageSessionUid);
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.loginState);
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.loginMethod);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.creation);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.userId);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.enterpriseUserId);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.clientVersionId);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.supportedLanguage);
            if (message.ssoLoginToken != null && message.hasOwnProperty("ssoLoginToken"))
                $root.Tokens.SSOLoginToken.encode(message.ssoLoginToken, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.username);
            if (message.relogin != null && message.hasOwnProperty("relogin"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.relogin);
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.loginType);
            return writer;
        };

        /**
         * Encodes the specified LoginToken message, length delimited. Does not implicitly {@link Tokens.LoginToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.LoginToken
         * @static
         * @param {Tokens.ILoginToken} message LoginToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.LoginToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.LoginToken} LoginToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.LoginToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.loginSessionId = reader.int64();
                    break;
                case 2:
                    message.deviceId = reader.int64();
                    break;
                case 3:
                    message.accountUid = reader.bytes();
                    break;
                case 4:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 5:
                    message.loginState = reader.int32();
                    break;
                case 6:
                    message.loginMethod = reader.int32();
                    break;
                case 7:
                    message.creation = reader.int64();
                    break;
                case 8:
                    message.userId = reader.int32();
                    break;
                case 9:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 10:
                    message.clientVersionId = reader.int32();
                    break;
                case 11:
                    message.supportedLanguage = reader.int32();
                    break;
                case 12:
                    message.ssoLoginToken = $root.Tokens.SSOLoginToken.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.username = reader.string();
                    break;
                case 14:
                    message.relogin = reader.bool();
                    break;
                case 15:
                    message.loginType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.LoginToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.LoginToken} LoginToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginToken message.
         * @function verify
         * @memberof Tokens.LoginToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                if (!$util.isInteger(message.loginSessionId) && !(message.loginSessionId && $util.isInteger(message.loginSessionId.low) && $util.isInteger(message.loginSessionId.high)))
                    return "loginSessionId: integer|Long expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                switch (message.loginState) {
                default:
                    return "loginState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 99:
                    break;
                }
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                switch (message.loginMethod) {
                default:
                    return "loginMethod: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.ssoLoginToken != null && message.hasOwnProperty("ssoLoginToken")) {
                let error = $root.Tokens.SSOLoginToken.verify(message.ssoLoginToken);
                if (error)
                    return "ssoLoginToken." + error;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.relogin != null && message.hasOwnProperty("relogin"))
                if (typeof message.relogin !== "boolean")
                    return "relogin: boolean expected";
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                switch (message.loginType) {
                default:
                    return "loginType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a LoginToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.LoginToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.LoginToken} LoginToken
         */
        LoginToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.LoginToken)
                return object;
            let message = new $root.Tokens.LoginToken();
            if (object.loginSessionId != null)
                if ($util.Long)
                    (message.loginSessionId = $util.Long.fromValue(object.loginSessionId)).unsigned = false;
                else if (typeof object.loginSessionId === "string")
                    message.loginSessionId = parseInt(object.loginSessionId, 10);
                else if (typeof object.loginSessionId === "number")
                    message.loginSessionId = object.loginSessionId;
                else if (typeof object.loginSessionId === "object")
                    message.loginSessionId = new $util.LongBits(object.loginSessionId.low >>> 0, object.loginSessionId.high >>> 0).toNumber();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            switch (object.loginState) {
            case "INVALID_LOGINSTATE":
            case 0:
                message.loginState = 0;
                break;
            case "LOGGED_OUT":
            case 1:
                message.loginState = 1;
                break;
            case "DEVICE_APPROVAL_REQUIRED":
            case 2:
                message.loginState = 2;
                break;
            case "DEVICE_LOCKED":
            case 3:
                message.loginState = 3;
                break;
            case "ACCOUNT_LOCKED":
            case 4:
                message.loginState = 4;
                break;
            case "DEVICE_ACCOUNT_LOCKED":
            case 5:
                message.loginState = 5;
                break;
            case "UPGRADE":
            case 6:
                message.loginState = 6;
                break;
            case "LICENSE_EXPIRED":
            case 7:
                message.loginState = 7;
                break;
            case "REGION_REDIRECT":
            case 8:
                message.loginState = 8;
                break;
            case "REDIRECT_CLOUD_SSO":
            case 9:
                message.loginState = 9;
                break;
            case "REDIRECT_ONSITE_SSO":
            case 10:
                message.loginState = 10;
                break;
            case "REQUIRES_2FA":
            case 12:
                message.loginState = 12;
                break;
            case "REQUIRES_AUTH_HASH":
            case 13:
                message.loginState = 13;
                break;
            case "REQUIRES_USERNAME":
            case 14:
                message.loginState = 14;
                break;
            case "AFTER_CLOUD_SSO_LOGIN":
            case 15:
                message.loginState = 15;
                break;
            case "REQUIRES_ACCOUNT_CREATION":
            case 16:
                message.loginState = 16;
                break;
            case "REQUIRES_DEVICE_ENCRYPTED_DATA_KEY":
            case 17:
                message.loginState = 17;
                break;
            case "LOGIN_TOKEN_EXPIRED":
            case 18:
                message.loginState = 18;
                break;
            case "LOGGED_IN":
            case 99:
                message.loginState = 99;
                break;
            }
            switch (object.loginMethod) {
            case "INVALID_LOGINMETHOD":
            case 0:
                message.loginMethod = 0;
                break;
            case "EXISTING_ACCOUNT":
            case 1:
                message.loginMethod = 1;
                break;
            case "SSO_DOMAIN":
            case 2:
                message.loginMethod = 2;
                break;
            case "AFTER_SSO":
            case 3:
                message.loginMethod = 3;
                break;
            case "NEW_ACCOUNT":
            case 4:
                message.loginMethod = 4;
                break;
            }
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.ssoLoginToken != null) {
                if (typeof object.ssoLoginToken !== "object")
                    throw TypeError(".Tokens.LoginToken.ssoLoginToken: object expected");
                message.ssoLoginToken = $root.Tokens.SSOLoginToken.fromObject(object.ssoLoginToken);
            }
            if (object.username != null)
                message.username = String(object.username);
            if (object.relogin != null)
                message.relogin = Boolean(object.relogin);
            switch (object.loginType) {
            case "NORMAL":
            case 0:
                message.loginType = 0;
                break;
            case "SSO":
            case 1:
                message.loginType = 1;
                break;
            case "BIO":
            case 2:
                message.loginType = 2;
                break;
            case "ALTERNATE":
            case 3:
                message.loginType = 3;
                break;
            case "OFFLINE":
            case 4:
                message.loginType = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LoginToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.LoginToken
         * @static
         * @param {Tokens.LoginToken} message LoginToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.loginSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.loginSessionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.loginState = options.enums === String ? "INVALID_LOGINSTATE" : 0;
                object.loginMethod = options.enums === String ? "INVALID_LOGINMETHOD" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                object.userId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.clientVersionId = 0;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.ssoLoginToken = null;
                object.username = "";
                object.relogin = false;
                object.loginType = options.enums === String ? "NORMAL" : 0;
            }
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                if (typeof message.loginSessionId === "number")
                    object.loginSessionId = options.longs === String ? String(message.loginSessionId) : message.loginSessionId;
                else
                    object.loginSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.loginSessionId) : options.longs === Number ? new $util.LongBits(message.loginSessionId.low >>> 0, message.loginSessionId.high >>> 0).toNumber() : message.loginSessionId;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.loginState != null && message.hasOwnProperty("loginState"))
                object.loginState = options.enums === String ? $root.Authentication.LoginState[message.loginState] : message.loginState;
            if (message.loginMethod != null && message.hasOwnProperty("loginMethod"))
                object.loginMethod = options.enums === String ? $root.Authentication.LoginMethod[message.loginMethod] : message.loginMethod;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.ssoLoginToken != null && message.hasOwnProperty("ssoLoginToken"))
                object.ssoLoginToken = $root.Tokens.SSOLoginToken.toObject(message.ssoLoginToken, options);
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.relogin != null && message.hasOwnProperty("relogin"))
                object.relogin = message.relogin;
            if (message.loginType != null && message.hasOwnProperty("loginType"))
                object.loginType = options.enums === String ? $root.Authentication.LoginType[message.loginType] : message.loginType;
            return object;
        };

        /**
         * Converts this LoginToken to JSON.
         * @function toJSON
         * @memberof Tokens.LoginToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LoginToken;
    })();

    Tokens.DeviceApprovalToken = (function() {

        /**
         * Properties of a DeviceApprovalToken.
         * @memberof Tokens
         * @interface IDeviceApprovalToken
         * @property {number|Long|null} [creation] DeviceApprovalToken creation
         * @property {number|Long|null} [expiration] DeviceApprovalToken expiration
         * @property {Tokens.IDeviceToken|null} [deviceToken] DeviceApprovalToken deviceToken
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] DeviceApprovalToken supportedLanguage
         */

        /**
         * Constructs a new DeviceApprovalToken.
         * @memberof Tokens
         * @classdesc Represents a DeviceApprovalToken.
         * @implements IDeviceApprovalToken
         * @constructor
         * @param {Tokens.IDeviceApprovalToken=} [properties] Properties to set
         */
        function DeviceApprovalToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceApprovalToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceApprovalToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceApprovalToken deviceToken.
         * @member {Tokens.IDeviceToken|null|undefined} deviceToken
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.deviceToken = null;

        /**
         * DeviceApprovalToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         */
        DeviceApprovalToken.prototype.supportedLanguage = 0;

        /**
         * Creates a new DeviceApprovalToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken=} [properties] Properties to set
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken instance
         */
        DeviceApprovalToken.create = function create(properties) {
            return new DeviceApprovalToken(properties);
        };

        /**
         * Encodes the specified DeviceApprovalToken message. Does not implicitly {@link Tokens.DeviceApprovalToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken} message DeviceApprovalToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.creation);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.Tokens.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            return writer;
        };

        /**
         * Encodes the specified DeviceApprovalToken message, length delimited. Does not implicitly {@link Tokens.DeviceApprovalToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.IDeviceApprovalToken} message DeviceApprovalToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceApprovalToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceApprovalToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeviceApprovalToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.creation = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.deviceToken = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceApprovalToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceApprovalToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceApprovalToken message.
         * @function verify
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceApprovalToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.Tokens.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeviceApprovalToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeviceApprovalToken} DeviceApprovalToken
         */
        DeviceApprovalToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeviceApprovalToken)
                return object;
            let message = new $root.Tokens.DeviceApprovalToken();
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".Tokens.DeviceApprovalToken.deviceToken: object expected");
                message.deviceToken = $root.Tokens.DeviceToken.fromObject(object.deviceToken);
            }
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeviceApprovalToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeviceApprovalToken
         * @static
         * @param {Tokens.DeviceApprovalToken} message DeviceApprovalToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceApprovalToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.deviceToken = null;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
            }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.Tokens.DeviceToken.toObject(message.deviceToken, options);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            return object;
        };

        /**
         * Converts this DeviceApprovalToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeviceApprovalToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceApprovalToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceApprovalToken;
    })();

    Tokens.TwoFactorToken = (function() {

        /**
         * Properties of a TwoFactorToken.
         * @memberof Tokens
         * @interface ITwoFactorToken
         * @property {number|Long|null} [creation] TwoFactorToken creation
         * @property {number|Long|null} [expiration] TwoFactorToken expiration
         * @property {Tokens.IDeviceToken|null} [deviceToken] TwoFactorToken deviceToken
         * @property {string|null} [deviceIp] TwoFactorToken deviceIp
         */

        /**
         * Constructs a new TwoFactorToken.
         * @memberof Tokens
         * @classdesc Represents a TwoFactorToken.
         * @implements ITwoFactorToken
         * @constructor
         * @param {Tokens.ITwoFactorToken=} [properties] Properties to set
         */
        function TwoFactorToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TwoFactorToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TwoFactorToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TwoFactorToken deviceToken.
         * @member {Tokens.IDeviceToken|null|undefined} deviceToken
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.deviceToken = null;

        /**
         * TwoFactorToken deviceIp.
         * @member {string} deviceIp
         * @memberof Tokens.TwoFactorToken
         * @instance
         */
        TwoFactorToken.prototype.deviceIp = "";

        /**
         * Creates a new TwoFactorToken instance using the specified properties.
         * @function create
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken=} [properties] Properties to set
         * @returns {Tokens.TwoFactorToken} TwoFactorToken instance
         */
        TwoFactorToken.create = function create(properties) {
            return new TwoFactorToken(properties);
        };

        /**
         * Encodes the specified TwoFactorToken message. Does not implicitly {@link Tokens.TwoFactorToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken} message TwoFactorToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.creation);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                $root.Tokens.DeviceToken.encode(message.deviceToken, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deviceIp);
            return writer;
        };

        /**
         * Encodes the specified TwoFactorToken message, length delimited. Does not implicitly {@link Tokens.TwoFactorToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.ITwoFactorToken} message TwoFactorToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TwoFactorToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TwoFactorToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.TwoFactorToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.creation = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.deviceToken = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.deviceIp = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TwoFactorToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TwoFactorToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TwoFactorToken message.
         * @function verify
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TwoFactorToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken")) {
                let error = $root.Tokens.DeviceToken.verify(message.deviceToken);
                if (error)
                    return "deviceToken." + error;
            }
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                if (!$util.isString(message.deviceIp))
                    return "deviceIp: string expected";
            return null;
        };

        /**
         * Creates a TwoFactorToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.TwoFactorToken} TwoFactorToken
         */
        TwoFactorToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.TwoFactorToken)
                return object;
            let message = new $root.Tokens.TwoFactorToken();
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.deviceToken != null) {
                if (typeof object.deviceToken !== "object")
                    throw TypeError(".Tokens.TwoFactorToken.deviceToken: object expected");
                message.deviceToken = $root.Tokens.DeviceToken.fromObject(object.deviceToken);
            }
            if (object.deviceIp != null)
                message.deviceIp = String(object.deviceIp);
            return message;
        };

        /**
         * Creates a plain object from a TwoFactorToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.TwoFactorToken
         * @static
         * @param {Tokens.TwoFactorToken} message TwoFactorToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TwoFactorToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.deviceToken = null;
                object.deviceIp = "";
            }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.deviceToken != null && message.hasOwnProperty("deviceToken"))
                object.deviceToken = $root.Tokens.DeviceToken.toObject(message.deviceToken, options);
            if (message.deviceIp != null && message.hasOwnProperty("deviceIp"))
                object.deviceIp = message.deviceIp;
            return object;
        };

        /**
         * Converts this TwoFactorToken to JSON.
         * @function toJSON
         * @memberof Tokens.TwoFactorToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TwoFactorToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TwoFactorToken;
    })();

    Tokens.BreachWatchToken = (function() {

        /**
         * Properties of a BreachWatchToken.
         * @memberof Tokens
         * @interface IBreachWatchToken
         * @property {number|null} [userId] BreachWatchToken userId
         * @property {Uint8Array|null} [domainUid] BreachWatchToken domainUid
         * @property {Uint8Array|null} [emailUid] BreachWatchToken emailUid
         * @property {Uint8Array|null} [passwordUid] BreachWatchToken passwordUid
         */

        /**
         * Constructs a new BreachWatchToken.
         * @memberof Tokens
         * @classdesc Represents a BreachWatchToken.
         * @implements IBreachWatchToken
         * @constructor
         * @param {Tokens.IBreachWatchToken=} [properties] Properties to set
         */
        function BreachWatchToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BreachWatchToken userId.
         * @member {number} userId
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.userId = 0;

        /**
         * BreachWatchToken domainUid.
         * @member {Uint8Array} domainUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.domainUid = $util.newBuffer([]);

        /**
         * BreachWatchToken emailUid.
         * @member {Uint8Array} emailUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.emailUid = $util.newBuffer([]);

        /**
         * BreachWatchToken passwordUid.
         * @member {Uint8Array} passwordUid
         * @memberof Tokens.BreachWatchToken
         * @instance
         */
        BreachWatchToken.prototype.passwordUid = $util.newBuffer([]);

        /**
         * Creates a new BreachWatchToken instance using the specified properties.
         * @function create
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken=} [properties] Properties to set
         * @returns {Tokens.BreachWatchToken} BreachWatchToken instance
         */
        BreachWatchToken.create = function create(properties) {
            return new BreachWatchToken(properties);
        };

        /**
         * Encodes the specified BreachWatchToken message. Does not implicitly {@link Tokens.BreachWatchToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken} message BreachWatchToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.domainUid);
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.emailUid);
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.passwordUid);
            return writer;
        };

        /**
         * Encodes the specified BreachWatchToken message, length delimited. Does not implicitly {@link Tokens.BreachWatchToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.IBreachWatchToken} message BreachWatchToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BreachWatchToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BreachWatchToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.BreachWatchToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.domainUid = reader.bytes();
                    break;
                case 3:
                    message.emailUid = reader.bytes();
                    break;
                case 4:
                    message.passwordUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BreachWatchToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BreachWatchToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BreachWatchToken message.
         * @function verify
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BreachWatchToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                if (!(message.domainUid && typeof message.domainUid.length === "number" || $util.isString(message.domainUid)))
                    return "domainUid: buffer expected";
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                if (!(message.emailUid && typeof message.emailUid.length === "number" || $util.isString(message.emailUid)))
                    return "emailUid: buffer expected";
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                if (!(message.passwordUid && typeof message.passwordUid.length === "number" || $util.isString(message.passwordUid)))
                    return "passwordUid: buffer expected";
            return null;
        };

        /**
         * Creates a BreachWatchToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.BreachWatchToken} BreachWatchToken
         */
        BreachWatchToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.BreachWatchToken)
                return object;
            let message = new $root.Tokens.BreachWatchToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.domainUid != null)
                if (typeof object.domainUid === "string")
                    $util.base64.decode(object.domainUid, message.domainUid = $util.newBuffer($util.base64.length(object.domainUid)), 0);
                else if (object.domainUid.length)
                    message.domainUid = object.domainUid;
            if (object.emailUid != null)
                if (typeof object.emailUid === "string")
                    $util.base64.decode(object.emailUid, message.emailUid = $util.newBuffer($util.base64.length(object.emailUid)), 0);
                else if (object.emailUid.length)
                    message.emailUid = object.emailUid;
            if (object.passwordUid != null)
                if (typeof object.passwordUid === "string")
                    $util.base64.decode(object.passwordUid, message.passwordUid = $util.newBuffer($util.base64.length(object.passwordUid)), 0);
                else if (object.passwordUid.length)
                    message.passwordUid = object.passwordUid;
            return message;
        };

        /**
         * Creates a plain object from a BreachWatchToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.BreachWatchToken
         * @static
         * @param {Tokens.BreachWatchToken} message BreachWatchToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BreachWatchToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                if (options.bytes === String)
                    object.domainUid = "";
                else {
                    object.domainUid = [];
                    if (options.bytes !== Array)
                        object.domainUid = $util.newBuffer(object.domainUid);
                }
                if (options.bytes === String)
                    object.emailUid = "";
                else {
                    object.emailUid = [];
                    if (options.bytes !== Array)
                        object.emailUid = $util.newBuffer(object.emailUid);
                }
                if (options.bytes === String)
                    object.passwordUid = "";
                else {
                    object.passwordUid = [];
                    if (options.bytes !== Array)
                        object.passwordUid = $util.newBuffer(object.passwordUid);
                }
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.domainUid != null && message.hasOwnProperty("domainUid"))
                object.domainUid = options.bytes === String ? $util.base64.encode(message.domainUid, 0, message.domainUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.domainUid) : message.domainUid;
            if (message.emailUid != null && message.hasOwnProperty("emailUid"))
                object.emailUid = options.bytes === String ? $util.base64.encode(message.emailUid, 0, message.emailUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.emailUid) : message.emailUid;
            if (message.passwordUid != null && message.hasOwnProperty("passwordUid"))
                object.passwordUid = options.bytes === String ? $util.base64.encode(message.passwordUid, 0, message.passwordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.passwordUid) : message.passwordUid;
            return object;
        };

        /**
         * Converts this BreachWatchToken to JSON.
         * @function toJSON
         * @memberof Tokens.BreachWatchToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BreachWatchToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BreachWatchToken;
    })();

    /**
     * AnonymizedTokenType enum.
     * @name Tokens.AnonymizedTokenType
     * @enum {string}
     * @property {number} DAT=0 DAT value
     * @property {number} EAT=1 EAT value
     * @property {number} PAT=2 PAT value
     */
    Tokens.AnonymizedTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DAT"] = 0;
        values[valuesById[1] = "EAT"] = 1;
        values[valuesById[2] = "PAT"] = 2;
        return values;
    })();

    Tokens.AnonymizedToken = (function() {

        /**
         * Properties of an AnonymizedToken.
         * @memberof Tokens
         * @interface IAnonymizedToken
         * @property {number|Long|null} [created] AnonymizedToken created
         * @property {number|Long|null} [expiration] AnonymizedToken expiration
         * @property {Uint8Array|null} [uid] AnonymizedToken uid
         * @property {Tokens.AnonymizedTokenType|null} [anonymizedTokenType] AnonymizedToken anonymizedTokenType
         */

        /**
         * Constructs a new AnonymizedToken.
         * @memberof Tokens
         * @classdesc Represents an AnonymizedToken.
         * @implements IAnonymizedToken
         * @constructor
         * @param {Tokens.IAnonymizedToken=} [properties] Properties to set
         */
        function AnonymizedToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnonymizedToken created.
         * @member {number|Long} created
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnonymizedToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AnonymizedToken uid.
         * @member {Uint8Array} uid
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.uid = $util.newBuffer([]);

        /**
         * AnonymizedToken anonymizedTokenType.
         * @member {Tokens.AnonymizedTokenType} anonymizedTokenType
         * @memberof Tokens.AnonymizedToken
         * @instance
         */
        AnonymizedToken.prototype.anonymizedTokenType = 0;

        /**
         * Creates a new AnonymizedToken instance using the specified properties.
         * @function create
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken=} [properties] Properties to set
         * @returns {Tokens.AnonymizedToken} AnonymizedToken instance
         */
        AnonymizedToken.create = function create(properties) {
            return new AnonymizedToken(properties);
        };

        /**
         * Encodes the specified AnonymizedToken message. Does not implicitly {@link Tokens.AnonymizedToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken} message AnonymizedToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.uid != null && message.hasOwnProperty("uid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.uid);
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.anonymizedTokenType);
            return writer;
        };

        /**
         * Encodes the specified AnonymizedToken message, length delimited. Does not implicitly {@link Tokens.AnonymizedToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.IAnonymizedToken} message AnonymizedToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AnonymizedToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AnonymizedToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.AnonymizedToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.uid = reader.bytes();
                    break;
                case 4:
                    message.anonymizedTokenType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AnonymizedToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AnonymizedToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AnonymizedToken message.
         * @function verify
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnonymizedToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!(message.uid && typeof message.uid.length === "number" || $util.isString(message.uid)))
                    return "uid: buffer expected";
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                switch (message.anonymizedTokenType) {
                default:
                    return "anonymizedTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an AnonymizedToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.AnonymizedToken} AnonymizedToken
         */
        AnonymizedToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.AnonymizedToken)
                return object;
            let message = new $root.Tokens.AnonymizedToken();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.uid != null)
                if (typeof object.uid === "string")
                    $util.base64.decode(object.uid, message.uid = $util.newBuffer($util.base64.length(object.uid)), 0);
                else if (object.uid.length)
                    message.uid = object.uid;
            switch (object.anonymizedTokenType) {
            case "DAT":
            case 0:
                message.anonymizedTokenType = 0;
                break;
            case "EAT":
            case 1:
                message.anonymizedTokenType = 1;
                break;
            case "PAT":
            case 2:
                message.anonymizedTokenType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AnonymizedToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.AnonymizedToken
         * @static
         * @param {Tokens.AnonymizedToken} message AnonymizedToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnonymizedToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.uid = "";
                else {
                    object.uid = [];
                    if (options.bytes !== Array)
                        object.uid = $util.newBuffer(object.uid);
                }
                object.anonymizedTokenType = options.enums === String ? "DAT" : 0;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = options.bytes === String ? $util.base64.encode(message.uid, 0, message.uid.length) : options.bytes === Array ? Array.prototype.slice.call(message.uid) : message.uid;
            if (message.anonymizedTokenType != null && message.hasOwnProperty("anonymizedTokenType"))
                object.anonymizedTokenType = options.enums === String ? $root.Tokens.AnonymizedTokenType[message.anonymizedTokenType] : message.anonymizedTokenType;
            return object;
        };

        /**
         * Converts this AnonymizedToken to JSON.
         * @function toJSON
         * @memberof Tokens.AnonymizedToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnonymizedToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnonymizedToken;
    })();

    Tokens.LicenseToken = (function() {

        /**
         * Properties of a LicenseToken.
         * @memberof Tokens
         * @interface ILicenseToken
         * @property {number|Long|null} [expiration] LicenseToken expiration
         * @property {Authentication.LicenseStatus|null} [licenseStatus] LicenseToken licenseStatus
         */

        /**
         * Constructs a new LicenseToken.
         * @memberof Tokens
         * @classdesc Represents a LicenseToken.
         * @implements ILicenseToken
         * @constructor
         * @param {Tokens.ILicenseToken=} [properties] Properties to set
         */
        function LicenseToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LicenseToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.LicenseToken
         * @instance
         */
        LicenseToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LicenseToken licenseStatus.
         * @member {Authentication.LicenseStatus} licenseStatus
         * @memberof Tokens.LicenseToken
         * @instance
         */
        LicenseToken.prototype.licenseStatus = 0;

        /**
         * Creates a new LicenseToken instance using the specified properties.
         * @function create
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken=} [properties] Properties to set
         * @returns {Tokens.LicenseToken} LicenseToken instance
         */
        LicenseToken.create = function create(properties) {
            return new LicenseToken(properties);
        };

        /**
         * Encodes the specified LicenseToken message. Does not implicitly {@link Tokens.LicenseToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken} message LicenseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LicenseToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.licenseStatus);
            return writer;
        };

        /**
         * Encodes the specified LicenseToken message, length delimited. Does not implicitly {@link Tokens.LicenseToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.ILicenseToken} message LicenseToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LicenseToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LicenseToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.LicenseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.LicenseToken} LicenseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LicenseToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.LicenseToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.licenseStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LicenseToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.LicenseToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.LicenseToken} LicenseToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LicenseToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LicenseToken message.
         * @function verify
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LicenseToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                switch (message.licenseStatus) {
                default:
                    return "licenseStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a LicenseToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.LicenseToken} LicenseToken
         */
        LicenseToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.LicenseToken)
                return object;
            let message = new $root.Tokens.LicenseToken();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            switch (object.licenseStatus) {
            case "OTHER":
            case 0:
                message.licenseStatus = 0;
                break;
            case "ACTIVE":
            case 1:
                message.licenseStatus = 1;
                break;
            case "EXPIRED":
            case 2:
                message.licenseStatus = 2;
                break;
            case "DISABLED":
            case 3:
                message.licenseStatus = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LicenseToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.LicenseToken
         * @static
         * @param {Tokens.LicenseToken} message LicenseToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LicenseToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.licenseStatus = options.enums === String ? "OTHER" : 0;
            }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.licenseStatus != null && message.hasOwnProperty("licenseStatus"))
                object.licenseStatus = options.enums === String ? $root.Authentication.LicenseStatus[message.licenseStatus] : message.licenseStatus;
            return object;
        };

        /**
         * Converts this LicenseToken to JSON.
         * @function toJSON
         * @memberof Tokens.LicenseToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LicenseToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LicenseToken;
    })();

    /**
     * AccessType enum.
     * @name Tokens.AccessType
     * @enum {string}
     * @property {number} VAULT_RW=0 VAULT_RW value
     * @property {number} VAULT_RO=1 VAULT_RO value
     * @property {number} ADMIN=2 ADMIN value
     */
    Tokens.AccessType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "VAULT_RW"] = 0;
        values[valuesById[1] = "VAULT_RO"] = 1;
        values[valuesById[2] = "ADMIN"] = 2;
        return values;
    })();

    Tokens.SessionToken = (function() {

        /**
         * Properties of a SessionToken.
         * @memberof Tokens
         * @interface ISessionToken
         * @property {number|Long|null} [created] SessionToken created
         * @property {number|Long|null} [expiration] SessionToken expiration
         * @property {string|null} [du1] SessionToken du1
         * @property {Uint8Array|null} [messageSessionUid] SessionToken messageSessionUid
         * @property {Tokens.IDeviceToken|null} [du8] SessionToken du8
         * @property {number|null} [fromUserId] SessionToken fromUserId
         * @property {number|null} [forUserId] SessionToken forUserId
         * @property {number|Long|null} [enterpriseUserId] SessionToken enterpriseUserId
         * @property {Tokens.ILicenseToken|null} [du2] SessionToken du2
         * @property {Tokens.ILicenseToken|null} [du3] SessionToken du3
         * @property {Tokens.ILicenseToken|null} [du4] SessionToken du4
         * @property {Tokens.ILicenseToken|null} [du5] SessionToken du5
         * @property {Authentication.AccountType|null} [du6] SessionToken du6
         * @property {number|null} [clientVersionId] SessionToken clientVersionId
         * @property {Authentication.SessionTokenType|null} [sessionTokenType] SessionToken sessionTokenType
         * @property {number|null} [mcEnterpriseId] SessionToken mcEnterpriseId
         * @property {boolean|null} [du7] SessionToken du7
         * @property {number|Long|null} [deviceId] SessionToken deviceId
         * @property {number|Long|null} [loginSessionId] SessionToken loginSessionId
         */

        /**
         * Constructs a new SessionToken.
         * @memberof Tokens
         * @classdesc Represents a SessionToken.
         * @implements ISessionToken
         * @constructor
         * @param {Tokens.ISessionToken=} [properties] Properties to set
         */
        function SessionToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SessionToken created.
         * @member {number|Long} created
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.created = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken du1.
         * @member {string} du1
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du1 = "";

        /**
         * SessionToken messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * SessionToken du8.
         * @member {Tokens.IDeviceToken|null|undefined} du8
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du8 = null;

        /**
         * SessionToken fromUserId.
         * @member {number} fromUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.fromUserId = 0;

        /**
         * SessionToken forUserId.
         * @member {number} forUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.forUserId = 0;

        /**
         * SessionToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken du2.
         * @member {Tokens.ILicenseToken|null|undefined} du2
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du2 = null;

        /**
         * SessionToken du3.
         * @member {Tokens.ILicenseToken|null|undefined} du3
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du3 = null;

        /**
         * SessionToken du4.
         * @member {Tokens.ILicenseToken|null|undefined} du4
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du4 = null;

        /**
         * SessionToken du5.
         * @member {Tokens.ILicenseToken|null|undefined} du5
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du5 = null;

        /**
         * SessionToken du6.
         * @member {Authentication.AccountType} du6
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du6 = 0;

        /**
         * SessionToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.clientVersionId = 0;

        /**
         * SessionToken sessionTokenType.
         * @member {Authentication.SessionTokenType} sessionTokenType
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.sessionTokenType = 0;

        /**
         * SessionToken mcEnterpriseId.
         * @member {number} mcEnterpriseId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.mcEnterpriseId = 0;

        /**
         * SessionToken du7.
         * @member {boolean} du7
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.du7 = false;

        /**
         * SessionToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SessionToken loginSessionId.
         * @member {number|Long} loginSessionId
         * @memberof Tokens.SessionToken
         * @instance
         */
        SessionToken.prototype.loginSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SessionToken instance using the specified properties.
         * @function create
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken=} [properties] Properties to set
         * @returns {Tokens.SessionToken} SessionToken instance
         */
        SessionToken.create = function create(properties) {
            return new SessionToken(properties);
        };

        /**
         * Encodes the specified SessionToken message. Does not implicitly {@link Tokens.SessionToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.created != null && message.hasOwnProperty("created"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.created);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            if (message.du1 != null && message.hasOwnProperty("du1"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.du1);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.messageSessionUid);
            if (message.du8 != null && message.hasOwnProperty("du8"))
                $root.Tokens.DeviceToken.encode(message.du8, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fromUserId);
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.forUserId);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.enterpriseUserId);
            if (message.du2 != null && message.hasOwnProperty("du2"))
                $root.Tokens.LicenseToken.encode(message.du2, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.du3 != null && message.hasOwnProperty("du3"))
                $root.Tokens.LicenseToken.encode(message.du3, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.du4 != null && message.hasOwnProperty("du4"))
                $root.Tokens.LicenseToken.encode(message.du4, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.du6 != null && message.hasOwnProperty("du6"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.du6);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.clientVersionId);
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.sessionTokenType);
            if (message.du5 != null && message.hasOwnProperty("du5"))
                $root.Tokens.LicenseToken.encode(message.du5, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.mcEnterpriseId);
            if (message.du7 != null && message.hasOwnProperty("du7"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message.du7);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.deviceId);
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.loginSessionId);
            return writer;
        };

        /**
         * Encodes the specified SessionToken message, length delimited. Does not implicitly {@link Tokens.SessionToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.ISessionToken} message SessionToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.SessionToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.created = reader.int64();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                case 3:
                    message.du1 = reader.string();
                    break;
                case 4:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 5:
                    message.du8 = $root.Tokens.DeviceToken.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.fromUserId = reader.int32();
                    break;
                case 7:
                    message.forUserId = reader.int32();
                    break;
                case 8:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 9:
                    message.du2 = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.du3 = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.du4 = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.du5 = $root.Tokens.LicenseToken.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.du6 = reader.int32();
                    break;
                case 13:
                    message.clientVersionId = reader.int32();
                    break;
                case 14:
                    message.sessionTokenType = reader.int32();
                    break;
                case 16:
                    message.mcEnterpriseId = reader.int32();
                    break;
                case 17:
                    message.du7 = reader.bool();
                    break;
                case 18:
                    message.deviceId = reader.int64();
                    break;
                case 19:
                    message.loginSessionId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SessionToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.SessionToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.SessionToken} SessionToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SessionToken message.
         * @function verify
         * @memberof Tokens.SessionToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SessionToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.created != null && message.hasOwnProperty("created"))
                if (!$util.isInteger(message.created) && !(message.created && $util.isInteger(message.created.low) && $util.isInteger(message.created.high)))
                    return "created: integer|Long expected";
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            if (message.du1 != null && message.hasOwnProperty("du1"))
                if (!$util.isString(message.du1))
                    return "du1: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.du8 != null && message.hasOwnProperty("du8")) {
                let error = $root.Tokens.DeviceToken.verify(message.du8);
                if (error)
                    return "du8." + error;
            }
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                if (!$util.isInteger(message.fromUserId))
                    return "fromUserId: integer expected";
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                if (!$util.isInteger(message.forUserId))
                    return "forUserId: integer expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.du2 != null && message.hasOwnProperty("du2")) {
                let error = $root.Tokens.LicenseToken.verify(message.du2);
                if (error)
                    return "du2." + error;
            }
            if (message.du3 != null && message.hasOwnProperty("du3")) {
                let error = $root.Tokens.LicenseToken.verify(message.du3);
                if (error)
                    return "du3." + error;
            }
            if (message.du4 != null && message.hasOwnProperty("du4")) {
                let error = $root.Tokens.LicenseToken.verify(message.du4);
                if (error)
                    return "du4." + error;
            }
            if (message.du5 != null && message.hasOwnProperty("du5")) {
                let error = $root.Tokens.LicenseToken.verify(message.du5);
                if (error)
                    return "du5." + error;
            }
            if (message.du6 != null && message.hasOwnProperty("du6"))
                switch (message.du6) {
                default:
                    return "du6: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                switch (message.sessionTokenType) {
                default:
                    return "sessionTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                if (!$util.isInteger(message.mcEnterpriseId))
                    return "mcEnterpriseId: integer expected";
            if (message.du7 != null && message.hasOwnProperty("du7"))
                if (typeof message.du7 !== "boolean")
                    return "du7: boolean expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                if (!$util.isInteger(message.loginSessionId) && !(message.loginSessionId && $util.isInteger(message.loginSessionId.low) && $util.isInteger(message.loginSessionId.high)))
                    return "loginSessionId: integer|Long expected";
            return null;
        };

        /**
         * Creates a SessionToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.SessionToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.SessionToken} SessionToken
         */
        SessionToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.SessionToken)
                return object;
            let message = new $root.Tokens.SessionToken();
            if (object.created != null)
                if ($util.Long)
                    (message.created = $util.Long.fromValue(object.created)).unsigned = false;
                else if (typeof object.created === "string")
                    message.created = parseInt(object.created, 10);
                else if (typeof object.created === "number")
                    message.created = object.created;
                else if (typeof object.created === "object")
                    message.created = new $util.LongBits(object.created.low >>> 0, object.created.high >>> 0).toNumber();
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            if (object.du1 != null)
                message.du1 = String(object.du1);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.du8 != null) {
                if (typeof object.du8 !== "object")
                    throw TypeError(".Tokens.SessionToken.du8: object expected");
                message.du8 = $root.Tokens.DeviceToken.fromObject(object.du8);
            }
            if (object.fromUserId != null)
                message.fromUserId = object.fromUserId | 0;
            if (object.forUserId != null)
                message.forUserId = object.forUserId | 0;
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.du2 != null) {
                if (typeof object.du2 !== "object")
                    throw TypeError(".Tokens.SessionToken.du2: object expected");
                message.du2 = $root.Tokens.LicenseToken.fromObject(object.du2);
            }
            if (object.du3 != null) {
                if (typeof object.du3 !== "object")
                    throw TypeError(".Tokens.SessionToken.du3: object expected");
                message.du3 = $root.Tokens.LicenseToken.fromObject(object.du3);
            }
            if (object.du4 != null) {
                if (typeof object.du4 !== "object")
                    throw TypeError(".Tokens.SessionToken.du4: object expected");
                message.du4 = $root.Tokens.LicenseToken.fromObject(object.du4);
            }
            if (object.du5 != null) {
                if (typeof object.du5 !== "object")
                    throw TypeError(".Tokens.SessionToken.du5: object expected");
                message.du5 = $root.Tokens.LicenseToken.fromObject(object.du5);
            }
            switch (object.du6) {
            case "CONSUMER":
            case 0:
                message.du6 = 0;
                break;
            case "FAMILY":
            case 1:
                message.du6 = 1;
                break;
            case "ENTERPRISE":
            case 2:
                message.du6 = 2;
                break;
            }
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            switch (object.sessionTokenType) {
            case "NO_RESTRICTION":
            case 0:
                message.sessionTokenType = 0;
                break;
            case "ACCOUNT_RECOVERY":
            case 1:
                message.sessionTokenType = 1;
                break;
            case "SHARE_ACCOUNT":
            case 2:
                message.sessionTokenType = 2;
                break;
            case "PURCHASE":
            case 3:
                message.sessionTokenType = 3;
                break;
            case "RESTRICT":
            case 4:
                message.sessionTokenType = 4;
                break;
            case "ACCEPT_INVITE":
            case 5:
                message.sessionTokenType = 5;
                break;
            case "SUPPORT_SERVER":
            case 6:
                message.sessionTokenType = 6;
                break;
            case "ENTERPRISE_CREATION":
            case 7:
                message.sessionTokenType = 7;
                break;
            case "EXPIRED_BUT_ALLOWED_TO_SYNC":
            case 8:
                message.sessionTokenType = 8;
                break;
            }
            if (object.mcEnterpriseId != null)
                message.mcEnterpriseId = object.mcEnterpriseId | 0;
            if (object.du7 != null)
                message.du7 = Boolean(object.du7);
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.loginSessionId != null)
                if ($util.Long)
                    (message.loginSessionId = $util.Long.fromValue(object.loginSessionId)).unsigned = false;
                else if (typeof object.loginSessionId === "string")
                    message.loginSessionId = parseInt(object.loginSessionId, 10);
                else if (typeof object.loginSessionId === "number")
                    message.loginSessionId = object.loginSessionId;
                else if (typeof object.loginSessionId === "object")
                    message.loginSessionId = new $util.LongBits(object.loginSessionId.low >>> 0, object.loginSessionId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SessionToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.SessionToken
         * @static
         * @param {Tokens.SessionToken} message SessionToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.created = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.created = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
                object.du1 = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.du8 = null;
                object.fromUserId = 0;
                object.forUserId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.du2 = null;
                object.du3 = null;
                object.du4 = null;
                object.du6 = options.enums === String ? "CONSUMER" : 0;
                object.clientVersionId = 0;
                object.sessionTokenType = options.enums === String ? "NO_RESTRICTION" : 0;
                object.du5 = null;
                object.mcEnterpriseId = 0;
                object.du7 = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.loginSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.loginSessionId = options.longs === String ? "0" : 0;
            }
            if (message.created != null && message.hasOwnProperty("created"))
                if (typeof message.created === "number")
                    object.created = options.longs === String ? String(message.created) : message.created;
                else
                    object.created = options.longs === String ? $util.Long.prototype.toString.call(message.created) : options.longs === Number ? new $util.LongBits(message.created.low >>> 0, message.created.high >>> 0).toNumber() : message.created;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            if (message.du1 != null && message.hasOwnProperty("du1"))
                object.du1 = message.du1;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.du8 != null && message.hasOwnProperty("du8"))
                object.du8 = $root.Tokens.DeviceToken.toObject(message.du8, options);
            if (message.fromUserId != null && message.hasOwnProperty("fromUserId"))
                object.fromUserId = message.fromUserId;
            if (message.forUserId != null && message.hasOwnProperty("forUserId"))
                object.forUserId = message.forUserId;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.du2 != null && message.hasOwnProperty("du2"))
                object.du2 = $root.Tokens.LicenseToken.toObject(message.du2, options);
            if (message.du3 != null && message.hasOwnProperty("du3"))
                object.du3 = $root.Tokens.LicenseToken.toObject(message.du3, options);
            if (message.du4 != null && message.hasOwnProperty("du4"))
                object.du4 = $root.Tokens.LicenseToken.toObject(message.du4, options);
            if (message.du6 != null && message.hasOwnProperty("du6"))
                object.du6 = options.enums === String ? $root.Authentication.AccountType[message.du6] : message.du6;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            if (message.sessionTokenType != null && message.hasOwnProperty("sessionTokenType"))
                object.sessionTokenType = options.enums === String ? $root.Authentication.SessionTokenType[message.sessionTokenType] : message.sessionTokenType;
            if (message.du5 != null && message.hasOwnProperty("du5"))
                object.du5 = $root.Tokens.LicenseToken.toObject(message.du5, options);
            if (message.mcEnterpriseId != null && message.hasOwnProperty("mcEnterpriseId"))
                object.mcEnterpriseId = message.mcEnterpriseId;
            if (message.du7 != null && message.hasOwnProperty("du7"))
                object.du7 = message.du7;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.loginSessionId != null && message.hasOwnProperty("loginSessionId"))
                if (typeof message.loginSessionId === "number")
                    object.loginSessionId = options.longs === String ? String(message.loginSessionId) : message.loginSessionId;
                else
                    object.loginSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.loginSessionId) : options.longs === Number ? new $util.LongBits(message.loginSessionId.low >>> 0, message.loginSessionId.high >>> 0).toNumber() : message.loginSessionId;
            return object;
        };

        /**
         * Converts this SessionToken to JSON.
         * @function toJSON
         * @memberof Tokens.SessionToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SessionToken;
    })();

    Tokens.UserLicenseStatus = (function() {

        /**
         * Properties of a UserLicenseStatus.
         * @memberof Tokens
         * @interface IUserLicenseStatus
         * @property {Authentication.LicenseType|null} [licenseType] UserLicenseStatus licenseType
         * @property {number|Long|null} [expiration] UserLicenseStatus expiration
         */

        /**
         * Constructs a new UserLicenseStatus.
         * @memberof Tokens
         * @classdesc Represents a UserLicenseStatus.
         * @implements IUserLicenseStatus
         * @constructor
         * @param {Tokens.IUserLicenseStatus=} [properties] Properties to set
         */
        function UserLicenseStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserLicenseStatus licenseType.
         * @member {Authentication.LicenseType} licenseType
         * @memberof Tokens.UserLicenseStatus
         * @instance
         */
        UserLicenseStatus.prototype.licenseType = 0;

        /**
         * UserLicenseStatus expiration.
         * @member {number|Long} expiration
         * @memberof Tokens.UserLicenseStatus
         * @instance
         */
        UserLicenseStatus.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserLicenseStatus instance using the specified properties.
         * @function create
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Tokens.IUserLicenseStatus=} [properties] Properties to set
         * @returns {Tokens.UserLicenseStatus} UserLicenseStatus instance
         */
        UserLicenseStatus.create = function create(properties) {
            return new UserLicenseStatus(properties);
        };

        /**
         * Encodes the specified UserLicenseStatus message. Does not implicitly {@link Tokens.UserLicenseStatus.verify|verify} messages.
         * @function encode
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Tokens.IUserLicenseStatus} message UserLicenseStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserLicenseStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.licenseType != null && message.hasOwnProperty("licenseType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.licenseType);
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expiration);
            return writer;
        };

        /**
         * Encodes the specified UserLicenseStatus message, length delimited. Does not implicitly {@link Tokens.UserLicenseStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Tokens.IUserLicenseStatus} message UserLicenseStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserLicenseStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserLicenseStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.UserLicenseStatus} UserLicenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserLicenseStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.UserLicenseStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.licenseType = reader.int32();
                    break;
                case 2:
                    message.expiration = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserLicenseStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.UserLicenseStatus} UserLicenseStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserLicenseStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserLicenseStatus message.
         * @function verify
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserLicenseStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.licenseType != null && message.hasOwnProperty("licenseType"))
                switch (message.licenseType) {
                default:
                    return "licenseType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                    return "expiration: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserLicenseStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.UserLicenseStatus} UserLicenseStatus
         */
        UserLicenseStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.UserLicenseStatus)
                return object;
            let message = new $root.Tokens.UserLicenseStatus();
            switch (object.licenseType) {
            case "VAULT":
            case 0:
                message.licenseType = 0;
                break;
            case "CHAT":
            case 1:
                message.licenseType = 1;
                break;
            case "STORAGE":
            case 2:
                message.licenseType = 2;
                break;
            case "BREACHWATCH":
            case 3:
                message.licenseType = 3;
                break;
            }
            if (object.expiration != null)
                if ($util.Long)
                    (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                else if (typeof object.expiration === "string")
                    message.expiration = parseInt(object.expiration, 10);
                else if (typeof object.expiration === "number")
                    message.expiration = object.expiration;
                else if (typeof object.expiration === "object")
                    message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserLicenseStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.UserLicenseStatus
         * @static
         * @param {Tokens.UserLicenseStatus} message UserLicenseStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserLicenseStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.licenseType = options.enums === String ? "VAULT" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration = options.longs === String ? "0" : 0;
            }
            if (message.licenseType != null && message.hasOwnProperty("licenseType"))
                object.licenseType = options.enums === String ? $root.Authentication.LicenseType[message.licenseType] : message.licenseType;
            if (message.expiration != null && message.hasOwnProperty("expiration"))
                if (typeof message.expiration === "number")
                    object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                else
                    object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
            return object;
        };

        /**
         * Converts this UserLicenseStatus to JSON.
         * @function toJSON
         * @memberof Tokens.UserLicenseStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserLicenseStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserLicenseStatus;
    })();

    Tokens.CheckOutTokenResponse = (function() {

        /**
         * Properties of a CheckOutTokenResponse.
         * @memberof Tokens
         * @interface ICheckOutTokenResponse
         * @property {string|null} [checkOutToken] CheckOutTokenResponse checkOutToken
         */

        /**
         * Constructs a new CheckOutTokenResponse.
         * @memberof Tokens
         * @classdesc Represents a CheckOutTokenResponse.
         * @implements ICheckOutTokenResponse
         * @constructor
         * @param {Tokens.ICheckOutTokenResponse=} [properties] Properties to set
         */
        function CheckOutTokenResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CheckOutTokenResponse checkOutToken.
         * @member {string} checkOutToken
         * @memberof Tokens.CheckOutTokenResponse
         * @instance
         */
        CheckOutTokenResponse.prototype.checkOutToken = "";

        /**
         * Creates a new CheckOutTokenResponse instance using the specified properties.
         * @function create
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse=} [properties] Properties to set
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse instance
         */
        CheckOutTokenResponse.create = function create(properties) {
            return new CheckOutTokenResponse(properties);
        };

        /**
         * Encodes the specified CheckOutTokenResponse message. Does not implicitly {@link Tokens.CheckOutTokenResponse.verify|verify} messages.
         * @function encode
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse} message CheckOutTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckOutTokenResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.checkOutToken);
            return writer;
        };

        /**
         * Encodes the specified CheckOutTokenResponse message, length delimited. Does not implicitly {@link Tokens.CheckOutTokenResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.ICheckOutTokenResponse} message CheckOutTokenResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CheckOutTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CheckOutTokenResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckOutTokenResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.CheckOutTokenResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.checkOutToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CheckOutTokenResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CheckOutTokenResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CheckOutTokenResponse message.
         * @function verify
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CheckOutTokenResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                if (!$util.isString(message.checkOutToken))
                    return "checkOutToken: string expected";
            return null;
        };

        /**
         * Creates a CheckOutTokenResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.CheckOutTokenResponse} CheckOutTokenResponse
         */
        CheckOutTokenResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.CheckOutTokenResponse)
                return object;
            let message = new $root.Tokens.CheckOutTokenResponse();
            if (object.checkOutToken != null)
                message.checkOutToken = String(object.checkOutToken);
            return message;
        };

        /**
         * Creates a plain object from a CheckOutTokenResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.CheckOutTokenResponse
         * @static
         * @param {Tokens.CheckOutTokenResponse} message CheckOutTokenResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CheckOutTokenResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.checkOutToken = "";
            if (message.checkOutToken != null && message.hasOwnProperty("checkOutToken"))
                object.checkOutToken = message.checkOutToken;
            return object;
        };

        /**
         * Converts this CheckOutTokenResponse to JSON.
         * @function toJSON
         * @memberof Tokens.CheckOutTokenResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CheckOutTokenResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CheckOutTokenResponse;
    })();

    Tokens.ImporterToken = (function() {

        /**
         * Properties of an ImporterToken.
         * @memberof Tokens
         * @interface IImporterToken
         * @property {number|null} [importId] ImporterToken importId
         * @property {number|null} [userId] ImporterToken userId
         * @property {string|null} [region] ImporterToken region
         */

        /**
         * Constructs a new ImporterToken.
         * @memberof Tokens
         * @classdesc Represents an ImporterToken.
         * @implements IImporterToken
         * @constructor
         * @param {Tokens.IImporterToken=} [properties] Properties to set
         */
        function ImporterToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImporterToken importId.
         * @member {number} importId
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.importId = 0;

        /**
         * ImporterToken userId.
         * @member {number} userId
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.userId = 0;

        /**
         * ImporterToken region.
         * @member {string} region
         * @memberof Tokens.ImporterToken
         * @instance
         */
        ImporterToken.prototype.region = "";

        /**
         * Creates a new ImporterToken instance using the specified properties.
         * @function create
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken=} [properties] Properties to set
         * @returns {Tokens.ImporterToken} ImporterToken instance
         */
        ImporterToken.create = function create(properties) {
            return new ImporterToken(properties);
        };

        /**
         * Encodes the specified ImporterToken message. Does not implicitly {@link Tokens.ImporterToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken} message ImporterToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImporterToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.importId != null && message.hasOwnProperty("importId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.importId);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            if (message.region != null && message.hasOwnProperty("region"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.region);
            return writer;
        };

        /**
         * Encodes the specified ImporterToken message, length delimited. Does not implicitly {@link Tokens.ImporterToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.IImporterToken} message ImporterToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImporterToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImporterToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ImporterToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ImporterToken} ImporterToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImporterToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ImporterToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.importId = reader.int32();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                case 3:
                    message.region = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImporterToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ImporterToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ImporterToken} ImporterToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImporterToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImporterToken message.
         * @function verify
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImporterToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.importId != null && message.hasOwnProperty("importId"))
                if (!$util.isInteger(message.importId))
                    return "importId: integer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isString(message.region))
                    return "region: string expected";
            return null;
        };

        /**
         * Creates an ImporterToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ImporterToken} ImporterToken
         */
        ImporterToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ImporterToken)
                return object;
            let message = new $root.Tokens.ImporterToken();
            if (object.importId != null)
                message.importId = object.importId | 0;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.region != null)
                message.region = String(object.region);
            return message;
        };

        /**
         * Creates a plain object from an ImporterToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ImporterToken
         * @static
         * @param {Tokens.ImporterToken} message ImporterToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImporterToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.importId = 0;
                object.userId = 0;
                object.region = "";
            }
            if (message.importId != null && message.hasOwnProperty("importId"))
                object.importId = message.importId;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            return object;
        };

        /**
         * Converts this ImporterToken to JSON.
         * @function toJSON
         * @memberof Tokens.ImporterToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImporterToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImporterToken;
    })();

    Tokens.ApiDecryptedRequest = (function() {

        /**
         * Properties of an ApiDecryptedRequest.
         * @memberof Tokens
         * @interface IApiDecryptedRequest
         * @property {Uint8Array|null} [decryptedTransmissionKey] ApiDecryptedRequest decryptedTransmissionKey
         * @property {Authentication.IApiRequestPayload|null} [apiRequestPayload] ApiDecryptedRequest apiRequestPayload
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] ApiDecryptedRequest supportedLanguage
         * @property {string|null} [recaptcha] ApiDecryptedRequest recaptcha
         * @property {string|null} [userAgent] ApiDecryptedRequest userAgent
         * @property {string|null} [subEnvironment] ApiDecryptedRequest subEnvironment
         */

        /**
         * Constructs a new ApiDecryptedRequest.
         * @memberof Tokens
         * @classdesc Represents an ApiDecryptedRequest.
         * @implements IApiDecryptedRequest
         * @constructor
         * @param {Tokens.IApiDecryptedRequest=} [properties] Properties to set
         */
        function ApiDecryptedRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApiDecryptedRequest decryptedTransmissionKey.
         * @member {Uint8Array} decryptedTransmissionKey
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.decryptedTransmissionKey = $util.newBuffer([]);

        /**
         * ApiDecryptedRequest apiRequestPayload.
         * @member {Authentication.IApiRequestPayload|null|undefined} apiRequestPayload
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.apiRequestPayload = null;

        /**
         * ApiDecryptedRequest supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.supportedLanguage = 0;

        /**
         * ApiDecryptedRequest recaptcha.
         * @member {string} recaptcha
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.recaptcha = "";

        /**
         * ApiDecryptedRequest userAgent.
         * @member {string} userAgent
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.userAgent = "";

        /**
         * ApiDecryptedRequest subEnvironment.
         * @member {string} subEnvironment
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         */
        ApiDecryptedRequest.prototype.subEnvironment = "";

        /**
         * Creates a new ApiDecryptedRequest instance using the specified properties.
         * @function create
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest=} [properties] Properties to set
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest instance
         */
        ApiDecryptedRequest.create = function create(properties) {
            return new ApiDecryptedRequest(properties);
        };

        /**
         * Encodes the specified ApiDecryptedRequest message. Does not implicitly {@link Tokens.ApiDecryptedRequest.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest} message ApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiDecryptedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.decryptedTransmissionKey);
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload"))
                $root.Authentication.ApiRequestPayload.encode(message.apiRequestPayload, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.recaptcha);
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.userAgent);
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.subEnvironment);
            return writer;
        };

        /**
         * Encodes the specified ApiDecryptedRequest message, length delimited. Does not implicitly {@link Tokens.ApiDecryptedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.IApiDecryptedRequest} message ApiDecryptedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApiDecryptedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApiDecryptedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiDecryptedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ApiDecryptedRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.decryptedTransmissionKey = reader.bytes();
                    break;
                case 3:
                    message.apiRequestPayload = $root.Authentication.ApiRequestPayload.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                case 5:
                    message.recaptcha = reader.string();
                    break;
                case 6:
                    message.userAgent = reader.string();
                    break;
                case 7:
                    message.subEnvironment = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApiDecryptedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApiDecryptedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApiDecryptedRequest message.
         * @function verify
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApiDecryptedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                if (!(message.decryptedTransmissionKey && typeof message.decryptedTransmissionKey.length === "number" || $util.isString(message.decryptedTransmissionKey)))
                    return "decryptedTransmissionKey: buffer expected";
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload")) {
                let error = $root.Authentication.ApiRequestPayload.verify(message.apiRequestPayload);
                if (error)
                    return "apiRequestPayload." + error;
            }
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                if (!$util.isString(message.recaptcha))
                    return "recaptcha: string expected";
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                if (!$util.isString(message.userAgent))
                    return "userAgent: string expected";
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                if (!$util.isString(message.subEnvironment))
                    return "subEnvironment: string expected";
            return null;
        };

        /**
         * Creates an ApiDecryptedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ApiDecryptedRequest} ApiDecryptedRequest
         */
        ApiDecryptedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ApiDecryptedRequest)
                return object;
            let message = new $root.Tokens.ApiDecryptedRequest();
            if (object.decryptedTransmissionKey != null)
                if (typeof object.decryptedTransmissionKey === "string")
                    $util.base64.decode(object.decryptedTransmissionKey, message.decryptedTransmissionKey = $util.newBuffer($util.base64.length(object.decryptedTransmissionKey)), 0);
                else if (object.decryptedTransmissionKey.length)
                    message.decryptedTransmissionKey = object.decryptedTransmissionKey;
            if (object.apiRequestPayload != null) {
                if (typeof object.apiRequestPayload !== "object")
                    throw TypeError(".Tokens.ApiDecryptedRequest.apiRequestPayload: object expected");
                message.apiRequestPayload = $root.Authentication.ApiRequestPayload.fromObject(object.apiRequestPayload);
            }
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.recaptcha != null)
                message.recaptcha = String(object.recaptcha);
            if (object.userAgent != null)
                message.userAgent = String(object.userAgent);
            if (object.subEnvironment != null)
                message.subEnvironment = String(object.subEnvironment);
            return message;
        };

        /**
         * Creates a plain object from an ApiDecryptedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ApiDecryptedRequest
         * @static
         * @param {Tokens.ApiDecryptedRequest} message ApiDecryptedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ApiDecryptedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.decryptedTransmissionKey = "";
                else {
                    object.decryptedTransmissionKey = [];
                    if (options.bytes !== Array)
                        object.decryptedTransmissionKey = $util.newBuffer(object.decryptedTransmissionKey);
                }
                object.apiRequestPayload = null;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.recaptcha = "";
                object.userAgent = "";
                object.subEnvironment = "";
            }
            if (message.decryptedTransmissionKey != null && message.hasOwnProperty("decryptedTransmissionKey"))
                object.decryptedTransmissionKey = options.bytes === String ? $util.base64.encode(message.decryptedTransmissionKey, 0, message.decryptedTransmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.decryptedTransmissionKey) : message.decryptedTransmissionKey;
            if (message.apiRequestPayload != null && message.hasOwnProperty("apiRequestPayload"))
                object.apiRequestPayload = $root.Authentication.ApiRequestPayload.toObject(message.apiRequestPayload, options);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.recaptcha != null && message.hasOwnProperty("recaptcha"))
                object.recaptcha = message.recaptcha;
            if (message.userAgent != null && message.hasOwnProperty("userAgent"))
                object.userAgent = message.userAgent;
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                object.subEnvironment = message.subEnvironment;
            return object;
        };

        /**
         * Converts this ApiDecryptedRequest to JSON.
         * @function toJSON
         * @memberof Tokens.ApiDecryptedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ApiDecryptedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ApiDecryptedRequest;
    })();

    Tokens.ChangeEmailToken = (function() {

        /**
         * Properties of a ChangeEmailToken.
         * @memberof Tokens
         * @interface IChangeEmailToken
         * @property {number|null} [userId] ChangeEmailToken userId
         * @property {string|null} [newEmail] ChangeEmailToken newEmail
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] ChangeEmailToken supportedLanguage
         * @property {number|Long|null} [enterpriseUserId] ChangeEmailToken enterpriseUserId
         * @property {number|Long|null} [creation] ChangeEmailToken creation
         * @property {number|null} [clientVersionId] ChangeEmailToken clientVersionId
         */

        /**
         * Constructs a new ChangeEmailToken.
         * @memberof Tokens
         * @classdesc Represents a ChangeEmailToken.
         * @implements IChangeEmailToken
         * @constructor
         * @param {Tokens.IChangeEmailToken=} [properties] Properties to set
         */
        function ChangeEmailToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeEmailToken userId.
         * @member {number} userId
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.userId = 0;

        /**
         * ChangeEmailToken newEmail.
         * @member {string} newEmail
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.newEmail = "";

        /**
         * ChangeEmailToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.supportedLanguage = 0;

        /**
         * ChangeEmailToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChangeEmailToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChangeEmailToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof Tokens.ChangeEmailToken
         * @instance
         */
        ChangeEmailToken.prototype.clientVersionId = 0;

        /**
         * Creates a new ChangeEmailToken instance using the specified properties.
         * @function create
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken=} [properties] Properties to set
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken instance
         */
        ChangeEmailToken.create = function create(properties) {
            return new ChangeEmailToken(properties);
        };

        /**
         * Encodes the specified ChangeEmailToken message. Does not implicitly {@link Tokens.ChangeEmailToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken} message ChangeEmailToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.newEmail);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.supportedLanguage);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.enterpriseUserId);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.creation);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.clientVersionId);
            return writer;
        };

        /**
         * Encodes the specified ChangeEmailToken message, length delimited. Does not implicitly {@link Tokens.ChangeEmailToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.IChangeEmailToken} message ChangeEmailToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeEmailToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeEmailToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ChangeEmailToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.newEmail = reader.string();
                    break;
                case 3:
                    message.supportedLanguage = reader.int32();
                    break;
                case 4:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 5:
                    message.creation = reader.int64();
                    break;
                case 6:
                    message.clientVersionId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeEmailToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeEmailToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeEmailToken message.
         * @function verify
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeEmailToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                if (!$util.isString(message.newEmail))
                    return "newEmail: string expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            return null;
        };

        /**
         * Creates a ChangeEmailToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ChangeEmailToken} ChangeEmailToken
         */
        ChangeEmailToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ChangeEmailToken)
                return object;
            let message = new $root.Tokens.ChangeEmailToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.newEmail != null)
                message.newEmail = String(object.newEmail);
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            return message;
        };

        /**
         * Creates a plain object from a ChangeEmailToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ChangeEmailToken
         * @static
         * @param {Tokens.ChangeEmailToken} message ChangeEmailToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangeEmailToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.newEmail = "";
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                object.clientVersionId = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.newEmail != null && message.hasOwnProperty("newEmail"))
                object.newEmail = message.newEmail;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            return object;
        };

        /**
         * Converts this ChangeEmailToken to JSON.
         * @function toJSON
         * @memberof Tokens.ChangeEmailToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangeEmailToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangeEmailToken;
    })();

    Tokens.EmailVerificationToken = (function() {

        /**
         * Properties of an EmailVerificationToken.
         * @memberof Tokens
         * @interface IEmailVerificationToken
         * @property {number|null} [userId] EmailVerificationToken userId
         * @property {string|null} [email] EmailVerificationToken email
         * @property {string|null} [du1] EmailVerificationToken du1
         * @property {number|Long|null} [enterpriseUserId] EmailVerificationToken enterpriseUserId
         * @property {number|Long|null} [du2] EmailVerificationToken du2
         */

        /**
         * Constructs a new EmailVerificationToken.
         * @memberof Tokens
         * @classdesc Represents an EmailVerificationToken.
         * @implements IEmailVerificationToken
         * @constructor
         * @param {Tokens.IEmailVerificationToken=} [properties] Properties to set
         */
        function EmailVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmailVerificationToken userId.
         * @member {number} userId
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.userId = 0;

        /**
         * EmailVerificationToken email.
         * @member {string} email
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.email = "";

        /**
         * EmailVerificationToken du1.
         * @member {string} du1
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.du1 = "";

        /**
         * EmailVerificationToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EmailVerificationToken du2.
         * @member {number|Long} du2
         * @memberof Tokens.EmailVerificationToken
         * @instance
         */
        EmailVerificationToken.prototype.du2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EmailVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken=} [properties] Properties to set
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken instance
         */
        EmailVerificationToken.create = function create(properties) {
            return new EmailVerificationToken(properties);
        };

        /**
         * Encodes the specified EmailVerificationToken message. Does not implicitly {@link Tokens.EmailVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken} message EmailVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.du1 != null && message.hasOwnProperty("du1"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.du1);
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.enterpriseUserId);
            if (message.du2 != null && message.hasOwnProperty("du2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.du2);
            return writer;
        };

        /**
         * Encodes the specified EmailVerificationToken message, length delimited. Does not implicitly {@link Tokens.EmailVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.IEmailVerificationToken} message EmailVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmailVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmailVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.EmailVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.du1 = reader.string();
                    break;
                case 4:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 5:
                    message.du2 = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmailVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmailVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmailVerificationToken message.
         * @function verify
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmailVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.du1 != null && message.hasOwnProperty("du1"))
                if (!$util.isString(message.du1))
                    return "du1: string expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.du2 != null && message.hasOwnProperty("du2"))
                if (!$util.isInteger(message.du2) && !(message.du2 && $util.isInteger(message.du2.low) && $util.isInteger(message.du2.high)))
                    return "du2: integer|Long expected";
            return null;
        };

        /**
         * Creates an EmailVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.EmailVerificationToken} EmailVerificationToken
         */
        EmailVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.EmailVerificationToken)
                return object;
            let message = new $root.Tokens.EmailVerificationToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.email != null)
                message.email = String(object.email);
            if (object.du1 != null)
                message.du1 = String(object.du1);
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.du2 != null)
                if ($util.Long)
                    (message.du2 = $util.Long.fromValue(object.du2)).unsigned = false;
                else if (typeof object.du2 === "string")
                    message.du2 = parseInt(object.du2, 10);
                else if (typeof object.du2 === "number")
                    message.du2 = object.du2;
                else if (typeof object.du2 === "object")
                    message.du2 = new $util.LongBits(object.du2.low >>> 0, object.du2.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EmailVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.EmailVerificationToken
         * @static
         * @param {Tokens.EmailVerificationToken} message EmailVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EmailVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.email = "";
                object.du1 = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.du2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.du2 = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.du1 != null && message.hasOwnProperty("du1"))
                object.du1 = message.du1;
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.du2 != null && message.hasOwnProperty("du2"))
                if (typeof message.du2 === "number")
                    object.du2 = options.longs === String ? String(message.du2) : message.du2;
                else
                    object.du2 = options.longs === String ? $util.Long.prototype.toString.call(message.du2) : options.longs === Number ? new $util.LongBits(message.du2.low >>> 0, message.du2.high >>> 0).toNumber() : message.du2;
            return object;
        };

        /**
         * Converts this EmailVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.EmailVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EmailVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EmailVerificationToken;
    })();

    Tokens.IpAddressVerificationToken = (function() {

        /**
         * Properties of an IpAddressVerificationToken.
         * @memberof Tokens
         * @interface IIpAddressVerificationToken
         * @property {number|null} [userId] IpAddressVerificationToken userId
         * @property {string|null} [email] IpAddressVerificationToken email
         * @property {number|Long|null} [ssoServiceProviderId] IpAddressVerificationToken ssoServiceProviderId
         * @property {string|null} [ipAddress] IpAddressVerificationToken ipAddress
         * @property {string|null} [du1] IpAddressVerificationToken du1
         * @property {number|Long|null} [du2] IpAddressVerificationToken du2
         * @property {number|null} [enterpriseId] IpAddressVerificationToken enterpriseId
         * @property {number|Long|null} [deviceId] IpAddressVerificationToken deviceId
         */

        /**
         * Constructs a new IpAddressVerificationToken.
         * @memberof Tokens
         * @classdesc Represents an IpAddressVerificationToken.
         * @implements IIpAddressVerificationToken
         * @constructor
         * @param {Tokens.IIpAddressVerificationToken=} [properties] Properties to set
         */
        function IpAddressVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IpAddressVerificationToken userId.
         * @member {number} userId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.userId = 0;

        /**
         * IpAddressVerificationToken email.
         * @member {string} email
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.email = "";

        /**
         * IpAddressVerificationToken ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpAddressVerificationToken ipAddress.
         * @member {string} ipAddress
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.ipAddress = "";

        /**
         * IpAddressVerificationToken du1.
         * @member {string} du1
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.du1 = "";

        /**
         * IpAddressVerificationToken du2.
         * @member {number|Long} du2
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.du2 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * IpAddressVerificationToken enterpriseId.
         * @member {number} enterpriseId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.enterpriseId = 0;

        /**
         * IpAddressVerificationToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         */
        IpAddressVerificationToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new IpAddressVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken=} [properties] Properties to set
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken instance
         */
        IpAddressVerificationToken.create = function create(properties) {
            return new IpAddressVerificationToken(properties);
        };

        /**
         * Encodes the specified IpAddressVerificationToken message. Does not implicitly {@link Tokens.IpAddressVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken} message IpAddressVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpAddressVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ssoServiceProviderId);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ipAddress);
            if (message.du1 != null && message.hasOwnProperty("du1"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.du1);
            if (message.du2 != null && message.hasOwnProperty("du2"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.du2);
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.enterpriseId);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.deviceId);
            return writer;
        };

        /**
         * Encodes the specified IpAddressVerificationToken message, length delimited. Does not implicitly {@link Tokens.IpAddressVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IIpAddressVerificationToken} message IpAddressVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IpAddressVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IpAddressVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpAddressVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.IpAddressVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userId = reader.int32();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.ssoServiceProviderId = reader.int64();
                    break;
                case 4:
                    message.ipAddress = reader.string();
                    break;
                case 5:
                    message.du1 = reader.string();
                    break;
                case 6:
                    message.du2 = reader.int64();
                    break;
                case 7:
                    message.enterpriseId = reader.int32();
                    break;
                case 8:
                    message.deviceId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IpAddressVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IpAddressVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IpAddressVerificationToken message.
         * @function verify
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IpAddressVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            if (message.du1 != null && message.hasOwnProperty("du1"))
                if (!$util.isString(message.du1))
                    return "du1: string expected";
            if (message.du2 != null && message.hasOwnProperty("du2"))
                if (!$util.isInteger(message.du2) && !(message.du2 && $util.isInteger(message.du2.low) && $util.isInteger(message.du2.high)))
                    return "du2: integer|Long expected";
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (!$util.isInteger(message.enterpriseId))
                    return "enterpriseId: integer expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            return null;
        };

        /**
         * Creates an IpAddressVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.IpAddressVerificationToken} IpAddressVerificationToken
         */
        IpAddressVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.IpAddressVerificationToken)
                return object;
            let message = new $root.Tokens.IpAddressVerificationToken();
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.email != null)
                message.email = String(object.email);
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = false;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber();
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            if (object.du1 != null)
                message.du1 = String(object.du1);
            if (object.du2 != null)
                if ($util.Long)
                    (message.du2 = $util.Long.fromValue(object.du2)).unsigned = false;
                else if (typeof object.du2 === "string")
                    message.du2 = parseInt(object.du2, 10);
                else if (typeof object.du2 === "number")
                    message.du2 = object.du2;
                else if (typeof object.du2 === "object")
                    message.du2 = new $util.LongBits(object.du2.low >>> 0, object.du2.high >>> 0).toNumber();
            if (object.enterpriseId != null)
                message.enterpriseId = object.enterpriseId | 0;
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an IpAddressVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.IpAddressVerificationToken
         * @static
         * @param {Tokens.IpAddressVerificationToken} message IpAddressVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IpAddressVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = 0;
                object.email = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                object.ipAddress = "";
                object.du1 = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.du2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.du2 = options.longs === String ? "0" : 0;
                object.enterpriseId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber() : message.ssoServiceProviderId;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            if (message.du1 != null && message.hasOwnProperty("du1"))
                object.du1 = message.du1;
            if (message.du2 != null && message.hasOwnProperty("du2"))
                if (typeof message.du2 === "number")
                    object.du2 = options.longs === String ? String(message.du2) : message.du2;
                else
                    object.du2 = options.longs === String ? $util.Long.prototype.toString.call(message.du2) : options.longs === Number ? new $util.LongBits(message.du2.low >>> 0, message.du2.high >>> 0).toNumber() : message.du2;
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                object.enterpriseId = message.enterpriseId;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            return object;
        };

        /**
         * Converts this IpAddressVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.IpAddressVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IpAddressVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IpAddressVerificationToken;
    })();

    Tokens.EnterprisePersonalAccountToken = (function() {

        /**
         * Properties of an EnterprisePersonalAccountToken.
         * @memberof Tokens
         * @interface IEnterprisePersonalAccountToken
         * @property {number|Long|null} [enterpriseUserId] EnterprisePersonalAccountToken enterpriseUserId
         * @property {string|null} [email] EnterprisePersonalAccountToken email
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] EnterprisePersonalAccountToken supportedLanguage
         * @property {number|Long|null} [duration] EnterprisePersonalAccountToken duration
         * @property {string|null} [referralName] EnterprisePersonalAccountToken referralName
         * @property {number|Long|null} [creation] EnterprisePersonalAccountToken creation
         */

        /**
         * Constructs a new EnterprisePersonalAccountToken.
         * @memberof Tokens
         * @classdesc Represents an EnterprisePersonalAccountToken.
         * @implements IEnterprisePersonalAccountToken
         * @constructor
         * @param {Tokens.IEnterprisePersonalAccountToken=} [properties] Properties to set
         */
        function EnterprisePersonalAccountToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterprisePersonalAccountToken enterpriseUserId.
         * @member {number|Long} enterpriseUserId
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.enterpriseUserId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterprisePersonalAccountToken email.
         * @member {string} email
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.email = "";

        /**
         * EnterprisePersonalAccountToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.supportedLanguage = 0;

        /**
         * EnterprisePersonalAccountToken duration.
         * @member {number|Long} duration
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnterprisePersonalAccountToken referralName.
         * @member {string} referralName
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.referralName = "";

        /**
         * EnterprisePersonalAccountToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         */
        EnterprisePersonalAccountToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EnterprisePersonalAccountToken instance using the specified properties.
         * @function create
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken=} [properties] Properties to set
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken instance
         */
        EnterprisePersonalAccountToken.create = function create(properties) {
            return new EnterprisePersonalAccountToken(properties);
        };

        /**
         * Encodes the specified EnterprisePersonalAccountToken message. Does not implicitly {@link Tokens.EnterprisePersonalAccountToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken} message EnterprisePersonalAccountToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccountToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.enterpriseUserId);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.email);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.supportedLanguage);
            if (message.duration != null && message.hasOwnProperty("duration"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.duration);
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.referralName);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.creation);
            return writer;
        };

        /**
         * Encodes the specified EnterprisePersonalAccountToken message, length delimited. Does not implicitly {@link Tokens.EnterprisePersonalAccountToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.IEnterprisePersonalAccountToken} message EnterprisePersonalAccountToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterprisePersonalAccountToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterprisePersonalAccountToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccountToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.EnterprisePersonalAccountToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseUserId = reader.int64();
                    break;
                case 2:
                    message.email = reader.string();
                    break;
                case 3:
                    message.supportedLanguage = reader.int32();
                    break;
                case 4:
                    message.duration = reader.int64();
                    break;
                case 5:
                    message.referralName = reader.string();
                    break;
                case 6:
                    message.creation = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterprisePersonalAccountToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterprisePersonalAccountToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterprisePersonalAccountToken message.
         * @function verify
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterprisePersonalAccountToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (!$util.isInteger(message.enterpriseUserId) && !(message.enterpriseUserId && $util.isInteger(message.enterpriseUserId.low) && $util.isInteger(message.enterpriseUserId.high)))
                    return "enterpriseUserId: integer|Long expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (!$util.isInteger(message.duration) && !(message.duration && $util.isInteger(message.duration.low) && $util.isInteger(message.duration.high)))
                    return "duration: integer|Long expected";
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                if (!$util.isString(message.referralName))
                    return "referralName: string expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            return null;
        };

        /**
         * Creates an EnterprisePersonalAccountToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.EnterprisePersonalAccountToken} EnterprisePersonalAccountToken
         */
        EnterprisePersonalAccountToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.EnterprisePersonalAccountToken)
                return object;
            let message = new $root.Tokens.EnterprisePersonalAccountToken();
            if (object.enterpriseUserId != null)
                if ($util.Long)
                    (message.enterpriseUserId = $util.Long.fromValue(object.enterpriseUserId)).unsigned = false;
                else if (typeof object.enterpriseUserId === "string")
                    message.enterpriseUserId = parseInt(object.enterpriseUserId, 10);
                else if (typeof object.enterpriseUserId === "number")
                    message.enterpriseUserId = object.enterpriseUserId;
                else if (typeof object.enterpriseUserId === "object")
                    message.enterpriseUserId = new $util.LongBits(object.enterpriseUserId.low >>> 0, object.enterpriseUserId.high >>> 0).toNumber();
            if (object.email != null)
                message.email = String(object.email);
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.duration != null)
                if ($util.Long)
                    (message.duration = $util.Long.fromValue(object.duration)).unsigned = false;
                else if (typeof object.duration === "string")
                    message.duration = parseInt(object.duration, 10);
                else if (typeof object.duration === "number")
                    message.duration = object.duration;
                else if (typeof object.duration === "object")
                    message.duration = new $util.LongBits(object.duration.low >>> 0, object.duration.high >>> 0).toNumber();
            if (object.referralName != null)
                message.referralName = String(object.referralName);
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EnterprisePersonalAccountToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @static
         * @param {Tokens.EnterprisePersonalAccountToken} message EnterprisePersonalAccountToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnterprisePersonalAccountToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.enterpriseUserId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseUserId = options.longs === String ? "0" : 0;
                object.email = "";
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.duration = options.longs === String ? "0" : 0;
                object.referralName = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
            }
            if (message.enterpriseUserId != null && message.hasOwnProperty("enterpriseUserId"))
                if (typeof message.enterpriseUserId === "number")
                    object.enterpriseUserId = options.longs === String ? String(message.enterpriseUserId) : message.enterpriseUserId;
                else
                    object.enterpriseUserId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseUserId) : options.longs === Number ? new $util.LongBits(message.enterpriseUserId.low >>> 0, message.enterpriseUserId.high >>> 0).toNumber() : message.enterpriseUserId;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.duration != null && message.hasOwnProperty("duration"))
                if (typeof message.duration === "number")
                    object.duration = options.longs === String ? String(message.duration) : message.duration;
                else
                    object.duration = options.longs === String ? $util.Long.prototype.toString.call(message.duration) : options.longs === Number ? new $util.LongBits(message.duration.low >>> 0, message.duration.high >>> 0).toNumber() : message.duration;
            if (message.referralName != null && message.hasOwnProperty("referralName"))
                object.referralName = message.referralName;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            return object;
        };

        /**
         * Converts this EnterprisePersonalAccountToken to JSON.
         * @function toJSON
         * @memberof Tokens.EnterprisePersonalAccountToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnterprisePersonalAccountToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnterprisePersonalAccountToken;
    })();

    Tokens.UsernameVerificationToken = (function() {

        /**
         * Properties of a UsernameVerificationToken.
         * @memberof Tokens
         * @interface IUsernameVerificationToken
         * @property {string|null} [username] UsernameVerificationToken username
         * @property {Uint8Array|null} [accountUid] UsernameVerificationToken accountUid
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] UsernameVerificationToken supportedLanguage
         * @property {number|Long|null} [creation] UsernameVerificationToken creation
         * @property {number|null} [clientVersionId] UsernameVerificationToken clientVersionId
         */

        /**
         * Constructs a new UsernameVerificationToken.
         * @memberof Tokens
         * @classdesc Represents a UsernameVerificationToken.
         * @implements IUsernameVerificationToken
         * @constructor
         * @param {Tokens.IUsernameVerificationToken=} [properties] Properties to set
         */
        function UsernameVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UsernameVerificationToken username.
         * @member {string} username
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         */
        UsernameVerificationToken.prototype.username = "";

        /**
         * UsernameVerificationToken accountUid.
         * @member {Uint8Array} accountUid
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         */
        UsernameVerificationToken.prototype.accountUid = $util.newBuffer([]);

        /**
         * UsernameVerificationToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         */
        UsernameVerificationToken.prototype.supportedLanguage = 0;

        /**
         * UsernameVerificationToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         */
        UsernameVerificationToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UsernameVerificationToken clientVersionId.
         * @member {number} clientVersionId
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         */
        UsernameVerificationToken.prototype.clientVersionId = 0;

        /**
         * Creates a new UsernameVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Tokens.IUsernameVerificationToken=} [properties] Properties to set
         * @returns {Tokens.UsernameVerificationToken} UsernameVerificationToken instance
         */
        UsernameVerificationToken.create = function create(properties) {
            return new UsernameVerificationToken(properties);
        };

        /**
         * Encodes the specified UsernameVerificationToken message. Does not implicitly {@link Tokens.UsernameVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Tokens.IUsernameVerificationToken} message UsernameVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.username);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountUid);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.supportedLanguage);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.creation);
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.clientVersionId);
            return writer;
        };

        /**
         * Encodes the specified UsernameVerificationToken message, length delimited. Does not implicitly {@link Tokens.UsernameVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Tokens.IUsernameVerificationToken} message UsernameVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UsernameVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UsernameVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.UsernameVerificationToken} UsernameVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.UsernameVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.username = reader.string();
                    break;
                case 2:
                    message.accountUid = reader.bytes();
                    break;
                case 3:
                    message.supportedLanguage = reader.int32();
                    break;
                case 4:
                    message.creation = reader.int64();
                    break;
                case 5:
                    message.clientVersionId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UsernameVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.UsernameVerificationToken} UsernameVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UsernameVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UsernameVerificationToken message.
         * @function verify
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UsernameVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                if (!$util.isInteger(message.clientVersionId))
                    return "clientVersionId: integer expected";
            return null;
        };

        /**
         * Creates a UsernameVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.UsernameVerificationToken} UsernameVerificationToken
         */
        UsernameVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.UsernameVerificationToken)
                return object;
            let message = new $root.Tokens.UsernameVerificationToken();
            if (object.username != null)
                message.username = String(object.username);
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.clientVersionId != null)
                message.clientVersionId = object.clientVersionId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UsernameVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.UsernameVerificationToken
         * @static
         * @param {Tokens.UsernameVerificationToken} message UsernameVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UsernameVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.username = "";
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                object.clientVersionId = 0;
            }
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.clientVersionId != null && message.hasOwnProperty("clientVersionId"))
                object.clientVersionId = message.clientVersionId;
            return object;
        };

        /**
         * Converts this UsernameVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.UsernameVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UsernameVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UsernameVerificationToken;
    })();

    Tokens.DeviceVerificationToken = (function() {

        /**
         * Properties of a DeviceVerificationToken.
         * @memberof Tokens
         * @interface IDeviceVerificationToken
         * @property {number|Long|null} [deviceId] DeviceVerificationToken deviceId
         * @property {string|null} [username] DeviceVerificationToken username
         * @property {Uint8Array|null} [accountUid] DeviceVerificationToken accountUid
         * @property {string|null} [clientVersion] DeviceVerificationToken clientVersion
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] DeviceVerificationToken supportedLanguage
         * @property {number|Long|null} [creation] DeviceVerificationToken creation
         * @property {Uint8Array|null} [messageSessionUid] DeviceVerificationToken messageSessionUid
         * @property {string|null} [ipAddress] DeviceVerificationToken ipAddress
         */

        /**
         * Constructs a new DeviceVerificationToken.
         * @memberof Tokens
         * @classdesc Represents a DeviceVerificationToken.
         * @implements IDeviceVerificationToken
         * @constructor
         * @param {Tokens.IDeviceVerificationToken=} [properties] Properties to set
         */
        function DeviceVerificationToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeviceVerificationToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceVerificationToken username.
         * @member {string} username
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.username = "";

        /**
         * DeviceVerificationToken accountUid.
         * @member {Uint8Array} accountUid
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.accountUid = $util.newBuffer([]);

        /**
         * DeviceVerificationToken clientVersion.
         * @member {string} clientVersion
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.clientVersion = "";

        /**
         * DeviceVerificationToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.supportedLanguage = 0;

        /**
         * DeviceVerificationToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeviceVerificationToken messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * DeviceVerificationToken ipAddress.
         * @member {string} ipAddress
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         */
        DeviceVerificationToken.prototype.ipAddress = "";

        /**
         * Creates a new DeviceVerificationToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Tokens.IDeviceVerificationToken=} [properties] Properties to set
         * @returns {Tokens.DeviceVerificationToken} DeviceVerificationToken instance
         */
        DeviceVerificationToken.create = function create(properties) {
            return new DeviceVerificationToken(properties);
        };

        /**
         * Encodes the specified DeviceVerificationToken message. Does not implicitly {@link Tokens.DeviceVerificationToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Tokens.IDeviceVerificationToken} message DeviceVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.deviceId);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.accountUid);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.clientVersion);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.supportedLanguage);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.creation);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.messageSessionUid);
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.ipAddress);
            return writer;
        };

        /**
         * Encodes the specified DeviceVerificationToken message, length delimited. Does not implicitly {@link Tokens.DeviceVerificationToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Tokens.IDeviceVerificationToken} message DeviceVerificationToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeviceVerificationToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeviceVerificationToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeviceVerificationToken} DeviceVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeviceVerificationToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.deviceId = reader.int64();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.accountUid = reader.bytes();
                    break;
                case 4:
                    message.clientVersion = reader.string();
                    break;
                case 5:
                    message.supportedLanguage = reader.int32();
                    break;
                case 6:
                    message.creation = reader.int64();
                    break;
                case 7:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 8:
                    message.ipAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeviceVerificationToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeviceVerificationToken} DeviceVerificationToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeviceVerificationToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeviceVerificationToken message.
         * @function verify
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeviceVerificationToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                if (!(message.accountUid && typeof message.accountUid.length === "number" || $util.isString(message.accountUid)))
                    return "accountUid: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                if (!$util.isString(message.ipAddress))
                    return "ipAddress: string expected";
            return null;
        };

        /**
         * Creates a DeviceVerificationToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeviceVerificationToken} DeviceVerificationToken
         */
        DeviceVerificationToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeviceVerificationToken)
                return object;
            let message = new $root.Tokens.DeviceVerificationToken();
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            if (object.username != null)
                message.username = String(object.username);
            if (object.accountUid != null)
                if (typeof object.accountUid === "string")
                    $util.base64.decode(object.accountUid, message.accountUid = $util.newBuffer($util.base64.length(object.accountUid)), 0);
                else if (object.accountUid.length)
                    message.accountUid = object.accountUid;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.ipAddress != null)
                message.ipAddress = String(object.ipAddress);
            return message;
        };

        /**
         * Creates a plain object from a DeviceVerificationToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeviceVerificationToken
         * @static
         * @param {Tokens.DeviceVerificationToken} message DeviceVerificationToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeviceVerificationToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
                object.username = "";
                if (options.bytes === String)
                    object.accountUid = "";
                else {
                    object.accountUid = [];
                    if (options.bytes !== Array)
                        object.accountUid = $util.newBuffer(object.accountUid);
                }
                object.clientVersion = "";
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.ipAddress = "";
            }
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                object.accountUid = options.bytes === String ? $util.base64.encode(message.accountUid, 0, message.accountUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountUid) : message.accountUid;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                object.ipAddress = message.ipAddress;
            return object;
        };

        /**
         * Converts this DeviceVerificationToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeviceVerificationToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeviceVerificationToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeviceVerificationToken;
    })();

    Tokens.CreateUserToken = (function() {

        /**
         * Properties of a CreateUserToken.
         * @memberof Tokens
         * @interface ICreateUserToken
         * @property {number|null} [createUserRequestId] CreateUserToken createUserRequestId
         * @property {string|null} [verificationCode] CreateUserToken verificationCode
         * @property {number|Long|null} [requestTimeStamp] CreateUserToken requestTimeStamp
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] CreateUserToken supportedLanguage
         * @property {string|null} [remoteAddress] CreateUserToken remoteAddress
         * @property {Uint8Array|null} [messageSessionUid] CreateUserToken messageSessionUid
         * @property {number|Long|null} [deviceId] CreateUserToken deviceId
         */

        /**
         * Constructs a new CreateUserToken.
         * @memberof Tokens
         * @classdesc Represents a CreateUserToken.
         * @implements ICreateUserToken
         * @constructor
         * @param {Tokens.ICreateUserToken=} [properties] Properties to set
         */
        function CreateUserToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateUserToken createUserRequestId.
         * @member {number} createUserRequestId
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.createUserRequestId = 0;

        /**
         * CreateUserToken verificationCode.
         * @member {string} verificationCode
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.verificationCode = "";

        /**
         * CreateUserToken requestTimeStamp.
         * @member {number|Long} requestTimeStamp
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.requestTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateUserToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.supportedLanguage = 0;

        /**
         * CreateUserToken remoteAddress.
         * @member {string} remoteAddress
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.remoteAddress = "";

        /**
         * CreateUserToken messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * CreateUserToken deviceId.
         * @member {number|Long} deviceId
         * @memberof Tokens.CreateUserToken
         * @instance
         */
        CreateUserToken.prototype.deviceId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CreateUserToken instance using the specified properties.
         * @function create
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Tokens.ICreateUserToken=} [properties] Properties to set
         * @returns {Tokens.CreateUserToken} CreateUserToken instance
         */
        CreateUserToken.create = function create(properties) {
            return new CreateUserToken(properties);
        };

        /**
         * Encodes the specified CreateUserToken message. Does not implicitly {@link Tokens.CreateUserToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Tokens.ICreateUserToken} message CreateUserToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateUserToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.createUserRequestId != null && message.hasOwnProperty("createUserRequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.createUserRequestId);
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.verificationCode);
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.requestTimeStamp);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            if (message.remoteAddress != null && message.hasOwnProperty("remoteAddress"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.remoteAddress);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.messageSessionUid);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.deviceId);
            return writer;
        };

        /**
         * Encodes the specified CreateUserToken message, length delimited. Does not implicitly {@link Tokens.CreateUserToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Tokens.ICreateUserToken} message CreateUserToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateUserToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateUserToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.CreateUserToken} CreateUserToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateUserToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.CreateUserToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.createUserRequestId = reader.int32();
                    break;
                case 2:
                    message.verificationCode = reader.string();
                    break;
                case 3:
                    message.requestTimeStamp = reader.int64();
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                case 5:
                    message.remoteAddress = reader.string();
                    break;
                case 6:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 7:
                    message.deviceId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateUserToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.CreateUserToken} CreateUserToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateUserToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateUserToken message.
         * @function verify
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateUserToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.createUserRequestId != null && message.hasOwnProperty("createUserRequestId"))
                if (!$util.isInteger(message.createUserRequestId))
                    return "createUserRequestId: integer expected";
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                if (!$util.isString(message.verificationCode))
                    return "verificationCode: string expected";
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (!$util.isInteger(message.requestTimeStamp) && !(message.requestTimeStamp && $util.isInteger(message.requestTimeStamp.low) && $util.isInteger(message.requestTimeStamp.high)))
                    return "requestTimeStamp: integer|Long expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.remoteAddress != null && message.hasOwnProperty("remoteAddress"))
                if (!$util.isString(message.remoteAddress))
                    return "remoteAddress: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isInteger(message.deviceId) && !(message.deviceId && $util.isInteger(message.deviceId.low) && $util.isInteger(message.deviceId.high)))
                    return "deviceId: integer|Long expected";
            return null;
        };

        /**
         * Creates a CreateUserToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.CreateUserToken} CreateUserToken
         */
        CreateUserToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.CreateUserToken)
                return object;
            let message = new $root.Tokens.CreateUserToken();
            if (object.createUserRequestId != null)
                message.createUserRequestId = object.createUserRequestId | 0;
            if (object.verificationCode != null)
                message.verificationCode = String(object.verificationCode);
            if (object.requestTimeStamp != null)
                if ($util.Long)
                    (message.requestTimeStamp = $util.Long.fromValue(object.requestTimeStamp)).unsigned = false;
                else if (typeof object.requestTimeStamp === "string")
                    message.requestTimeStamp = parseInt(object.requestTimeStamp, 10);
                else if (typeof object.requestTimeStamp === "number")
                    message.requestTimeStamp = object.requestTimeStamp;
                else if (typeof object.requestTimeStamp === "object")
                    message.requestTimeStamp = new $util.LongBits(object.requestTimeStamp.low >>> 0, object.requestTimeStamp.high >>> 0).toNumber();
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.remoteAddress != null)
                message.remoteAddress = String(object.remoteAddress);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.deviceId != null)
                if ($util.Long)
                    (message.deviceId = $util.Long.fromValue(object.deviceId)).unsigned = false;
                else if (typeof object.deviceId === "string")
                    message.deviceId = parseInt(object.deviceId, 10);
                else if (typeof object.deviceId === "number")
                    message.deviceId = object.deviceId;
                else if (typeof object.deviceId === "object")
                    message.deviceId = new $util.LongBits(object.deviceId.low >>> 0, object.deviceId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CreateUserToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.CreateUserToken
         * @static
         * @param {Tokens.CreateUserToken} message CreateUserToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateUserToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.createUserRequestId = 0;
                object.verificationCode = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.requestTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestTimeStamp = options.longs === String ? "0" : 0;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.remoteAddress = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceId = options.longs === String ? "0" : 0;
            }
            if (message.createUserRequestId != null && message.hasOwnProperty("createUserRequestId"))
                object.createUserRequestId = message.createUserRequestId;
            if (message.verificationCode != null && message.hasOwnProperty("verificationCode"))
                object.verificationCode = message.verificationCode;
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (typeof message.requestTimeStamp === "number")
                    object.requestTimeStamp = options.longs === String ? String(message.requestTimeStamp) : message.requestTimeStamp;
                else
                    object.requestTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.requestTimeStamp) : options.longs === Number ? new $util.LongBits(message.requestTimeStamp.low >>> 0, message.requestTimeStamp.high >>> 0).toNumber() : message.requestTimeStamp;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.remoteAddress != null && message.hasOwnProperty("remoteAddress"))
                object.remoteAddress = message.remoteAddress;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (typeof message.deviceId === "number")
                    object.deviceId = options.longs === String ? String(message.deviceId) : message.deviceId;
                else
                    object.deviceId = options.longs === String ? $util.Long.prototype.toString.call(message.deviceId) : options.longs === Number ? new $util.LongBits(message.deviceId.low >>> 0, message.deviceId.high >>> 0).toNumber() : message.deviceId;
            return object;
        };

        /**
         * Converts this CreateUserToken to JSON.
         * @function toJSON
         * @memberof Tokens.CreateUserToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateUserToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateUserToken;
    })();

    Tokens.DeleteUserToken = (function() {

        /**
         * Properties of a DeleteUserToken.
         * @memberof Tokens
         * @interface IDeleteUserToken
         * @property {number|null} [userIdForDelete] DeleteUserToken userIdForDelete
         * @property {string|null} [username] DeleteUserToken username
         * @property {string|null} [reason] DeleteUserToken reason
         * @property {number|Long|null} [requestTimeStamp] DeleteUserToken requestTimeStamp
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] DeleteUserToken supportedLanguage
         */

        /**
         * Constructs a new DeleteUserToken.
         * @memberof Tokens
         * @classdesc Represents a DeleteUserToken.
         * @implements IDeleteUserToken
         * @constructor
         * @param {Tokens.IDeleteUserToken=} [properties] Properties to set
         */
        function DeleteUserToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteUserToken userIdForDelete.
         * @member {number} userIdForDelete
         * @memberof Tokens.DeleteUserToken
         * @instance
         */
        DeleteUserToken.prototype.userIdForDelete = 0;

        /**
         * DeleteUserToken username.
         * @member {string} username
         * @memberof Tokens.DeleteUserToken
         * @instance
         */
        DeleteUserToken.prototype.username = "";

        /**
         * DeleteUserToken reason.
         * @member {string} reason
         * @memberof Tokens.DeleteUserToken
         * @instance
         */
        DeleteUserToken.prototype.reason = "";

        /**
         * DeleteUserToken requestTimeStamp.
         * @member {number|Long} requestTimeStamp
         * @memberof Tokens.DeleteUserToken
         * @instance
         */
        DeleteUserToken.prototype.requestTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DeleteUserToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.DeleteUserToken
         * @instance
         */
        DeleteUserToken.prototype.supportedLanguage = 0;

        /**
         * Creates a new DeleteUserToken instance using the specified properties.
         * @function create
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Tokens.IDeleteUserToken=} [properties] Properties to set
         * @returns {Tokens.DeleteUserToken} DeleteUserToken instance
         */
        DeleteUserToken.create = function create(properties) {
            return new DeleteUserToken(properties);
        };

        /**
         * Encodes the specified DeleteUserToken message. Does not implicitly {@link Tokens.DeleteUserToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Tokens.IDeleteUserToken} message DeleteUserToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteUserToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userIdForDelete != null && message.hasOwnProperty("userIdForDelete"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.userIdForDelete);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.requestTimeStamp);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.supportedLanguage);
            return writer;
        };

        /**
         * Encodes the specified DeleteUserToken message, length delimited. Does not implicitly {@link Tokens.DeleteUserToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Tokens.IDeleteUserToken} message DeleteUserToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteUserToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteUserToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.DeleteUserToken} DeleteUserToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteUserToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.DeleteUserToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.userIdForDelete = reader.int32();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                case 4:
                    message.requestTimeStamp = reader.int64();
                    break;
                case 5:
                    message.supportedLanguage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteUserToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.DeleteUserToken} DeleteUserToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteUserToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteUserToken message.
         * @function verify
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteUserToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userIdForDelete != null && message.hasOwnProperty("userIdForDelete"))
                if (!$util.isInteger(message.userIdForDelete))
                    return "userIdForDelete: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (!$util.isInteger(message.requestTimeStamp) && !(message.requestTimeStamp && $util.isInteger(message.requestTimeStamp.low) && $util.isInteger(message.requestTimeStamp.high)))
                    return "requestTimeStamp: integer|Long expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            return null;
        };

        /**
         * Creates a DeleteUserToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.DeleteUserToken} DeleteUserToken
         */
        DeleteUserToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.DeleteUserToken)
                return object;
            let message = new $root.Tokens.DeleteUserToken();
            if (object.userIdForDelete != null)
                message.userIdForDelete = object.userIdForDelete | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.reason != null)
                message.reason = String(object.reason);
            if (object.requestTimeStamp != null)
                if ($util.Long)
                    (message.requestTimeStamp = $util.Long.fromValue(object.requestTimeStamp)).unsigned = false;
                else if (typeof object.requestTimeStamp === "string")
                    message.requestTimeStamp = parseInt(object.requestTimeStamp, 10);
                else if (typeof object.requestTimeStamp === "number")
                    message.requestTimeStamp = object.requestTimeStamp;
                else if (typeof object.requestTimeStamp === "object")
                    message.requestTimeStamp = new $util.LongBits(object.requestTimeStamp.low >>> 0, object.requestTimeStamp.high >>> 0).toNumber();
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DeleteUserToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.DeleteUserToken
         * @static
         * @param {Tokens.DeleteUserToken} message DeleteUserToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteUserToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userIdForDelete = 0;
                object.username = "";
                object.reason = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.requestTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.requestTimeStamp = options.longs === String ? "0" : 0;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
            }
            if (message.userIdForDelete != null && message.hasOwnProperty("userIdForDelete"))
                object.userIdForDelete = message.userIdForDelete;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            if (message.requestTimeStamp != null && message.hasOwnProperty("requestTimeStamp"))
                if (typeof message.requestTimeStamp === "number")
                    object.requestTimeStamp = options.longs === String ? String(message.requestTimeStamp) : message.requestTimeStamp;
                else
                    object.requestTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.requestTimeStamp) : options.longs === Number ? new $util.LongBits(message.requestTimeStamp.low >>> 0, message.requestTimeStamp.high >>> 0).toNumber() : message.requestTimeStamp;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            return object;
        };

        /**
         * Converts this DeleteUserToken to JSON.
         * @function toJSON
         * @memberof Tokens.DeleteUserToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteUserToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteUserToken;
    })();

    /**
     * ProcessTokenType enum.
     * @name Tokens.ProcessTokenType
     * @enum {string}
     * @property {number} CHANGE_EMAIL=0 CHANGE_EMAIL value
     * @property {number} EMAIL_VERIFICATION=1 EMAIL_VERIFICATION value
     * @property {number} IP_ADDRESS_VERIFICATION=2 IP_ADDRESS_VERIFICATION value
     * @property {number} USERNAME_VERIFICATION=3 USERNAME_VERIFICATION value
     * @property {number} DEVICE_VERIFICATION=4 DEVICE_VERIFICATION value
     * @property {number} CREATE_ACCOUNT_VERIFICATION=5 CREATE_ACCOUNT_VERIFICATION value
     * @property {number} REDEEM_PERSONAL_LICENSE=6 REDEEM_PERSONAL_LICENSE value
     * @property {number} DELETE_ACCOUNT_VERIFICATION=7 DELETE_ACCOUNT_VERIFICATION value
     */
    Tokens.ProcessTokenType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CHANGE_EMAIL"] = 0;
        values[valuesById[1] = "EMAIL_VERIFICATION"] = 1;
        values[valuesById[2] = "IP_ADDRESS_VERIFICATION"] = 2;
        values[valuesById[3] = "USERNAME_VERIFICATION"] = 3;
        values[valuesById[4] = "DEVICE_VERIFICATION"] = 4;
        values[valuesById[5] = "CREATE_ACCOUNT_VERIFICATION"] = 5;
        values[valuesById[6] = "REDEEM_PERSONAL_LICENSE"] = 6;
        values[valuesById[7] = "DELETE_ACCOUNT_VERIFICATION"] = 7;
        return values;
    })();

    Tokens.ProcessToken = (function() {

        /**
         * Properties of a ProcessToken.
         * @memberof Tokens
         * @interface IProcessToken
         * @property {Tokens.ProcessTokenType|null} [processTokenType] ProcessToken processTokenType
         * @property {Uint8Array|null} [payload] ProcessToken payload
         * @property {number|Long|null} [creation] ProcessToken creation
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] ProcessToken supportedLanguage
         * @property {string|null} [subEnvironment] ProcessToken subEnvironment
         */

        /**
         * Constructs a new ProcessToken.
         * @memberof Tokens
         * @classdesc Represents a ProcessToken.
         * @implements IProcessToken
         * @constructor
         * @param {Tokens.IProcessToken=} [properties] Properties to set
         */
        function ProcessToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProcessToken processTokenType.
         * @member {Tokens.ProcessTokenType} processTokenType
         * @memberof Tokens.ProcessToken
         * @instance
         */
        ProcessToken.prototype.processTokenType = 0;

        /**
         * ProcessToken payload.
         * @member {Uint8Array} payload
         * @memberof Tokens.ProcessToken
         * @instance
         */
        ProcessToken.prototype.payload = $util.newBuffer([]);

        /**
         * ProcessToken creation.
         * @member {number|Long} creation
         * @memberof Tokens.ProcessToken
         * @instance
         */
        ProcessToken.prototype.creation = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ProcessToken supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof Tokens.ProcessToken
         * @instance
         */
        ProcessToken.prototype.supportedLanguage = 0;

        /**
         * ProcessToken subEnvironment.
         * @member {string} subEnvironment
         * @memberof Tokens.ProcessToken
         * @instance
         */
        ProcessToken.prototype.subEnvironment = "";

        /**
         * Creates a new ProcessToken instance using the specified properties.
         * @function create
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Tokens.IProcessToken=} [properties] Properties to set
         * @returns {Tokens.ProcessToken} ProcessToken instance
         */
        ProcessToken.create = function create(properties) {
            return new ProcessToken(properties);
        };

        /**
         * Encodes the specified ProcessToken message. Does not implicitly {@link Tokens.ProcessToken.verify|verify} messages.
         * @function encode
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Tokens.IProcessToken} message ProcessToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessToken.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.processTokenType);
            if (message.payload != null && message.hasOwnProperty("payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
            if (message.creation != null && message.hasOwnProperty("creation"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creation);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.supportedLanguage);
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.subEnvironment);
            return writer;
        };

        /**
         * Encodes the specified ProcessToken message, length delimited. Does not implicitly {@link Tokens.ProcessToken.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Tokens.IProcessToken} message ProcessToken message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProcessToken.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProcessToken message from the specified reader or buffer.
         * @function decode
         * @memberof Tokens.ProcessToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Tokens.ProcessToken} ProcessToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Tokens.ProcessToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.processTokenType = reader.int32();
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.creation = reader.int64();
                    break;
                case 4:
                    message.supportedLanguage = reader.int32();
                    break;
                case 5:
                    message.subEnvironment = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProcessToken message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Tokens.ProcessToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Tokens.ProcessToken} ProcessToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProcessToken.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProcessToken message.
         * @function verify
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProcessToken.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                switch (message.processTokenType) {
                default:
                    return "processTokenType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                    return "payload: buffer expected";
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (!$util.isInteger(message.creation) && !(message.creation && $util.isInteger(message.creation.low) && $util.isInteger(message.creation.high)))
                    return "creation: integer|Long expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                if (!$util.isString(message.subEnvironment))
                    return "subEnvironment: string expected";
            return null;
        };

        /**
         * Creates a ProcessToken message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Tokens.ProcessToken} ProcessToken
         */
        ProcessToken.fromObject = function fromObject(object) {
            if (object instanceof $root.Tokens.ProcessToken)
                return object;
            let message = new $root.Tokens.ProcessToken();
            switch (object.processTokenType) {
            case "CHANGE_EMAIL":
            case 0:
                message.processTokenType = 0;
                break;
            case "EMAIL_VERIFICATION":
            case 1:
                message.processTokenType = 1;
                break;
            case "IP_ADDRESS_VERIFICATION":
            case 2:
                message.processTokenType = 2;
                break;
            case "USERNAME_VERIFICATION":
            case 3:
                message.processTokenType = 3;
                break;
            case "DEVICE_VERIFICATION":
            case 4:
                message.processTokenType = 4;
                break;
            case "CREATE_ACCOUNT_VERIFICATION":
            case 5:
                message.processTokenType = 5;
                break;
            case "REDEEM_PERSONAL_LICENSE":
            case 6:
                message.processTokenType = 6;
                break;
            case "DELETE_ACCOUNT_VERIFICATION":
            case 7:
                message.processTokenType = 7;
                break;
            }
            if (object.payload != null)
                if (typeof object.payload === "string")
                    $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                else if (object.payload.length)
                    message.payload = object.payload;
            if (object.creation != null)
                if ($util.Long)
                    (message.creation = $util.Long.fromValue(object.creation)).unsigned = false;
                else if (typeof object.creation === "string")
                    message.creation = parseInt(object.creation, 10);
                else if (typeof object.creation === "number")
                    message.creation = object.creation;
                else if (typeof object.creation === "object")
                    message.creation = new $util.LongBits(object.creation.low >>> 0, object.creation.high >>> 0).toNumber();
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.subEnvironment != null)
                message.subEnvironment = String(object.subEnvironment);
            return message;
        };

        /**
         * Creates a plain object from a ProcessToken message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Tokens.ProcessToken
         * @static
         * @param {Tokens.ProcessToken} message ProcessToken
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProcessToken.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.processTokenType = options.enums === String ? "CHANGE_EMAIL" : 0;
                if (options.bytes === String)
                    object.payload = "";
                else {
                    object.payload = [];
                    if (options.bytes !== Array)
                        object.payload = $util.newBuffer(object.payload);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creation = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creation = options.longs === String ? "0" : 0;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                object.subEnvironment = "";
            }
            if (message.processTokenType != null && message.hasOwnProperty("processTokenType"))
                object.processTokenType = options.enums === String ? $root.Tokens.ProcessTokenType[message.processTokenType] : message.processTokenType;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
            if (message.creation != null && message.hasOwnProperty("creation"))
                if (typeof message.creation === "number")
                    object.creation = options.longs === String ? String(message.creation) : message.creation;
                else
                    object.creation = options.longs === String ? $util.Long.prototype.toString.call(message.creation) : options.longs === Number ? new $util.LongBits(message.creation.low >>> 0, message.creation.high >>> 0).toNumber() : message.creation;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.subEnvironment != null && message.hasOwnProperty("subEnvironment"))
                object.subEnvironment = message.subEnvironment;
            return object;
        };

        /**
         * Converts this ProcessToken to JSON.
         * @function toJSON
         * @memberof Tokens.ProcessToken
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProcessToken.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProcessToken;
    })();

    return Tokens;
})();

export const ExternalService = $root.ExternalService = (() => {

    /**
     * Namespace ExternalService.
     * @exports ExternalService
     * @namespace
     */
    const ExternalService = {};

    ExternalService.SaveSettingsRequest = (function() {

        /**
         * Properties of a SaveSettingsRequest.
         * @memberof ExternalService
         * @interface ISaveSettingsRequest
         * @property {number|null} [enterpriseId] SaveSettingsRequest enterpriseId
         * @property {Uint8Array|null} [certificate] SaveSettingsRequest certificate
         * @property {string|null} [password] SaveSettingsRequest password
         * @property {string|null} [directoryUrl] SaveSettingsRequest directoryUrl
         */

        /**
         * Constructs a new SaveSettingsRequest.
         * @memberof ExternalService
         * @classdesc Represents a SaveSettingsRequest.
         * @implements ISaveSettingsRequest
         * @constructor
         * @param {ExternalService.ISaveSettingsRequest=} [properties] Properties to set
         */
        function SaveSettingsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SaveSettingsRequest enterpriseId.
         * @member {number} enterpriseId
         * @memberof ExternalService.SaveSettingsRequest
         * @instance
         */
        SaveSettingsRequest.prototype.enterpriseId = 0;

        /**
         * SaveSettingsRequest certificate.
         * @member {Uint8Array} certificate
         * @memberof ExternalService.SaveSettingsRequest
         * @instance
         */
        SaveSettingsRequest.prototype.certificate = $util.newBuffer([]);

        /**
         * SaveSettingsRequest password.
         * @member {string} password
         * @memberof ExternalService.SaveSettingsRequest
         * @instance
         */
        SaveSettingsRequest.prototype.password = "";

        /**
         * SaveSettingsRequest directoryUrl.
         * @member {string} directoryUrl
         * @memberof ExternalService.SaveSettingsRequest
         * @instance
         */
        SaveSettingsRequest.prototype.directoryUrl = "";

        /**
         * Creates a new SaveSettingsRequest instance using the specified properties.
         * @function create
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {ExternalService.ISaveSettingsRequest=} [properties] Properties to set
         * @returns {ExternalService.SaveSettingsRequest} SaveSettingsRequest instance
         */
        SaveSettingsRequest.create = function create(properties) {
            return new SaveSettingsRequest(properties);
        };

        /**
         * Encodes the specified SaveSettingsRequest message. Does not implicitly {@link ExternalService.SaveSettingsRequest.verify|verify} messages.
         * @function encode
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {ExternalService.ISaveSettingsRequest} message SaveSettingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveSettingsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.enterpriseId);
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.certificate);
            if (message.password != null && message.hasOwnProperty("password"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
            if (message.directoryUrl != null && message.hasOwnProperty("directoryUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.directoryUrl);
            return writer;
        };

        /**
         * Encodes the specified SaveSettingsRequest message, length delimited. Does not implicitly {@link ExternalService.SaveSettingsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {ExternalService.ISaveSettingsRequest} message SaveSettingsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveSettingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SaveSettingsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ExternalService.SaveSettingsRequest} SaveSettingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveSettingsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExternalService.SaveSettingsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enterpriseId = reader.int32();
                    break;
                case 2:
                    message.certificate = reader.bytes();
                    break;
                case 3:
                    message.password = reader.string();
                    break;
                case 4:
                    message.directoryUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SaveSettingsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ExternalService.SaveSettingsRequest} SaveSettingsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveSettingsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SaveSettingsRequest message.
         * @function verify
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SaveSettingsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (!$util.isInteger(message.enterpriseId))
                    return "enterpriseId: integer expected";
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                if (!(message.certificate && typeof message.certificate.length === "number" || $util.isString(message.certificate)))
                    return "certificate: buffer expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.directoryUrl != null && message.hasOwnProperty("directoryUrl"))
                if (!$util.isString(message.directoryUrl))
                    return "directoryUrl: string expected";
            return null;
        };

        /**
         * Creates a SaveSettingsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ExternalService.SaveSettingsRequest} SaveSettingsRequest
         */
        SaveSettingsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ExternalService.SaveSettingsRequest)
                return object;
            let message = new $root.ExternalService.SaveSettingsRequest();
            if (object.enterpriseId != null)
                message.enterpriseId = object.enterpriseId | 0;
            if (object.certificate != null)
                if (typeof object.certificate === "string")
                    $util.base64.decode(object.certificate, message.certificate = $util.newBuffer($util.base64.length(object.certificate)), 0);
                else if (object.certificate.length)
                    message.certificate = object.certificate;
            if (object.password != null)
                message.password = String(object.password);
            if (object.directoryUrl != null)
                message.directoryUrl = String(object.directoryUrl);
            return message;
        };

        /**
         * Creates a plain object from a SaveSettingsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ExternalService.SaveSettingsRequest
         * @static
         * @param {ExternalService.SaveSettingsRequest} message SaveSettingsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SaveSettingsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.enterpriseId = 0;
                if (options.bytes === String)
                    object.certificate = "";
                else {
                    object.certificate = [];
                    if (options.bytes !== Array)
                        object.certificate = $util.newBuffer(object.certificate);
                }
                object.password = "";
                object.directoryUrl = "";
            }
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                object.enterpriseId = message.enterpriseId;
            if (message.certificate != null && message.hasOwnProperty("certificate"))
                object.certificate = options.bytes === String ? $util.base64.encode(message.certificate, 0, message.certificate.length) : options.bytes === Array ? Array.prototype.slice.call(message.certificate) : message.certificate;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.directoryUrl != null && message.hasOwnProperty("directoryUrl"))
                object.directoryUrl = message.directoryUrl;
            return object;
        };

        /**
         * Converts this SaveSettingsRequest to JSON.
         * @function toJSON
         * @memberof ExternalService.SaveSettingsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SaveSettingsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SaveSettingsRequest;
    })();

    ExternalService.GetUsersRequest = (function() {

        /**
         * Properties of a GetUsersRequest.
         * @memberof ExternalService
         * @interface IGetUsersRequest
         * @property {string|null} [field] GetUsersRequest field
         * @property {string|null} [value] GetUsersRequest value
         */

        /**
         * Constructs a new GetUsersRequest.
         * @memberof ExternalService
         * @classdesc Represents a GetUsersRequest.
         * @implements IGetUsersRequest
         * @constructor
         * @param {ExternalService.IGetUsersRequest=} [properties] Properties to set
         */
        function GetUsersRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetUsersRequest field.
         * @member {string} field
         * @memberof ExternalService.GetUsersRequest
         * @instance
         */
        GetUsersRequest.prototype.field = "";

        /**
         * GetUsersRequest value.
         * @member {string} value
         * @memberof ExternalService.GetUsersRequest
         * @instance
         */
        GetUsersRequest.prototype.value = "";

        /**
         * Creates a new GetUsersRequest instance using the specified properties.
         * @function create
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {ExternalService.IGetUsersRequest=} [properties] Properties to set
         * @returns {ExternalService.GetUsersRequest} GetUsersRequest instance
         */
        GetUsersRequest.create = function create(properties) {
            return new GetUsersRequest(properties);
        };

        /**
         * Encodes the specified GetUsersRequest message. Does not implicitly {@link ExternalService.GetUsersRequest.verify|verify} messages.
         * @function encode
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {ExternalService.IGetUsersRequest} message GetUsersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.field != null && message.hasOwnProperty("field"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.field);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified GetUsersRequest message, length delimited. Does not implicitly {@link ExternalService.GetUsersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {ExternalService.IGetUsersRequest} message GetUsersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetUsersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ExternalService.GetUsersRequest} GetUsersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExternalService.GetUsersRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.field = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetUsersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ExternalService.GetUsersRequest} GetUsersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetUsersRequest message.
         * @function verify
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetUsersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.field != null && message.hasOwnProperty("field"))
                if (!$util.isString(message.field))
                    return "field: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a GetUsersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ExternalService.GetUsersRequest} GetUsersRequest
         */
        GetUsersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ExternalService.GetUsersRequest)
                return object;
            let message = new $root.ExternalService.GetUsersRequest();
            if (object.field != null)
                message.field = String(object.field);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a GetUsersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ExternalService.GetUsersRequest
         * @static
         * @param {ExternalService.GetUsersRequest} message GetUsersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetUsersRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.field = "";
                object.value = "";
            }
            if (message.field != null && message.hasOwnProperty("field"))
                object.field = message.field;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this GetUsersRequest to JSON.
         * @function toJSON
         * @memberof ExternalService.GetUsersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetUsersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetUsersRequest;
    })();

    /**
     * UserStatus enum.
     * @name ExternalService.UserStatus
     * @enum {string}
     * @property {number} NEW=0 NEW value
     * @property {number} INVITED=1 INVITED value
     * @property {number} ACTIVE=2 ACTIVE value
     * @property {number} TAKEN=3 TAKEN value
     */
    ExternalService.UserStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NEW"] = 0;
        values[valuesById[1] = "INVITED"] = 1;
        values[valuesById[2] = "ACTIVE"] = 2;
        values[valuesById[3] = "TAKEN"] = 3;
        return values;
    })();

    /**
     * LockStatus enum.
     * @name ExternalService.LockStatus
     * @enum {string}
     * @property {number} UNLOCKED=0 UNLOCKED value
     * @property {number} LOCKED=1 LOCKED value
     * @property {number} DISABLED=2 DISABLED value
     */
    ExternalService.LockStatus = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNLOCKED"] = 0;
        values[valuesById[1] = "LOCKED"] = 1;
        values[valuesById[2] = "DISABLED"] = 2;
        return values;
    })();

    ExternalService.User = (function() {

        /**
         * Properties of a User.
         * @memberof ExternalService
         * @interface IUser
         * @property {string|null} [email] User email
         * @property {string|null} [name] User name
         * @property {ExternalService.UserStatus|null} [status] User status
         * @property {ExternalService.LockStatus|null} [lockStatus] User lockStatus
         */

        /**
         * Constructs a new User.
         * @memberof ExternalService
         * @classdesc Represents a User.
         * @implements IUser
         * @constructor
         * @param {ExternalService.IUser=} [properties] Properties to set
         */
        function User(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * User email.
         * @member {string} email
         * @memberof ExternalService.User
         * @instance
         */
        User.prototype.email = "";

        /**
         * User name.
         * @member {string} name
         * @memberof ExternalService.User
         * @instance
         */
        User.prototype.name = "";

        /**
         * User status.
         * @member {ExternalService.UserStatus} status
         * @memberof ExternalService.User
         * @instance
         */
        User.prototype.status = 0;

        /**
         * User lockStatus.
         * @member {ExternalService.LockStatus} lockStatus
         * @memberof ExternalService.User
         * @instance
         */
        User.prototype.lockStatus = 0;

        /**
         * Creates a new User instance using the specified properties.
         * @function create
         * @memberof ExternalService.User
         * @static
         * @param {ExternalService.IUser=} [properties] Properties to set
         * @returns {ExternalService.User} User instance
         */
        User.create = function create(properties) {
            return new User(properties);
        };

        /**
         * Encodes the specified User message. Does not implicitly {@link ExternalService.User.verify|verify} messages.
         * @function encode
         * @memberof ExternalService.User
         * @static
         * @param {ExternalService.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.lockStatus != null && message.hasOwnProperty("lockStatus"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lockStatus);
            return writer;
        };

        /**
         * Encodes the specified User message, length delimited. Does not implicitly {@link ExternalService.User.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ExternalService.User
         * @static
         * @param {ExternalService.IUser} message User message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        User.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a User message from the specified reader or buffer.
         * @function decode
         * @memberof ExternalService.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ExternalService.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExternalService.User();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.lockStatus = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a User message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ExternalService.User
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ExternalService.User} User
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        User.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a User message.
         * @function verify
         * @memberof ExternalService.User
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        User.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.lockStatus != null && message.hasOwnProperty("lockStatus"))
                switch (message.lockStatus) {
                default:
                    return "lockStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a User message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ExternalService.User
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ExternalService.User} User
         */
        User.fromObject = function fromObject(object) {
            if (object instanceof $root.ExternalService.User)
                return object;
            let message = new $root.ExternalService.User();
            if (object.email != null)
                message.email = String(object.email);
            if (object.name != null)
                message.name = String(object.name);
            switch (object.status) {
            case "NEW":
            case 0:
                message.status = 0;
                break;
            case "INVITED":
            case 1:
                message.status = 1;
                break;
            case "ACTIVE":
            case 2:
                message.status = 2;
                break;
            case "TAKEN":
            case 3:
                message.status = 3;
                break;
            }
            switch (object.lockStatus) {
            case "UNLOCKED":
            case 0:
                message.lockStatus = 0;
                break;
            case "LOCKED":
            case 1:
                message.lockStatus = 1;
                break;
            case "DISABLED":
            case 2:
                message.lockStatus = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a User message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ExternalService.User
         * @static
         * @param {ExternalService.User} message User
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        User.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.name = "";
                object.status = options.enums === String ? "NEW" : 0;
                object.lockStatus = options.enums === String ? "UNLOCKED" : 0;
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.ExternalService.UserStatus[message.status] : message.status;
            if (message.lockStatus != null && message.hasOwnProperty("lockStatus"))
                object.lockStatus = options.enums === String ? $root.ExternalService.LockStatus[message.lockStatus] : message.lockStatus;
            return object;
        };

        /**
         * Converts this User to JSON.
         * @function toJSON
         * @memberof ExternalService.User
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        User.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return User;
    })();

    ExternalService.GetUsersResponse = (function() {

        /**
         * Properties of a GetUsersResponse.
         * @memberof ExternalService
         * @interface IGetUsersResponse
         * @property {Array.<ExternalService.IUser>|null} [users] GetUsersResponse users
         */

        /**
         * Constructs a new GetUsersResponse.
         * @memberof ExternalService
         * @classdesc Represents a GetUsersResponse.
         * @implements IGetUsersResponse
         * @constructor
         * @param {ExternalService.IGetUsersResponse=} [properties] Properties to set
         */
        function GetUsersResponse(properties) {
            this.users = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetUsersResponse users.
         * @member {Array.<ExternalService.IUser>} users
         * @memberof ExternalService.GetUsersResponse
         * @instance
         */
        GetUsersResponse.prototype.users = $util.emptyArray;

        /**
         * Creates a new GetUsersResponse instance using the specified properties.
         * @function create
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {ExternalService.IGetUsersResponse=} [properties] Properties to set
         * @returns {ExternalService.GetUsersResponse} GetUsersResponse instance
         */
        GetUsersResponse.create = function create(properties) {
            return new GetUsersResponse(properties);
        };

        /**
         * Encodes the specified GetUsersResponse message. Does not implicitly {@link ExternalService.GetUsersResponse.verify|verify} messages.
         * @function encode
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {ExternalService.IGetUsersResponse} message GetUsersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.users != null && message.users.length)
                for (let i = 0; i < message.users.length; ++i)
                    $root.ExternalService.User.encode(message.users[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetUsersResponse message, length delimited. Does not implicitly {@link ExternalService.GetUsersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {ExternalService.IGetUsersResponse} message GetUsersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetUsersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetUsersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ExternalService.GetUsersResponse} GetUsersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ExternalService.GetUsersResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.users && message.users.length))
                        message.users = [];
                    message.users.push($root.ExternalService.User.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetUsersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ExternalService.GetUsersResponse} GetUsersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetUsersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetUsersResponse message.
         * @function verify
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetUsersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (let i = 0; i < message.users.length; ++i) {
                    let error = $root.ExternalService.User.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GetUsersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ExternalService.GetUsersResponse} GetUsersResponse
         */
        GetUsersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ExternalService.GetUsersResponse)
                return object;
            let message = new $root.ExternalService.GetUsersResponse();
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".ExternalService.GetUsersResponse.users: array expected");
                message.users = [];
                for (let i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".ExternalService.GetUsersResponse.users: object expected");
                    message.users[i] = $root.ExternalService.User.fromObject(object.users[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GetUsersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ExternalService.GetUsersResponse
         * @static
         * @param {ExternalService.GetUsersResponse} message GetUsersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetUsersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.users = [];
            if (message.users && message.users.length) {
                object.users = [];
                for (let j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.ExternalService.User.toObject(message.users[j], options);
            }
            return object;
        };

        /**
         * Converts this GetUsersResponse to JSON.
         * @function toJSON
         * @memberof ExternalService.GetUsersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetUsersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetUsersResponse;
    })();

    return ExternalService;
})();

export const Folder = $root.Folder = (() => {

    /**
     * Namespace Folder.
     * @exports Folder
     * @namespace
     */
    const Folder = {};

    /**
     * RecordType enum.
     * @name Folder.RecordType
     * @enum {string}
     * @property {number} password=0 password value
     */
    Folder.RecordType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "password"] = 0;
        return values;
    })();

    /**
     * FolderType enum.
     * @name Folder.FolderType
     * @enum {string}
     * @property {number} default_folder=0 default_folder value
     * @property {number} user_folder=1 user_folder value
     * @property {number} shared_folder=2 shared_folder value
     * @property {number} shared_folder_folder=3 shared_folder_folder value
     */
    Folder.FolderType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "default_folder"] = 0;
        values[valuesById[1] = "user_folder"] = 1;
        values[valuesById[2] = "shared_folder"] = 2;
        values[valuesById[3] = "shared_folder_folder"] = 3;
        return values;
    })();

    /**
     * EncryptedKeyType enum.
     * @name Folder.EncryptedKeyType
     * @enum {string}
     * @property {number} no_key=0 no_key value
     * @property {number} encrypted_by_data_key=1 encrypted_by_data_key value
     * @property {number} encrypted_by_public_key=2 encrypted_by_public_key value
     */
    Folder.EncryptedKeyType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "no_key"] = 0;
        values[valuesById[1] = "encrypted_by_data_key"] = 1;
        values[valuesById[2] = "encrypted_by_public_key"] = 2;
        return values;
    })();

    Folder.EncryptedDataKey = (function() {

        /**
         * Properties of an EncryptedDataKey.
         * @memberof Folder
         * @interface IEncryptedDataKey
         * @property {Uint8Array|null} [encryptedKey] EncryptedDataKey encryptedKey
         * @property {Folder.EncryptedKeyType|null} [encryptedKeyType] EncryptedDataKey encryptedKeyType
         */

        /**
         * Constructs a new EncryptedDataKey.
         * @memberof Folder
         * @classdesc Represents an EncryptedDataKey.
         * @implements IEncryptedDataKey
         * @constructor
         * @param {Folder.IEncryptedDataKey=} [properties] Properties to set
         */
        function EncryptedDataKey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EncryptedDataKey encryptedKey.
         * @member {Uint8Array} encryptedKey
         * @memberof Folder.EncryptedDataKey
         * @instance
         */
        EncryptedDataKey.prototype.encryptedKey = $util.newBuffer([]);

        /**
         * EncryptedDataKey encryptedKeyType.
         * @member {Folder.EncryptedKeyType} encryptedKeyType
         * @memberof Folder.EncryptedDataKey
         * @instance
         */
        EncryptedDataKey.prototype.encryptedKeyType = 0;

        /**
         * Creates a new EncryptedDataKey instance using the specified properties.
         * @function create
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey=} [properties] Properties to set
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey instance
         */
        EncryptedDataKey.create = function create(properties) {
            return new EncryptedDataKey(properties);
        };

        /**
         * Encodes the specified EncryptedDataKey message. Does not implicitly {@link Folder.EncryptedDataKey.verify|verify} messages.
         * @function encode
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey} message EncryptedDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedDataKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedKey);
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.encryptedKeyType);
            return writer;
        };

        /**
         * Encodes the specified EncryptedDataKey message, length delimited. Does not implicitly {@link Folder.EncryptedDataKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.IEncryptedDataKey} message EncryptedDataKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EncryptedDataKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EncryptedDataKey message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedDataKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.EncryptedDataKey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedKey = reader.bytes();
                    break;
                case 2:
                    message.encryptedKeyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EncryptedDataKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EncryptedDataKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EncryptedDataKey message.
         * @function verify
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EncryptedDataKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                if (!(message.encryptedKey && typeof message.encryptedKey.length === "number" || $util.isString(message.encryptedKey)))
                    return "encryptedKey: buffer expected";
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                switch (message.encryptedKeyType) {
                default:
                    return "encryptedKeyType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an EncryptedDataKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.EncryptedDataKey} EncryptedDataKey
         */
        EncryptedDataKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.EncryptedDataKey)
                return object;
            let message = new $root.Folder.EncryptedDataKey();
            if (object.encryptedKey != null)
                if (typeof object.encryptedKey === "string")
                    $util.base64.decode(object.encryptedKey, message.encryptedKey = $util.newBuffer($util.base64.length(object.encryptedKey)), 0);
                else if (object.encryptedKey.length)
                    message.encryptedKey = object.encryptedKey;
            switch (object.encryptedKeyType) {
            case "no_key":
            case 0:
                message.encryptedKeyType = 0;
                break;
            case "encrypted_by_data_key":
            case 1:
                message.encryptedKeyType = 1;
                break;
            case "encrypted_by_public_key":
            case 2:
                message.encryptedKeyType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an EncryptedDataKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.EncryptedDataKey
         * @static
         * @param {Folder.EncryptedDataKey} message EncryptedDataKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EncryptedDataKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedKey = "";
                else {
                    object.encryptedKey = [];
                    if (options.bytes !== Array)
                        object.encryptedKey = $util.newBuffer(object.encryptedKey);
                }
                object.encryptedKeyType = options.enums === String ? "no_key" : 0;
            }
            if (message.encryptedKey != null && message.hasOwnProperty("encryptedKey"))
                object.encryptedKey = options.bytes === String ? $util.base64.encode(message.encryptedKey, 0, message.encryptedKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedKey) : message.encryptedKey;
            if (message.encryptedKeyType != null && message.hasOwnProperty("encryptedKeyType"))
                object.encryptedKeyType = options.enums === String ? $root.Folder.EncryptedKeyType[message.encryptedKeyType] : message.encryptedKeyType;
            return object;
        };

        /**
         * Converts this EncryptedDataKey to JSON.
         * @function toJSON
         * @memberof Folder.EncryptedDataKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EncryptedDataKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EncryptedDataKey;
    })();

    Folder.SharedFolderRecordData = (function() {

        /**
         * Properties of a SharedFolderRecordData.
         * @memberof Folder
         * @interface ISharedFolderRecordData
         * @property {Uint8Array|null} [folderUid] SharedFolderRecordData folderUid
         * @property {Uint8Array|null} [recordUid] SharedFolderRecordData recordUid
         * @property {number|null} [userId] SharedFolderRecordData userId
         * @property {Array.<Folder.IEncryptedDataKey>|null} [encryptedDataKey] SharedFolderRecordData encryptedDataKey
         */

        /**
         * Constructs a new SharedFolderRecordData.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordData.
         * @implements ISharedFolderRecordData
         * @constructor
         * @param {Folder.ISharedFolderRecordData=} [properties] Properties to set
         */
        function SharedFolderRecordData(properties) {
            this.encryptedDataKey = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordData folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.folderUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordData recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.recordUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordData userId.
         * @member {number} userId
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.userId = 0;

        /**
         * SharedFolderRecordData encryptedDataKey.
         * @member {Array.<Folder.IEncryptedDataKey>} encryptedDataKey
         * @memberof Folder.SharedFolderRecordData
         * @instance
         */
        SharedFolderRecordData.prototype.encryptedDataKey = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordData instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData instance
         */
        SharedFolderRecordData.create = function create(properties) {
            return new SharedFolderRecordData(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordData message. Does not implicitly {@link Folder.SharedFolderRecordData.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData} message SharedFolderRecordData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordUid);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userId);
            if (message.encryptedDataKey != null && message.encryptedDataKey.length)
                for (let i = 0; i < message.encryptedDataKey.length; ++i)
                    $root.Folder.EncryptedDataKey.encode(message.encryptedDataKey[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordData message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.ISharedFolderRecordData} message SharedFolderRecordData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordData message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.recordUid = reader.bytes();
                    break;
                case 3:
                    message.userId = reader.int32();
                    break;
                case 4:
                    if (!(message.encryptedDataKey && message.encryptedDataKey.length))
                        message.encryptedDataKey = [];
                    message.encryptedDataKey.push($root.Folder.EncryptedDataKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordData message.
         * @function verify
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.encryptedDataKey != null && message.hasOwnProperty("encryptedDataKey")) {
                if (!Array.isArray(message.encryptedDataKey))
                    return "encryptedDataKey: array expected";
                for (let i = 0; i < message.encryptedDataKey.length; ++i) {
                    let error = $root.Folder.EncryptedDataKey.verify(message.encryptedDataKey[i]);
                    if (error)
                        return "encryptedDataKey." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordData} SharedFolderRecordData
         */
        SharedFolderRecordData.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordData)
                return object;
            let message = new $root.Folder.SharedFolderRecordData();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.encryptedDataKey) {
                if (!Array.isArray(object.encryptedDataKey))
                    throw TypeError(".Folder.SharedFolderRecordData.encryptedDataKey: array expected");
                message.encryptedDataKey = [];
                for (let i = 0; i < object.encryptedDataKey.length; ++i) {
                    if (typeof object.encryptedDataKey[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordData.encryptedDataKey: object expected");
                    message.encryptedDataKey[i] = $root.Folder.EncryptedDataKey.fromObject(object.encryptedDataKey[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordData
         * @static
         * @param {Folder.SharedFolderRecordData} message SharedFolderRecordData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.encryptedDataKey = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.userId = 0;
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.encryptedDataKey && message.encryptedDataKey.length) {
                object.encryptedDataKey = [];
                for (let j = 0; j < message.encryptedDataKey.length; ++j)
                    object.encryptedDataKey[j] = $root.Folder.EncryptedDataKey.toObject(message.encryptedDataKey[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordData to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordData;
    })();

    Folder.SharedFolderRecordDataList = (function() {

        /**
         * Properties of a SharedFolderRecordDataList.
         * @memberof Folder
         * @interface ISharedFolderRecordDataList
         * @property {Array.<Folder.ISharedFolderRecordData>|null} [sharedFolderRecordData] SharedFolderRecordDataList sharedFolderRecordData
         */

        /**
         * Constructs a new SharedFolderRecordDataList.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordDataList.
         * @implements ISharedFolderRecordDataList
         * @constructor
         * @param {Folder.ISharedFolderRecordDataList=} [properties] Properties to set
         */
        function SharedFolderRecordDataList(properties) {
            this.sharedFolderRecordData = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordDataList sharedFolderRecordData.
         * @member {Array.<Folder.ISharedFolderRecordData>} sharedFolderRecordData
         * @memberof Folder.SharedFolderRecordDataList
         * @instance
         */
        SharedFolderRecordDataList.prototype.sharedFolderRecordData = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordDataList instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList instance
         */
        SharedFolderRecordDataList.create = function create(properties) {
            return new SharedFolderRecordDataList(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordDataList message. Does not implicitly {@link Folder.SharedFolderRecordDataList.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList} message SharedFolderRecordDataList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordDataList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderRecordData != null && message.sharedFolderRecordData.length)
                for (let i = 0; i < message.sharedFolderRecordData.length; ++i)
                    $root.Folder.SharedFolderRecordData.encode(message.sharedFolderRecordData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordDataList message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordDataList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.ISharedFolderRecordDataList} message SharedFolderRecordDataList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordDataList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordDataList message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordDataList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordDataList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharedFolderRecordData && message.sharedFolderRecordData.length))
                        message.sharedFolderRecordData = [];
                    message.sharedFolderRecordData.push($root.Folder.SharedFolderRecordData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordDataList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordDataList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordDataList message.
         * @function verify
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordDataList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderRecordData != null && message.hasOwnProperty("sharedFolderRecordData")) {
                if (!Array.isArray(message.sharedFolderRecordData))
                    return "sharedFolderRecordData: array expected";
                for (let i = 0; i < message.sharedFolderRecordData.length; ++i) {
                    let error = $root.Folder.SharedFolderRecordData.verify(message.sharedFolderRecordData[i]);
                    if (error)
                        return "sharedFolderRecordData." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordDataList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordDataList} SharedFolderRecordDataList
         */
        SharedFolderRecordDataList.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordDataList)
                return object;
            let message = new $root.Folder.SharedFolderRecordDataList();
            if (object.sharedFolderRecordData) {
                if (!Array.isArray(object.sharedFolderRecordData))
                    throw TypeError(".Folder.SharedFolderRecordDataList.sharedFolderRecordData: array expected");
                message.sharedFolderRecordData = [];
                for (let i = 0; i < object.sharedFolderRecordData.length; ++i) {
                    if (typeof object.sharedFolderRecordData[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordDataList.sharedFolderRecordData: object expected");
                    message.sharedFolderRecordData[i] = $root.Folder.SharedFolderRecordData.fromObject(object.sharedFolderRecordData[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordDataList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordDataList
         * @static
         * @param {Folder.SharedFolderRecordDataList} message SharedFolderRecordDataList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordDataList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sharedFolderRecordData = [];
            if (message.sharedFolderRecordData && message.sharedFolderRecordData.length) {
                object.sharedFolderRecordData = [];
                for (let j = 0; j < message.sharedFolderRecordData.length; ++j)
                    object.sharedFolderRecordData[j] = $root.Folder.SharedFolderRecordData.toObject(message.sharedFolderRecordData[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordDataList to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordDataList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordDataList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordDataList;
    })();

    Folder.SharedFolderRecordFix = (function() {

        /**
         * Properties of a SharedFolderRecordFix.
         * @memberof Folder
         * @interface ISharedFolderRecordFix
         * @property {Uint8Array|null} [folderUid] SharedFolderRecordFix folderUid
         * @property {Uint8Array|null} [recordUid] SharedFolderRecordFix recordUid
         * @property {Uint8Array|null} [encryptedRecordFolderKey] SharedFolderRecordFix encryptedRecordFolderKey
         */

        /**
         * Constructs a new SharedFolderRecordFix.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordFix.
         * @implements ISharedFolderRecordFix
         * @constructor
         * @param {Folder.ISharedFolderRecordFix=} [properties] Properties to set
         */
        function SharedFolderRecordFix(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordFix folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.folderUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordFix recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.recordUid = $util.newBuffer([]);

        /**
         * SharedFolderRecordFix encryptedRecordFolderKey.
         * @member {Uint8Array} encryptedRecordFolderKey
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         */
        SharedFolderRecordFix.prototype.encryptedRecordFolderKey = $util.newBuffer([]);

        /**
         * Creates a new SharedFolderRecordFix instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix instance
         */
        SharedFolderRecordFix.create = function create(properties) {
            return new SharedFolderRecordFix(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordFix message. Does not implicitly {@link Folder.SharedFolderRecordFix.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix} message SharedFolderRecordFix message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFix.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordUid);
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.encryptedRecordFolderKey);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordFix message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordFix.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.ISharedFolderRecordFix} message SharedFolderRecordFix message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFix.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordFix message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFix.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordFix();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.recordUid = reader.bytes();
                    break;
                case 3:
                    message.encryptedRecordFolderKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordFix message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFix.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordFix message.
         * @function verify
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordFix.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                if (!(message.encryptedRecordFolderKey && typeof message.encryptedRecordFolderKey.length === "number" || $util.isString(message.encryptedRecordFolderKey)))
                    return "encryptedRecordFolderKey: buffer expected";
            return null;
        };

        /**
         * Creates a SharedFolderRecordFix message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordFix} SharedFolderRecordFix
         */
        SharedFolderRecordFix.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordFix)
                return object;
            let message = new $root.Folder.SharedFolderRecordFix();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.encryptedRecordFolderKey != null)
                if (typeof object.encryptedRecordFolderKey === "string")
                    $util.base64.decode(object.encryptedRecordFolderKey, message.encryptedRecordFolderKey = $util.newBuffer($util.base64.length(object.encryptedRecordFolderKey)), 0);
                else if (object.encryptedRecordFolderKey.length)
                    message.encryptedRecordFolderKey = object.encryptedRecordFolderKey;
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordFix message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordFix
         * @static
         * @param {Folder.SharedFolderRecordFix} message SharedFolderRecordFix
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordFix.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.encryptedRecordFolderKey = "";
                else {
                    object.encryptedRecordFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordFolderKey = $util.newBuffer(object.encryptedRecordFolderKey);
                }
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                object.encryptedRecordFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordFolderKey, 0, message.encryptedRecordFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordFolderKey) : message.encryptedRecordFolderKey;
            return object;
        };

        /**
         * Converts this SharedFolderRecordFix to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordFix
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordFix.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordFix;
    })();

    Folder.SharedFolderRecordFixList = (function() {

        /**
         * Properties of a SharedFolderRecordFixList.
         * @memberof Folder
         * @interface ISharedFolderRecordFixList
         * @property {Array.<Folder.ISharedFolderRecordFix>|null} [sharedFolderRecordFix] SharedFolderRecordFixList sharedFolderRecordFix
         */

        /**
         * Constructs a new SharedFolderRecordFixList.
         * @memberof Folder
         * @classdesc Represents a SharedFolderRecordFixList.
         * @implements ISharedFolderRecordFixList
         * @constructor
         * @param {Folder.ISharedFolderRecordFixList=} [properties] Properties to set
         */
        function SharedFolderRecordFixList(properties) {
            this.sharedFolderRecordFix = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderRecordFixList sharedFolderRecordFix.
         * @member {Array.<Folder.ISharedFolderRecordFix>} sharedFolderRecordFix
         * @memberof Folder.SharedFolderRecordFixList
         * @instance
         */
        SharedFolderRecordFixList.prototype.sharedFolderRecordFix = $util.emptyArray;

        /**
         * Creates a new SharedFolderRecordFixList instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList=} [properties] Properties to set
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList instance
         */
        SharedFolderRecordFixList.create = function create(properties) {
            return new SharedFolderRecordFixList(properties);
        };

        /**
         * Encodes the specified SharedFolderRecordFixList message. Does not implicitly {@link Folder.SharedFolderRecordFixList.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList} message SharedFolderRecordFixList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFixList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderRecordFix != null && message.sharedFolderRecordFix.length)
                for (let i = 0; i < message.sharedFolderRecordFix.length; ++i)
                    $root.Folder.SharedFolderRecordFix.encode(message.sharedFolderRecordFix[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SharedFolderRecordFixList message, length delimited. Does not implicitly {@link Folder.SharedFolderRecordFixList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.ISharedFolderRecordFixList} message SharedFolderRecordFixList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderRecordFixList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderRecordFixList message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFixList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderRecordFixList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.sharedFolderRecordFix && message.sharedFolderRecordFix.length))
                        message.sharedFolderRecordFix = [];
                    message.sharedFolderRecordFix.push($root.Folder.SharedFolderRecordFix.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderRecordFixList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderRecordFixList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderRecordFixList message.
         * @function verify
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderRecordFixList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderRecordFix != null && message.hasOwnProperty("sharedFolderRecordFix")) {
                if (!Array.isArray(message.sharedFolderRecordFix))
                    return "sharedFolderRecordFix: array expected";
                for (let i = 0; i < message.sharedFolderRecordFix.length; ++i) {
                    let error = $root.Folder.SharedFolderRecordFix.verify(message.sharedFolderRecordFix[i]);
                    if (error)
                        return "sharedFolderRecordFix." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SharedFolderRecordFixList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderRecordFixList} SharedFolderRecordFixList
         */
        SharedFolderRecordFixList.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderRecordFixList)
                return object;
            let message = new $root.Folder.SharedFolderRecordFixList();
            if (object.sharedFolderRecordFix) {
                if (!Array.isArray(object.sharedFolderRecordFix))
                    throw TypeError(".Folder.SharedFolderRecordFixList.sharedFolderRecordFix: array expected");
                message.sharedFolderRecordFix = [];
                for (let i = 0; i < object.sharedFolderRecordFix.length; ++i) {
                    if (typeof object.sharedFolderRecordFix[i] !== "object")
                        throw TypeError(".Folder.SharedFolderRecordFixList.sharedFolderRecordFix: object expected");
                    message.sharedFolderRecordFix[i] = $root.Folder.SharedFolderRecordFix.fromObject(object.sharedFolderRecordFix[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderRecordFixList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderRecordFixList
         * @static
         * @param {Folder.SharedFolderRecordFixList} message SharedFolderRecordFixList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderRecordFixList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sharedFolderRecordFix = [];
            if (message.sharedFolderRecordFix && message.sharedFolderRecordFix.length) {
                object.sharedFolderRecordFix = [];
                for (let j = 0; j < message.sharedFolderRecordFix.length; ++j)
                    object.sharedFolderRecordFix[j] = $root.Folder.SharedFolderRecordFix.toObject(message.sharedFolderRecordFix[j], options);
            }
            return object;
        };

        /**
         * Converts this SharedFolderRecordFixList to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderRecordFixList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderRecordFixList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderRecordFixList;
    })();

    Folder.RecordRequest = (function() {

        /**
         * Properties of a RecordRequest.
         * @memberof Folder
         * @interface IRecordRequest
         * @property {Uint8Array|null} [recordUid] RecordRequest recordUid
         * @property {Folder.RecordType|null} [recordType] RecordRequest recordType
         * @property {Uint8Array|null} [recordData] RecordRequest recordData
         * @property {Uint8Array|null} [encryptedRecordKey] RecordRequest encryptedRecordKey
         * @property {Folder.FolderType|null} [folderType] RecordRequest folderType
         * @property {number|Long|null} [howLongAgo] RecordRequest howLongAgo
         * @property {Uint8Array|null} [folderUid] RecordRequest folderUid
         * @property {Uint8Array|null} [encryptedRecordFolderKey] RecordRequest encryptedRecordFolderKey
         * @property {Uint8Array|null} [extra] RecordRequest extra
         * @property {Uint8Array|null} [nonSharedData] RecordRequest nonSharedData
         * @property {Array.<number|Long>|null} [fileIds] RecordRequest fileIds
         */

        /**
         * Constructs a new RecordRequest.
         * @memberof Folder
         * @classdesc Represents a RecordRequest.
         * @implements IRecordRequest
         * @constructor
         * @param {Folder.IRecordRequest=} [properties] Properties to set
         */
        function RecordRequest(properties) {
            this.fileIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordRequest recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordRequest recordType.
         * @member {Folder.RecordType} recordType
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordType = 0;

        /**
         * RecordRequest recordData.
         * @member {Uint8Array} recordData
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.recordData = $util.newBuffer([]);

        /**
         * RecordRequest encryptedRecordKey.
         * @member {Uint8Array} encryptedRecordKey
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.encryptedRecordKey = $util.newBuffer([]);

        /**
         * RecordRequest folderType.
         * @member {Folder.FolderType} folderType
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.folderType = 0;

        /**
         * RecordRequest howLongAgo.
         * @member {number|Long} howLongAgo
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.howLongAgo = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordRequest folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.folderUid = $util.newBuffer([]);

        /**
         * RecordRequest encryptedRecordFolderKey.
         * @member {Uint8Array} encryptedRecordFolderKey
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.encryptedRecordFolderKey = $util.newBuffer([]);

        /**
         * RecordRequest extra.
         * @member {Uint8Array} extra
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.extra = $util.newBuffer([]);

        /**
         * RecordRequest nonSharedData.
         * @member {Uint8Array} nonSharedData
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.nonSharedData = $util.newBuffer([]);

        /**
         * RecordRequest fileIds.
         * @member {Array.<number|Long>} fileIds
         * @memberof Folder.RecordRequest
         * @instance
         */
        RecordRequest.prototype.fileIds = $util.emptyArray;

        /**
         * Creates a new RecordRequest instance using the specified properties.
         * @function create
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest=} [properties] Properties to set
         * @returns {Folder.RecordRequest} RecordRequest instance
         */
        RecordRequest.create = function create(properties) {
            return new RecordRequest(properties);
        };

        /**
         * Encodes the specified RecordRequest message. Does not implicitly {@link Folder.RecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest} message RecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.recordType);
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.recordData);
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedRecordKey);
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.folderType);
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.howLongAgo);
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.folderUid);
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.encryptedRecordFolderKey);
            if (message.extra != null && message.hasOwnProperty("extra"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.extra);
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.nonSharedData);
            if (message.fileIds != null && message.fileIds.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (let i = 0; i < message.fileIds.length; ++i)
                    writer.int64(message.fileIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RecordRequest message, length delimited. Does not implicitly {@link Folder.RecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.IRecordRequest} message RecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.RecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.RecordRequest} RecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.RecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordType = reader.int32();
                    break;
                case 3:
                    message.recordData = reader.bytes();
                    break;
                case 4:
                    message.encryptedRecordKey = reader.bytes();
                    break;
                case 5:
                    message.folderType = reader.int32();
                    break;
                case 6:
                    message.howLongAgo = reader.int64();
                    break;
                case 7:
                    message.folderUid = reader.bytes();
                    break;
                case 8:
                    message.encryptedRecordFolderKey = reader.bytes();
                    break;
                case 9:
                    message.extra = reader.bytes();
                    break;
                case 10:
                    message.nonSharedData = reader.bytes();
                    break;
                case 11:
                    if (!(message.fileIds && message.fileIds.length))
                        message.fileIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.fileIds.push(reader.int64());
                    } else
                        message.fileIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.RecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.RecordRequest} RecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordRequest message.
         * @function verify
         * @memberof Folder.RecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                switch (message.recordType) {
                default:
                    return "recordType: enum value expected";
                case 0:
                    break;
                }
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                if (!(message.recordData && typeof message.recordData.length === "number" || $util.isString(message.recordData)))
                    return "recordData: buffer expected";
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                if (!(message.encryptedRecordKey && typeof message.encryptedRecordKey.length === "number" || $util.isString(message.encryptedRecordKey)))
                    return "encryptedRecordKey: buffer expected";
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                switch (message.folderType) {
                default:
                    return "folderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                if (!$util.isInteger(message.howLongAgo) && !(message.howLongAgo && $util.isInteger(message.howLongAgo.low) && $util.isInteger(message.howLongAgo.high)))
                    return "howLongAgo: integer|Long expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                if (!(message.encryptedRecordFolderKey && typeof message.encryptedRecordFolderKey.length === "number" || $util.isString(message.encryptedRecordFolderKey)))
                    return "encryptedRecordFolderKey: buffer expected";
            if (message.extra != null && message.hasOwnProperty("extra"))
                if (!(message.extra && typeof message.extra.length === "number" || $util.isString(message.extra)))
                    return "extra: buffer expected";
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                if (!(message.nonSharedData && typeof message.nonSharedData.length === "number" || $util.isString(message.nonSharedData)))
                    return "nonSharedData: buffer expected";
            if (message.fileIds != null && message.hasOwnProperty("fileIds")) {
                if (!Array.isArray(message.fileIds))
                    return "fileIds: array expected";
                for (let i = 0; i < message.fileIds.length; ++i)
                    if (!$util.isInteger(message.fileIds[i]) && !(message.fileIds[i] && $util.isInteger(message.fileIds[i].low) && $util.isInteger(message.fileIds[i].high)))
                        return "fileIds: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a RecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.RecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.RecordRequest} RecordRequest
         */
        RecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.RecordRequest)
                return object;
            let message = new $root.Folder.RecordRequest();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            switch (object.recordType) {
            case "password":
            case 0:
                message.recordType = 0;
                break;
            }
            if (object.recordData != null)
                if (typeof object.recordData === "string")
                    $util.base64.decode(object.recordData, message.recordData = $util.newBuffer($util.base64.length(object.recordData)), 0);
                else if (object.recordData.length)
                    message.recordData = object.recordData;
            if (object.encryptedRecordKey != null)
                if (typeof object.encryptedRecordKey === "string")
                    $util.base64.decode(object.encryptedRecordKey, message.encryptedRecordKey = $util.newBuffer($util.base64.length(object.encryptedRecordKey)), 0);
                else if (object.encryptedRecordKey.length)
                    message.encryptedRecordKey = object.encryptedRecordKey;
            switch (object.folderType) {
            case "default_folder":
            case 0:
                message.folderType = 0;
                break;
            case "user_folder":
            case 1:
                message.folderType = 1;
                break;
            case "shared_folder":
            case 2:
                message.folderType = 2;
                break;
            case "shared_folder_folder":
            case 3:
                message.folderType = 3;
                break;
            }
            if (object.howLongAgo != null)
                if ($util.Long)
                    (message.howLongAgo = $util.Long.fromValue(object.howLongAgo)).unsigned = false;
                else if (typeof object.howLongAgo === "string")
                    message.howLongAgo = parseInt(object.howLongAgo, 10);
                else if (typeof object.howLongAgo === "number")
                    message.howLongAgo = object.howLongAgo;
                else if (typeof object.howLongAgo === "object")
                    message.howLongAgo = new $util.LongBits(object.howLongAgo.low >>> 0, object.howLongAgo.high >>> 0).toNumber();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.encryptedRecordFolderKey != null)
                if (typeof object.encryptedRecordFolderKey === "string")
                    $util.base64.decode(object.encryptedRecordFolderKey, message.encryptedRecordFolderKey = $util.newBuffer($util.base64.length(object.encryptedRecordFolderKey)), 0);
                else if (object.encryptedRecordFolderKey.length)
                    message.encryptedRecordFolderKey = object.encryptedRecordFolderKey;
            if (object.extra != null)
                if (typeof object.extra === "string")
                    $util.base64.decode(object.extra, message.extra = $util.newBuffer($util.base64.length(object.extra)), 0);
                else if (object.extra.length)
                    message.extra = object.extra;
            if (object.nonSharedData != null)
                if (typeof object.nonSharedData === "string")
                    $util.base64.decode(object.nonSharedData, message.nonSharedData = $util.newBuffer($util.base64.length(object.nonSharedData)), 0);
                else if (object.nonSharedData.length)
                    message.nonSharedData = object.nonSharedData;
            if (object.fileIds) {
                if (!Array.isArray(object.fileIds))
                    throw TypeError(".Folder.RecordRequest.fileIds: array expected");
                message.fileIds = [];
                for (let i = 0; i < object.fileIds.length; ++i)
                    if ($util.Long)
                        (message.fileIds[i] = $util.Long.fromValue(object.fileIds[i])).unsigned = false;
                    else if (typeof object.fileIds[i] === "string")
                        message.fileIds[i] = parseInt(object.fileIds[i], 10);
                    else if (typeof object.fileIds[i] === "number")
                        message.fileIds[i] = object.fileIds[i];
                    else if (typeof object.fileIds[i] === "object")
                        message.fileIds[i] = new $util.LongBits(object.fileIds[i].low >>> 0, object.fileIds[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.RecordRequest
         * @static
         * @param {Folder.RecordRequest} message RecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fileIds = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.recordType = options.enums === String ? "password" : 0;
                if (options.bytes === String)
                    object.recordData = "";
                else {
                    object.recordData = [];
                    if (options.bytes !== Array)
                        object.recordData = $util.newBuffer(object.recordData);
                }
                if (options.bytes === String)
                    object.encryptedRecordKey = "";
                else {
                    object.encryptedRecordKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordKey = $util.newBuffer(object.encryptedRecordKey);
                }
                object.folderType = options.enums === String ? "default_folder" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.howLongAgo = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.howLongAgo = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.encryptedRecordFolderKey = "";
                else {
                    object.encryptedRecordFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedRecordFolderKey = $util.newBuffer(object.encryptedRecordFolderKey);
                }
                if (options.bytes === String)
                    object.extra = "";
                else {
                    object.extra = [];
                    if (options.bytes !== Array)
                        object.extra = $util.newBuffer(object.extra);
                }
                if (options.bytes === String)
                    object.nonSharedData = "";
                else {
                    object.nonSharedData = [];
                    if (options.bytes !== Array)
                        object.nonSharedData = $util.newBuffer(object.nonSharedData);
                }
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordType != null && message.hasOwnProperty("recordType"))
                object.recordType = options.enums === String ? $root.Folder.RecordType[message.recordType] : message.recordType;
            if (message.recordData != null && message.hasOwnProperty("recordData"))
                object.recordData = options.bytes === String ? $util.base64.encode(message.recordData, 0, message.recordData.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordData) : message.recordData;
            if (message.encryptedRecordKey != null && message.hasOwnProperty("encryptedRecordKey"))
                object.encryptedRecordKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordKey, 0, message.encryptedRecordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordKey) : message.encryptedRecordKey;
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                object.folderType = options.enums === String ? $root.Folder.FolderType[message.folderType] : message.folderType;
            if (message.howLongAgo != null && message.hasOwnProperty("howLongAgo"))
                if (typeof message.howLongAgo === "number")
                    object.howLongAgo = options.longs === String ? String(message.howLongAgo) : message.howLongAgo;
                else
                    object.howLongAgo = options.longs === String ? $util.Long.prototype.toString.call(message.howLongAgo) : options.longs === Number ? new $util.LongBits(message.howLongAgo.low >>> 0, message.howLongAgo.high >>> 0).toNumber() : message.howLongAgo;
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.encryptedRecordFolderKey != null && message.hasOwnProperty("encryptedRecordFolderKey"))
                object.encryptedRecordFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedRecordFolderKey, 0, message.encryptedRecordFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedRecordFolderKey) : message.encryptedRecordFolderKey;
            if (message.extra != null && message.hasOwnProperty("extra"))
                object.extra = options.bytes === String ? $util.base64.encode(message.extra, 0, message.extra.length) : options.bytes === Array ? Array.prototype.slice.call(message.extra) : message.extra;
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                object.nonSharedData = options.bytes === String ? $util.base64.encode(message.nonSharedData, 0, message.nonSharedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonSharedData) : message.nonSharedData;
            if (message.fileIds && message.fileIds.length) {
                object.fileIds = [];
                for (let j = 0; j < message.fileIds.length; ++j)
                    if (typeof message.fileIds[j] === "number")
                        object.fileIds[j] = options.longs === String ? String(message.fileIds[j]) : message.fileIds[j];
                    else
                        object.fileIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.fileIds[j]) : options.longs === Number ? new $util.LongBits(message.fileIds[j].low >>> 0, message.fileIds[j].high >>> 0).toNumber() : message.fileIds[j];
            }
            return object;
        };

        /**
         * Converts this RecordRequest to JSON.
         * @function toJSON
         * @memberof Folder.RecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordRequest;
    })();

    Folder.RecordResponse = (function() {

        /**
         * Properties of a RecordResponse.
         * @memberof Folder
         * @interface IRecordResponse
         * @property {Uint8Array|null} [recordUid] RecordResponse recordUid
         * @property {number|Long|null} [revision] RecordResponse revision
         * @property {string|null} [status] RecordResponse status
         */

        /**
         * Constructs a new RecordResponse.
         * @memberof Folder
         * @classdesc Represents a RecordResponse.
         * @implements IRecordResponse
         * @constructor
         * @param {Folder.IRecordResponse=} [properties] Properties to set
         */
        function RecordResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordResponse recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordResponse revision.
         * @member {number|Long} revision
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordResponse status.
         * @member {string} status
         * @memberof Folder.RecordResponse
         * @instance
         */
        RecordResponse.prototype.status = "";

        /**
         * Creates a new RecordResponse instance using the specified properties.
         * @function create
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse=} [properties] Properties to set
         * @returns {Folder.RecordResponse} RecordResponse instance
         */
        RecordResponse.create = function create(properties) {
            return new RecordResponse(properties);
        };

        /**
         * Encodes the specified RecordResponse message. Does not implicitly {@link Folder.RecordResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse} message RecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.revision);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            return writer;
        };

        /**
         * Encodes the specified RecordResponse message, length delimited. Does not implicitly {@link Folder.RecordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.IRecordResponse} message RecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.RecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.RecordResponse} RecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.RecordResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.revision = reader.int64();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.RecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.RecordResponse} RecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordResponse message.
         * @function verify
         * @memberof Folder.RecordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            return null;
        };

        /**
         * Creates a RecordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.RecordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.RecordResponse} RecordResponse
         */
        RecordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.RecordResponse)
                return object;
            let message = new $root.Folder.RecordResponse();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.status != null)
                message.status = String(object.status);
            return message;
        };

        /**
         * Creates a plain object from a RecordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.RecordResponse
         * @static
         * @param {Folder.RecordResponse} message RecordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.status = "";
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this RecordResponse to JSON.
         * @function toJSON
         * @memberof Folder.RecordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordResponse;
    })();

    Folder.SharedFolderFields = (function() {

        /**
         * Properties of a SharedFolderFields.
         * @memberof Folder
         * @interface ISharedFolderFields
         * @property {Uint8Array|null} [encryptedFolderName] SharedFolderFields encryptedFolderName
         * @property {boolean|null} [manageUsers] SharedFolderFields manageUsers
         * @property {boolean|null} [manageRecords] SharedFolderFields manageRecords
         * @property {boolean|null} [canEdit] SharedFolderFields canEdit
         * @property {boolean|null} [canShare] SharedFolderFields canShare
         */

        /**
         * Constructs a new SharedFolderFields.
         * @memberof Folder
         * @classdesc Represents a SharedFolderFields.
         * @implements ISharedFolderFields
         * @constructor
         * @param {Folder.ISharedFolderFields=} [properties] Properties to set
         */
        function SharedFolderFields(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderFields encryptedFolderName.
         * @member {Uint8Array} encryptedFolderName
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.encryptedFolderName = $util.newBuffer([]);

        /**
         * SharedFolderFields manageUsers.
         * @member {boolean} manageUsers
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.manageUsers = false;

        /**
         * SharedFolderFields manageRecords.
         * @member {boolean} manageRecords
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.manageRecords = false;

        /**
         * SharedFolderFields canEdit.
         * @member {boolean} canEdit
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.canEdit = false;

        /**
         * SharedFolderFields canShare.
         * @member {boolean} canShare
         * @memberof Folder.SharedFolderFields
         * @instance
         */
        SharedFolderFields.prototype.canShare = false;

        /**
         * Creates a new SharedFolderFields instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields=} [properties] Properties to set
         * @returns {Folder.SharedFolderFields} SharedFolderFields instance
         */
        SharedFolderFields.create = function create(properties) {
            return new SharedFolderFields(properties);
        };

        /**
         * Encodes the specified SharedFolderFields message. Does not implicitly {@link Folder.SharedFolderFields.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields} message SharedFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedFolderName);
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.manageUsers);
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.manageRecords);
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.canEdit);
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canShare);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderFields message, length delimited. Does not implicitly {@link Folder.SharedFolderFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.ISharedFolderFields} message SharedFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderFields message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderFields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedFolderName = reader.bytes();
                    break;
                case 2:
                    message.manageUsers = reader.bool();
                    break;
                case 3:
                    message.manageRecords = reader.bool();
                    break;
                case 4:
                    message.canEdit = reader.bool();
                    break;
                case 5:
                    message.canShare = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderFields message.
         * @function verify
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                if (!(message.encryptedFolderName && typeof message.encryptedFolderName.length === "number" || $util.isString(message.encryptedFolderName)))
                    return "encryptedFolderName: buffer expected";
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                if (typeof message.manageUsers !== "boolean")
                    return "manageUsers: boolean expected";
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                if (typeof message.manageRecords !== "boolean")
                    return "manageRecords: boolean expected";
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                if (typeof message.canEdit !== "boolean")
                    return "canEdit: boolean expected";
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                if (typeof message.canShare !== "boolean")
                    return "canShare: boolean expected";
            return null;
        };

        /**
         * Creates a SharedFolderFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderFields} SharedFolderFields
         */
        SharedFolderFields.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderFields)
                return object;
            let message = new $root.Folder.SharedFolderFields();
            if (object.encryptedFolderName != null)
                if (typeof object.encryptedFolderName === "string")
                    $util.base64.decode(object.encryptedFolderName, message.encryptedFolderName = $util.newBuffer($util.base64.length(object.encryptedFolderName)), 0);
                else if (object.encryptedFolderName.length)
                    message.encryptedFolderName = object.encryptedFolderName;
            if (object.manageUsers != null)
                message.manageUsers = Boolean(object.manageUsers);
            if (object.manageRecords != null)
                message.manageRecords = Boolean(object.manageRecords);
            if (object.canEdit != null)
                message.canEdit = Boolean(object.canEdit);
            if (object.canShare != null)
                message.canShare = Boolean(object.canShare);
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderFields
         * @static
         * @param {Folder.SharedFolderFields} message SharedFolderFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedFolderName = "";
                else {
                    object.encryptedFolderName = [];
                    if (options.bytes !== Array)
                        object.encryptedFolderName = $util.newBuffer(object.encryptedFolderName);
                }
                object.manageUsers = false;
                object.manageRecords = false;
                object.canEdit = false;
                object.canShare = false;
            }
            if (message.encryptedFolderName != null && message.hasOwnProperty("encryptedFolderName"))
                object.encryptedFolderName = options.bytes === String ? $util.base64.encode(message.encryptedFolderName, 0, message.encryptedFolderName.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedFolderName) : message.encryptedFolderName;
            if (message.manageUsers != null && message.hasOwnProperty("manageUsers"))
                object.manageUsers = message.manageUsers;
            if (message.manageRecords != null && message.hasOwnProperty("manageRecords"))
                object.manageRecords = message.manageRecords;
            if (message.canEdit != null && message.hasOwnProperty("canEdit"))
                object.canEdit = message.canEdit;
            if (message.canShare != null && message.hasOwnProperty("canShare"))
                object.canShare = message.canShare;
            return object;
        };

        /**
         * Converts this SharedFolderFields to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderFields;
    })();

    Folder.SharedFolderFolderFields = (function() {

        /**
         * Properties of a SharedFolderFolderFields.
         * @memberof Folder
         * @interface ISharedFolderFolderFields
         * @property {Uint8Array|null} [sharedFolderUid] SharedFolderFolderFields sharedFolderUid
         */

        /**
         * Constructs a new SharedFolderFolderFields.
         * @memberof Folder
         * @classdesc Represents a SharedFolderFolderFields.
         * @implements ISharedFolderFolderFields
         * @constructor
         * @param {Folder.ISharedFolderFolderFields=} [properties] Properties to set
         */
        function SharedFolderFolderFields(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SharedFolderFolderFields sharedFolderUid.
         * @member {Uint8Array} sharedFolderUid
         * @memberof Folder.SharedFolderFolderFields
         * @instance
         */
        SharedFolderFolderFields.prototype.sharedFolderUid = $util.newBuffer([]);

        /**
         * Creates a new SharedFolderFolderFields instance using the specified properties.
         * @function create
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields=} [properties] Properties to set
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields instance
         */
        SharedFolderFolderFields.create = function create(properties) {
            return new SharedFolderFolderFields(properties);
        };

        /**
         * Encodes the specified SharedFolderFolderFields message. Does not implicitly {@link Folder.SharedFolderFolderFields.verify|verify} messages.
         * @function encode
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields} message SharedFolderFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFolderFields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.sharedFolderUid);
            return writer;
        };

        /**
         * Encodes the specified SharedFolderFolderFields message, length delimited. Does not implicitly {@link Folder.SharedFolderFolderFields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.ISharedFolderFolderFields} message SharedFolderFolderFields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SharedFolderFolderFields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SharedFolderFolderFields message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFolderFields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.SharedFolderFolderFields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.sharedFolderUid = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SharedFolderFolderFields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SharedFolderFolderFields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SharedFolderFolderFields message.
         * @function verify
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SharedFolderFolderFields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                if (!(message.sharedFolderUid && typeof message.sharedFolderUid.length === "number" || $util.isString(message.sharedFolderUid)))
                    return "sharedFolderUid: buffer expected";
            return null;
        };

        /**
         * Creates a SharedFolderFolderFields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.SharedFolderFolderFields} SharedFolderFolderFields
         */
        SharedFolderFolderFields.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.SharedFolderFolderFields)
                return object;
            let message = new $root.Folder.SharedFolderFolderFields();
            if (object.sharedFolderUid != null)
                if (typeof object.sharedFolderUid === "string")
                    $util.base64.decode(object.sharedFolderUid, message.sharedFolderUid = $util.newBuffer($util.base64.length(object.sharedFolderUid)), 0);
                else if (object.sharedFolderUid.length)
                    message.sharedFolderUid = object.sharedFolderUid;
            return message;
        };

        /**
         * Creates a plain object from a SharedFolderFolderFields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.SharedFolderFolderFields
         * @static
         * @param {Folder.SharedFolderFolderFields} message SharedFolderFolderFields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SharedFolderFolderFields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.sharedFolderUid = "";
                else {
                    object.sharedFolderUid = [];
                    if (options.bytes !== Array)
                        object.sharedFolderUid = $util.newBuffer(object.sharedFolderUid);
                }
            if (message.sharedFolderUid != null && message.hasOwnProperty("sharedFolderUid"))
                object.sharedFolderUid = options.bytes === String ? $util.base64.encode(message.sharedFolderUid, 0, message.sharedFolderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.sharedFolderUid) : message.sharedFolderUid;
            return object;
        };

        /**
         * Converts this SharedFolderFolderFields to JSON.
         * @function toJSON
         * @memberof Folder.SharedFolderFolderFields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SharedFolderFolderFields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SharedFolderFolderFields;
    })();

    Folder.FolderRequest = (function() {

        /**
         * Properties of a FolderRequest.
         * @memberof Folder
         * @interface IFolderRequest
         * @property {Uint8Array|null} [folderUid] FolderRequest folderUid
         * @property {Folder.FolderType|null} [folderType] FolderRequest folderType
         * @property {Uint8Array|null} [parentFolderUid] FolderRequest parentFolderUid
         * @property {Uint8Array|null} [folderData] FolderRequest folderData
         * @property {Uint8Array|null} [encryptedFolderKey] FolderRequest encryptedFolderKey
         * @property {Folder.ISharedFolderFields|null} [sharedFolderFields] FolderRequest sharedFolderFields
         * @property {Folder.ISharedFolderFolderFields|null} [sharedFolderFolderFields] FolderRequest sharedFolderFolderFields
         */

        /**
         * Constructs a new FolderRequest.
         * @memberof Folder
         * @classdesc Represents a FolderRequest.
         * @implements IFolderRequest
         * @constructor
         * @param {Folder.IFolderRequest=} [properties] Properties to set
         */
        function FolderRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FolderRequest folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderUid = $util.newBuffer([]);

        /**
         * FolderRequest folderType.
         * @member {Folder.FolderType} folderType
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderType = 0;

        /**
         * FolderRequest parentFolderUid.
         * @member {Uint8Array} parentFolderUid
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.parentFolderUid = $util.newBuffer([]);

        /**
         * FolderRequest folderData.
         * @member {Uint8Array} folderData
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.folderData = $util.newBuffer([]);

        /**
         * FolderRequest encryptedFolderKey.
         * @member {Uint8Array} encryptedFolderKey
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.encryptedFolderKey = $util.newBuffer([]);

        /**
         * FolderRequest sharedFolderFields.
         * @member {Folder.ISharedFolderFields|null|undefined} sharedFolderFields
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.sharedFolderFields = null;

        /**
         * FolderRequest sharedFolderFolderFields.
         * @member {Folder.ISharedFolderFolderFields|null|undefined} sharedFolderFolderFields
         * @memberof Folder.FolderRequest
         * @instance
         */
        FolderRequest.prototype.sharedFolderFolderFields = null;

        /**
         * Creates a new FolderRequest instance using the specified properties.
         * @function create
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest=} [properties] Properties to set
         * @returns {Folder.FolderRequest} FolderRequest instance
         */
        FolderRequest.create = function create(properties) {
            return new FolderRequest(properties);
        };

        /**
         * Encodes the specified FolderRequest message. Does not implicitly {@link Folder.FolderRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest} message FolderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.folderType);
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentFolderUid);
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.folderData);
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.encryptedFolderKey);
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields"))
                $root.Folder.SharedFolderFields.encode(message.sharedFolderFields, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields"))
                $root.Folder.SharedFolderFolderFields.encode(message.sharedFolderFolderFields, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FolderRequest message, length delimited. Does not implicitly {@link Folder.FolderRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.IFolderRequest} message FolderRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FolderRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.FolderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.FolderRequest} FolderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.FolderRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.folderType = reader.int32();
                    break;
                case 3:
                    message.parentFolderUid = reader.bytes();
                    break;
                case 4:
                    message.folderData = reader.bytes();
                    break;
                case 5:
                    message.encryptedFolderKey = reader.bytes();
                    break;
                case 6:
                    message.sharedFolderFields = $root.Folder.SharedFolderFields.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FolderRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.FolderRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.FolderRequest} FolderRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FolderRequest message.
         * @function verify
         * @memberof Folder.FolderRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FolderRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                switch (message.folderType) {
                default:
                    return "folderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                if (!(message.parentFolderUid && typeof message.parentFolderUid.length === "number" || $util.isString(message.parentFolderUid)))
                    return "parentFolderUid: buffer expected";
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                if (!(message.folderData && typeof message.folderData.length === "number" || $util.isString(message.folderData)))
                    return "folderData: buffer expected";
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                if (!(message.encryptedFolderKey && typeof message.encryptedFolderKey.length === "number" || $util.isString(message.encryptedFolderKey)))
                    return "encryptedFolderKey: buffer expected";
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields")) {
                let error = $root.Folder.SharedFolderFields.verify(message.sharedFolderFields);
                if (error)
                    return "sharedFolderFields." + error;
            }
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields")) {
                let error = $root.Folder.SharedFolderFolderFields.verify(message.sharedFolderFolderFields);
                if (error)
                    return "sharedFolderFolderFields." + error;
            }
            return null;
        };

        /**
         * Creates a FolderRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.FolderRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.FolderRequest} FolderRequest
         */
        FolderRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.FolderRequest)
                return object;
            let message = new $root.Folder.FolderRequest();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            switch (object.folderType) {
            case "default_folder":
            case 0:
                message.folderType = 0;
                break;
            case "user_folder":
            case 1:
                message.folderType = 1;
                break;
            case "shared_folder":
            case 2:
                message.folderType = 2;
                break;
            case "shared_folder_folder":
            case 3:
                message.folderType = 3;
                break;
            }
            if (object.parentFolderUid != null)
                if (typeof object.parentFolderUid === "string")
                    $util.base64.decode(object.parentFolderUid, message.parentFolderUid = $util.newBuffer($util.base64.length(object.parentFolderUid)), 0);
                else if (object.parentFolderUid.length)
                    message.parentFolderUid = object.parentFolderUid;
            if (object.folderData != null)
                if (typeof object.folderData === "string")
                    $util.base64.decode(object.folderData, message.folderData = $util.newBuffer($util.base64.length(object.folderData)), 0);
                else if (object.folderData.length)
                    message.folderData = object.folderData;
            if (object.encryptedFolderKey != null)
                if (typeof object.encryptedFolderKey === "string")
                    $util.base64.decode(object.encryptedFolderKey, message.encryptedFolderKey = $util.newBuffer($util.base64.length(object.encryptedFolderKey)), 0);
                else if (object.encryptedFolderKey.length)
                    message.encryptedFolderKey = object.encryptedFolderKey;
            if (object.sharedFolderFields != null) {
                if (typeof object.sharedFolderFields !== "object")
                    throw TypeError(".Folder.FolderRequest.sharedFolderFields: object expected");
                message.sharedFolderFields = $root.Folder.SharedFolderFields.fromObject(object.sharedFolderFields);
            }
            if (object.sharedFolderFolderFields != null) {
                if (typeof object.sharedFolderFolderFields !== "object")
                    throw TypeError(".Folder.FolderRequest.sharedFolderFolderFields: object expected");
                message.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.fromObject(object.sharedFolderFolderFields);
            }
            return message;
        };

        /**
         * Creates a plain object from a FolderRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.FolderRequest
         * @static
         * @param {Folder.FolderRequest} message FolderRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FolderRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                object.folderType = options.enums === String ? "default_folder" : 0;
                if (options.bytes === String)
                    object.parentFolderUid = "";
                else {
                    object.parentFolderUid = [];
                    if (options.bytes !== Array)
                        object.parentFolderUid = $util.newBuffer(object.parentFolderUid);
                }
                if (options.bytes === String)
                    object.folderData = "";
                else {
                    object.folderData = [];
                    if (options.bytes !== Array)
                        object.folderData = $util.newBuffer(object.folderData);
                }
                if (options.bytes === String)
                    object.encryptedFolderKey = "";
                else {
                    object.encryptedFolderKey = [];
                    if (options.bytes !== Array)
                        object.encryptedFolderKey = $util.newBuffer(object.encryptedFolderKey);
                }
                object.sharedFolderFields = null;
                object.sharedFolderFolderFields = null;
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                object.folderType = options.enums === String ? $root.Folder.FolderType[message.folderType] : message.folderType;
            if (message.parentFolderUid != null && message.hasOwnProperty("parentFolderUid"))
                object.parentFolderUid = options.bytes === String ? $util.base64.encode(message.parentFolderUid, 0, message.parentFolderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentFolderUid) : message.parentFolderUid;
            if (message.folderData != null && message.hasOwnProperty("folderData"))
                object.folderData = options.bytes === String ? $util.base64.encode(message.folderData, 0, message.folderData.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderData) : message.folderData;
            if (message.encryptedFolderKey != null && message.hasOwnProperty("encryptedFolderKey"))
                object.encryptedFolderKey = options.bytes === String ? $util.base64.encode(message.encryptedFolderKey, 0, message.encryptedFolderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedFolderKey) : message.encryptedFolderKey;
            if (message.sharedFolderFields != null && message.hasOwnProperty("sharedFolderFields"))
                object.sharedFolderFields = $root.Folder.SharedFolderFields.toObject(message.sharedFolderFields, options);
            if (message.sharedFolderFolderFields != null && message.hasOwnProperty("sharedFolderFolderFields"))
                object.sharedFolderFolderFields = $root.Folder.SharedFolderFolderFields.toObject(message.sharedFolderFolderFields, options);
            return object;
        };

        /**
         * Converts this FolderRequest to JSON.
         * @function toJSON
         * @memberof Folder.FolderRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FolderRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FolderRequest;
    })();

    Folder.FolderResponse = (function() {

        /**
         * Properties of a FolderResponse.
         * @memberof Folder
         * @interface IFolderResponse
         * @property {Uint8Array|null} [folderUid] FolderResponse folderUid
         * @property {number|Long|null} [revision] FolderResponse revision
         * @property {string|null} [status] FolderResponse status
         */

        /**
         * Constructs a new FolderResponse.
         * @memberof Folder
         * @classdesc Represents a FolderResponse.
         * @implements IFolderResponse
         * @constructor
         * @param {Folder.IFolderResponse=} [properties] Properties to set
         */
        function FolderResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FolderResponse folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.folderUid = $util.newBuffer([]);

        /**
         * FolderResponse revision.
         * @member {number|Long} revision
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FolderResponse status.
         * @member {string} status
         * @memberof Folder.FolderResponse
         * @instance
         */
        FolderResponse.prototype.status = "";

        /**
         * Creates a new FolderResponse instance using the specified properties.
         * @function create
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse=} [properties] Properties to set
         * @returns {Folder.FolderResponse} FolderResponse instance
         */
        FolderResponse.create = function create(properties) {
            return new FolderResponse(properties);
        };

        /**
         * Encodes the specified FolderResponse message. Does not implicitly {@link Folder.FolderResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse} message FolderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.folderUid);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.revision);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
            return writer;
        };

        /**
         * Encodes the specified FolderResponse message, length delimited. Does not implicitly {@link Folder.FolderResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.IFolderResponse} message FolderResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FolderResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.FolderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.FolderResponse} FolderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.FolderResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.folderUid = reader.bytes();
                    break;
                case 2:
                    message.revision = reader.int64();
                    break;
                case 3:
                    message.status = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FolderResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.FolderResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.FolderResponse} FolderResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FolderResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FolderResponse message.
         * @function verify
         * @memberof Folder.FolderResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FolderResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isString(message.status))
                    return "status: string expected";
            return null;
        };

        /**
         * Creates a FolderResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.FolderResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.FolderResponse} FolderResponse
         */
        FolderResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.FolderResponse)
                return object;
            let message = new $root.Folder.FolderResponse();
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.status != null)
                message.status = String(object.status);
            return message;
        };

        /**
         * Creates a plain object from a FolderResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.FolderResponse
         * @static
         * @param {Folder.FolderResponse} message FolderResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FolderResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                object.status = "";
            }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            return object;
        };

        /**
         * Converts this FolderResponse to JSON.
         * @function toJSON
         * @memberof Folder.FolderResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FolderResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FolderResponse;
    })();

    Folder.ImportFolderRecordRequest = (function() {

        /**
         * Properties of an ImportFolderRecordRequest.
         * @memberof Folder
         * @interface IImportFolderRecordRequest
         * @property {Array.<Folder.IFolderRequest>|null} [folderRequest] ImportFolderRecordRequest folderRequest
         * @property {Array.<Folder.IRecordRequest>|null} [recordRequest] ImportFolderRecordRequest recordRequest
         */

        /**
         * Constructs a new ImportFolderRecordRequest.
         * @memberof Folder
         * @classdesc Represents an ImportFolderRecordRequest.
         * @implements IImportFolderRecordRequest
         * @constructor
         * @param {Folder.IImportFolderRecordRequest=} [properties] Properties to set
         */
        function ImportFolderRecordRequest(properties) {
            this.folderRequest = [];
            this.recordRequest = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportFolderRecordRequest folderRequest.
         * @member {Array.<Folder.IFolderRequest>} folderRequest
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         */
        ImportFolderRecordRequest.prototype.folderRequest = $util.emptyArray;

        /**
         * ImportFolderRecordRequest recordRequest.
         * @member {Array.<Folder.IRecordRequest>} recordRequest
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         */
        ImportFolderRecordRequest.prototype.recordRequest = $util.emptyArray;

        /**
         * Creates a new ImportFolderRecordRequest instance using the specified properties.
         * @function create
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest=} [properties] Properties to set
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest instance
         */
        ImportFolderRecordRequest.create = function create(properties) {
            return new ImportFolderRecordRequest(properties);
        };

        /**
         * Encodes the specified ImportFolderRecordRequest message. Does not implicitly {@link Folder.ImportFolderRecordRequest.verify|verify} messages.
         * @function encode
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest} message ImportFolderRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderRequest != null && message.folderRequest.length)
                for (let i = 0; i < message.folderRequest.length; ++i)
                    $root.Folder.FolderRequest.encode(message.folderRequest[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.recordRequest != null && message.recordRequest.length)
                for (let i = 0; i < message.recordRequest.length; ++i)
                    $root.Folder.RecordRequest.encode(message.recordRequest[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportFolderRecordRequest message, length delimited. Does not implicitly {@link Folder.ImportFolderRecordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.IImportFolderRecordRequest} message ImportFolderRecordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportFolderRecordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.ImportFolderRecordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.folderRequest && message.folderRequest.length))
                        message.folderRequest = [];
                    message.folderRequest.push($root.Folder.FolderRequest.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.recordRequest && message.recordRequest.length))
                        message.recordRequest = [];
                    message.recordRequest.push($root.Folder.RecordRequest.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportFolderRecordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportFolderRecordRequest message.
         * @function verify
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportFolderRecordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderRequest != null && message.hasOwnProperty("folderRequest")) {
                if (!Array.isArray(message.folderRequest))
                    return "folderRequest: array expected";
                for (let i = 0; i < message.folderRequest.length; ++i) {
                    let error = $root.Folder.FolderRequest.verify(message.folderRequest[i]);
                    if (error)
                        return "folderRequest." + error;
                }
            }
            if (message.recordRequest != null && message.hasOwnProperty("recordRequest")) {
                if (!Array.isArray(message.recordRequest))
                    return "recordRequest: array expected";
                for (let i = 0; i < message.recordRequest.length; ++i) {
                    let error = $root.Folder.RecordRequest.verify(message.recordRequest[i]);
                    if (error)
                        return "recordRequest." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportFolderRecordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.ImportFolderRecordRequest} ImportFolderRecordRequest
         */
        ImportFolderRecordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.ImportFolderRecordRequest)
                return object;
            let message = new $root.Folder.ImportFolderRecordRequest();
            if (object.folderRequest) {
                if (!Array.isArray(object.folderRequest))
                    throw TypeError(".Folder.ImportFolderRecordRequest.folderRequest: array expected");
                message.folderRequest = [];
                for (let i = 0; i < object.folderRequest.length; ++i) {
                    if (typeof object.folderRequest[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordRequest.folderRequest: object expected");
                    message.folderRequest[i] = $root.Folder.FolderRequest.fromObject(object.folderRequest[i]);
                }
            }
            if (object.recordRequest) {
                if (!Array.isArray(object.recordRequest))
                    throw TypeError(".Folder.ImportFolderRecordRequest.recordRequest: array expected");
                message.recordRequest = [];
                for (let i = 0; i < object.recordRequest.length; ++i) {
                    if (typeof object.recordRequest[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordRequest.recordRequest: object expected");
                    message.recordRequest[i] = $root.Folder.RecordRequest.fromObject(object.recordRequest[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportFolderRecordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.ImportFolderRecordRequest
         * @static
         * @param {Folder.ImportFolderRecordRequest} message ImportFolderRecordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportFolderRecordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.folderRequest = [];
                object.recordRequest = [];
            }
            if (message.folderRequest && message.folderRequest.length) {
                object.folderRequest = [];
                for (let j = 0; j < message.folderRequest.length; ++j)
                    object.folderRequest[j] = $root.Folder.FolderRequest.toObject(message.folderRequest[j], options);
            }
            if (message.recordRequest && message.recordRequest.length) {
                object.recordRequest = [];
                for (let j = 0; j < message.recordRequest.length; ++j)
                    object.recordRequest[j] = $root.Folder.RecordRequest.toObject(message.recordRequest[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportFolderRecordRequest to JSON.
         * @function toJSON
         * @memberof Folder.ImportFolderRecordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportFolderRecordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportFolderRecordRequest;
    })();

    Folder.ImportFolderRecordResponse = (function() {

        /**
         * Properties of an ImportFolderRecordResponse.
         * @memberof Folder
         * @interface IImportFolderRecordResponse
         * @property {Array.<Folder.IFolderResponse>|null} [folderResponse] ImportFolderRecordResponse folderResponse
         * @property {Array.<Folder.IRecordResponse>|null} [recordResponse] ImportFolderRecordResponse recordResponse
         */

        /**
         * Constructs a new ImportFolderRecordResponse.
         * @memberof Folder
         * @classdesc Represents an ImportFolderRecordResponse.
         * @implements IImportFolderRecordResponse
         * @constructor
         * @param {Folder.IImportFolderRecordResponse=} [properties] Properties to set
         */
        function ImportFolderRecordResponse(properties) {
            this.folderResponse = [];
            this.recordResponse = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImportFolderRecordResponse folderResponse.
         * @member {Array.<Folder.IFolderResponse>} folderResponse
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         */
        ImportFolderRecordResponse.prototype.folderResponse = $util.emptyArray;

        /**
         * ImportFolderRecordResponse recordResponse.
         * @member {Array.<Folder.IRecordResponse>} recordResponse
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         */
        ImportFolderRecordResponse.prototype.recordResponse = $util.emptyArray;

        /**
         * Creates a new ImportFolderRecordResponse instance using the specified properties.
         * @function create
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse=} [properties] Properties to set
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse instance
         */
        ImportFolderRecordResponse.create = function create(properties) {
            return new ImportFolderRecordResponse(properties);
        };

        /**
         * Encodes the specified ImportFolderRecordResponse message. Does not implicitly {@link Folder.ImportFolderRecordResponse.verify|verify} messages.
         * @function encode
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse} message ImportFolderRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.folderResponse != null && message.folderResponse.length)
                for (let i = 0; i < message.folderResponse.length; ++i)
                    $root.Folder.FolderResponse.encode(message.folderResponse[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.recordResponse != null && message.recordResponse.length)
                for (let i = 0; i < message.recordResponse.length; ++i)
                    $root.Folder.RecordResponse.encode(message.recordResponse[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImportFolderRecordResponse message, length delimited. Does not implicitly {@link Folder.ImportFolderRecordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.IImportFolderRecordResponse} message ImportFolderRecordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImportFolderRecordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImportFolderRecordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Folder.ImportFolderRecordResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.folderResponse && message.folderResponse.length))
                        message.folderResponse = [];
                    message.folderResponse.push($root.Folder.FolderResponse.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.recordResponse && message.recordResponse.length))
                        message.recordResponse = [];
                    message.recordResponse.push($root.Folder.RecordResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImportFolderRecordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImportFolderRecordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImportFolderRecordResponse message.
         * @function verify
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImportFolderRecordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.folderResponse != null && message.hasOwnProperty("folderResponse")) {
                if (!Array.isArray(message.folderResponse))
                    return "folderResponse: array expected";
                for (let i = 0; i < message.folderResponse.length; ++i) {
                    let error = $root.Folder.FolderResponse.verify(message.folderResponse[i]);
                    if (error)
                        return "folderResponse." + error;
                }
            }
            if (message.recordResponse != null && message.hasOwnProperty("recordResponse")) {
                if (!Array.isArray(message.recordResponse))
                    return "recordResponse: array expected";
                for (let i = 0; i < message.recordResponse.length; ++i) {
                    let error = $root.Folder.RecordResponse.verify(message.recordResponse[i]);
                    if (error)
                        return "recordResponse." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImportFolderRecordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Folder.ImportFolderRecordResponse} ImportFolderRecordResponse
         */
        ImportFolderRecordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Folder.ImportFolderRecordResponse)
                return object;
            let message = new $root.Folder.ImportFolderRecordResponse();
            if (object.folderResponse) {
                if (!Array.isArray(object.folderResponse))
                    throw TypeError(".Folder.ImportFolderRecordResponse.folderResponse: array expected");
                message.folderResponse = [];
                for (let i = 0; i < object.folderResponse.length; ++i) {
                    if (typeof object.folderResponse[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordResponse.folderResponse: object expected");
                    message.folderResponse[i] = $root.Folder.FolderResponse.fromObject(object.folderResponse[i]);
                }
            }
            if (object.recordResponse) {
                if (!Array.isArray(object.recordResponse))
                    throw TypeError(".Folder.ImportFolderRecordResponse.recordResponse: array expected");
                message.recordResponse = [];
                for (let i = 0; i < object.recordResponse.length; ++i) {
                    if (typeof object.recordResponse[i] !== "object")
                        throw TypeError(".Folder.ImportFolderRecordResponse.recordResponse: object expected");
                    message.recordResponse[i] = $root.Folder.RecordResponse.fromObject(object.recordResponse[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImportFolderRecordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Folder.ImportFolderRecordResponse
         * @static
         * @param {Folder.ImportFolderRecordResponse} message ImportFolderRecordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImportFolderRecordResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.folderResponse = [];
                object.recordResponse = [];
            }
            if (message.folderResponse && message.folderResponse.length) {
                object.folderResponse = [];
                for (let j = 0; j < message.folderResponse.length; ++j)
                    object.folderResponse[j] = $root.Folder.FolderResponse.toObject(message.folderResponse[j], options);
            }
            if (message.recordResponse && message.recordResponse.length) {
                object.recordResponse = [];
                for (let j = 0; j < message.recordResponse.length; ++j)
                    object.recordResponse[j] = $root.Folder.RecordResponse.toObject(message.recordResponse[j], options);
            }
            return object;
        };

        /**
         * Converts this ImportFolderRecordResponse to JSON.
         * @function toJSON
         * @memberof Folder.ImportFolderRecordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImportFolderRecordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ImportFolderRecordResponse;
    })();

    return Folder;
})();

export const Push = $root.Push = (() => {

    /**
     * Namespace Push.
     * @exports Push
     * @namespace
     */
    const Push = {};

    Push.UserRegistrationRequest = (function() {

        /**
         * Properties of a UserRegistrationRequest.
         * @memberof Push
         * @interface IUserRegistrationRequest
         * @property {Uint8Array|null} [messageSessionUid] UserRegistrationRequest messageSessionUid
         * @property {number|null} [userId] UserRegistrationRequest userId
         * @property {number|null} [enterpriseId] UserRegistrationRequest enterpriseId
         */

        /**
         * Constructs a new UserRegistrationRequest.
         * @memberof Push
         * @classdesc Represents a UserRegistrationRequest.
         * @implements IUserRegistrationRequest
         * @constructor
         * @param {Push.IUserRegistrationRequest=} [properties] Properties to set
         */
        function UserRegistrationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserRegistrationRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Push.UserRegistrationRequest
         * @instance
         */
        UserRegistrationRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * UserRegistrationRequest userId.
         * @member {number} userId
         * @memberof Push.UserRegistrationRequest
         * @instance
         */
        UserRegistrationRequest.prototype.userId = 0;

        /**
         * UserRegistrationRequest enterpriseId.
         * @member {number} enterpriseId
         * @memberof Push.UserRegistrationRequest
         * @instance
         */
        UserRegistrationRequest.prototype.enterpriseId = 0;

        /**
         * Creates a new UserRegistrationRequest instance using the specified properties.
         * @function create
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Push.IUserRegistrationRequest=} [properties] Properties to set
         * @returns {Push.UserRegistrationRequest} UserRegistrationRequest instance
         */
        UserRegistrationRequest.create = function create(properties) {
            return new UserRegistrationRequest(properties);
        };

        /**
         * Encodes the specified UserRegistrationRequest message. Does not implicitly {@link Push.UserRegistrationRequest.verify|verify} messages.
         * @function encode
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Push.IUserRegistrationRequest} message UserRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserRegistrationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageSessionUid);
            if (message.userId != null && message.hasOwnProperty("userId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userId);
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.enterpriseId);
            return writer;
        };

        /**
         * Encodes the specified UserRegistrationRequest message, length delimited. Does not implicitly {@link Push.UserRegistrationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Push.IUserRegistrationRequest} message UserRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserRegistrationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserRegistrationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.UserRegistrationRequest} UserRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserRegistrationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.UserRegistrationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                case 3:
                    message.enterpriseId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserRegistrationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.UserRegistrationRequest} UserRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserRegistrationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserRegistrationRequest message.
         * @function verify
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserRegistrationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isInteger(message.userId))
                    return "userId: integer expected";
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (!$util.isInteger(message.enterpriseId))
                    return "enterpriseId: integer expected";
            return null;
        };

        /**
         * Creates a UserRegistrationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.UserRegistrationRequest} UserRegistrationRequest
         */
        UserRegistrationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.UserRegistrationRequest)
                return object;
            let message = new $root.Push.UserRegistrationRequest();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.userId != null)
                message.userId = object.userId | 0;
            if (object.enterpriseId != null)
                message.enterpriseId = object.enterpriseId | 0;
            return message;
        };

        /**
         * Creates a plain object from a UserRegistrationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.UserRegistrationRequest
         * @static
         * @param {Push.UserRegistrationRequest} message UserRegistrationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserRegistrationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.userId = 0;
                object.enterpriseId = 0;
            }
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                object.enterpriseId = message.enterpriseId;
            return object;
        };

        /**
         * Converts this UserRegistrationRequest to JSON.
         * @function toJSON
         * @memberof Push.UserRegistrationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserRegistrationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UserRegistrationRequest;
    })();

    /**
     * MessageType enum.
     * @name Push.MessageType
     * @enum {string}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} DNA=1 DNA value
     * @property {number} SSO=2 SSO value
     * @property {number} CHAT=3 CHAT value
     * @property {number} USER=4 USER value
     * @property {number} ENTERPRISE=5 ENTERPRISE value
     * @property {number} KEEPER=6 KEEPER value
     * @property {number} SESSION=7 SESSION value
     * @property {number} DEVICE=8 DEVICE value
     * @property {number} TOTP=9 TOTP value
     */
    Push.MessageType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "DNA"] = 1;
        values[valuesById[2] = "SSO"] = 2;
        values[valuesById[3] = "CHAT"] = 3;
        values[valuesById[4] = "USER"] = 4;
        values[valuesById[5] = "ENTERPRISE"] = 5;
        values[valuesById[6] = "KEEPER"] = 6;
        values[valuesById[7] = "SESSION"] = 7;
        values[valuesById[8] = "DEVICE"] = 8;
        values[valuesById[9] = "TOTP"] = 9;
        return values;
    })();

    Push.KAToPushServerRequest = (function() {

        /**
         * Properties of a KAToPushServerRequest.
         * @memberof Push
         * @interface IKAToPushServerRequest
         * @property {Push.MessageType|null} [messageType] KAToPushServerRequest messageType
         * @property {string|null} [message] KAToPushServerRequest message
         * @property {Uint8Array|null} [messageSessionUid] KAToPushServerRequest messageSessionUid
         * @property {Array.<Uint8Array>|null} [encryptedDeviceToken] KAToPushServerRequest encryptedDeviceToken
         * @property {Array.<number>|null} [userId] KAToPushServerRequest userId
         * @property {Array.<number>|null} [enterpriseId] KAToPushServerRequest enterpriseId
         */

        /**
         * Constructs a new KAToPushServerRequest.
         * @memberof Push
         * @classdesc Represents a KAToPushServerRequest.
         * @implements IKAToPushServerRequest
         * @constructor
         * @param {Push.IKAToPushServerRequest=} [properties] Properties to set
         */
        function KAToPushServerRequest(properties) {
            this.encryptedDeviceToken = [];
            this.userId = [];
            this.enterpriseId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KAToPushServerRequest messageType.
         * @member {Push.MessageType} messageType
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.messageType = 0;

        /**
         * KAToPushServerRequest message.
         * @member {string} message
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.message = "";

        /**
         * KAToPushServerRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * KAToPushServerRequest encryptedDeviceToken.
         * @member {Array.<Uint8Array>} encryptedDeviceToken
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.encryptedDeviceToken = $util.emptyArray;

        /**
         * KAToPushServerRequest userId.
         * @member {Array.<number>} userId
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.userId = $util.emptyArray;

        /**
         * KAToPushServerRequest enterpriseId.
         * @member {Array.<number>} enterpriseId
         * @memberof Push.KAToPushServerRequest
         * @instance
         */
        KAToPushServerRequest.prototype.enterpriseId = $util.emptyArray;

        /**
         * Creates a new KAToPushServerRequest instance using the specified properties.
         * @function create
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Push.IKAToPushServerRequest=} [properties] Properties to set
         * @returns {Push.KAToPushServerRequest} KAToPushServerRequest instance
         */
        KAToPushServerRequest.create = function create(properties) {
            return new KAToPushServerRequest(properties);
        };

        /**
         * Encodes the specified KAToPushServerRequest message. Does not implicitly {@link Push.KAToPushServerRequest.verify|verify} messages.
         * @function encode
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Push.IKAToPushServerRequest} message KAToPushServerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KAToPushServerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.messageSessionUid);
            if (message.encryptedDeviceToken != null && message.encryptedDeviceToken.length)
                for (let i = 0; i < message.encryptedDeviceToken.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedDeviceToken[i]);
            if (message.userId != null && message.userId.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.userId.length; ++i)
                    writer.int32(message.userId[i]);
                writer.ldelim();
            }
            if (message.enterpriseId != null && message.enterpriseId.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.enterpriseId.length; ++i)
                    writer.int32(message.enterpriseId[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified KAToPushServerRequest message, length delimited. Does not implicitly {@link Push.KAToPushServerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Push.IKAToPushServerRequest} message KAToPushServerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KAToPushServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KAToPushServerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.KAToPushServerRequest} KAToPushServerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KAToPushServerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.KAToPushServerRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                case 3:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 4:
                    if (!(message.encryptedDeviceToken && message.encryptedDeviceToken.length))
                        message.encryptedDeviceToken = [];
                    message.encryptedDeviceToken.push(reader.bytes());
                    break;
                case 5:
                    if (!(message.userId && message.userId.length))
                        message.userId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.userId.push(reader.int32());
                    } else
                        message.userId.push(reader.int32());
                    break;
                case 6:
                    if (!(message.enterpriseId && message.enterpriseId.length))
                        message.enterpriseId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enterpriseId.push(reader.int32());
                    } else
                        message.enterpriseId.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KAToPushServerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.KAToPushServerRequest} KAToPushServerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KAToPushServerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KAToPushServerRequest message.
         * @function verify
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KAToPushServerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                switch (message.messageType) {
                default:
                    return "messageType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken")) {
                if (!Array.isArray(message.encryptedDeviceToken))
                    return "encryptedDeviceToken: array expected";
                for (let i = 0; i < message.encryptedDeviceToken.length; ++i)
                    if (!(message.encryptedDeviceToken[i] && typeof message.encryptedDeviceToken[i].length === "number" || $util.isString(message.encryptedDeviceToken[i])))
                        return "encryptedDeviceToken: buffer[] expected";
            }
            if (message.userId != null && message.hasOwnProperty("userId")) {
                if (!Array.isArray(message.userId))
                    return "userId: array expected";
                for (let i = 0; i < message.userId.length; ++i)
                    if (!$util.isInteger(message.userId[i]))
                        return "userId: integer[] expected";
            }
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId")) {
                if (!Array.isArray(message.enterpriseId))
                    return "enterpriseId: array expected";
                for (let i = 0; i < message.enterpriseId.length; ++i)
                    if (!$util.isInteger(message.enterpriseId[i]))
                        return "enterpriseId: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a KAToPushServerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.KAToPushServerRequest} KAToPushServerRequest
         */
        KAToPushServerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.KAToPushServerRequest)
                return object;
            let message = new $root.Push.KAToPushServerRequest();
            switch (object.messageType) {
            case "UNKNOWN":
            case 0:
                message.messageType = 0;
                break;
            case "DNA":
            case 1:
                message.messageType = 1;
                break;
            case "SSO":
            case 2:
                message.messageType = 2;
                break;
            case "CHAT":
            case 3:
                message.messageType = 3;
                break;
            case "USER":
            case 4:
                message.messageType = 4;
                break;
            case "ENTERPRISE":
            case 5:
                message.messageType = 5;
                break;
            case "KEEPER":
            case 6:
                message.messageType = 6;
                break;
            case "SESSION":
            case 7:
                message.messageType = 7;
                break;
            case "DEVICE":
            case 8:
                message.messageType = 8;
                break;
            case "TOTP":
            case 9:
                message.messageType = 9;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.encryptedDeviceToken) {
                if (!Array.isArray(object.encryptedDeviceToken))
                    throw TypeError(".Push.KAToPushServerRequest.encryptedDeviceToken: array expected");
                message.encryptedDeviceToken = [];
                for (let i = 0; i < object.encryptedDeviceToken.length; ++i)
                    if (typeof object.encryptedDeviceToken[i] === "string")
                        $util.base64.decode(object.encryptedDeviceToken[i], message.encryptedDeviceToken[i] = $util.newBuffer($util.base64.length(object.encryptedDeviceToken[i])), 0);
                    else if (object.encryptedDeviceToken[i].length)
                        message.encryptedDeviceToken[i] = object.encryptedDeviceToken[i];
            }
            if (object.userId) {
                if (!Array.isArray(object.userId))
                    throw TypeError(".Push.KAToPushServerRequest.userId: array expected");
                message.userId = [];
                for (let i = 0; i < object.userId.length; ++i)
                    message.userId[i] = object.userId[i] | 0;
            }
            if (object.enterpriseId) {
                if (!Array.isArray(object.enterpriseId))
                    throw TypeError(".Push.KAToPushServerRequest.enterpriseId: array expected");
                message.enterpriseId = [];
                for (let i = 0; i < object.enterpriseId.length; ++i)
                    message.enterpriseId[i] = object.enterpriseId[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a KAToPushServerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.KAToPushServerRequest
         * @static
         * @param {Push.KAToPushServerRequest} message KAToPushServerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KAToPushServerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.encryptedDeviceToken = [];
                object.userId = [];
                object.enterpriseId = [];
            }
            if (options.defaults) {
                object.messageType = options.enums === String ? "UNKNOWN" : 0;
                object.message = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = options.enums === String ? $root.Push.MessageType[message.messageType] : message.messageType;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.encryptedDeviceToken && message.encryptedDeviceToken.length) {
                object.encryptedDeviceToken = [];
                for (let j = 0; j < message.encryptedDeviceToken.length; ++j)
                    object.encryptedDeviceToken[j] = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken[j], 0, message.encryptedDeviceToken[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken[j]) : message.encryptedDeviceToken[j];
            }
            if (message.userId && message.userId.length) {
                object.userId = [];
                for (let j = 0; j < message.userId.length; ++j)
                    object.userId[j] = message.userId[j];
            }
            if (message.enterpriseId && message.enterpriseId.length) {
                object.enterpriseId = [];
                for (let j = 0; j < message.enterpriseId.length; ++j)
                    object.enterpriseId[j] = message.enterpriseId[j];
            }
            return object;
        };

        /**
         * Converts this KAToPushServerRequest to JSON.
         * @function toJSON
         * @memberof Push.KAToPushServerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KAToPushServerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return KAToPushServerRequest;
    })();

    Push.WssConnectionRequest = (function() {

        /**
         * Properties of a WssConnectionRequest.
         * @memberof Push
         * @interface IWssConnectionRequest
         * @property {Uint8Array|null} [messageSessionUid] WssConnectionRequest messageSessionUid
         * @property {Uint8Array|null} [encryptedDeviceToken] WssConnectionRequest encryptedDeviceToken
         * @property {number|Long|null} [deviceTimeStamp] WssConnectionRequest deviceTimeStamp
         */

        /**
         * Constructs a new WssConnectionRequest.
         * @memberof Push
         * @classdesc Represents a WssConnectionRequest.
         * @implements IWssConnectionRequest
         * @constructor
         * @param {Push.IWssConnectionRequest=} [properties] Properties to set
         */
        function WssConnectionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WssConnectionRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof Push.WssConnectionRequest
         * @instance
         */
        WssConnectionRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * WssConnectionRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Push.WssConnectionRequest
         * @instance
         */
        WssConnectionRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * WssConnectionRequest deviceTimeStamp.
         * @member {number|Long} deviceTimeStamp
         * @memberof Push.WssConnectionRequest
         * @instance
         */
        WssConnectionRequest.prototype.deviceTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new WssConnectionRequest instance using the specified properties.
         * @function create
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Push.IWssConnectionRequest=} [properties] Properties to set
         * @returns {Push.WssConnectionRequest} WssConnectionRequest instance
         */
        WssConnectionRequest.create = function create(properties) {
            return new WssConnectionRequest(properties);
        };

        /**
         * Encodes the specified WssConnectionRequest message. Does not implicitly {@link Push.WssConnectionRequest.verify|verify} messages.
         * @function encode
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Push.IWssConnectionRequest} message WssConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WssConnectionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageSessionUid);
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encryptedDeviceToken);
            if (message.deviceTimeStamp != null && message.hasOwnProperty("deviceTimeStamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.deviceTimeStamp);
            return writer;
        };

        /**
         * Encodes the specified WssConnectionRequest message, length delimited. Does not implicitly {@link Push.WssConnectionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Push.IWssConnectionRequest} message WssConnectionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WssConnectionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WssConnectionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.WssConnectionRequest} WssConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WssConnectionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.WssConnectionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 2:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 3:
                    message.deviceTimeStamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WssConnectionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.WssConnectionRequest} WssConnectionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WssConnectionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WssConnectionRequest message.
         * @function verify
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WssConnectionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.deviceTimeStamp != null && message.hasOwnProperty("deviceTimeStamp"))
                if (!$util.isInteger(message.deviceTimeStamp) && !(message.deviceTimeStamp && $util.isInteger(message.deviceTimeStamp.low) && $util.isInteger(message.deviceTimeStamp.high)))
                    return "deviceTimeStamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a WssConnectionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.WssConnectionRequest} WssConnectionRequest
         */
        WssConnectionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.WssConnectionRequest)
                return object;
            let message = new $root.Push.WssConnectionRequest();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.deviceTimeStamp != null)
                if ($util.Long)
                    (message.deviceTimeStamp = $util.Long.fromValue(object.deviceTimeStamp)).unsigned = false;
                else if (typeof object.deviceTimeStamp === "string")
                    message.deviceTimeStamp = parseInt(object.deviceTimeStamp, 10);
                else if (typeof object.deviceTimeStamp === "number")
                    message.deviceTimeStamp = object.deviceTimeStamp;
                else if (typeof object.deviceTimeStamp === "object")
                    message.deviceTimeStamp = new $util.LongBits(object.deviceTimeStamp.low >>> 0, object.deviceTimeStamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a WssConnectionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.WssConnectionRequest
         * @static
         * @param {Push.WssConnectionRequest} message WssConnectionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WssConnectionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.deviceTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.deviceTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.deviceTimeStamp != null && message.hasOwnProperty("deviceTimeStamp"))
                if (typeof message.deviceTimeStamp === "number")
                    object.deviceTimeStamp = options.longs === String ? String(message.deviceTimeStamp) : message.deviceTimeStamp;
                else
                    object.deviceTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.deviceTimeStamp) : options.longs === Number ? new $util.LongBits(message.deviceTimeStamp.low >>> 0, message.deviceTimeStamp.high >>> 0).toNumber() : message.deviceTimeStamp;
            return object;
        };

        /**
         * Converts this WssConnectionRequest to JSON.
         * @function toJSON
         * @memberof Push.WssConnectionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WssConnectionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WssConnectionRequest;
    })();

    Push.WssClientResponse = (function() {

        /**
         * Properties of a WssClientResponse.
         * @memberof Push
         * @interface IWssClientResponse
         * @property {Push.MessageType|null} [messageType] WssClientResponse messageType
         * @property {string|null} [message] WssClientResponse message
         */

        /**
         * Constructs a new WssClientResponse.
         * @memberof Push
         * @classdesc Represents a WssClientResponse.
         * @implements IWssClientResponse
         * @constructor
         * @param {Push.IWssClientResponse=} [properties] Properties to set
         */
        function WssClientResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WssClientResponse messageType.
         * @member {Push.MessageType} messageType
         * @memberof Push.WssClientResponse
         * @instance
         */
        WssClientResponse.prototype.messageType = 0;

        /**
         * WssClientResponse message.
         * @member {string} message
         * @memberof Push.WssClientResponse
         * @instance
         */
        WssClientResponse.prototype.message = "";

        /**
         * Creates a new WssClientResponse instance using the specified properties.
         * @function create
         * @memberof Push.WssClientResponse
         * @static
         * @param {Push.IWssClientResponse=} [properties] Properties to set
         * @returns {Push.WssClientResponse} WssClientResponse instance
         */
        WssClientResponse.create = function create(properties) {
            return new WssClientResponse(properties);
        };

        /**
         * Encodes the specified WssClientResponse message. Does not implicitly {@link Push.WssClientResponse.verify|verify} messages.
         * @function encode
         * @memberof Push.WssClientResponse
         * @static
         * @param {Push.IWssClientResponse} message WssClientResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WssClientResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified WssClientResponse message, length delimited. Does not implicitly {@link Push.WssClientResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.WssClientResponse
         * @static
         * @param {Push.IWssClientResponse} message WssClientResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WssClientResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WssClientResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Push.WssClientResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.WssClientResponse} WssClientResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WssClientResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.WssClientResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.int32();
                    break;
                case 2:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WssClientResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.WssClientResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.WssClientResponse} WssClientResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WssClientResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WssClientResponse message.
         * @function verify
         * @memberof Push.WssClientResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WssClientResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                switch (message.messageType) {
                default:
                    return "messageType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a WssClientResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.WssClientResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.WssClientResponse} WssClientResponse
         */
        WssClientResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.WssClientResponse)
                return object;
            let message = new $root.Push.WssClientResponse();
            switch (object.messageType) {
            case "UNKNOWN":
            case 0:
                message.messageType = 0;
                break;
            case "DNA":
            case 1:
                message.messageType = 1;
                break;
            case "SSO":
            case 2:
                message.messageType = 2;
                break;
            case "CHAT":
            case 3:
                message.messageType = 3;
                break;
            case "USER":
            case 4:
                message.messageType = 4;
                break;
            case "ENTERPRISE":
            case 5:
                message.messageType = 5;
                break;
            case "KEEPER":
            case 6:
                message.messageType = 6;
                break;
            case "SESSION":
            case 7:
                message.messageType = 7;
                break;
            case "DEVICE":
            case 8:
                message.messageType = 8;
                break;
            case "TOTP":
            case 9:
                message.messageType = 9;
                break;
            }
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a WssClientResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.WssClientResponse
         * @static
         * @param {Push.WssClientResponse} message WssClientResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WssClientResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.messageType = options.enums === String ? "UNKNOWN" : 0;
                object.message = "";
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = options.enums === String ? $root.Push.MessageType[message.messageType] : message.messageType;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this WssClientResponse to JSON.
         * @function toJSON
         * @memberof Push.WssClientResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WssClientResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WssClientResponse;
    })();

    Push.PushServerDeviceRegistrationRequest = (function() {

        /**
         * Properties of a PushServerDeviceRegistrationRequest.
         * @memberof Push
         * @interface IPushServerDeviceRegistrationRequest
         * @property {Uint8Array|null} [encryptedDeviceToken] PushServerDeviceRegistrationRequest encryptedDeviceToken
         * @property {string|null} [pushToken] PushServerDeviceRegistrationRequest pushToken
         * @property {string|null} [mobilePushPlatform] PushServerDeviceRegistrationRequest mobilePushPlatform
         * @property {Uint8Array|null} [transmissionKey] PushServerDeviceRegistrationRequest transmissionKey
         */

        /**
         * Constructs a new PushServerDeviceRegistrationRequest.
         * @memberof Push
         * @classdesc Represents a PushServerDeviceRegistrationRequest.
         * @implements IPushServerDeviceRegistrationRequest
         * @constructor
         * @param {Push.IPushServerDeviceRegistrationRequest=} [properties] Properties to set
         */
        function PushServerDeviceRegistrationRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PushServerDeviceRegistrationRequest encryptedDeviceToken.
         * @member {Uint8Array} encryptedDeviceToken
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @instance
         */
        PushServerDeviceRegistrationRequest.prototype.encryptedDeviceToken = $util.newBuffer([]);

        /**
         * PushServerDeviceRegistrationRequest pushToken.
         * @member {string} pushToken
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @instance
         */
        PushServerDeviceRegistrationRequest.prototype.pushToken = "";

        /**
         * PushServerDeviceRegistrationRequest mobilePushPlatform.
         * @member {string} mobilePushPlatform
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @instance
         */
        PushServerDeviceRegistrationRequest.prototype.mobilePushPlatform = "";

        /**
         * PushServerDeviceRegistrationRequest transmissionKey.
         * @member {Uint8Array} transmissionKey
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @instance
         */
        PushServerDeviceRegistrationRequest.prototype.transmissionKey = $util.newBuffer([]);

        /**
         * Creates a new PushServerDeviceRegistrationRequest instance using the specified properties.
         * @function create
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Push.IPushServerDeviceRegistrationRequest=} [properties] Properties to set
         * @returns {Push.PushServerDeviceRegistrationRequest} PushServerDeviceRegistrationRequest instance
         */
        PushServerDeviceRegistrationRequest.create = function create(properties) {
            return new PushServerDeviceRegistrationRequest(properties);
        };

        /**
         * Encodes the specified PushServerDeviceRegistrationRequest message. Does not implicitly {@link Push.PushServerDeviceRegistrationRequest.verify|verify} messages.
         * @function encode
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Push.IPushServerDeviceRegistrationRequest} message PushServerDeviceRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushServerDeviceRegistrationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryptedDeviceToken);
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pushToken);
            if (message.mobilePushPlatform != null && message.hasOwnProperty("mobilePushPlatform"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.mobilePushPlatform);
            if (message.transmissionKey != null && message.hasOwnProperty("transmissionKey"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.transmissionKey);
            return writer;
        };

        /**
         * Encodes the specified PushServerDeviceRegistrationRequest message, length delimited. Does not implicitly {@link Push.PushServerDeviceRegistrationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Push.IPushServerDeviceRegistrationRequest} message PushServerDeviceRegistrationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PushServerDeviceRegistrationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PushServerDeviceRegistrationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.PushServerDeviceRegistrationRequest} PushServerDeviceRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushServerDeviceRegistrationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.PushServerDeviceRegistrationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryptedDeviceToken = reader.bytes();
                    break;
                case 2:
                    message.pushToken = reader.string();
                    break;
                case 3:
                    message.mobilePushPlatform = reader.string();
                    break;
                case 4:
                    message.transmissionKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PushServerDeviceRegistrationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.PushServerDeviceRegistrationRequest} PushServerDeviceRegistrationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PushServerDeviceRegistrationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PushServerDeviceRegistrationRequest message.
         * @function verify
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PushServerDeviceRegistrationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                if (!(message.encryptedDeviceToken && typeof message.encryptedDeviceToken.length === "number" || $util.isString(message.encryptedDeviceToken)))
                    return "encryptedDeviceToken: buffer expected";
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                if (!$util.isString(message.pushToken))
                    return "pushToken: string expected";
            if (message.mobilePushPlatform != null && message.hasOwnProperty("mobilePushPlatform"))
                if (!$util.isString(message.mobilePushPlatform))
                    return "mobilePushPlatform: string expected";
            if (message.transmissionKey != null && message.hasOwnProperty("transmissionKey"))
                if (!(message.transmissionKey && typeof message.transmissionKey.length === "number" || $util.isString(message.transmissionKey)))
                    return "transmissionKey: buffer expected";
            return null;
        };

        /**
         * Creates a PushServerDeviceRegistrationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.PushServerDeviceRegistrationRequest} PushServerDeviceRegistrationRequest
         */
        PushServerDeviceRegistrationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.PushServerDeviceRegistrationRequest)
                return object;
            let message = new $root.Push.PushServerDeviceRegistrationRequest();
            if (object.encryptedDeviceToken != null)
                if (typeof object.encryptedDeviceToken === "string")
                    $util.base64.decode(object.encryptedDeviceToken, message.encryptedDeviceToken = $util.newBuffer($util.base64.length(object.encryptedDeviceToken)), 0);
                else if (object.encryptedDeviceToken.length)
                    message.encryptedDeviceToken = object.encryptedDeviceToken;
            if (object.pushToken != null)
                message.pushToken = String(object.pushToken);
            if (object.mobilePushPlatform != null)
                message.mobilePushPlatform = String(object.mobilePushPlatform);
            if (object.transmissionKey != null)
                if (typeof object.transmissionKey === "string")
                    $util.base64.decode(object.transmissionKey, message.transmissionKey = $util.newBuffer($util.base64.length(object.transmissionKey)), 0);
                else if (object.transmissionKey.length)
                    message.transmissionKey = object.transmissionKey;
            return message;
        };

        /**
         * Creates a plain object from a PushServerDeviceRegistrationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @static
         * @param {Push.PushServerDeviceRegistrationRequest} message PushServerDeviceRegistrationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PushServerDeviceRegistrationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.encryptedDeviceToken = "";
                else {
                    object.encryptedDeviceToken = [];
                    if (options.bytes !== Array)
                        object.encryptedDeviceToken = $util.newBuffer(object.encryptedDeviceToken);
                }
                object.pushToken = "";
                object.mobilePushPlatform = "";
                if (options.bytes === String)
                    object.transmissionKey = "";
                else {
                    object.transmissionKey = [];
                    if (options.bytes !== Array)
                        object.transmissionKey = $util.newBuffer(object.transmissionKey);
                }
            }
            if (message.encryptedDeviceToken != null && message.hasOwnProperty("encryptedDeviceToken"))
                object.encryptedDeviceToken = options.bytes === String ? $util.base64.encode(message.encryptedDeviceToken, 0, message.encryptedDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedDeviceToken) : message.encryptedDeviceToken;
            if (message.pushToken != null && message.hasOwnProperty("pushToken"))
                object.pushToken = message.pushToken;
            if (message.mobilePushPlatform != null && message.hasOwnProperty("mobilePushPlatform"))
                object.mobilePushPlatform = message.mobilePushPlatform;
            if (message.transmissionKey != null && message.hasOwnProperty("transmissionKey"))
                object.transmissionKey = options.bytes === String ? $util.base64.encode(message.transmissionKey, 0, message.transmissionKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.transmissionKey) : message.transmissionKey;
            return object;
        };

        /**
         * Converts this PushServerDeviceRegistrationRequest to JSON.
         * @function toJSON
         * @memberof Push.PushServerDeviceRegistrationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PushServerDeviceRegistrationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PushServerDeviceRegistrationRequest;
    })();

    Push.SnsMessage = (function() {

        /**
         * Properties of a SnsMessage.
         * @memberof Push
         * @interface ISnsMessage
         * @property {Push.MessageType|null} [messageType] SnsMessage messageType
         * @property {Uint8Array|null} [message] SnsMessage message
         */

        /**
         * Constructs a new SnsMessage.
         * @memberof Push
         * @classdesc Represents a SnsMessage.
         * @implements ISnsMessage
         * @constructor
         * @param {Push.ISnsMessage=} [properties] Properties to set
         */
        function SnsMessage(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnsMessage messageType.
         * @member {Push.MessageType} messageType
         * @memberof Push.SnsMessage
         * @instance
         */
        SnsMessage.prototype.messageType = 0;

        /**
         * SnsMessage message.
         * @member {Uint8Array} message
         * @memberof Push.SnsMessage
         * @instance
         */
        SnsMessage.prototype.message = $util.newBuffer([]);

        /**
         * Creates a new SnsMessage instance using the specified properties.
         * @function create
         * @memberof Push.SnsMessage
         * @static
         * @param {Push.ISnsMessage=} [properties] Properties to set
         * @returns {Push.SnsMessage} SnsMessage instance
         */
        SnsMessage.create = function create(properties) {
            return new SnsMessage(properties);
        };

        /**
         * Encodes the specified SnsMessage message. Does not implicitly {@link Push.SnsMessage.verify|verify} messages.
         * @function encode
         * @memberof Push.SnsMessage
         * @static
         * @param {Push.ISnsMessage} message SnsMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnsMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.messageType);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.message);
            return writer;
        };

        /**
         * Encodes the specified SnsMessage message, length delimited. Does not implicitly {@link Push.SnsMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Push.SnsMessage
         * @static
         * @param {Push.ISnsMessage} message SnsMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnsMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnsMessage message from the specified reader or buffer.
         * @function decode
         * @memberof Push.SnsMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Push.SnsMessage} SnsMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnsMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Push.SnsMessage();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageType = reader.int32();
                    break;
                case 2:
                    message.message = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SnsMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Push.SnsMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Push.SnsMessage} SnsMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnsMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnsMessage message.
         * @function verify
         * @memberof Push.SnsMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnsMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                switch (message.messageType) {
                default:
                    return "messageType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                    return "message: buffer expected";
            return null;
        };

        /**
         * Creates a SnsMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Push.SnsMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Push.SnsMessage} SnsMessage
         */
        SnsMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.Push.SnsMessage)
                return object;
            let message = new $root.Push.SnsMessage();
            switch (object.messageType) {
            case "UNKNOWN":
            case 0:
                message.messageType = 0;
                break;
            case "DNA":
            case 1:
                message.messageType = 1;
                break;
            case "SSO":
            case 2:
                message.messageType = 2;
                break;
            case "CHAT":
            case 3:
                message.messageType = 3;
                break;
            case "USER":
            case 4:
                message.messageType = 4;
                break;
            case "ENTERPRISE":
            case 5:
                message.messageType = 5;
                break;
            case "KEEPER":
            case 6:
                message.messageType = 6;
                break;
            case "SESSION":
            case 7:
                message.messageType = 7;
                break;
            case "DEVICE":
            case 8:
                message.messageType = 8;
                break;
            case "TOTP":
            case 9:
                message.messageType = 9;
                break;
            }
            if (object.message != null)
                if (typeof object.message === "string")
                    $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                else if (object.message.length)
                    message.message = object.message;
            return message;
        };

        /**
         * Creates a plain object from a SnsMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Push.SnsMessage
         * @static
         * @param {Push.SnsMessage} message SnsMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnsMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.messageType = options.enums === String ? "UNKNOWN" : 0;
                if (options.bytes === String)
                    object.message = "";
                else {
                    object.message = [];
                    if (options.bytes !== Array)
                        object.message = $util.newBuffer(object.message);
                }
            }
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = options.enums === String ? $root.Push.MessageType[message.messageType] : message.messageType;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
            return object;
        };

        /**
         * Converts this SnsMessage to JSON.
         * @function toJSON
         * @memberof Push.SnsMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnsMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SnsMessage;
    })();

    return Push;
})();

export const Records = $root.Records = (() => {

    /**
     * Namespace Records.
     * @exports Records
     * @namespace
     */
    const Records = {};

    /**
     * RecordTypeScope enum.
     * @name Records.RecordTypeScope
     * @enum {string}
     * @property {number} RT_STANDARD=0 RT_STANDARD value
     * @property {number} RT_USER=1 RT_USER value
     * @property {number} RT_ENTERPRISE=2 RT_ENTERPRISE value
     */
    Records.RecordTypeScope = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RT_STANDARD"] = 0;
        values[valuesById[1] = "RT_USER"] = 1;
        values[valuesById[2] = "RT_ENTERPRISE"] = 2;
        return values;
    })();

    Records.RecordType = (function() {

        /**
         * Properties of a RecordType.
         * @memberof Records
         * @interface IRecordType
         * @property {number|null} [recordTypeId] RecordType recordTypeId
         * @property {string|null} [content] RecordType content
         * @property {Records.RecordTypeScope|null} [scope] RecordType scope
         */

        /**
         * Constructs a new RecordType.
         * @memberof Records
         * @classdesc Represents a RecordType.
         * @implements IRecordType
         * @constructor
         * @param {Records.IRecordType=} [properties] Properties to set
         */
        function RecordType(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordType recordTypeId.
         * @member {number} recordTypeId
         * @memberof Records.RecordType
         * @instance
         */
        RecordType.prototype.recordTypeId = 0;

        /**
         * RecordType content.
         * @member {string} content
         * @memberof Records.RecordType
         * @instance
         */
        RecordType.prototype.content = "";

        /**
         * RecordType scope.
         * @member {Records.RecordTypeScope} scope
         * @memberof Records.RecordType
         * @instance
         */
        RecordType.prototype.scope = 0;

        /**
         * Creates a new RecordType instance using the specified properties.
         * @function create
         * @memberof Records.RecordType
         * @static
         * @param {Records.IRecordType=} [properties] Properties to set
         * @returns {Records.RecordType} RecordType instance
         */
        RecordType.create = function create(properties) {
            return new RecordType(properties);
        };

        /**
         * Encodes the specified RecordType message. Does not implicitly {@link Records.RecordType.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordType
         * @static
         * @param {Records.IRecordType} message RecordType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.recordTypeId);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            if (message.scope != null && message.hasOwnProperty("scope"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scope);
            return writer;
        };

        /**
         * Encodes the specified RecordType message, length delimited. Does not implicitly {@link Records.RecordType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordType
         * @static
         * @param {Records.IRecordType} message RecordType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordType message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordType} RecordType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordType();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordTypeId = reader.int32();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                case 3:
                    message.scope = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordType} RecordType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordType message.
         * @function verify
         * @memberof Records.RecordType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                if (!$util.isInteger(message.recordTypeId))
                    return "recordTypeId: integer expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.scope != null && message.hasOwnProperty("scope"))
                switch (message.scope) {
                default:
                    return "scope: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RecordType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordType} RecordType
         */
        RecordType.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordType)
                return object;
            let message = new $root.Records.RecordType();
            if (object.recordTypeId != null)
                message.recordTypeId = object.recordTypeId | 0;
            if (object.content != null)
                message.content = String(object.content);
            switch (object.scope) {
            case "RT_STANDARD":
            case 0:
                message.scope = 0;
                break;
            case "RT_USER":
            case 1:
                message.scope = 1;
                break;
            case "RT_ENTERPRISE":
            case 2:
                message.scope = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordType
         * @static
         * @param {Records.RecordType} message RecordType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.recordTypeId = 0;
                object.content = "";
                object.scope = options.enums === String ? "RT_STANDARD" : 0;
            }
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                object.recordTypeId = message.recordTypeId;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.scope != null && message.hasOwnProperty("scope"))
                object.scope = options.enums === String ? $root.Records.RecordTypeScope[message.scope] : message.scope;
            return object;
        };

        /**
         * Converts this RecordType to JSON.
         * @function toJSON
         * @memberof Records.RecordType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordType;
    })();

    Records.RecordTypesRequest = (function() {

        /**
         * Properties of a RecordTypesRequest.
         * @memberof Records
         * @interface IRecordTypesRequest
         * @property {boolean|null} [standard] RecordTypesRequest standard
         * @property {boolean|null} [user] RecordTypesRequest user
         * @property {boolean|null} [enterprise] RecordTypesRequest enterprise
         */

        /**
         * Constructs a new RecordTypesRequest.
         * @memberof Records
         * @classdesc Represents a RecordTypesRequest.
         * @implements IRecordTypesRequest
         * @constructor
         * @param {Records.IRecordTypesRequest=} [properties] Properties to set
         */
        function RecordTypesRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordTypesRequest standard.
         * @member {boolean} standard
         * @memberof Records.RecordTypesRequest
         * @instance
         */
        RecordTypesRequest.prototype.standard = false;

        /**
         * RecordTypesRequest user.
         * @member {boolean} user
         * @memberof Records.RecordTypesRequest
         * @instance
         */
        RecordTypesRequest.prototype.user = false;

        /**
         * RecordTypesRequest enterprise.
         * @member {boolean} enterprise
         * @memberof Records.RecordTypesRequest
         * @instance
         */
        RecordTypesRequest.prototype.enterprise = false;

        /**
         * Creates a new RecordTypesRequest instance using the specified properties.
         * @function create
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Records.IRecordTypesRequest=} [properties] Properties to set
         * @returns {Records.RecordTypesRequest} RecordTypesRequest instance
         */
        RecordTypesRequest.create = function create(properties) {
            return new RecordTypesRequest(properties);
        };

        /**
         * Encodes the specified RecordTypesRequest message. Does not implicitly {@link Records.RecordTypesRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Records.IRecordTypesRequest} message RecordTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.standard != null && message.hasOwnProperty("standard"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.standard);
            if (message.user != null && message.hasOwnProperty("user"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.user);
            if (message.enterprise != null && message.hasOwnProperty("enterprise"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.enterprise);
            return writer;
        };

        /**
         * Encodes the specified RecordTypesRequest message, length delimited. Does not implicitly {@link Records.RecordTypesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Records.IRecordTypesRequest} message RecordTypesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordTypesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordTypesRequest} RecordTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordTypesRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.standard = reader.bool();
                    break;
                case 2:
                    message.user = reader.bool();
                    break;
                case 3:
                    message.enterprise = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordTypesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordTypesRequest} RecordTypesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordTypesRequest message.
         * @function verify
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordTypesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.standard != null && message.hasOwnProperty("standard"))
                if (typeof message.standard !== "boolean")
                    return "standard: boolean expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (typeof message.user !== "boolean")
                    return "user: boolean expected";
            if (message.enterprise != null && message.hasOwnProperty("enterprise"))
                if (typeof message.enterprise !== "boolean")
                    return "enterprise: boolean expected";
            return null;
        };

        /**
         * Creates a RecordTypesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordTypesRequest} RecordTypesRequest
         */
        RecordTypesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordTypesRequest)
                return object;
            let message = new $root.Records.RecordTypesRequest();
            if (object.standard != null)
                message.standard = Boolean(object.standard);
            if (object.user != null)
                message.user = Boolean(object.user);
            if (object.enterprise != null)
                message.enterprise = Boolean(object.enterprise);
            return message;
        };

        /**
         * Creates a plain object from a RecordTypesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordTypesRequest
         * @static
         * @param {Records.RecordTypesRequest} message RecordTypesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordTypesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.standard = false;
                object.user = false;
                object.enterprise = false;
            }
            if (message.standard != null && message.hasOwnProperty("standard"))
                object.standard = message.standard;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.enterprise != null && message.hasOwnProperty("enterprise"))
                object.enterprise = message.enterprise;
            return object;
        };

        /**
         * Converts this RecordTypesRequest to JSON.
         * @function toJSON
         * @memberof Records.RecordTypesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordTypesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordTypesRequest;
    })();

    Records.RecordTypesResponse = (function() {

        /**
         * Properties of a RecordTypesResponse.
         * @memberof Records
         * @interface IRecordTypesResponse
         * @property {Array.<Records.IRecordType>|null} [recordTypes] RecordTypesResponse recordTypes
         * @property {number|null} [standardCounter] RecordTypesResponse standardCounter
         * @property {number|null} [userCounter] RecordTypesResponse userCounter
         * @property {number|null} [enterpriseCounter] RecordTypesResponse enterpriseCounter
         */

        /**
         * Constructs a new RecordTypesResponse.
         * @memberof Records
         * @classdesc Represents a RecordTypesResponse.
         * @implements IRecordTypesResponse
         * @constructor
         * @param {Records.IRecordTypesResponse=} [properties] Properties to set
         */
        function RecordTypesResponse(properties) {
            this.recordTypes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordTypesResponse recordTypes.
         * @member {Array.<Records.IRecordType>} recordTypes
         * @memberof Records.RecordTypesResponse
         * @instance
         */
        RecordTypesResponse.prototype.recordTypes = $util.emptyArray;

        /**
         * RecordTypesResponse standardCounter.
         * @member {number} standardCounter
         * @memberof Records.RecordTypesResponse
         * @instance
         */
        RecordTypesResponse.prototype.standardCounter = 0;

        /**
         * RecordTypesResponse userCounter.
         * @member {number} userCounter
         * @memberof Records.RecordTypesResponse
         * @instance
         */
        RecordTypesResponse.prototype.userCounter = 0;

        /**
         * RecordTypesResponse enterpriseCounter.
         * @member {number} enterpriseCounter
         * @memberof Records.RecordTypesResponse
         * @instance
         */
        RecordTypesResponse.prototype.enterpriseCounter = 0;

        /**
         * Creates a new RecordTypesResponse instance using the specified properties.
         * @function create
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Records.IRecordTypesResponse=} [properties] Properties to set
         * @returns {Records.RecordTypesResponse} RecordTypesResponse instance
         */
        RecordTypesResponse.create = function create(properties) {
            return new RecordTypesResponse(properties);
        };

        /**
         * Encodes the specified RecordTypesResponse message. Does not implicitly {@link Records.RecordTypesResponse.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Records.IRecordTypesResponse} message RecordTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordTypes != null && message.recordTypes.length)
                for (let i = 0; i < message.recordTypes.length; ++i)
                    $root.Records.RecordType.encode(message.recordTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.standardCounter != null && message.hasOwnProperty("standardCounter"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.standardCounter);
            if (message.userCounter != null && message.hasOwnProperty("userCounter"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.userCounter);
            if (message.enterpriseCounter != null && message.hasOwnProperty("enterpriseCounter"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.enterpriseCounter);
            return writer;
        };

        /**
         * Encodes the specified RecordTypesResponse message, length delimited. Does not implicitly {@link Records.RecordTypesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Records.IRecordTypesResponse} message RecordTypesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordTypesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordTypesResponse} RecordTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordTypesResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.recordTypes && message.recordTypes.length))
                        message.recordTypes = [];
                    message.recordTypes.push($root.Records.RecordType.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.standardCounter = reader.int32();
                    break;
                case 3:
                    message.userCounter = reader.int32();
                    break;
                case 4:
                    message.enterpriseCounter = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordTypesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordTypesResponse} RecordTypesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordTypesResponse message.
         * @function verify
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordTypesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordTypes != null && message.hasOwnProperty("recordTypes")) {
                if (!Array.isArray(message.recordTypes))
                    return "recordTypes: array expected";
                for (let i = 0; i < message.recordTypes.length; ++i) {
                    let error = $root.Records.RecordType.verify(message.recordTypes[i]);
                    if (error)
                        return "recordTypes." + error;
                }
            }
            if (message.standardCounter != null && message.hasOwnProperty("standardCounter"))
                if (!$util.isInteger(message.standardCounter))
                    return "standardCounter: integer expected";
            if (message.userCounter != null && message.hasOwnProperty("userCounter"))
                if (!$util.isInteger(message.userCounter))
                    return "userCounter: integer expected";
            if (message.enterpriseCounter != null && message.hasOwnProperty("enterpriseCounter"))
                if (!$util.isInteger(message.enterpriseCounter))
                    return "enterpriseCounter: integer expected";
            return null;
        };

        /**
         * Creates a RecordTypesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordTypesResponse} RecordTypesResponse
         */
        RecordTypesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordTypesResponse)
                return object;
            let message = new $root.Records.RecordTypesResponse();
            if (object.recordTypes) {
                if (!Array.isArray(object.recordTypes))
                    throw TypeError(".Records.RecordTypesResponse.recordTypes: array expected");
                message.recordTypes = [];
                for (let i = 0; i < object.recordTypes.length; ++i) {
                    if (typeof object.recordTypes[i] !== "object")
                        throw TypeError(".Records.RecordTypesResponse.recordTypes: object expected");
                    message.recordTypes[i] = $root.Records.RecordType.fromObject(object.recordTypes[i]);
                }
            }
            if (object.standardCounter != null)
                message.standardCounter = object.standardCounter | 0;
            if (object.userCounter != null)
                message.userCounter = object.userCounter | 0;
            if (object.enterpriseCounter != null)
                message.enterpriseCounter = object.enterpriseCounter | 0;
            return message;
        };

        /**
         * Creates a plain object from a RecordTypesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordTypesResponse
         * @static
         * @param {Records.RecordTypesResponse} message RecordTypesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordTypesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.recordTypes = [];
            if (options.defaults) {
                object.standardCounter = 0;
                object.userCounter = 0;
                object.enterpriseCounter = 0;
            }
            if (message.recordTypes && message.recordTypes.length) {
                object.recordTypes = [];
                for (let j = 0; j < message.recordTypes.length; ++j)
                    object.recordTypes[j] = $root.Records.RecordType.toObject(message.recordTypes[j], options);
            }
            if (message.standardCounter != null && message.hasOwnProperty("standardCounter"))
                object.standardCounter = message.standardCounter;
            if (message.userCounter != null && message.hasOwnProperty("userCounter"))
                object.userCounter = message.userCounter;
            if (message.enterpriseCounter != null && message.hasOwnProperty("enterpriseCounter"))
                object.enterpriseCounter = message.enterpriseCounter;
            return object;
        };

        /**
         * Converts this RecordTypesResponse to JSON.
         * @function toJSON
         * @memberof Records.RecordTypesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordTypesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordTypesResponse;
    })();

    Records.RecordTypeModifyResponse = (function() {

        /**
         * Properties of a RecordTypeModifyResponse.
         * @memberof Records
         * @interface IRecordTypeModifyResponse
         * @property {number|null} [recordTypeId] RecordTypeModifyResponse recordTypeId
         * @property {number|null} [counter] RecordTypeModifyResponse counter
         */

        /**
         * Constructs a new RecordTypeModifyResponse.
         * @memberof Records
         * @classdesc Represents a RecordTypeModifyResponse.
         * @implements IRecordTypeModifyResponse
         * @constructor
         * @param {Records.IRecordTypeModifyResponse=} [properties] Properties to set
         */
        function RecordTypeModifyResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordTypeModifyResponse recordTypeId.
         * @member {number} recordTypeId
         * @memberof Records.RecordTypeModifyResponse
         * @instance
         */
        RecordTypeModifyResponse.prototype.recordTypeId = 0;

        /**
         * RecordTypeModifyResponse counter.
         * @member {number} counter
         * @memberof Records.RecordTypeModifyResponse
         * @instance
         */
        RecordTypeModifyResponse.prototype.counter = 0;

        /**
         * Creates a new RecordTypeModifyResponse instance using the specified properties.
         * @function create
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Records.IRecordTypeModifyResponse=} [properties] Properties to set
         * @returns {Records.RecordTypeModifyResponse} RecordTypeModifyResponse instance
         */
        RecordTypeModifyResponse.create = function create(properties) {
            return new RecordTypeModifyResponse(properties);
        };

        /**
         * Encodes the specified RecordTypeModifyResponse message. Does not implicitly {@link Records.RecordTypeModifyResponse.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Records.IRecordTypeModifyResponse} message RecordTypeModifyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypeModifyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.recordTypeId);
            if (message.counter != null && message.hasOwnProperty("counter"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.counter);
            return writer;
        };

        /**
         * Encodes the specified RecordTypeModifyResponse message, length delimited. Does not implicitly {@link Records.RecordTypeModifyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Records.IRecordTypeModifyResponse} message RecordTypeModifyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordTypeModifyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordTypeModifyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordTypeModifyResponse} RecordTypeModifyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypeModifyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordTypeModifyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordTypeId = reader.int32();
                    break;
                case 2:
                    message.counter = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordTypeModifyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordTypeModifyResponse} RecordTypeModifyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordTypeModifyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordTypeModifyResponse message.
         * @function verify
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordTypeModifyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                if (!$util.isInteger(message.recordTypeId))
                    return "recordTypeId: integer expected";
            if (message.counter != null && message.hasOwnProperty("counter"))
                if (!$util.isInteger(message.counter))
                    return "counter: integer expected";
            return null;
        };

        /**
         * Creates a RecordTypeModifyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordTypeModifyResponse} RecordTypeModifyResponse
         */
        RecordTypeModifyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordTypeModifyResponse)
                return object;
            let message = new $root.Records.RecordTypeModifyResponse();
            if (object.recordTypeId != null)
                message.recordTypeId = object.recordTypeId | 0;
            if (object.counter != null)
                message.counter = object.counter | 0;
            return message;
        };

        /**
         * Creates a plain object from a RecordTypeModifyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordTypeModifyResponse
         * @static
         * @param {Records.RecordTypeModifyResponse} message RecordTypeModifyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordTypeModifyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.recordTypeId = 0;
                object.counter = 0;
            }
            if (message.recordTypeId != null && message.hasOwnProperty("recordTypeId"))
                object.recordTypeId = message.recordTypeId;
            if (message.counter != null && message.hasOwnProperty("counter"))
                object.counter = message.counter;
            return object;
        };

        /**
         * Converts this RecordTypeModifyResponse to JSON.
         * @function toJSON
         * @memberof Records.RecordTypeModifyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordTypeModifyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordTypeModifyResponse;
    })();

    /**
     * RecordFolderType enum.
     * @name Records.RecordFolderType
     * @enum {string}
     * @property {number} user_folder=0 user_folder value
     * @property {number} shared_folder=1 shared_folder value
     * @property {number} shared_folder_folder=2 shared_folder_folder value
     */
    Records.RecordFolderType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "user_folder"] = 0;
        values[valuesById[1] = "shared_folder"] = 1;
        values[valuesById[2] = "shared_folder_folder"] = 2;
        return values;
    })();

    Records.RecordLink = (function() {

        /**
         * Properties of a RecordLink.
         * @memberof Records
         * @interface IRecordLink
         * @property {Uint8Array|null} [recordUid] RecordLink recordUid
         * @property {Uint8Array|null} [recordKey] RecordLink recordKey
         */

        /**
         * Constructs a new RecordLink.
         * @memberof Records
         * @classdesc Represents a RecordLink.
         * @implements IRecordLink
         * @constructor
         * @param {Records.IRecordLink=} [properties] Properties to set
         */
        function RecordLink(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordLink recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.RecordLink
         * @instance
         */
        RecordLink.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordLink recordKey.
         * @member {Uint8Array} recordKey
         * @memberof Records.RecordLink
         * @instance
         */
        RecordLink.prototype.recordKey = $util.newBuffer([]);

        /**
         * Creates a new RecordLink instance using the specified properties.
         * @function create
         * @memberof Records.RecordLink
         * @static
         * @param {Records.IRecordLink=} [properties] Properties to set
         * @returns {Records.RecordLink} RecordLink instance
         */
        RecordLink.create = function create(properties) {
            return new RecordLink(properties);
        };

        /**
         * Encodes the specified RecordLink message. Does not implicitly {@link Records.RecordLink.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordLink
         * @static
         * @param {Records.IRecordLink} message RecordLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordLink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordKey);
            return writer;
        };

        /**
         * Encodes the specified RecordLink message, length delimited. Does not implicitly {@link Records.RecordLink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordLink
         * @static
         * @param {Records.IRecordLink} message RecordLink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordLink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordLink message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordLink} RecordLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordLink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordLink();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordLink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordLink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordLink} RecordLink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordLink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordLink message.
         * @function verify
         * @memberof Records.RecordLink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordLink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                if (!(message.recordKey && typeof message.recordKey.length === "number" || $util.isString(message.recordKey)))
                    return "recordKey: buffer expected";
            return null;
        };

        /**
         * Creates a RecordLink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordLink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordLink} RecordLink
         */
        RecordLink.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordLink)
                return object;
            let message = new $root.Records.RecordLink();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.recordKey != null)
                if (typeof object.recordKey === "string")
                    $util.base64.decode(object.recordKey, message.recordKey = $util.newBuffer($util.base64.length(object.recordKey)), 0);
                else if (object.recordKey.length)
                    message.recordKey = object.recordKey;
            return message;
        };

        /**
         * Creates a plain object from a RecordLink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordLink
         * @static
         * @param {Records.RecordLink} message RecordLink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordLink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.recordKey = "";
                else {
                    object.recordKey = [];
                    if (options.bytes !== Array)
                        object.recordKey = $util.newBuffer(object.recordKey);
                }
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                object.recordKey = options.bytes === String ? $util.base64.encode(message.recordKey, 0, message.recordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordKey) : message.recordKey;
            return object;
        };

        /**
         * Converts this RecordLink to JSON.
         * @function toJSON
         * @memberof Records.RecordLink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordLink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordLink;
    })();

    Records.RecordAdd = (function() {

        /**
         * Properties of a RecordAdd.
         * @memberof Records
         * @interface IRecordAdd
         * @property {Uint8Array|null} [recordUid] RecordAdd recordUid
         * @property {Uint8Array|null} [recordKey] RecordAdd recordKey
         * @property {number|Long|null} [clientModifiedTime] RecordAdd clientModifiedTime
         * @property {Uint8Array|null} [data] RecordAdd data
         * @property {Uint8Array|null} [nonSharedData] RecordAdd nonSharedData
         * @property {Records.RecordFolderType|null} [folderType] RecordAdd folderType
         * @property {Uint8Array|null} [folderUid] RecordAdd folderUid
         * @property {Uint8Array|null} [folderKey] RecordAdd folderKey
         * @property {Array.<Records.IRecordLink>|null} [recordLinks] RecordAdd recordLinks
         */

        /**
         * Constructs a new RecordAdd.
         * @memberof Records
         * @classdesc Represents a RecordAdd.
         * @implements IRecordAdd
         * @constructor
         * @param {Records.IRecordAdd=} [properties] Properties to set
         */
        function RecordAdd(properties) {
            this.recordLinks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordAdd recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordAdd recordKey.
         * @member {Uint8Array} recordKey
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.recordKey = $util.newBuffer([]);

        /**
         * RecordAdd clientModifiedTime.
         * @member {number|Long} clientModifiedTime
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.clientModifiedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordAdd data.
         * @member {Uint8Array} data
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.data = $util.newBuffer([]);

        /**
         * RecordAdd nonSharedData.
         * @member {Uint8Array} nonSharedData
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.nonSharedData = $util.newBuffer([]);

        /**
         * RecordAdd folderType.
         * @member {Records.RecordFolderType} folderType
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.folderType = 0;

        /**
         * RecordAdd folderUid.
         * @member {Uint8Array} folderUid
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.folderUid = $util.newBuffer([]);

        /**
         * RecordAdd folderKey.
         * @member {Uint8Array} folderKey
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.folderKey = $util.newBuffer([]);

        /**
         * RecordAdd recordLinks.
         * @member {Array.<Records.IRecordLink>} recordLinks
         * @memberof Records.RecordAdd
         * @instance
         */
        RecordAdd.prototype.recordLinks = $util.emptyArray;

        /**
         * Creates a new RecordAdd instance using the specified properties.
         * @function create
         * @memberof Records.RecordAdd
         * @static
         * @param {Records.IRecordAdd=} [properties] Properties to set
         * @returns {Records.RecordAdd} RecordAdd instance
         */
        RecordAdd.create = function create(properties) {
            return new RecordAdd(properties);
        };

        /**
         * Encodes the specified RecordAdd message. Does not implicitly {@link Records.RecordAdd.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordAdd
         * @static
         * @param {Records.IRecordAdd} message RecordAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordAdd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordKey);
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.clientModifiedTime);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.nonSharedData);
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.folderType);
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.folderUid);
            if (message.folderKey != null && message.hasOwnProperty("folderKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.folderKey);
            if (message.recordLinks != null && message.recordLinks.length)
                for (let i = 0; i < message.recordLinks.length; ++i)
                    $root.Records.RecordLink.encode(message.recordLinks[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RecordAdd message, length delimited. Does not implicitly {@link Records.RecordAdd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordAdd
         * @static
         * @param {Records.IRecordAdd} message RecordAdd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordAdd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordAdd message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordAdd} RecordAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordAdd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordAdd();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordKey = reader.bytes();
                    break;
                case 3:
                    message.clientModifiedTime = reader.int64();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.nonSharedData = reader.bytes();
                    break;
                case 6:
                    message.folderType = reader.int32();
                    break;
                case 7:
                    message.folderUid = reader.bytes();
                    break;
                case 8:
                    message.folderKey = reader.bytes();
                    break;
                case 9:
                    if (!(message.recordLinks && message.recordLinks.length))
                        message.recordLinks = [];
                    message.recordLinks.push($root.Records.RecordLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordAdd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordAdd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordAdd} RecordAdd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordAdd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordAdd message.
         * @function verify
         * @memberof Records.RecordAdd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordAdd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                if (!(message.recordKey && typeof message.recordKey.length === "number" || $util.isString(message.recordKey)))
                    return "recordKey: buffer expected";
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                if (!$util.isInteger(message.clientModifiedTime) && !(message.clientModifiedTime && $util.isInteger(message.clientModifiedTime.low) && $util.isInteger(message.clientModifiedTime.high)))
                    return "clientModifiedTime: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                if (!(message.nonSharedData && typeof message.nonSharedData.length === "number" || $util.isString(message.nonSharedData)))
                    return "nonSharedData: buffer expected";
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                switch (message.folderType) {
                default:
                    return "folderType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                if (!(message.folderUid && typeof message.folderUid.length === "number" || $util.isString(message.folderUid)))
                    return "folderUid: buffer expected";
            if (message.folderKey != null && message.hasOwnProperty("folderKey"))
                if (!(message.folderKey && typeof message.folderKey.length === "number" || $util.isString(message.folderKey)))
                    return "folderKey: buffer expected";
            if (message.recordLinks != null && message.hasOwnProperty("recordLinks")) {
                if (!Array.isArray(message.recordLinks))
                    return "recordLinks: array expected";
                for (let i = 0; i < message.recordLinks.length; ++i) {
                    let error = $root.Records.RecordLink.verify(message.recordLinks[i]);
                    if (error)
                        return "recordLinks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RecordAdd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordAdd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordAdd} RecordAdd
         */
        RecordAdd.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordAdd)
                return object;
            let message = new $root.Records.RecordAdd();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.recordKey != null)
                if (typeof object.recordKey === "string")
                    $util.base64.decode(object.recordKey, message.recordKey = $util.newBuffer($util.base64.length(object.recordKey)), 0);
                else if (object.recordKey.length)
                    message.recordKey = object.recordKey;
            if (object.clientModifiedTime != null)
                if ($util.Long)
                    (message.clientModifiedTime = $util.Long.fromValue(object.clientModifiedTime)).unsigned = false;
                else if (typeof object.clientModifiedTime === "string")
                    message.clientModifiedTime = parseInt(object.clientModifiedTime, 10);
                else if (typeof object.clientModifiedTime === "number")
                    message.clientModifiedTime = object.clientModifiedTime;
                else if (typeof object.clientModifiedTime === "object")
                    message.clientModifiedTime = new $util.LongBits(object.clientModifiedTime.low >>> 0, object.clientModifiedTime.high >>> 0).toNumber();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.nonSharedData != null)
                if (typeof object.nonSharedData === "string")
                    $util.base64.decode(object.nonSharedData, message.nonSharedData = $util.newBuffer($util.base64.length(object.nonSharedData)), 0);
                else if (object.nonSharedData.length)
                    message.nonSharedData = object.nonSharedData;
            switch (object.folderType) {
            case "user_folder":
            case 0:
                message.folderType = 0;
                break;
            case "shared_folder":
            case 1:
                message.folderType = 1;
                break;
            case "shared_folder_folder":
            case 2:
                message.folderType = 2;
                break;
            }
            if (object.folderUid != null)
                if (typeof object.folderUid === "string")
                    $util.base64.decode(object.folderUid, message.folderUid = $util.newBuffer($util.base64.length(object.folderUid)), 0);
                else if (object.folderUid.length)
                    message.folderUid = object.folderUid;
            if (object.folderKey != null)
                if (typeof object.folderKey === "string")
                    $util.base64.decode(object.folderKey, message.folderKey = $util.newBuffer($util.base64.length(object.folderKey)), 0);
                else if (object.folderKey.length)
                    message.folderKey = object.folderKey;
            if (object.recordLinks) {
                if (!Array.isArray(object.recordLinks))
                    throw TypeError(".Records.RecordAdd.recordLinks: array expected");
                message.recordLinks = [];
                for (let i = 0; i < object.recordLinks.length; ++i) {
                    if (typeof object.recordLinks[i] !== "object")
                        throw TypeError(".Records.RecordAdd.recordLinks: object expected");
                    message.recordLinks[i] = $root.Records.RecordLink.fromObject(object.recordLinks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordAdd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordAdd
         * @static
         * @param {Records.RecordAdd} message RecordAdd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordAdd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.recordLinks = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.recordKey = "";
                else {
                    object.recordKey = [];
                    if (options.bytes !== Array)
                        object.recordKey = $util.newBuffer(object.recordKey);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientModifiedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientModifiedTime = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.nonSharedData = "";
                else {
                    object.nonSharedData = [];
                    if (options.bytes !== Array)
                        object.nonSharedData = $util.newBuffer(object.nonSharedData);
                }
                object.folderType = options.enums === String ? "user_folder" : 0;
                if (options.bytes === String)
                    object.folderUid = "";
                else {
                    object.folderUid = [];
                    if (options.bytes !== Array)
                        object.folderUid = $util.newBuffer(object.folderUid);
                }
                if (options.bytes === String)
                    object.folderKey = "";
                else {
                    object.folderKey = [];
                    if (options.bytes !== Array)
                        object.folderKey = $util.newBuffer(object.folderKey);
                }
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                object.recordKey = options.bytes === String ? $util.base64.encode(message.recordKey, 0, message.recordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordKey) : message.recordKey;
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                if (typeof message.clientModifiedTime === "number")
                    object.clientModifiedTime = options.longs === String ? String(message.clientModifiedTime) : message.clientModifiedTime;
                else
                    object.clientModifiedTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientModifiedTime) : options.longs === Number ? new $util.LongBits(message.clientModifiedTime.low >>> 0, message.clientModifiedTime.high >>> 0).toNumber() : message.clientModifiedTime;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                object.nonSharedData = options.bytes === String ? $util.base64.encode(message.nonSharedData, 0, message.nonSharedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonSharedData) : message.nonSharedData;
            if (message.folderType != null && message.hasOwnProperty("folderType"))
                object.folderType = options.enums === String ? $root.Records.RecordFolderType[message.folderType] : message.folderType;
            if (message.folderUid != null && message.hasOwnProperty("folderUid"))
                object.folderUid = options.bytes === String ? $util.base64.encode(message.folderUid, 0, message.folderUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderUid) : message.folderUid;
            if (message.folderKey != null && message.hasOwnProperty("folderKey"))
                object.folderKey = options.bytes === String ? $util.base64.encode(message.folderKey, 0, message.folderKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.folderKey) : message.folderKey;
            if (message.recordLinks && message.recordLinks.length) {
                object.recordLinks = [];
                for (let j = 0; j < message.recordLinks.length; ++j)
                    object.recordLinks[j] = $root.Records.RecordLink.toObject(message.recordLinks[j], options);
            }
            return object;
        };

        /**
         * Converts this RecordAdd to JSON.
         * @function toJSON
         * @memberof Records.RecordAdd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordAdd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordAdd;
    })();

    Records.RecordsAddRequest = (function() {

        /**
         * Properties of a RecordsAddRequest.
         * @memberof Records
         * @interface IRecordsAddRequest
         * @property {Array.<Records.IRecordAdd>|null} [records] RecordsAddRequest records
         * @property {number|Long|null} [clientTime] RecordsAddRequest clientTime
         */

        /**
         * Constructs a new RecordsAddRequest.
         * @memberof Records
         * @classdesc Represents a RecordsAddRequest.
         * @implements IRecordsAddRequest
         * @constructor
         * @param {Records.IRecordsAddRequest=} [properties] Properties to set
         */
        function RecordsAddRequest(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordsAddRequest records.
         * @member {Array.<Records.IRecordAdd>} records
         * @memberof Records.RecordsAddRequest
         * @instance
         */
        RecordsAddRequest.prototype.records = $util.emptyArray;

        /**
         * RecordsAddRequest clientTime.
         * @member {number|Long} clientTime
         * @memberof Records.RecordsAddRequest
         * @instance
         */
        RecordsAddRequest.prototype.clientTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RecordsAddRequest instance using the specified properties.
         * @function create
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Records.IRecordsAddRequest=} [properties] Properties to set
         * @returns {Records.RecordsAddRequest} RecordsAddRequest instance
         */
        RecordsAddRequest.create = function create(properties) {
            return new RecordsAddRequest(properties);
        };

        /**
         * Encodes the specified RecordsAddRequest message. Does not implicitly {@link Records.RecordsAddRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Records.IRecordsAddRequest} message RecordsAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsAddRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    $root.Records.RecordAdd.encode(message.records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientTime);
            return writer;
        };

        /**
         * Encodes the specified RecordsAddRequest message, length delimited. Does not implicitly {@link Records.RecordsAddRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Records.IRecordsAddRequest} message RecordsAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordsAddRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordsAddRequest} RecordsAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsAddRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordsAddRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.Records.RecordAdd.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.clientTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordsAddRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordsAddRequest} RecordsAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsAddRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordsAddRequest message.
         * @function verify
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordsAddRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i) {
                    let error = $root.Records.RecordAdd.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (!$util.isInteger(message.clientTime) && !(message.clientTime && $util.isInteger(message.clientTime.low) && $util.isInteger(message.clientTime.high)))
                    return "clientTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a RecordsAddRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordsAddRequest} RecordsAddRequest
         */
        RecordsAddRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordsAddRequest)
                return object;
            let message = new $root.Records.RecordsAddRequest();
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".Records.RecordsAddRequest.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".Records.RecordsAddRequest.records: object expected");
                    message.records[i] = $root.Records.RecordAdd.fromObject(object.records[i]);
                }
            }
            if (object.clientTime != null)
                if ($util.Long)
                    (message.clientTime = $util.Long.fromValue(object.clientTime)).unsigned = false;
                else if (typeof object.clientTime === "string")
                    message.clientTime = parseInt(object.clientTime, 10);
                else if (typeof object.clientTime === "number")
                    message.clientTime = object.clientTime;
                else if (typeof object.clientTime === "object")
                    message.clientTime = new $util.LongBits(object.clientTime.low >>> 0, object.clientTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RecordsAddRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordsAddRequest
         * @static
         * @param {Records.RecordsAddRequest} message RecordsAddRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordsAddRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTime = options.longs === String ? "0" : 0;
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.Records.RecordAdd.toObject(message.records[j], options);
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (typeof message.clientTime === "number")
                    object.clientTime = options.longs === String ? String(message.clientTime) : message.clientTime;
                else
                    object.clientTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientTime) : options.longs === Number ? new $util.LongBits(message.clientTime.low >>> 0, message.clientTime.high >>> 0).toNumber() : message.clientTime;
            return object;
        };

        /**
         * Converts this RecordsAddRequest to JSON.
         * @function toJSON
         * @memberof Records.RecordsAddRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordsAddRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordsAddRequest;
    })();

    Records.RecordUpdate = (function() {

        /**
         * Properties of a RecordUpdate.
         * @memberof Records
         * @interface IRecordUpdate
         * @property {Uint8Array|null} [recordUid] RecordUpdate recordUid
         * @property {number|Long|null} [clientModifiedTime] RecordUpdate clientModifiedTime
         * @property {number|Long|null} [revision] RecordUpdate revision
         * @property {Uint8Array|null} [data] RecordUpdate data
         * @property {Uint8Array|null} [nonSharedData] RecordUpdate nonSharedData
         * @property {Array.<Records.IRecordLink>|null} [recordLinks] RecordUpdate recordLinks
         */

        /**
         * Constructs a new RecordUpdate.
         * @memberof Records
         * @classdesc Represents a RecordUpdate.
         * @implements IRecordUpdate
         * @constructor
         * @param {Records.IRecordUpdate=} [properties] Properties to set
         */
        function RecordUpdate(properties) {
            this.recordLinks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordUpdate recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordUpdate clientModifiedTime.
         * @member {number|Long} clientModifiedTime
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.clientModifiedTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordUpdate revision.
         * @member {number|Long} revision
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RecordUpdate data.
         * @member {Uint8Array} data
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.data = $util.newBuffer([]);

        /**
         * RecordUpdate nonSharedData.
         * @member {Uint8Array} nonSharedData
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.nonSharedData = $util.newBuffer([]);

        /**
         * RecordUpdate recordLinks.
         * @member {Array.<Records.IRecordLink>} recordLinks
         * @memberof Records.RecordUpdate
         * @instance
         */
        RecordUpdate.prototype.recordLinks = $util.emptyArray;

        /**
         * Creates a new RecordUpdate instance using the specified properties.
         * @function create
         * @memberof Records.RecordUpdate
         * @static
         * @param {Records.IRecordUpdate=} [properties] Properties to set
         * @returns {Records.RecordUpdate} RecordUpdate instance
         */
        RecordUpdate.create = function create(properties) {
            return new RecordUpdate(properties);
        };

        /**
         * Encodes the specified RecordUpdate message. Does not implicitly {@link Records.RecordUpdate.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordUpdate
         * @static
         * @param {Records.IRecordUpdate} message RecordUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientModifiedTime);
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.revision);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.nonSharedData);
            if (message.recordLinks != null && message.recordLinks.length)
                for (let i = 0; i < message.recordLinks.length; ++i)
                    $root.Records.RecordLink.encode(message.recordLinks[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RecordUpdate message, length delimited. Does not implicitly {@link Records.RecordUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordUpdate
         * @static
         * @param {Records.IRecordUpdate} message RecordUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordUpdate} RecordUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.clientModifiedTime = reader.int64();
                    break;
                case 3:
                    message.revision = reader.int64();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.nonSharedData = reader.bytes();
                    break;
                case 6:
                    if (!(message.recordLinks && message.recordLinks.length))
                        message.recordLinks = [];
                    message.recordLinks.push($root.Records.RecordLink.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordUpdate} RecordUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordUpdate message.
         * @function verify
         * @memberof Records.RecordUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                if (!$util.isInteger(message.clientModifiedTime) && !(message.clientModifiedTime && $util.isInteger(message.clientModifiedTime.low) && $util.isInteger(message.clientModifiedTime.high)))
                    return "clientModifiedTime: integer|Long expected";
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                if (!(message.nonSharedData && typeof message.nonSharedData.length === "number" || $util.isString(message.nonSharedData)))
                    return "nonSharedData: buffer expected";
            if (message.recordLinks != null && message.hasOwnProperty("recordLinks")) {
                if (!Array.isArray(message.recordLinks))
                    return "recordLinks: array expected";
                for (let i = 0; i < message.recordLinks.length; ++i) {
                    let error = $root.Records.RecordLink.verify(message.recordLinks[i]);
                    if (error)
                        return "recordLinks." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RecordUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordUpdate} RecordUpdate
         */
        RecordUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordUpdate)
                return object;
            let message = new $root.Records.RecordUpdate();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.clientModifiedTime != null)
                if ($util.Long)
                    (message.clientModifiedTime = $util.Long.fromValue(object.clientModifiedTime)).unsigned = false;
                else if (typeof object.clientModifiedTime === "string")
                    message.clientModifiedTime = parseInt(object.clientModifiedTime, 10);
                else if (typeof object.clientModifiedTime === "number")
                    message.clientModifiedTime = object.clientModifiedTime;
                else if (typeof object.clientModifiedTime === "object")
                    message.clientModifiedTime = new $util.LongBits(object.clientModifiedTime.low >>> 0, object.clientModifiedTime.high >>> 0).toNumber();
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.nonSharedData != null)
                if (typeof object.nonSharedData === "string")
                    $util.base64.decode(object.nonSharedData, message.nonSharedData = $util.newBuffer($util.base64.length(object.nonSharedData)), 0);
                else if (object.nonSharedData.length)
                    message.nonSharedData = object.nonSharedData;
            if (object.recordLinks) {
                if (!Array.isArray(object.recordLinks))
                    throw TypeError(".Records.RecordUpdate.recordLinks: array expected");
                message.recordLinks = [];
                for (let i = 0; i < object.recordLinks.length; ++i) {
                    if (typeof object.recordLinks[i] !== "object")
                        throw TypeError(".Records.RecordUpdate.recordLinks: object expected");
                    message.recordLinks[i] = $root.Records.RecordLink.fromObject(object.recordLinks[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordUpdate
         * @static
         * @param {Records.RecordUpdate} message RecordUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.recordLinks = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientModifiedTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientModifiedTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if (options.bytes === String)
                    object.nonSharedData = "";
                else {
                    object.nonSharedData = [];
                    if (options.bytes !== Array)
                        object.nonSharedData = $util.newBuffer(object.nonSharedData);
                }
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.clientModifiedTime != null && message.hasOwnProperty("clientModifiedTime"))
                if (typeof message.clientModifiedTime === "number")
                    object.clientModifiedTime = options.longs === String ? String(message.clientModifiedTime) : message.clientModifiedTime;
                else
                    object.clientModifiedTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientModifiedTime) : options.longs === Number ? new $util.LongBits(message.clientModifiedTime.low >>> 0, message.clientModifiedTime.high >>> 0).toNumber() : message.clientModifiedTime;
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.nonSharedData != null && message.hasOwnProperty("nonSharedData"))
                object.nonSharedData = options.bytes === String ? $util.base64.encode(message.nonSharedData, 0, message.nonSharedData.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonSharedData) : message.nonSharedData;
            if (message.recordLinks && message.recordLinks.length) {
                object.recordLinks = [];
                for (let j = 0; j < message.recordLinks.length; ++j)
                    object.recordLinks[j] = $root.Records.RecordLink.toObject(message.recordLinks[j], options);
            }
            return object;
        };

        /**
         * Converts this RecordUpdate to JSON.
         * @function toJSON
         * @memberof Records.RecordUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordUpdate;
    })();

    Records.RecordsUpdateRequest = (function() {

        /**
         * Properties of a RecordsUpdateRequest.
         * @memberof Records
         * @interface IRecordsUpdateRequest
         * @property {Array.<Records.IRecordUpdate>|null} [records] RecordsUpdateRequest records
         * @property {number|Long|null} [clientTime] RecordsUpdateRequest clientTime
         */

        /**
         * Constructs a new RecordsUpdateRequest.
         * @memberof Records
         * @classdesc Represents a RecordsUpdateRequest.
         * @implements IRecordsUpdateRequest
         * @constructor
         * @param {Records.IRecordsUpdateRequest=} [properties] Properties to set
         */
        function RecordsUpdateRequest(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordsUpdateRequest records.
         * @member {Array.<Records.IRecordUpdate>} records
         * @memberof Records.RecordsUpdateRequest
         * @instance
         */
        RecordsUpdateRequest.prototype.records = $util.emptyArray;

        /**
         * RecordsUpdateRequest clientTime.
         * @member {number|Long} clientTime
         * @memberof Records.RecordsUpdateRequest
         * @instance
         */
        RecordsUpdateRequest.prototype.clientTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RecordsUpdateRequest instance using the specified properties.
         * @function create
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Records.IRecordsUpdateRequest=} [properties] Properties to set
         * @returns {Records.RecordsUpdateRequest} RecordsUpdateRequest instance
         */
        RecordsUpdateRequest.create = function create(properties) {
            return new RecordsUpdateRequest(properties);
        };

        /**
         * Encodes the specified RecordsUpdateRequest message. Does not implicitly {@link Records.RecordsUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Records.IRecordsUpdateRequest} message RecordsUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    $root.Records.RecordUpdate.encode(message.records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientTime);
            return writer;
        };

        /**
         * Encodes the specified RecordsUpdateRequest message, length delimited. Does not implicitly {@link Records.RecordsUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Records.IRecordsUpdateRequest} message RecordsUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordsUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordsUpdateRequest} RecordsUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordsUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.Records.RecordUpdate.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.clientTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordsUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordsUpdateRequest} RecordsUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordsUpdateRequest message.
         * @function verify
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordsUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i) {
                    let error = $root.Records.RecordUpdate.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (!$util.isInteger(message.clientTime) && !(message.clientTime && $util.isInteger(message.clientTime.low) && $util.isInteger(message.clientTime.high)))
                    return "clientTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a RecordsUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordsUpdateRequest} RecordsUpdateRequest
         */
        RecordsUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordsUpdateRequest)
                return object;
            let message = new $root.Records.RecordsUpdateRequest();
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".Records.RecordsUpdateRequest.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".Records.RecordsUpdateRequest.records: object expected");
                    message.records[i] = $root.Records.RecordUpdate.fromObject(object.records[i]);
                }
            }
            if (object.clientTime != null)
                if ($util.Long)
                    (message.clientTime = $util.Long.fromValue(object.clientTime)).unsigned = false;
                else if (typeof object.clientTime === "string")
                    message.clientTime = parseInt(object.clientTime, 10);
                else if (typeof object.clientTime === "number")
                    message.clientTime = object.clientTime;
                else if (typeof object.clientTime === "object")
                    message.clientTime = new $util.LongBits(object.clientTime.low >>> 0, object.clientTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RecordsUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordsUpdateRequest
         * @static
         * @param {Records.RecordsUpdateRequest} message RecordsUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordsUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTime = options.longs === String ? "0" : 0;
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.Records.RecordUpdate.toObject(message.records[j], options);
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (typeof message.clientTime === "number")
                    object.clientTime = options.longs === String ? String(message.clientTime) : message.clientTime;
                else
                    object.clientTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientTime) : options.longs === Number ? new $util.LongBits(message.clientTime.low >>> 0, message.clientTime.high >>> 0).toNumber() : message.clientTime;
            return object;
        };

        /**
         * Converts this RecordsUpdateRequest to JSON.
         * @function toJSON
         * @memberof Records.RecordsUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordsUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordsUpdateRequest;
    })();

    Records.RecordsRemoveRequest = (function() {

        /**
         * Properties of a RecordsRemoveRequest.
         * @memberof Records
         * @interface IRecordsRemoveRequest
         * @property {Array.<Uint8Array>|null} [records] RecordsRemoveRequest records
         */

        /**
         * Constructs a new RecordsRemoveRequest.
         * @memberof Records
         * @classdesc Represents a RecordsRemoveRequest.
         * @implements IRecordsRemoveRequest
         * @constructor
         * @param {Records.IRecordsRemoveRequest=} [properties] Properties to set
         */
        function RecordsRemoveRequest(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordsRemoveRequest records.
         * @member {Array.<Uint8Array>} records
         * @memberof Records.RecordsRemoveRequest
         * @instance
         */
        RecordsRemoveRequest.prototype.records = $util.emptyArray;

        /**
         * Creates a new RecordsRemoveRequest instance using the specified properties.
         * @function create
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Records.IRecordsRemoveRequest=} [properties] Properties to set
         * @returns {Records.RecordsRemoveRequest} RecordsRemoveRequest instance
         */
        RecordsRemoveRequest.create = function create(properties) {
            return new RecordsRemoveRequest(properties);
        };

        /**
         * Encodes the specified RecordsRemoveRequest message. Does not implicitly {@link Records.RecordsRemoveRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Records.IRecordsRemoveRequest} message RecordsRemoveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsRemoveRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.records[i]);
            return writer;
        };

        /**
         * Encodes the specified RecordsRemoveRequest message, length delimited. Does not implicitly {@link Records.RecordsRemoveRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Records.IRecordsRemoveRequest} message RecordsRemoveRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsRemoveRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordsRemoveRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordsRemoveRequest} RecordsRemoveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsRemoveRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordsRemoveRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordsRemoveRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordsRemoveRequest} RecordsRemoveRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsRemoveRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordsRemoveRequest message.
         * @function verify
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordsRemoveRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i)
                    if (!(message.records[i] && typeof message.records[i].length === "number" || $util.isString(message.records[i])))
                        return "records: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a RecordsRemoveRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordsRemoveRequest} RecordsRemoveRequest
         */
        RecordsRemoveRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordsRemoveRequest)
                return object;
            let message = new $root.Records.RecordsRemoveRequest();
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".Records.RecordsRemoveRequest.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i)
                    if (typeof object.records[i] === "string")
                        $util.base64.decode(object.records[i], message.records[i] = $util.newBuffer($util.base64.length(object.records[i])), 0);
                    else if (object.records[i].length)
                        message.records[i] = object.records[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordsRemoveRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordsRemoveRequest
         * @static
         * @param {Records.RecordsRemoveRequest} message RecordsRemoveRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordsRemoveRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = options.bytes === String ? $util.base64.encode(message.records[j], 0, message.records[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.records[j]) : message.records[j];
            }
            return object;
        };

        /**
         * Converts this RecordsRemoveRequest to JSON.
         * @function toJSON
         * @memberof Records.RecordsRemoveRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordsRemoveRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordsRemoveRequest;
    })();

    /**
     * RecordModifyResult enum.
     * @name Records.RecordModifyResult
     * @enum {string}
     * @property {number} RS_SUCCESS=0 RS_SUCCESS value
     * @property {number} RS_OUT_OF_SYNC=1 RS_OUT_OF_SYNC value
     * @property {number} RS_ACCESS_DENIED=2 RS_ACCESS_DENIED value
     * @property {number} RS_SHARE_DENIED=3 RS_SHARE_DENIED value
     * @property {number} RS_RECORD_EXISTS=4 RS_RECORD_EXISTS value
     */
    Records.RecordModifyResult = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RS_SUCCESS"] = 0;
        values[valuesById[1] = "RS_OUT_OF_SYNC"] = 1;
        values[valuesById[2] = "RS_ACCESS_DENIED"] = 2;
        values[valuesById[3] = "RS_SHARE_DENIED"] = 3;
        values[valuesById[4] = "RS_RECORD_EXISTS"] = 4;
        return values;
    })();

    Records.RecordModifyStatus = (function() {

        /**
         * Properties of a RecordModifyStatus.
         * @memberof Records
         * @interface IRecordModifyStatus
         * @property {Uint8Array|null} [recordUid] RecordModifyStatus recordUid
         * @property {Records.RecordModifyResult|null} [status] RecordModifyStatus status
         */

        /**
         * Constructs a new RecordModifyStatus.
         * @memberof Records
         * @classdesc Represents a RecordModifyStatus.
         * @implements IRecordModifyStatus
         * @constructor
         * @param {Records.IRecordModifyStatus=} [properties] Properties to set
         */
        function RecordModifyStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordModifyStatus recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.RecordModifyStatus
         * @instance
         */
        RecordModifyStatus.prototype.recordUid = $util.newBuffer([]);

        /**
         * RecordModifyStatus status.
         * @member {Records.RecordModifyResult} status
         * @memberof Records.RecordModifyStatus
         * @instance
         */
        RecordModifyStatus.prototype.status = 0;

        /**
         * Creates a new RecordModifyStatus instance using the specified properties.
         * @function create
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Records.IRecordModifyStatus=} [properties] Properties to set
         * @returns {Records.RecordModifyStatus} RecordModifyStatus instance
         */
        RecordModifyStatus.create = function create(properties) {
            return new RecordModifyStatus(properties);
        };

        /**
         * Encodes the specified RecordModifyStatus message. Does not implicitly {@link Records.RecordModifyStatus.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Records.IRecordModifyStatus} message RecordModifyStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordModifyStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            return writer;
        };

        /**
         * Encodes the specified RecordModifyStatus message, length delimited. Does not implicitly {@link Records.RecordModifyStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Records.IRecordModifyStatus} message RecordModifyStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordModifyStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordModifyStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordModifyStatus} RecordModifyStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordModifyStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordModifyStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordModifyStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordModifyStatus} RecordModifyStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordModifyStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordModifyStatus message.
         * @function verify
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordModifyStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates a RecordModifyStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordModifyStatus} RecordModifyStatus
         */
        RecordModifyStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordModifyStatus)
                return object;
            let message = new $root.Records.RecordModifyStatus();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            switch (object.status) {
            case "RS_SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "RS_OUT_OF_SYNC":
            case 1:
                message.status = 1;
                break;
            case "RS_ACCESS_DENIED":
            case 2:
                message.status = 2;
                break;
            case "RS_SHARE_DENIED":
            case 3:
                message.status = 3;
                break;
            case "RS_RECORD_EXISTS":
            case 4:
                message.status = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RecordModifyStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordModifyStatus
         * @static
         * @param {Records.RecordModifyStatus} message RecordModifyStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordModifyStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.status = options.enums === String ? "RS_SUCCESS" : 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Records.RecordModifyResult[message.status] : message.status;
            return object;
        };

        /**
         * Converts this RecordModifyStatus to JSON.
         * @function toJSON
         * @memberof Records.RecordModifyStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordModifyStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordModifyStatus;
    })();

    Records.RecordsModifyResponse = (function() {

        /**
         * Properties of a RecordsModifyResponse.
         * @memberof Records
         * @interface IRecordsModifyResponse
         * @property {Array.<Records.IRecordModifyStatus>|null} [records] RecordsModifyResponse records
         * @property {number|Long|null} [revision] RecordsModifyResponse revision
         */

        /**
         * Constructs a new RecordsModifyResponse.
         * @memberof Records
         * @classdesc Represents a RecordsModifyResponse.
         * @implements IRecordsModifyResponse
         * @constructor
         * @param {Records.IRecordsModifyResponse=} [properties] Properties to set
         */
        function RecordsModifyResponse(properties) {
            this.records = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecordsModifyResponse records.
         * @member {Array.<Records.IRecordModifyStatus>} records
         * @memberof Records.RecordsModifyResponse
         * @instance
         */
        RecordsModifyResponse.prototype.records = $util.emptyArray;

        /**
         * RecordsModifyResponse revision.
         * @member {number|Long} revision
         * @memberof Records.RecordsModifyResponse
         * @instance
         */
        RecordsModifyResponse.prototype.revision = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new RecordsModifyResponse instance using the specified properties.
         * @function create
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Records.IRecordsModifyResponse=} [properties] Properties to set
         * @returns {Records.RecordsModifyResponse} RecordsModifyResponse instance
         */
        RecordsModifyResponse.create = function create(properties) {
            return new RecordsModifyResponse(properties);
        };

        /**
         * Encodes the specified RecordsModifyResponse message. Does not implicitly {@link Records.RecordsModifyResponse.verify|verify} messages.
         * @function encode
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Records.IRecordsModifyResponse} message RecordsModifyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsModifyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (let i = 0; i < message.records.length; ++i)
                    $root.Records.RecordModifyStatus.encode(message.records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.revision != null && message.hasOwnProperty("revision"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.revision);
            return writer;
        };

        /**
         * Encodes the specified RecordsModifyResponse message, length delimited. Does not implicitly {@link Records.RecordsModifyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Records.IRecordsModifyResponse} message RecordsModifyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecordsModifyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecordsModifyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.RecordsModifyResponse} RecordsModifyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsModifyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.RecordsModifyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.Records.RecordModifyStatus.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.revision = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecordsModifyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.RecordsModifyResponse} RecordsModifyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecordsModifyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecordsModifyResponse message.
         * @function verify
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecordsModifyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (let i = 0; i < message.records.length; ++i) {
                    let error = $root.Records.RecordModifyStatus.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (!$util.isInteger(message.revision) && !(message.revision && $util.isInteger(message.revision.low) && $util.isInteger(message.revision.high)))
                    return "revision: integer|Long expected";
            return null;
        };

        /**
         * Creates a RecordsModifyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.RecordsModifyResponse} RecordsModifyResponse
         */
        RecordsModifyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.RecordsModifyResponse)
                return object;
            let message = new $root.Records.RecordsModifyResponse();
            if (object.records) {
                if (!Array.isArray(object.records))
                    throw TypeError(".Records.RecordsModifyResponse.records: array expected");
                message.records = [];
                for (let i = 0; i < object.records.length; ++i) {
                    if (typeof object.records[i] !== "object")
                        throw TypeError(".Records.RecordsModifyResponse.records: object expected");
                    message.records[i] = $root.Records.RecordModifyStatus.fromObject(object.records[i]);
                }
            }
            if (object.revision != null)
                if ($util.Long)
                    (message.revision = $util.Long.fromValue(object.revision)).unsigned = false;
                else if (typeof object.revision === "string")
                    message.revision = parseInt(object.revision, 10);
                else if (typeof object.revision === "number")
                    message.revision = object.revision;
                else if (typeof object.revision === "object")
                    message.revision = new $util.LongBits(object.revision.low >>> 0, object.revision.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a RecordsModifyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.RecordsModifyResponse
         * @static
         * @param {Records.RecordsModifyResponse} message RecordsModifyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RecordsModifyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.records = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.revision = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.revision = options.longs === String ? "0" : 0;
            if (message.records && message.records.length) {
                object.records = [];
                for (let j = 0; j < message.records.length; ++j)
                    object.records[j] = $root.Records.RecordModifyStatus.toObject(message.records[j], options);
            }
            if (message.revision != null && message.hasOwnProperty("revision"))
                if (typeof message.revision === "number")
                    object.revision = options.longs === String ? String(message.revision) : message.revision;
                else
                    object.revision = options.longs === String ? $util.Long.prototype.toString.call(message.revision) : options.longs === Number ? new $util.LongBits(message.revision.low >>> 0, message.revision.high >>> 0).toNumber() : message.revision;
            return object;
        };

        /**
         * Converts this RecordsModifyResponse to JSON.
         * @function toJSON
         * @memberof Records.RecordsModifyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RecordsModifyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RecordsModifyResponse;
    })();

    Records.File = (function() {

        /**
         * Properties of a File.
         * @memberof Records
         * @interface IFile
         * @property {Uint8Array|null} [recordUid] File recordUid
         * @property {Uint8Array|null} [recordKey] File recordKey
         * @property {Uint8Array|null} [data] File data
         * @property {number|Long|null} [fileSize] File fileSize
         * @property {number|null} [thumbSize] File thumbSize
         */

        /**
         * Constructs a new File.
         * @memberof Records
         * @classdesc Represents a File.
         * @implements IFile
         * @constructor
         * @param {Records.IFile=} [properties] Properties to set
         */
        function File(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * File recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.File
         * @instance
         */
        File.prototype.recordUid = $util.newBuffer([]);

        /**
         * File recordKey.
         * @member {Uint8Array} recordKey
         * @memberof Records.File
         * @instance
         */
        File.prototype.recordKey = $util.newBuffer([]);

        /**
         * File data.
         * @member {Uint8Array} data
         * @memberof Records.File
         * @instance
         */
        File.prototype.data = $util.newBuffer([]);

        /**
         * File fileSize.
         * @member {number|Long} fileSize
         * @memberof Records.File
         * @instance
         */
        File.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * File thumbSize.
         * @member {number} thumbSize
         * @memberof Records.File
         * @instance
         */
        File.prototype.thumbSize = 0;

        /**
         * Creates a new File instance using the specified properties.
         * @function create
         * @memberof Records.File
         * @static
         * @param {Records.IFile=} [properties] Properties to set
         * @returns {Records.File} File instance
         */
        File.create = function create(properties) {
            return new File(properties);
        };

        /**
         * Encodes the specified File message. Does not implicitly {@link Records.File.verify|verify} messages.
         * @function encode
         * @memberof Records.File
         * @static
         * @param {Records.IFile} message File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        File.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recordKey);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
            if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fileSize);
            if (message.thumbSize != null && message.hasOwnProperty("thumbSize"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.thumbSize);
            return writer;
        };

        /**
         * Encodes the specified File message, length delimited. Does not implicitly {@link Records.File.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.File
         * @static
         * @param {Records.IFile} message File message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        File.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a File message from the specified reader or buffer.
         * @function decode
         * @memberof Records.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        File.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.File();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.recordKey = reader.bytes();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                case 4:
                    message.fileSize = reader.int64();
                    break;
                case 5:
                    message.thumbSize = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a File message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.File
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.File} File
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        File.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a File message.
         * @function verify
         * @memberof Records.File
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        File.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                if (!(message.recordKey && typeof message.recordKey.length === "number" || $util.isString(message.recordKey)))
                    return "recordKey: buffer expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                    return "fileSize: integer|Long expected";
            if (message.thumbSize != null && message.hasOwnProperty("thumbSize"))
                if (!$util.isInteger(message.thumbSize))
                    return "thumbSize: integer expected";
            return null;
        };

        /**
         * Creates a File message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.File
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.File} File
         */
        File.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.File)
                return object;
            let message = new $root.Records.File();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            if (object.recordKey != null)
                if (typeof object.recordKey === "string")
                    $util.base64.decode(object.recordKey, message.recordKey = $util.newBuffer($util.base64.length(object.recordKey)), 0);
                else if (object.recordKey.length)
                    message.recordKey = object.recordKey;
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.fileSize != null)
                if ($util.Long)
                    (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = false;
                else if (typeof object.fileSize === "string")
                    message.fileSize = parseInt(object.fileSize, 10);
                else if (typeof object.fileSize === "number")
                    message.fileSize = object.fileSize;
                else if (typeof object.fileSize === "object")
                    message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber();
            if (object.thumbSize != null)
                message.thumbSize = object.thumbSize | 0;
            return message;
        };

        /**
         * Creates a plain object from a File message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.File
         * @static
         * @param {Records.File} message File
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        File.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                if (options.bytes === String)
                    object.recordKey = "";
                else {
                    object.recordKey = [];
                    if (options.bytes !== Array)
                        object.recordKey = $util.newBuffer(object.recordKey);
                }
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fileSize = options.longs === String ? "0" : 0;
                object.thumbSize = 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.recordKey != null && message.hasOwnProperty("recordKey"))
                object.recordKey = options.bytes === String ? $util.base64.encode(message.recordKey, 0, message.recordKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordKey) : message.recordKey;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                if (typeof message.fileSize === "number")
                    object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                else
                    object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber() : message.fileSize;
            if (message.thumbSize != null && message.hasOwnProperty("thumbSize"))
                object.thumbSize = message.thumbSize;
            return object;
        };

        /**
         * Converts this File to JSON.
         * @function toJSON
         * @memberof Records.File
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        File.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return File;
    })();

    Records.FilesAddRequest = (function() {

        /**
         * Properties of a FilesAddRequest.
         * @memberof Records
         * @interface IFilesAddRequest
         * @property {Array.<Records.IFile>|null} [files] FilesAddRequest files
         * @property {number|Long|null} [clientTime] FilesAddRequest clientTime
         */

        /**
         * Constructs a new FilesAddRequest.
         * @memberof Records
         * @classdesc Represents a FilesAddRequest.
         * @implements IFilesAddRequest
         * @constructor
         * @param {Records.IFilesAddRequest=} [properties] Properties to set
         */
        function FilesAddRequest(properties) {
            this.files = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FilesAddRequest files.
         * @member {Array.<Records.IFile>} files
         * @memberof Records.FilesAddRequest
         * @instance
         */
        FilesAddRequest.prototype.files = $util.emptyArray;

        /**
         * FilesAddRequest clientTime.
         * @member {number|Long} clientTime
         * @memberof Records.FilesAddRequest
         * @instance
         */
        FilesAddRequest.prototype.clientTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FilesAddRequest instance using the specified properties.
         * @function create
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Records.IFilesAddRequest=} [properties] Properties to set
         * @returns {Records.FilesAddRequest} FilesAddRequest instance
         */
        FilesAddRequest.create = function create(properties) {
            return new FilesAddRequest(properties);
        };

        /**
         * Encodes the specified FilesAddRequest message. Does not implicitly {@link Records.FilesAddRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Records.IFilesAddRequest} message FilesAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesAddRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.files != null && message.files.length)
                for (let i = 0; i < message.files.length; ++i)
                    $root.Records.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.clientTime);
            return writer;
        };

        /**
         * Encodes the specified FilesAddRequest message, length delimited. Does not implicitly {@link Records.FilesAddRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Records.IFilesAddRequest} message FilesAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FilesAddRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FilesAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FilesAddRequest} FilesAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesAddRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FilesAddRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.files && message.files.length))
                        message.files = [];
                    message.files.push($root.Records.File.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.clientTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FilesAddRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FilesAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FilesAddRequest} FilesAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesAddRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FilesAddRequest message.
         * @function verify
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FilesAddRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                    return "files: array expected";
                for (let i = 0; i < message.files.length; ++i) {
                    let error = $root.Records.File.verify(message.files[i]);
                    if (error)
                        return "files." + error;
                }
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (!$util.isInteger(message.clientTime) && !(message.clientTime && $util.isInteger(message.clientTime.low) && $util.isInteger(message.clientTime.high)))
                    return "clientTime: integer|Long expected";
            return null;
        };

        /**
         * Creates a FilesAddRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FilesAddRequest} FilesAddRequest
         */
        FilesAddRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FilesAddRequest)
                return object;
            let message = new $root.Records.FilesAddRequest();
            if (object.files) {
                if (!Array.isArray(object.files))
                    throw TypeError(".Records.FilesAddRequest.files: array expected");
                message.files = [];
                for (let i = 0; i < object.files.length; ++i) {
                    if (typeof object.files[i] !== "object")
                        throw TypeError(".Records.FilesAddRequest.files: object expected");
                    message.files[i] = $root.Records.File.fromObject(object.files[i]);
                }
            }
            if (object.clientTime != null)
                if ($util.Long)
                    (message.clientTime = $util.Long.fromValue(object.clientTime)).unsigned = false;
                else if (typeof object.clientTime === "string")
                    message.clientTime = parseInt(object.clientTime, 10);
                else if (typeof object.clientTime === "number")
                    message.clientTime = object.clientTime;
                else if (typeof object.clientTime === "object")
                    message.clientTime = new $util.LongBits(object.clientTime.low >>> 0, object.clientTime.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FilesAddRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FilesAddRequest
         * @static
         * @param {Records.FilesAddRequest} message FilesAddRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FilesAddRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.files = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.clientTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.clientTime = options.longs === String ? "0" : 0;
            if (message.files && message.files.length) {
                object.files = [];
                for (let j = 0; j < message.files.length; ++j)
                    object.files[j] = $root.Records.File.toObject(message.files[j], options);
            }
            if (message.clientTime != null && message.hasOwnProperty("clientTime"))
                if (typeof message.clientTime === "number")
                    object.clientTime = options.longs === String ? String(message.clientTime) : message.clientTime;
                else
                    object.clientTime = options.longs === String ? $util.Long.prototype.toString.call(message.clientTime) : options.longs === Number ? new $util.LongBits(message.clientTime.low >>> 0, message.clientTime.high >>> 0).toNumber() : message.clientTime;
            return object;
        };

        /**
         * Converts this FilesAddRequest to JSON.
         * @function toJSON
         * @memberof Records.FilesAddRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FilesAddRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FilesAddRequest;
    })();

    /**
     * FileAddResult enum.
     * @name Records.FileAddResult
     * @enum {string}
     * @property {number} FA_SUCCESS=0 FA_SUCCESS value
     * @property {number} FA_ERROR=1 FA_ERROR value
     */
    Records.FileAddResult = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FA_SUCCESS"] = 0;
        values[valuesById[1] = "FA_ERROR"] = 1;
        return values;
    })();

    Records.FileAddStatus = (function() {

        /**
         * Properties of a FileAddStatus.
         * @memberof Records
         * @interface IFileAddStatus
         * @property {Uint8Array|null} [recordUid] FileAddStatus recordUid
         * @property {Records.FileAddResult|null} [status] FileAddStatus status
         * @property {string|null} [url] FileAddStatus url
         * @property {string|null} [parameters] FileAddStatus parameters
         * @property {string|null} [thumbnailParameters] FileAddStatus thumbnailParameters
         * @property {number|null} [successStatusCode] FileAddStatus successStatusCode
         */

        /**
         * Constructs a new FileAddStatus.
         * @memberof Records
         * @classdesc Represents a FileAddStatus.
         * @implements IFileAddStatus
         * @constructor
         * @param {Records.IFileAddStatus=} [properties] Properties to set
         */
        function FileAddStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileAddStatus recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.recordUid = $util.newBuffer([]);

        /**
         * FileAddStatus status.
         * @member {Records.FileAddResult} status
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.status = 0;

        /**
         * FileAddStatus url.
         * @member {string} url
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.url = "";

        /**
         * FileAddStatus parameters.
         * @member {string} parameters
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.parameters = "";

        /**
         * FileAddStatus thumbnailParameters.
         * @member {string} thumbnailParameters
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.thumbnailParameters = "";

        /**
         * FileAddStatus successStatusCode.
         * @member {number} successStatusCode
         * @memberof Records.FileAddStatus
         * @instance
         */
        FileAddStatus.prototype.successStatusCode = 0;

        /**
         * Creates a new FileAddStatus instance using the specified properties.
         * @function create
         * @memberof Records.FileAddStatus
         * @static
         * @param {Records.IFileAddStatus=} [properties] Properties to set
         * @returns {Records.FileAddStatus} FileAddStatus instance
         */
        FileAddStatus.create = function create(properties) {
            return new FileAddStatus(properties);
        };

        /**
         * Encodes the specified FileAddStatus message. Does not implicitly {@link Records.FileAddStatus.verify|verify} messages.
         * @function encode
         * @memberof Records.FileAddStatus
         * @static
         * @param {Records.IFileAddStatus} message FileAddStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileAddStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.parameters);
            if (message.thumbnailParameters != null && message.hasOwnProperty("thumbnailParameters"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.thumbnailParameters);
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.successStatusCode);
            return writer;
        };

        /**
         * Encodes the specified FileAddStatus message, length delimited. Does not implicitly {@link Records.FileAddStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FileAddStatus
         * @static
         * @param {Records.IFileAddStatus} message FileAddStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileAddStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileAddStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FileAddStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FileAddStatus} FileAddStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileAddStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FileAddStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.url = reader.string();
                    break;
                case 4:
                    message.parameters = reader.string();
                    break;
                case 5:
                    message.thumbnailParameters = reader.string();
                    break;
                case 6:
                    message.successStatusCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileAddStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FileAddStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FileAddStatus} FileAddStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileAddStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileAddStatus message.
         * @function verify
         * @memberof Records.FileAddStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileAddStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                if (!$util.isString(message.parameters))
                    return "parameters: string expected";
            if (message.thumbnailParameters != null && message.hasOwnProperty("thumbnailParameters"))
                if (!$util.isString(message.thumbnailParameters))
                    return "thumbnailParameters: string expected";
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                if (!$util.isInteger(message.successStatusCode))
                    return "successStatusCode: integer expected";
            return null;
        };

        /**
         * Creates a FileAddStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FileAddStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FileAddStatus} FileAddStatus
         */
        FileAddStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FileAddStatus)
                return object;
            let message = new $root.Records.FileAddStatus();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            switch (object.status) {
            case "FA_SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FA_ERROR":
            case 1:
                message.status = 1;
                break;
            }
            if (object.url != null)
                message.url = String(object.url);
            if (object.parameters != null)
                message.parameters = String(object.parameters);
            if (object.thumbnailParameters != null)
                message.thumbnailParameters = String(object.thumbnailParameters);
            if (object.successStatusCode != null)
                message.successStatusCode = object.successStatusCode | 0;
            return message;
        };

        /**
         * Creates a plain object from a FileAddStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FileAddStatus
         * @static
         * @param {Records.FileAddStatus} message FileAddStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileAddStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.status = options.enums === String ? "FA_SUCCESS" : 0;
                object.url = "";
                object.parameters = "";
                object.thumbnailParameters = "";
                object.successStatusCode = 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Records.FileAddResult[message.status] : message.status;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                object.parameters = message.parameters;
            if (message.thumbnailParameters != null && message.hasOwnProperty("thumbnailParameters"))
                object.thumbnailParameters = message.thumbnailParameters;
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                object.successStatusCode = message.successStatusCode;
            return object;
        };

        /**
         * Converts this FileAddStatus to JSON.
         * @function toJSON
         * @memberof Records.FileAddStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileAddStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileAddStatus;
    })();

    Records.FilesAddResponse = (function() {

        /**
         * Properties of a FilesAddResponse.
         * @memberof Records
         * @interface IFilesAddResponse
         * @property {Array.<Records.IFileAddStatus>|null} [files] FilesAddResponse files
         */

        /**
         * Constructs a new FilesAddResponse.
         * @memberof Records
         * @classdesc Represents a FilesAddResponse.
         * @implements IFilesAddResponse
         * @constructor
         * @param {Records.IFilesAddResponse=} [properties] Properties to set
         */
        function FilesAddResponse(properties) {
            this.files = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FilesAddResponse files.
         * @member {Array.<Records.IFileAddStatus>} files
         * @memberof Records.FilesAddResponse
         * @instance
         */
        FilesAddResponse.prototype.files = $util.emptyArray;

        /**
         * Creates a new FilesAddResponse instance using the specified properties.
         * @function create
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Records.IFilesAddResponse=} [properties] Properties to set
         * @returns {Records.FilesAddResponse} FilesAddResponse instance
         */
        FilesAddResponse.create = function create(properties) {
            return new FilesAddResponse(properties);
        };

        /**
         * Encodes the specified FilesAddResponse message. Does not implicitly {@link Records.FilesAddResponse.verify|verify} messages.
         * @function encode
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Records.IFilesAddResponse} message FilesAddResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesAddResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.files != null && message.files.length)
                for (let i = 0; i < message.files.length; ++i)
                    $root.Records.FileAddStatus.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FilesAddResponse message, length delimited. Does not implicitly {@link Records.FilesAddResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Records.IFilesAddResponse} message FilesAddResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FilesAddResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FilesAddResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FilesAddResponse} FilesAddResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesAddResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FilesAddResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.files && message.files.length))
                        message.files = [];
                    message.files.push($root.Records.FileAddStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FilesAddResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FilesAddResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FilesAddResponse} FilesAddResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesAddResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FilesAddResponse message.
         * @function verify
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FilesAddResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                    return "files: array expected";
                for (let i = 0; i < message.files.length; ++i) {
                    let error = $root.Records.FileAddStatus.verify(message.files[i]);
                    if (error)
                        return "files." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FilesAddResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FilesAddResponse} FilesAddResponse
         */
        FilesAddResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FilesAddResponse)
                return object;
            let message = new $root.Records.FilesAddResponse();
            if (object.files) {
                if (!Array.isArray(object.files))
                    throw TypeError(".Records.FilesAddResponse.files: array expected");
                message.files = [];
                for (let i = 0; i < object.files.length; ++i) {
                    if (typeof object.files[i] !== "object")
                        throw TypeError(".Records.FilesAddResponse.files: object expected");
                    message.files[i] = $root.Records.FileAddStatus.fromObject(object.files[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FilesAddResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FilesAddResponse
         * @static
         * @param {Records.FilesAddResponse} message FilesAddResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FilesAddResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.files = [];
            if (message.files && message.files.length) {
                object.files = [];
                for (let j = 0; j < message.files.length; ++j)
                    object.files[j] = $root.Records.FileAddStatus.toObject(message.files[j], options);
            }
            return object;
        };

        /**
         * Converts this FilesAddResponse to JSON.
         * @function toJSON
         * @memberof Records.FilesAddResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FilesAddResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FilesAddResponse;
    })();

    Records.FilesGetRequest = (function() {

        /**
         * Properties of a FilesGetRequest.
         * @memberof Records
         * @interface IFilesGetRequest
         * @property {Array.<Uint8Array>|null} [recordUids] FilesGetRequest recordUids
         * @property {boolean|null} [forThumbnails] FilesGetRequest forThumbnails
         * @property {string|null} [emergencyAccessAccountOwner] FilesGetRequest emergencyAccessAccountOwner
         */

        /**
         * Constructs a new FilesGetRequest.
         * @memberof Records
         * @classdesc Represents a FilesGetRequest.
         * @implements IFilesGetRequest
         * @constructor
         * @param {Records.IFilesGetRequest=} [properties] Properties to set
         */
        function FilesGetRequest(properties) {
            this.recordUids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FilesGetRequest recordUids.
         * @member {Array.<Uint8Array>} recordUids
         * @memberof Records.FilesGetRequest
         * @instance
         */
        FilesGetRequest.prototype.recordUids = $util.emptyArray;

        /**
         * FilesGetRequest forThumbnails.
         * @member {boolean} forThumbnails
         * @memberof Records.FilesGetRequest
         * @instance
         */
        FilesGetRequest.prototype.forThumbnails = false;

        /**
         * FilesGetRequest emergencyAccessAccountOwner.
         * @member {string} emergencyAccessAccountOwner
         * @memberof Records.FilesGetRequest
         * @instance
         */
        FilesGetRequest.prototype.emergencyAccessAccountOwner = "";

        /**
         * Creates a new FilesGetRequest instance using the specified properties.
         * @function create
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Records.IFilesGetRequest=} [properties] Properties to set
         * @returns {Records.FilesGetRequest} FilesGetRequest instance
         */
        FilesGetRequest.create = function create(properties) {
            return new FilesGetRequest(properties);
        };

        /**
         * Encodes the specified FilesGetRequest message. Does not implicitly {@link Records.FilesGetRequest.verify|verify} messages.
         * @function encode
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Records.IFilesGetRequest} message FilesGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUids != null && message.recordUids.length)
                for (let i = 0; i < message.recordUids.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUids[i]);
            if (message.forThumbnails != null && message.hasOwnProperty("forThumbnails"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.forThumbnails);
            if (message.emergencyAccessAccountOwner != null && message.hasOwnProperty("emergencyAccessAccountOwner"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.emergencyAccessAccountOwner);
            return writer;
        };

        /**
         * Encodes the specified FilesGetRequest message, length delimited. Does not implicitly {@link Records.FilesGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Records.IFilesGetRequest} message FilesGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FilesGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FilesGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FilesGetRequest} FilesGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FilesGetRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.recordUids && message.recordUids.length))
                        message.recordUids = [];
                    message.recordUids.push(reader.bytes());
                    break;
                case 2:
                    message.forThumbnails = reader.bool();
                    break;
                case 3:
                    message.emergencyAccessAccountOwner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FilesGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FilesGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FilesGetRequest} FilesGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FilesGetRequest message.
         * @function verify
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FilesGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUids != null && message.hasOwnProperty("recordUids")) {
                if (!Array.isArray(message.recordUids))
                    return "recordUids: array expected";
                for (let i = 0; i < message.recordUids.length; ++i)
                    if (!(message.recordUids[i] && typeof message.recordUids[i].length === "number" || $util.isString(message.recordUids[i])))
                        return "recordUids: buffer[] expected";
            }
            if (message.forThumbnails != null && message.hasOwnProperty("forThumbnails"))
                if (typeof message.forThumbnails !== "boolean")
                    return "forThumbnails: boolean expected";
            if (message.emergencyAccessAccountOwner != null && message.hasOwnProperty("emergencyAccessAccountOwner"))
                if (!$util.isString(message.emergencyAccessAccountOwner))
                    return "emergencyAccessAccountOwner: string expected";
            return null;
        };

        /**
         * Creates a FilesGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FilesGetRequest} FilesGetRequest
         */
        FilesGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FilesGetRequest)
                return object;
            let message = new $root.Records.FilesGetRequest();
            if (object.recordUids) {
                if (!Array.isArray(object.recordUids))
                    throw TypeError(".Records.FilesGetRequest.recordUids: array expected");
                message.recordUids = [];
                for (let i = 0; i < object.recordUids.length; ++i)
                    if (typeof object.recordUids[i] === "string")
                        $util.base64.decode(object.recordUids[i], message.recordUids[i] = $util.newBuffer($util.base64.length(object.recordUids[i])), 0);
                    else if (object.recordUids[i].length)
                        message.recordUids[i] = object.recordUids[i];
            }
            if (object.forThumbnails != null)
                message.forThumbnails = Boolean(object.forThumbnails);
            if (object.emergencyAccessAccountOwner != null)
                message.emergencyAccessAccountOwner = String(object.emergencyAccessAccountOwner);
            return message;
        };

        /**
         * Creates a plain object from a FilesGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FilesGetRequest
         * @static
         * @param {Records.FilesGetRequest} message FilesGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FilesGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.recordUids = [];
            if (options.defaults) {
                object.forThumbnails = false;
                object.emergencyAccessAccountOwner = "";
            }
            if (message.recordUids && message.recordUids.length) {
                object.recordUids = [];
                for (let j = 0; j < message.recordUids.length; ++j)
                    object.recordUids[j] = options.bytes === String ? $util.base64.encode(message.recordUids[j], 0, message.recordUids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUids[j]) : message.recordUids[j];
            }
            if (message.forThumbnails != null && message.hasOwnProperty("forThumbnails"))
                object.forThumbnails = message.forThumbnails;
            if (message.emergencyAccessAccountOwner != null && message.hasOwnProperty("emergencyAccessAccountOwner"))
                object.emergencyAccessAccountOwner = message.emergencyAccessAccountOwner;
            return object;
        };

        /**
         * Converts this FilesGetRequest to JSON.
         * @function toJSON
         * @memberof Records.FilesGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FilesGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FilesGetRequest;
    })();

    /**
     * FileGetResult enum.
     * @name Records.FileGetResult
     * @enum {string}
     * @property {number} FG_SUCCESS=0 FG_SUCCESS value
     * @property {number} FG_ERROR=1 FG_ERROR value
     * @property {number} FG_ACCESS_DENIED=2 FG_ACCESS_DENIED value
     */
    Records.FileGetResult = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "FG_SUCCESS"] = 0;
        values[valuesById[1] = "FG_ERROR"] = 1;
        values[valuesById[2] = "FG_ACCESS_DENIED"] = 2;
        return values;
    })();

    Records.FileGetStatus = (function() {

        /**
         * Properties of a FileGetStatus.
         * @memberof Records
         * @interface IFileGetStatus
         * @property {Uint8Array|null} [recordUid] FileGetStatus recordUid
         * @property {Records.FileGetResult|null} [status] FileGetStatus status
         * @property {string|null} [url] FileGetStatus url
         * @property {number|null} [successStatusCode] FileGetStatus successStatusCode
         */

        /**
         * Constructs a new FileGetStatus.
         * @memberof Records
         * @classdesc Represents a FileGetStatus.
         * @implements IFileGetStatus
         * @constructor
         * @param {Records.IFileGetStatus=} [properties] Properties to set
         */
        function FileGetStatus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FileGetStatus recordUid.
         * @member {Uint8Array} recordUid
         * @memberof Records.FileGetStatus
         * @instance
         */
        FileGetStatus.prototype.recordUid = $util.newBuffer([]);

        /**
         * FileGetStatus status.
         * @member {Records.FileGetResult} status
         * @memberof Records.FileGetStatus
         * @instance
         */
        FileGetStatus.prototype.status = 0;

        /**
         * FileGetStatus url.
         * @member {string} url
         * @memberof Records.FileGetStatus
         * @instance
         */
        FileGetStatus.prototype.url = "";

        /**
         * FileGetStatus successStatusCode.
         * @member {number} successStatusCode
         * @memberof Records.FileGetStatus
         * @instance
         */
        FileGetStatus.prototype.successStatusCode = 0;

        /**
         * Creates a new FileGetStatus instance using the specified properties.
         * @function create
         * @memberof Records.FileGetStatus
         * @static
         * @param {Records.IFileGetStatus=} [properties] Properties to set
         * @returns {Records.FileGetStatus} FileGetStatus instance
         */
        FileGetStatus.create = function create(properties) {
            return new FileGetStatus(properties);
        };

        /**
         * Encodes the specified FileGetStatus message. Does not implicitly {@link Records.FileGetStatus.verify|verify} messages.
         * @function encode
         * @memberof Records.FileGetStatus
         * @static
         * @param {Records.IFileGetStatus} message FileGetStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.recordUid);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.successStatusCode);
            return writer;
        };

        /**
         * Encodes the specified FileGetStatus message, length delimited. Does not implicitly {@link Records.FileGetStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FileGetStatus
         * @static
         * @param {Records.IFileGetStatus} message FileGetStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FileGetStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FileGetStatus message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FileGetStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FileGetStatus} FileGetStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FileGetStatus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.recordUid = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.url = reader.string();
                    break;
                case 4:
                    message.successStatusCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FileGetStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FileGetStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FileGetStatus} FileGetStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FileGetStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FileGetStatus message.
         * @function verify
         * @memberof Records.FileGetStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FileGetStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                if (!(message.recordUid && typeof message.recordUid.length === "number" || $util.isString(message.recordUid)))
                    return "recordUid: buffer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                if (!$util.isInteger(message.successStatusCode))
                    return "successStatusCode: integer expected";
            return null;
        };

        /**
         * Creates a FileGetStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FileGetStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FileGetStatus} FileGetStatus
         */
        FileGetStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FileGetStatus)
                return object;
            let message = new $root.Records.FileGetStatus();
            if (object.recordUid != null)
                if (typeof object.recordUid === "string")
                    $util.base64.decode(object.recordUid, message.recordUid = $util.newBuffer($util.base64.length(object.recordUid)), 0);
                else if (object.recordUid.length)
                    message.recordUid = object.recordUid;
            switch (object.status) {
            case "FG_SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FG_ERROR":
            case 1:
                message.status = 1;
                break;
            case "FG_ACCESS_DENIED":
            case 2:
                message.status = 2;
                break;
            }
            if (object.url != null)
                message.url = String(object.url);
            if (object.successStatusCode != null)
                message.successStatusCode = object.successStatusCode | 0;
            return message;
        };

        /**
         * Creates a plain object from a FileGetStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FileGetStatus
         * @static
         * @param {Records.FileGetStatus} message FileGetStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FileGetStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.recordUid = "";
                else {
                    object.recordUid = [];
                    if (options.bytes !== Array)
                        object.recordUid = $util.newBuffer(object.recordUid);
                }
                object.status = options.enums === String ? "FG_SUCCESS" : 0;
                object.url = "";
                object.successStatusCode = 0;
            }
            if (message.recordUid != null && message.hasOwnProperty("recordUid"))
                object.recordUid = options.bytes === String ? $util.base64.encode(message.recordUid, 0, message.recordUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.recordUid) : message.recordUid;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.Records.FileGetResult[message.status] : message.status;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.successStatusCode != null && message.hasOwnProperty("successStatusCode"))
                object.successStatusCode = message.successStatusCode;
            return object;
        };

        /**
         * Converts this FileGetStatus to JSON.
         * @function toJSON
         * @memberof Records.FileGetStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FileGetStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FileGetStatus;
    })();

    Records.FilesGetResponse = (function() {

        /**
         * Properties of a FilesGetResponse.
         * @memberof Records
         * @interface IFilesGetResponse
         * @property {Array.<Records.IFileGetStatus>|null} [files] FilesGetResponse files
         */

        /**
         * Constructs a new FilesGetResponse.
         * @memberof Records
         * @classdesc Represents a FilesGetResponse.
         * @implements IFilesGetResponse
         * @constructor
         * @param {Records.IFilesGetResponse=} [properties] Properties to set
         */
        function FilesGetResponse(properties) {
            this.files = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FilesGetResponse files.
         * @member {Array.<Records.IFileGetStatus>} files
         * @memberof Records.FilesGetResponse
         * @instance
         */
        FilesGetResponse.prototype.files = $util.emptyArray;

        /**
         * Creates a new FilesGetResponse instance using the specified properties.
         * @function create
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Records.IFilesGetResponse=} [properties] Properties to set
         * @returns {Records.FilesGetResponse} FilesGetResponse instance
         */
        FilesGetResponse.create = function create(properties) {
            return new FilesGetResponse(properties);
        };

        /**
         * Encodes the specified FilesGetResponse message. Does not implicitly {@link Records.FilesGetResponse.verify|verify} messages.
         * @function encode
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Records.IFilesGetResponse} message FilesGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesGetResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.files != null && message.files.length)
                for (let i = 0; i < message.files.length; ++i)
                    $root.Records.FileGetStatus.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FilesGetResponse message, length delimited. Does not implicitly {@link Records.FilesGetResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Records.IFilesGetResponse} message FilesGetResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilesGetResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FilesGetResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Records.FilesGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Records.FilesGetResponse} FilesGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesGetResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Records.FilesGetResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.files && message.files.length))
                        message.files = [];
                    message.files.push($root.Records.FileGetStatus.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FilesGetResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Records.FilesGetResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Records.FilesGetResponse} FilesGetResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilesGetResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FilesGetResponse message.
         * @function verify
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FilesGetResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                    return "files: array expected";
                for (let i = 0; i < message.files.length; ++i) {
                    let error = $root.Records.FileGetStatus.verify(message.files[i]);
                    if (error)
                        return "files." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FilesGetResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Records.FilesGetResponse} FilesGetResponse
         */
        FilesGetResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Records.FilesGetResponse)
                return object;
            let message = new $root.Records.FilesGetResponse();
            if (object.files) {
                if (!Array.isArray(object.files))
                    throw TypeError(".Records.FilesGetResponse.files: array expected");
                message.files = [];
                for (let i = 0; i < object.files.length; ++i) {
                    if (typeof object.files[i] !== "object")
                        throw TypeError(".Records.FilesGetResponse.files: object expected");
                    message.files[i] = $root.Records.FileGetStatus.fromObject(object.files[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a FilesGetResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Records.FilesGetResponse
         * @static
         * @param {Records.FilesGetResponse} message FilesGetResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FilesGetResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.files = [];
            if (message.files && message.files.length) {
                object.files = [];
                for (let j = 0; j < message.files.length; ++j)
                    object.files[j] = $root.Records.FileGetStatus.toObject(message.files[j], options);
            }
            return object;
        };

        /**
         * Converts this FilesGetResponse to JSON.
         * @function toJSON
         * @memberof Records.FilesGetResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FilesGetResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FilesGetResponse;
    })();

    return Records;
})();

export const ServiceLogger = $root.ServiceLogger = (() => {

    /**
     * Namespace ServiceLogger.
     * @exports ServiceLogger
     * @namespace
     */
    const ServiceLogger = {};

    ServiceLogger.IdRange = (function() {

        /**
         * Properties of an IdRange.
         * @memberof ServiceLogger
         * @interface IIdRange
         * @property {number|Long|null} [startingId] IdRange startingId
         * @property {number|Long|null} [endingId] IdRange endingId
         */

        /**
         * Constructs a new IdRange.
         * @memberof ServiceLogger
         * @classdesc Specifies the first and last IDs of a range of IDs so that a Request can ask for information about a range of IDs.
         * @implements IIdRange
         * @constructor
         * @param {ServiceLogger.IIdRange=} [properties] Properties to set
         */
        function IdRange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IdRange startingId.
         * @member {number|Long} startingId
         * @memberof ServiceLogger.IdRange
         * @instance
         */
        IdRange.prototype.startingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * IdRange endingId.
         * @member {number|Long} endingId
         * @memberof ServiceLogger.IdRange
         * @instance
         */
        IdRange.prototype.endingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new IdRange instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {ServiceLogger.IIdRange=} [properties] Properties to set
         * @returns {ServiceLogger.IdRange} IdRange instance
         */
        IdRange.create = function create(properties) {
            return new IdRange(properties);
        };

        /**
         * Encodes the specified IdRange message. Does not implicitly {@link ServiceLogger.IdRange.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {ServiceLogger.IIdRange} message IdRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdRange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startingId != null && message.hasOwnProperty("startingId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startingId);
            if (message.endingId != null && message.hasOwnProperty("endingId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endingId);
            return writer;
        };

        /**
         * Encodes the specified IdRange message, length delimited. Does not implicitly {@link ServiceLogger.IdRange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {ServiceLogger.IIdRange} message IdRange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IdRange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IdRange message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.IdRange} IdRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.IdRange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startingId = reader.uint64();
                    break;
                case 2:
                    message.endingId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IdRange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.IdRange} IdRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IdRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IdRange message.
         * @function verify
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IdRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startingId != null && message.hasOwnProperty("startingId"))
                if (!$util.isInteger(message.startingId) && !(message.startingId && $util.isInteger(message.startingId.low) && $util.isInteger(message.startingId.high)))
                    return "startingId: integer|Long expected";
            if (message.endingId != null && message.hasOwnProperty("endingId"))
                if (!$util.isInteger(message.endingId) && !(message.endingId && $util.isInteger(message.endingId.low) && $util.isInteger(message.endingId.high)))
                    return "endingId: integer|Long expected";
            return null;
        };

        /**
         * Creates an IdRange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.IdRange} IdRange
         */
        IdRange.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.IdRange)
                return object;
            let message = new $root.ServiceLogger.IdRange();
            if (object.startingId != null)
                if ($util.Long)
                    (message.startingId = $util.Long.fromValue(object.startingId)).unsigned = true;
                else if (typeof object.startingId === "string")
                    message.startingId = parseInt(object.startingId, 10);
                else if (typeof object.startingId === "number")
                    message.startingId = object.startingId;
                else if (typeof object.startingId === "object")
                    message.startingId = new $util.LongBits(object.startingId.low >>> 0, object.startingId.high >>> 0).toNumber(true);
            if (object.endingId != null)
                if ($util.Long)
                    (message.endingId = $util.Long.fromValue(object.endingId)).unsigned = true;
                else if (typeof object.endingId === "string")
                    message.endingId = parseInt(object.endingId, 10);
                else if (typeof object.endingId === "number")
                    message.endingId = object.endingId;
                else if (typeof object.endingId === "object")
                    message.endingId = new $util.LongBits(object.endingId.low >>> 0, object.endingId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an IdRange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.IdRange
         * @static
         * @param {ServiceLogger.IdRange} message IdRange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        IdRange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startingId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endingId = options.longs === String ? "0" : 0;
            }
            if (message.startingId != null && message.hasOwnProperty("startingId"))
                if (typeof message.startingId === "number")
                    object.startingId = options.longs === String ? String(message.startingId) : message.startingId;
                else
                    object.startingId = options.longs === String ? $util.Long.prototype.toString.call(message.startingId) : options.longs === Number ? new $util.LongBits(message.startingId.low >>> 0, message.startingId.high >>> 0).toNumber(true) : message.startingId;
            if (message.endingId != null && message.hasOwnProperty("endingId"))
                if (typeof message.endingId === "number")
                    object.endingId = options.longs === String ? String(message.endingId) : message.endingId;
                else
                    object.endingId = options.longs === String ? $util.Long.prototype.toString.call(message.endingId) : options.longs === Number ? new $util.LongBits(message.endingId.low >>> 0, message.endingId.high >>> 0).toNumber(true) : message.endingId;
            return object;
        };

        /**
         * Converts this IdRange to JSON.
         * @function toJSON
         * @memberof ServiceLogger.IdRange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        IdRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return IdRange;
    })();

    ServiceLogger.ServiceInfoSpecifier = (function() {

        /**
         * Properties of a ServiceInfoSpecifier.
         * @memberof ServiceLogger
         * @interface IServiceInfoSpecifier
         * @property {boolean|null} [all] ServiceInfoSpecifier all
         * @property {number|Long|null} [serviceInfoId] ServiceInfoSpecifier serviceInfoId
         * @property {string|null} [name] ServiceInfoSpecifier name
         */

        /**
         * Constructs a new ServiceInfoSpecifier.
         * @memberof ServiceLogger
         * @classdesc Used in ServiceInfoRequest
         * @implements IServiceInfoSpecifier
         * @constructor
         * @param {ServiceLogger.IServiceInfoSpecifier=} [properties] Properties to set
         */
        function ServiceInfoSpecifier(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceInfoSpecifier all.
         * @member {boolean} all
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @instance
         */
        ServiceInfoSpecifier.prototype.all = false;

        /**
         * ServiceInfoSpecifier serviceInfoId.
         * @member {number|Long} serviceInfoId
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @instance
         */
        ServiceInfoSpecifier.prototype.serviceInfoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceInfoSpecifier name.
         * @member {string} name
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @instance
         */
        ServiceInfoSpecifier.prototype.name = "";

        /**
         * Creates a new ServiceInfoSpecifier instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {ServiceLogger.IServiceInfoSpecifier=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceInfoSpecifier} ServiceInfoSpecifier instance
         */
        ServiceInfoSpecifier.create = function create(properties) {
            return new ServiceInfoSpecifier(properties);
        };

        /**
         * Encodes the specified ServiceInfoSpecifier message. Does not implicitly {@link ServiceLogger.ServiceInfoSpecifier.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {ServiceLogger.IServiceInfoSpecifier} message ServiceInfoSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoSpecifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.all != null && message.hasOwnProperty("all"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.all);
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceInfoId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ServiceInfoSpecifier message, length delimited. Does not implicitly {@link ServiceLogger.ServiceInfoSpecifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {ServiceLogger.IServiceInfoSpecifier} message ServiceInfoSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoSpecifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceInfoSpecifier message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceInfoSpecifier} ServiceInfoSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoSpecifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceInfoSpecifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.all = reader.bool();
                    break;
                case 2:
                    message.serviceInfoId = reader.uint64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceInfoSpecifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceInfoSpecifier} ServiceInfoSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoSpecifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceInfoSpecifier message.
         * @function verify
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceInfoSpecifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.all != null && message.hasOwnProperty("all"))
                if (typeof message.all !== "boolean")
                    return "all: boolean expected";
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (!$util.isInteger(message.serviceInfoId) && !(message.serviceInfoId && $util.isInteger(message.serviceInfoId.low) && $util.isInteger(message.serviceInfoId.high)))
                    return "serviceInfoId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a ServiceInfoSpecifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceInfoSpecifier} ServiceInfoSpecifier
         */
        ServiceInfoSpecifier.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceInfoSpecifier)
                return object;
            let message = new $root.ServiceLogger.ServiceInfoSpecifier();
            if (object.all != null)
                message.all = Boolean(object.all);
            if (object.serviceInfoId != null)
                if ($util.Long)
                    (message.serviceInfoId = $util.Long.fromValue(object.serviceInfoId)).unsigned = true;
                else if (typeof object.serviceInfoId === "string")
                    message.serviceInfoId = parseInt(object.serviceInfoId, 10);
                else if (typeof object.serviceInfoId === "number")
                    message.serviceInfoId = object.serviceInfoId;
                else if (typeof object.serviceInfoId === "object")
                    message.serviceInfoId = new $util.LongBits(object.serviceInfoId.low >>> 0, object.serviceInfoId.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a ServiceInfoSpecifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @static
         * @param {ServiceLogger.ServiceInfoSpecifier} message ServiceInfoSpecifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceInfoSpecifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.all = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceInfoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceInfoId = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.all != null && message.hasOwnProperty("all"))
                object.all = message.all;
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (typeof message.serviceInfoId === "number")
                    object.serviceInfoId = options.longs === String ? String(message.serviceInfoId) : message.serviceInfoId;
                else
                    object.serviceInfoId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceInfoId) : options.longs === Number ? new $util.LongBits(message.serviceInfoId.low >>> 0, message.serviceInfoId.high >>> 0).toNumber(true) : message.serviceInfoId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this ServiceInfoSpecifier to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceInfoSpecifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceInfoSpecifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceInfoSpecifier;
    })();

    ServiceLogger.ServiceInfoRequest = (function() {

        /**
         * Properties of a ServiceInfoRequest.
         * @memberof ServiceLogger
         * @interface IServiceInfoRequest
         * @property {Array.<ServiceLogger.IServiceInfoSpecifier>|null} [serviceInfoSpecifier] ServiceInfoRequest serviceInfoSpecifier
         */

        /**
         * Constructs a new ServiceInfoRequest.
         * @memberof ServiceLogger
         * @classdesc Request information about one or more services by ID or name, or retrieve all.
         * @implements IServiceInfoRequest
         * @constructor
         * @param {ServiceLogger.IServiceInfoRequest=} [properties] Properties to set
         */
        function ServiceInfoRequest(properties) {
            this.serviceInfoSpecifier = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceInfoRequest serviceInfoSpecifier.
         * @member {Array.<ServiceLogger.IServiceInfoSpecifier>} serviceInfoSpecifier
         * @memberof ServiceLogger.ServiceInfoRequest
         * @instance
         */
        ServiceInfoRequest.prototype.serviceInfoSpecifier = $util.emptyArray;

        /**
         * Creates a new ServiceInfoRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {ServiceLogger.IServiceInfoRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceInfoRequest} ServiceInfoRequest instance
         */
        ServiceInfoRequest.create = function create(properties) {
            return new ServiceInfoRequest(properties);
        };

        /**
         * Encodes the specified ServiceInfoRequest message. Does not implicitly {@link ServiceLogger.ServiceInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {ServiceLogger.IServiceInfoRequest} message ServiceInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceInfoSpecifier != null && message.serviceInfoSpecifier.length)
                for (let i = 0; i < message.serviceInfoSpecifier.length; ++i)
                    $root.ServiceLogger.ServiceInfoSpecifier.encode(message.serviceInfoSpecifier[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceInfoRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {ServiceLogger.IServiceInfoRequest} message ServiceInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceInfoRequest} ServiceInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceInfoSpecifier && message.serviceInfoSpecifier.length))
                        message.serviceInfoSpecifier = [];
                    message.serviceInfoSpecifier.push($root.ServiceLogger.ServiceInfoSpecifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceInfoRequest} ServiceInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceInfoRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceInfoSpecifier != null && message.hasOwnProperty("serviceInfoSpecifier")) {
                if (!Array.isArray(message.serviceInfoSpecifier))
                    return "serviceInfoSpecifier: array expected";
                for (let i = 0; i < message.serviceInfoSpecifier.length; ++i) {
                    let error = $root.ServiceLogger.ServiceInfoSpecifier.verify(message.serviceInfoSpecifier[i]);
                    if (error)
                        return "serviceInfoSpecifier." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceInfoRequest} ServiceInfoRequest
         */
        ServiceInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceInfoRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceInfoRequest();
            if (object.serviceInfoSpecifier) {
                if (!Array.isArray(object.serviceInfoSpecifier))
                    throw TypeError(".ServiceLogger.ServiceInfoRequest.serviceInfoSpecifier: array expected");
                message.serviceInfoSpecifier = [];
                for (let i = 0; i < object.serviceInfoSpecifier.length; ++i) {
                    if (typeof object.serviceInfoSpecifier[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceInfoRequest.serviceInfoSpecifier: object expected");
                    message.serviceInfoSpecifier[i] = $root.ServiceLogger.ServiceInfoSpecifier.fromObject(object.serviceInfoSpecifier[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceInfoRequest
         * @static
         * @param {ServiceLogger.ServiceInfoRequest} message ServiceInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceInfoSpecifier = [];
            if (message.serviceInfoSpecifier && message.serviceInfoSpecifier.length) {
                object.serviceInfoSpecifier = [];
                for (let j = 0; j < message.serviceInfoSpecifier.length; ++j)
                    object.serviceInfoSpecifier[j] = $root.ServiceLogger.ServiceInfoSpecifier.toObject(message.serviceInfoSpecifier[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceInfoRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceInfoRequest;
    })();

    ServiceLogger.ServiceInfoRecord = (function() {

        /**
         * Properties of a ServiceInfoRecord.
         * @memberof ServiceLogger
         * @interface IServiceInfoRecord
         * @property {number|Long|null} [serviceInfoId] ServiceInfoRecord serviceInfoId
         * @property {string|null} [name] ServiceInfoRecord name
         * @property {number|null} [deleteAfter] ServiceInfoRecord deleteAfter
         * @property {string|null} [deleteAfterTimeUnits] ServiceInfoRecord deleteAfterTimeUnits
         * @property {boolean|null} [isShortTermLogging] ServiceInfoRecord isShortTermLogging
         */

        /**
         * Constructs a new ServiceInfoRecord.
         * @memberof ServiceLogger
         * @classdesc Used in ServiceInfoResponse
         * @implements IServiceInfoRecord
         * @constructor
         * @param {ServiceLogger.IServiceInfoRecord=} [properties] Properties to set
         */
        function ServiceInfoRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceInfoRecord serviceInfoId.
         * @member {number|Long} serviceInfoId
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         */
        ServiceInfoRecord.prototype.serviceInfoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceInfoRecord name.
         * @member {string} name
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         */
        ServiceInfoRecord.prototype.name = "";

        /**
         * ServiceInfoRecord deleteAfter.
         * @member {number} deleteAfter
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         */
        ServiceInfoRecord.prototype.deleteAfter = 0;

        /**
         * ServiceInfoRecord deleteAfterTimeUnits.
         * @member {string} deleteAfterTimeUnits
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         */
        ServiceInfoRecord.prototype.deleteAfterTimeUnits = "";

        /**
         * ServiceInfoRecord isShortTermLogging.
         * @member {boolean} isShortTermLogging
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         */
        ServiceInfoRecord.prototype.isShortTermLogging = false;

        /**
         * Creates a new ServiceInfoRecord instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {ServiceLogger.IServiceInfoRecord=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceInfoRecord} ServiceInfoRecord instance
         */
        ServiceInfoRecord.create = function create(properties) {
            return new ServiceInfoRecord(properties);
        };

        /**
         * Encodes the specified ServiceInfoRecord message. Does not implicitly {@link ServiceLogger.ServiceInfoRecord.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {ServiceLogger.IServiceInfoRecord} message ServiceInfoRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serviceInfoId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.deleteAfter != null && message.hasOwnProperty("deleteAfter"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.deleteAfter);
            if (message.deleteAfterTimeUnits != null && message.hasOwnProperty("deleteAfterTimeUnits"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.deleteAfterTimeUnits);
            if (message.isShortTermLogging != null && message.hasOwnProperty("isShortTermLogging"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isShortTermLogging);
            return writer;
        };

        /**
         * Encodes the specified ServiceInfoRecord message, length delimited. Does not implicitly {@link ServiceLogger.ServiceInfoRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {ServiceLogger.IServiceInfoRecord} message ServiceInfoRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceInfoRecord message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceInfoRecord} ServiceInfoRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceInfoRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceInfoId = reader.uint64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.deleteAfter = reader.uint32();
                    break;
                case 4:
                    message.deleteAfterTimeUnits = reader.string();
                    break;
                case 5:
                    message.isShortTermLogging = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceInfoRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceInfoRecord} ServiceInfoRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceInfoRecord message.
         * @function verify
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceInfoRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (!$util.isInteger(message.serviceInfoId) && !(message.serviceInfoId && $util.isInteger(message.serviceInfoId.low) && $util.isInteger(message.serviceInfoId.high)))
                    return "serviceInfoId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.deleteAfter != null && message.hasOwnProperty("deleteAfter"))
                if (!$util.isInteger(message.deleteAfter))
                    return "deleteAfter: integer expected";
            if (message.deleteAfterTimeUnits != null && message.hasOwnProperty("deleteAfterTimeUnits"))
                if (!$util.isString(message.deleteAfterTimeUnits))
                    return "deleteAfterTimeUnits: string expected";
            if (message.isShortTermLogging != null && message.hasOwnProperty("isShortTermLogging"))
                if (typeof message.isShortTermLogging !== "boolean")
                    return "isShortTermLogging: boolean expected";
            return null;
        };

        /**
         * Creates a ServiceInfoRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceInfoRecord} ServiceInfoRecord
         */
        ServiceInfoRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceInfoRecord)
                return object;
            let message = new $root.ServiceLogger.ServiceInfoRecord();
            if (object.serviceInfoId != null)
                if ($util.Long)
                    (message.serviceInfoId = $util.Long.fromValue(object.serviceInfoId)).unsigned = true;
                else if (typeof object.serviceInfoId === "string")
                    message.serviceInfoId = parseInt(object.serviceInfoId, 10);
                else if (typeof object.serviceInfoId === "number")
                    message.serviceInfoId = object.serviceInfoId;
                else if (typeof object.serviceInfoId === "object")
                    message.serviceInfoId = new $util.LongBits(object.serviceInfoId.low >>> 0, object.serviceInfoId.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            if (object.deleteAfter != null)
                message.deleteAfter = object.deleteAfter >>> 0;
            if (object.deleteAfterTimeUnits != null)
                message.deleteAfterTimeUnits = String(object.deleteAfterTimeUnits);
            if (object.isShortTermLogging != null)
                message.isShortTermLogging = Boolean(object.isShortTermLogging);
            return message;
        };

        /**
         * Creates a plain object from a ServiceInfoRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceInfoRecord
         * @static
         * @param {ServiceLogger.ServiceInfoRecord} message ServiceInfoRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceInfoRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceInfoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceInfoId = options.longs === String ? "0" : 0;
                object.name = "";
                object.deleteAfter = 0;
                object.deleteAfterTimeUnits = "";
                object.isShortTermLogging = false;
            }
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (typeof message.serviceInfoId === "number")
                    object.serviceInfoId = options.longs === String ? String(message.serviceInfoId) : message.serviceInfoId;
                else
                    object.serviceInfoId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceInfoId) : options.longs === Number ? new $util.LongBits(message.serviceInfoId.low >>> 0, message.serviceInfoId.high >>> 0).toNumber(true) : message.serviceInfoId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.deleteAfter != null && message.hasOwnProperty("deleteAfter"))
                object.deleteAfter = message.deleteAfter;
            if (message.deleteAfterTimeUnits != null && message.hasOwnProperty("deleteAfterTimeUnits"))
                object.deleteAfterTimeUnits = message.deleteAfterTimeUnits;
            if (message.isShortTermLogging != null && message.hasOwnProperty("isShortTermLogging"))
                object.isShortTermLogging = message.isShortTermLogging;
            return object;
        };

        /**
         * Converts this ServiceInfoRecord to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceInfoRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceInfoRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceInfoRecord;
    })();

    ServiceLogger.ServiceInfoResponse = (function() {

        /**
         * Properties of a ServiceInfoResponse.
         * @memberof ServiceLogger
         * @interface IServiceInfoResponse
         * @property {Array.<ServiceLogger.IServiceInfoRecord>|null} [serviceInfoRecord] ServiceInfoResponse serviceInfoRecord
         */

        /**
         * Constructs a new ServiceInfoResponse.
         * @memberof ServiceLogger
         * @classdesc Returns information about Services
         * @implements IServiceInfoResponse
         * @constructor
         * @param {ServiceLogger.IServiceInfoResponse=} [properties] Properties to set
         */
        function ServiceInfoResponse(properties) {
            this.serviceInfoRecord = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceInfoResponse serviceInfoRecord.
         * @member {Array.<ServiceLogger.IServiceInfoRecord>} serviceInfoRecord
         * @memberof ServiceLogger.ServiceInfoResponse
         * @instance
         */
        ServiceInfoResponse.prototype.serviceInfoRecord = $util.emptyArray;

        /**
         * Creates a new ServiceInfoResponse instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {ServiceLogger.IServiceInfoResponse=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceInfoResponse} ServiceInfoResponse instance
         */
        ServiceInfoResponse.create = function create(properties) {
            return new ServiceInfoResponse(properties);
        };

        /**
         * Encodes the specified ServiceInfoResponse message. Does not implicitly {@link ServiceLogger.ServiceInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {ServiceLogger.IServiceInfoResponse} message ServiceInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceInfoRecord != null && message.serviceInfoRecord.length)
                for (let i = 0; i < message.serviceInfoRecord.length; ++i)
                    $root.ServiceLogger.ServiceInfoRecord.encode(message.serviceInfoRecord[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceInfoResponse message, length delimited. Does not implicitly {@link ServiceLogger.ServiceInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {ServiceLogger.IServiceInfoResponse} message ServiceInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceInfoResponse} ServiceInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceInfoResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceInfoRecord && message.serviceInfoRecord.length))
                        message.serviceInfoRecord = [];
                    message.serviceInfoRecord.push($root.ServiceLogger.ServiceInfoRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceInfoResponse} ServiceInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceInfoResponse message.
         * @function verify
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceInfoRecord != null && message.hasOwnProperty("serviceInfoRecord")) {
                if (!Array.isArray(message.serviceInfoRecord))
                    return "serviceInfoRecord: array expected";
                for (let i = 0; i < message.serviceInfoRecord.length; ++i) {
                    let error = $root.ServiceLogger.ServiceInfoRecord.verify(message.serviceInfoRecord[i]);
                    if (error)
                        return "serviceInfoRecord." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceInfoResponse} ServiceInfoResponse
         */
        ServiceInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceInfoResponse)
                return object;
            let message = new $root.ServiceLogger.ServiceInfoResponse();
            if (object.serviceInfoRecord) {
                if (!Array.isArray(object.serviceInfoRecord))
                    throw TypeError(".ServiceLogger.ServiceInfoResponse.serviceInfoRecord: array expected");
                message.serviceInfoRecord = [];
                for (let i = 0; i < object.serviceInfoRecord.length; ++i) {
                    if (typeof object.serviceInfoRecord[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceInfoResponse.serviceInfoRecord: object expected");
                    message.serviceInfoRecord[i] = $root.ServiceLogger.ServiceInfoRecord.fromObject(object.serviceInfoRecord[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceInfoResponse
         * @static
         * @param {ServiceLogger.ServiceInfoResponse} message ServiceInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceInfoRecord = [];
            if (message.serviceInfoRecord && message.serviceInfoRecord.length) {
                object.serviceInfoRecord = [];
                for (let j = 0; j < message.serviceInfoRecord.length; ++j)
                    object.serviceInfoRecord[j] = $root.ServiceLogger.ServiceInfoRecord.toObject(message.serviceInfoRecord[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceInfoResponse to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceInfoResponse;
    })();

    ServiceLogger.ServiceInfoUpdateRequest = (function() {

        /**
         * Properties of a ServiceInfoUpdateRequest.
         * @memberof ServiceLogger
         * @interface IServiceInfoUpdateRequest
         * @property {Array.<ServiceLogger.IServiceInfoRecord>|null} [serviceInfoRecord] ServiceInfoUpdateRequest serviceInfoRecord
         */

        /**
         * Constructs a new ServiceInfoUpdateRequest.
         * @memberof ServiceLogger
         * @classdesc Update one or more ServiceInfo records by their IDs
         * @implements IServiceInfoUpdateRequest
         * @constructor
         * @param {ServiceLogger.IServiceInfoUpdateRequest=} [properties] Properties to set
         */
        function ServiceInfoUpdateRequest(properties) {
            this.serviceInfoRecord = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceInfoUpdateRequest serviceInfoRecord.
         * @member {Array.<ServiceLogger.IServiceInfoRecord>} serviceInfoRecord
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @instance
         */
        ServiceInfoUpdateRequest.prototype.serviceInfoRecord = $util.emptyArray;

        /**
         * Creates a new ServiceInfoUpdateRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceInfoUpdateRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceInfoUpdateRequest} ServiceInfoUpdateRequest instance
         */
        ServiceInfoUpdateRequest.create = function create(properties) {
            return new ServiceInfoUpdateRequest(properties);
        };

        /**
         * Encodes the specified ServiceInfoUpdateRequest message. Does not implicitly {@link ServiceLogger.ServiceInfoUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceInfoUpdateRequest} message ServiceInfoUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceInfoRecord != null && message.serviceInfoRecord.length)
                for (let i = 0; i < message.serviceInfoRecord.length; ++i)
                    $root.ServiceLogger.ServiceInfoRecord.encode(message.serviceInfoRecord[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceInfoUpdateRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceInfoUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceInfoUpdateRequest} message ServiceInfoUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceInfoUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceInfoUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceInfoUpdateRequest} ServiceInfoUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceInfoUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceInfoRecord && message.serviceInfoRecord.length))
                        message.serviceInfoRecord = [];
                    message.serviceInfoRecord.push($root.ServiceLogger.ServiceInfoRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceInfoUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceInfoUpdateRequest} ServiceInfoUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceInfoUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceInfoUpdateRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceInfoUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceInfoRecord != null && message.hasOwnProperty("serviceInfoRecord")) {
                if (!Array.isArray(message.serviceInfoRecord))
                    return "serviceInfoRecord: array expected";
                for (let i = 0; i < message.serviceInfoRecord.length; ++i) {
                    let error = $root.ServiceLogger.ServiceInfoRecord.verify(message.serviceInfoRecord[i]);
                    if (error)
                        return "serviceInfoRecord." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceInfoUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceInfoUpdateRequest} ServiceInfoUpdateRequest
         */
        ServiceInfoUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceInfoUpdateRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceInfoUpdateRequest();
            if (object.serviceInfoRecord) {
                if (!Array.isArray(object.serviceInfoRecord))
                    throw TypeError(".ServiceLogger.ServiceInfoUpdateRequest.serviceInfoRecord: array expected");
                message.serviceInfoRecord = [];
                for (let i = 0; i < object.serviceInfoRecord.length; ++i) {
                    if (typeof object.serviceInfoRecord[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceInfoUpdateRequest.serviceInfoRecord: object expected");
                    message.serviceInfoRecord[i] = $root.ServiceLogger.ServiceInfoRecord.fromObject(object.serviceInfoRecord[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceInfoUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @static
         * @param {ServiceLogger.ServiceInfoUpdateRequest} message ServiceInfoUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceInfoUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceInfoRecord = [];
            if (message.serviceInfoRecord && message.serviceInfoRecord.length) {
                object.serviceInfoRecord = [];
                for (let j = 0; j < message.serviceInfoRecord.length; ++j)
                    object.serviceInfoRecord[j] = $root.ServiceLogger.ServiceInfoRecord.toObject(message.serviceInfoRecord[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceInfoUpdateRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceInfoUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceInfoUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceInfoUpdateRequest;
    })();

    ServiceLogger.ServiceRuleSpecifier = (function() {

        /**
         * Properties of a ServiceRuleSpecifier.
         * @memberof ServiceLogger
         * @interface IServiceRuleSpecifier
         * @property {boolean|null} [all] ServiceRuleSpecifier all
         * @property {number|Long|null} [serviceRuleId] ServiceRuleSpecifier serviceRuleId
         * @property {number|Long|null} [serviceInfoId] ServiceRuleSpecifier serviceInfoId
         * @property {Array.<ServiceLogger.IIdRange>|null} [resourceIdRange] ServiceRuleSpecifier resourceIdRange
         */

        /**
         * Constructs a new ServiceRuleSpecifier.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceRuleSpecifier.
         * @implements IServiceRuleSpecifier
         * @constructor
         * @param {ServiceLogger.IServiceRuleSpecifier=} [properties] Properties to set
         */
        function ServiceRuleSpecifier(properties) {
            this.resourceIdRange = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceRuleSpecifier all.
         * @member {boolean} all
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @instance
         */
        ServiceRuleSpecifier.prototype.all = false;

        /**
         * ServiceRuleSpecifier serviceRuleId.
         * @member {number|Long} serviceRuleId
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @instance
         */
        ServiceRuleSpecifier.prototype.serviceRuleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceRuleSpecifier serviceInfoId.
         * @member {number|Long} serviceInfoId
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @instance
         */
        ServiceRuleSpecifier.prototype.serviceInfoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceRuleSpecifier resourceIdRange.
         * @member {Array.<ServiceLogger.IIdRange>} resourceIdRange
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @instance
         */
        ServiceRuleSpecifier.prototype.resourceIdRange = $util.emptyArray;

        /**
         * Creates a new ServiceRuleSpecifier instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {ServiceLogger.IServiceRuleSpecifier=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceRuleSpecifier} ServiceRuleSpecifier instance
         */
        ServiceRuleSpecifier.create = function create(properties) {
            return new ServiceRuleSpecifier(properties);
        };

        /**
         * Encodes the specified ServiceRuleSpecifier message. Does not implicitly {@link ServiceLogger.ServiceRuleSpecifier.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {ServiceLogger.IServiceRuleSpecifier} message ServiceRuleSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleSpecifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.all != null && message.hasOwnProperty("all"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.all);
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceRuleId);
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.serviceInfoId);
            if (message.resourceIdRange != null && message.resourceIdRange.length)
                for (let i = 0; i < message.resourceIdRange.length; ++i)
                    $root.ServiceLogger.IdRange.encode(message.resourceIdRange[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceRuleSpecifier message, length delimited. Does not implicitly {@link ServiceLogger.ServiceRuleSpecifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {ServiceLogger.IServiceRuleSpecifier} message ServiceRuleSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleSpecifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceRuleSpecifier message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceRuleSpecifier} ServiceRuleSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleSpecifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceRuleSpecifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.all = reader.bool();
                    break;
                case 2:
                    message.serviceRuleId = reader.uint64();
                    break;
                case 3:
                    message.serviceInfoId = reader.uint64();
                    break;
                case 4:
                    if (!(message.resourceIdRange && message.resourceIdRange.length))
                        message.resourceIdRange = [];
                    message.resourceIdRange.push($root.ServiceLogger.IdRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceRuleSpecifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceRuleSpecifier} ServiceRuleSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleSpecifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceRuleSpecifier message.
         * @function verify
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceRuleSpecifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.all != null && message.hasOwnProperty("all"))
                if (typeof message.all !== "boolean")
                    return "all: boolean expected";
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                if (!$util.isInteger(message.serviceRuleId) && !(message.serviceRuleId && $util.isInteger(message.serviceRuleId.low) && $util.isInteger(message.serviceRuleId.high)))
                    return "serviceRuleId: integer|Long expected";
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (!$util.isInteger(message.serviceInfoId) && !(message.serviceInfoId && $util.isInteger(message.serviceInfoId.low) && $util.isInteger(message.serviceInfoId.high)))
                    return "serviceInfoId: integer|Long expected";
            if (message.resourceIdRange != null && message.hasOwnProperty("resourceIdRange")) {
                if (!Array.isArray(message.resourceIdRange))
                    return "resourceIdRange: array expected";
                for (let i = 0; i < message.resourceIdRange.length; ++i) {
                    let error = $root.ServiceLogger.IdRange.verify(message.resourceIdRange[i]);
                    if (error)
                        return "resourceIdRange." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceRuleSpecifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceRuleSpecifier} ServiceRuleSpecifier
         */
        ServiceRuleSpecifier.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceRuleSpecifier)
                return object;
            let message = new $root.ServiceLogger.ServiceRuleSpecifier();
            if (object.all != null)
                message.all = Boolean(object.all);
            if (object.serviceRuleId != null)
                if ($util.Long)
                    (message.serviceRuleId = $util.Long.fromValue(object.serviceRuleId)).unsigned = true;
                else if (typeof object.serviceRuleId === "string")
                    message.serviceRuleId = parseInt(object.serviceRuleId, 10);
                else if (typeof object.serviceRuleId === "number")
                    message.serviceRuleId = object.serviceRuleId;
                else if (typeof object.serviceRuleId === "object")
                    message.serviceRuleId = new $util.LongBits(object.serviceRuleId.low >>> 0, object.serviceRuleId.high >>> 0).toNumber(true);
            if (object.serviceInfoId != null)
                if ($util.Long)
                    (message.serviceInfoId = $util.Long.fromValue(object.serviceInfoId)).unsigned = true;
                else if (typeof object.serviceInfoId === "string")
                    message.serviceInfoId = parseInt(object.serviceInfoId, 10);
                else if (typeof object.serviceInfoId === "number")
                    message.serviceInfoId = object.serviceInfoId;
                else if (typeof object.serviceInfoId === "object")
                    message.serviceInfoId = new $util.LongBits(object.serviceInfoId.low >>> 0, object.serviceInfoId.high >>> 0).toNumber(true);
            if (object.resourceIdRange) {
                if (!Array.isArray(object.resourceIdRange))
                    throw TypeError(".ServiceLogger.ServiceRuleSpecifier.resourceIdRange: array expected");
                message.resourceIdRange = [];
                for (let i = 0; i < object.resourceIdRange.length; ++i) {
                    if (typeof object.resourceIdRange[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceRuleSpecifier.resourceIdRange: object expected");
                    message.resourceIdRange[i] = $root.ServiceLogger.IdRange.fromObject(object.resourceIdRange[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceRuleSpecifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @static
         * @param {ServiceLogger.ServiceRuleSpecifier} message ServiceRuleSpecifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceRuleSpecifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resourceIdRange = [];
            if (options.defaults) {
                object.all = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceRuleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceRuleId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceInfoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceInfoId = options.longs === String ? "0" : 0;
            }
            if (message.all != null && message.hasOwnProperty("all"))
                object.all = message.all;
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                if (typeof message.serviceRuleId === "number")
                    object.serviceRuleId = options.longs === String ? String(message.serviceRuleId) : message.serviceRuleId;
                else
                    object.serviceRuleId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceRuleId) : options.longs === Number ? new $util.LongBits(message.serviceRuleId.low >>> 0, message.serviceRuleId.high >>> 0).toNumber(true) : message.serviceRuleId;
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (typeof message.serviceInfoId === "number")
                    object.serviceInfoId = options.longs === String ? String(message.serviceInfoId) : message.serviceInfoId;
                else
                    object.serviceInfoId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceInfoId) : options.longs === Number ? new $util.LongBits(message.serviceInfoId.low >>> 0, message.serviceInfoId.high >>> 0).toNumber(true) : message.serviceInfoId;
            if (message.resourceIdRange && message.resourceIdRange.length) {
                object.resourceIdRange = [];
                for (let j = 0; j < message.resourceIdRange.length; ++j)
                    object.resourceIdRange[j] = $root.ServiceLogger.IdRange.toObject(message.resourceIdRange[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceRuleSpecifier to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceRuleSpecifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceRuleSpecifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceRuleSpecifier;
    })();

    ServiceLogger.ServiceRuleRequest = (function() {

        /**
         * Properties of a ServiceRuleRequest.
         * @memberof ServiceLogger
         * @interface IServiceRuleRequest
         * @property {Array.<ServiceLogger.IServiceRuleSpecifier>|null} [serviceRuleSpecifier] ServiceRuleRequest serviceRuleSpecifier
         */

        /**
         * Constructs a new ServiceRuleRequest.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceRuleRequest.
         * @implements IServiceRuleRequest
         * @constructor
         * @param {ServiceLogger.IServiceRuleRequest=} [properties] Properties to set
         */
        function ServiceRuleRequest(properties) {
            this.serviceRuleSpecifier = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceRuleRequest serviceRuleSpecifier.
         * @member {Array.<ServiceLogger.IServiceRuleSpecifier>} serviceRuleSpecifier
         * @memberof ServiceLogger.ServiceRuleRequest
         * @instance
         */
        ServiceRuleRequest.prototype.serviceRuleSpecifier = $util.emptyArray;

        /**
         * Creates a new ServiceRuleRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {ServiceLogger.IServiceRuleRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceRuleRequest} ServiceRuleRequest instance
         */
        ServiceRuleRequest.create = function create(properties) {
            return new ServiceRuleRequest(properties);
        };

        /**
         * Encodes the specified ServiceRuleRequest message. Does not implicitly {@link ServiceLogger.ServiceRuleRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {ServiceLogger.IServiceRuleRequest} message ServiceRuleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceRuleSpecifier != null && message.serviceRuleSpecifier.length)
                for (let i = 0; i < message.serviceRuleSpecifier.length; ++i)
                    $root.ServiceLogger.ServiceRuleSpecifier.encode(message.serviceRuleSpecifier[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceRuleRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceRuleRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {ServiceLogger.IServiceRuleRequest} message ServiceRuleRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceRuleRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceRuleRequest} ServiceRuleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceRuleRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceRuleSpecifier && message.serviceRuleSpecifier.length))
                        message.serviceRuleSpecifier = [];
                    message.serviceRuleSpecifier.push($root.ServiceLogger.ServiceRuleSpecifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceRuleRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceRuleRequest} ServiceRuleRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceRuleRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceRuleRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceRuleSpecifier != null && message.hasOwnProperty("serviceRuleSpecifier")) {
                if (!Array.isArray(message.serviceRuleSpecifier))
                    return "serviceRuleSpecifier: array expected";
                for (let i = 0; i < message.serviceRuleSpecifier.length; ++i) {
                    let error = $root.ServiceLogger.ServiceRuleSpecifier.verify(message.serviceRuleSpecifier[i]);
                    if (error)
                        return "serviceRuleSpecifier." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceRuleRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceRuleRequest} ServiceRuleRequest
         */
        ServiceRuleRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceRuleRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceRuleRequest();
            if (object.serviceRuleSpecifier) {
                if (!Array.isArray(object.serviceRuleSpecifier))
                    throw TypeError(".ServiceLogger.ServiceRuleRequest.serviceRuleSpecifier: array expected");
                message.serviceRuleSpecifier = [];
                for (let i = 0; i < object.serviceRuleSpecifier.length; ++i) {
                    if (typeof object.serviceRuleSpecifier[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceRuleRequest.serviceRuleSpecifier: object expected");
                    message.serviceRuleSpecifier[i] = $root.ServiceLogger.ServiceRuleSpecifier.fromObject(object.serviceRuleSpecifier[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceRuleRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceRuleRequest
         * @static
         * @param {ServiceLogger.ServiceRuleRequest} message ServiceRuleRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceRuleRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceRuleSpecifier = [];
            if (message.serviceRuleSpecifier && message.serviceRuleSpecifier.length) {
                object.serviceRuleSpecifier = [];
                for (let j = 0; j < message.serviceRuleSpecifier.length; ++j)
                    object.serviceRuleSpecifier[j] = $root.ServiceLogger.ServiceRuleSpecifier.toObject(message.serviceRuleSpecifier[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceRuleRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceRuleRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceRuleRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceRuleRequest;
    })();

    ServiceLogger.ServiceRuleRecord = (function() {

        /**
         * Properties of a ServiceRuleRecord.
         * @memberof ServiceLogger
         * @interface IServiceRuleRecord
         * @property {number|Long|null} [serviceRuleId] ServiceRuleRecord serviceRuleId
         * @property {number|Long|null} [serviceInfoId] ServiceRuleRecord serviceInfoId
         * @property {number|Long|null} [resourceId] ServiceRuleRecord resourceId
         * @property {boolean|null} [isLoggingEnabled] ServiceRuleRecord isLoggingEnabled
         * @property {string|null} [logLevel] ServiceRuleRecord logLevel
         * @property {string|null} [ruleStart] ServiceRuleRecord ruleStart
         * @property {string|null} [ruleEnd] ServiceRuleRecord ruleEnd
         * @property {string|null} [dateModified] ServiceRuleRecord dateModified
         */

        /**
         * Constructs a new ServiceRuleRecord.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceRuleRecord.
         * @implements IServiceRuleRecord
         * @constructor
         * @param {ServiceLogger.IServiceRuleRecord=} [properties] Properties to set
         */
        function ServiceRuleRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceRuleRecord serviceRuleId.
         * @member {number|Long} serviceRuleId
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.serviceRuleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceRuleRecord serviceInfoId.
         * @member {number|Long} serviceInfoId
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.serviceInfoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceRuleRecord resourceId.
         * @member {number|Long} resourceId
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.resourceId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceRuleRecord isLoggingEnabled.
         * @member {boolean} isLoggingEnabled
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.isLoggingEnabled = false;

        /**
         * ServiceRuleRecord logLevel.
         * @member {string} logLevel
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.logLevel = "";

        /**
         * ServiceRuleRecord ruleStart.
         * @member {string} ruleStart
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.ruleStart = "";

        /**
         * ServiceRuleRecord ruleEnd.
         * @member {string} ruleEnd
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.ruleEnd = "";

        /**
         * ServiceRuleRecord dateModified.
         * @member {string} dateModified
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         */
        ServiceRuleRecord.prototype.dateModified = "";

        /**
         * Creates a new ServiceRuleRecord instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {ServiceLogger.IServiceRuleRecord=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceRuleRecord} ServiceRuleRecord instance
         */
        ServiceRuleRecord.create = function create(properties) {
            return new ServiceRuleRecord(properties);
        };

        /**
         * Encodes the specified ServiceRuleRecord message. Does not implicitly {@link ServiceLogger.ServiceRuleRecord.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {ServiceLogger.IServiceRuleRecord} message ServiceRuleRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serviceRuleId);
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceInfoId);
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.resourceId);
            if (message.isLoggingEnabled != null && message.hasOwnProperty("isLoggingEnabled"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isLoggingEnabled);
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.logLevel);
            if (message.ruleStart != null && message.hasOwnProperty("ruleStart"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ruleStart);
            if (message.ruleEnd != null && message.hasOwnProperty("ruleEnd"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.ruleEnd);
            if (message.dateModified != null && message.hasOwnProperty("dateModified"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.dateModified);
            return writer;
        };

        /**
         * Encodes the specified ServiceRuleRecord message, length delimited. Does not implicitly {@link ServiceLogger.ServiceRuleRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {ServiceLogger.IServiceRuleRecord} message ServiceRuleRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceRuleRecord message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceRuleRecord} ServiceRuleRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceRuleRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceRuleId = reader.uint64();
                    break;
                case 2:
                    message.serviceInfoId = reader.uint64();
                    break;
                case 3:
                    message.resourceId = reader.uint64();
                    break;
                case 4:
                    message.isLoggingEnabled = reader.bool();
                    break;
                case 5:
                    message.logLevel = reader.string();
                    break;
                case 6:
                    message.ruleStart = reader.string();
                    break;
                case 7:
                    message.ruleEnd = reader.string();
                    break;
                case 8:
                    message.dateModified = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceRuleRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceRuleRecord} ServiceRuleRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceRuleRecord message.
         * @function verify
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceRuleRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                if (!$util.isInteger(message.serviceRuleId) && !(message.serviceRuleId && $util.isInteger(message.serviceRuleId.low) && $util.isInteger(message.serviceRuleId.high)))
                    return "serviceRuleId: integer|Long expected";
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (!$util.isInteger(message.serviceInfoId) && !(message.serviceInfoId && $util.isInteger(message.serviceInfoId.low) && $util.isInteger(message.serviceInfoId.high)))
                    return "serviceInfoId: integer|Long expected";
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                if (!$util.isInteger(message.resourceId) && !(message.resourceId && $util.isInteger(message.resourceId.low) && $util.isInteger(message.resourceId.high)))
                    return "resourceId: integer|Long expected";
            if (message.isLoggingEnabled != null && message.hasOwnProperty("isLoggingEnabled"))
                if (typeof message.isLoggingEnabled !== "boolean")
                    return "isLoggingEnabled: boolean expected";
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                if (!$util.isString(message.logLevel))
                    return "logLevel: string expected";
            if (message.ruleStart != null && message.hasOwnProperty("ruleStart"))
                if (!$util.isString(message.ruleStart))
                    return "ruleStart: string expected";
            if (message.ruleEnd != null && message.hasOwnProperty("ruleEnd"))
                if (!$util.isString(message.ruleEnd))
                    return "ruleEnd: string expected";
            if (message.dateModified != null && message.hasOwnProperty("dateModified"))
                if (!$util.isString(message.dateModified))
                    return "dateModified: string expected";
            return null;
        };

        /**
         * Creates a ServiceRuleRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceRuleRecord} ServiceRuleRecord
         */
        ServiceRuleRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceRuleRecord)
                return object;
            let message = new $root.ServiceLogger.ServiceRuleRecord();
            if (object.serviceRuleId != null)
                if ($util.Long)
                    (message.serviceRuleId = $util.Long.fromValue(object.serviceRuleId)).unsigned = true;
                else if (typeof object.serviceRuleId === "string")
                    message.serviceRuleId = parseInt(object.serviceRuleId, 10);
                else if (typeof object.serviceRuleId === "number")
                    message.serviceRuleId = object.serviceRuleId;
                else if (typeof object.serviceRuleId === "object")
                    message.serviceRuleId = new $util.LongBits(object.serviceRuleId.low >>> 0, object.serviceRuleId.high >>> 0).toNumber(true);
            if (object.serviceInfoId != null)
                if ($util.Long)
                    (message.serviceInfoId = $util.Long.fromValue(object.serviceInfoId)).unsigned = true;
                else if (typeof object.serviceInfoId === "string")
                    message.serviceInfoId = parseInt(object.serviceInfoId, 10);
                else if (typeof object.serviceInfoId === "number")
                    message.serviceInfoId = object.serviceInfoId;
                else if (typeof object.serviceInfoId === "object")
                    message.serviceInfoId = new $util.LongBits(object.serviceInfoId.low >>> 0, object.serviceInfoId.high >>> 0).toNumber(true);
            if (object.resourceId != null)
                if ($util.Long)
                    (message.resourceId = $util.Long.fromValue(object.resourceId)).unsigned = true;
                else if (typeof object.resourceId === "string")
                    message.resourceId = parseInt(object.resourceId, 10);
                else if (typeof object.resourceId === "number")
                    message.resourceId = object.resourceId;
                else if (typeof object.resourceId === "object")
                    message.resourceId = new $util.LongBits(object.resourceId.low >>> 0, object.resourceId.high >>> 0).toNumber(true);
            if (object.isLoggingEnabled != null)
                message.isLoggingEnabled = Boolean(object.isLoggingEnabled);
            if (object.logLevel != null)
                message.logLevel = String(object.logLevel);
            if (object.ruleStart != null)
                message.ruleStart = String(object.ruleStart);
            if (object.ruleEnd != null)
                message.ruleEnd = String(object.ruleEnd);
            if (object.dateModified != null)
                message.dateModified = String(object.dateModified);
            return message;
        };

        /**
         * Creates a plain object from a ServiceRuleRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceRuleRecord
         * @static
         * @param {ServiceLogger.ServiceRuleRecord} message ServiceRuleRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceRuleRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceRuleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceRuleId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceInfoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceInfoId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.resourceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceId = options.longs === String ? "0" : 0;
                object.isLoggingEnabled = false;
                object.logLevel = "";
                object.ruleStart = "";
                object.ruleEnd = "";
                object.dateModified = "";
            }
            if (message.serviceRuleId != null && message.hasOwnProperty("serviceRuleId"))
                if (typeof message.serviceRuleId === "number")
                    object.serviceRuleId = options.longs === String ? String(message.serviceRuleId) : message.serviceRuleId;
                else
                    object.serviceRuleId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceRuleId) : options.longs === Number ? new $util.LongBits(message.serviceRuleId.low >>> 0, message.serviceRuleId.high >>> 0).toNumber(true) : message.serviceRuleId;
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (typeof message.serviceInfoId === "number")
                    object.serviceInfoId = options.longs === String ? String(message.serviceInfoId) : message.serviceInfoId;
                else
                    object.serviceInfoId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceInfoId) : options.longs === Number ? new $util.LongBits(message.serviceInfoId.low >>> 0, message.serviceInfoId.high >>> 0).toNumber(true) : message.serviceInfoId;
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                if (typeof message.resourceId === "number")
                    object.resourceId = options.longs === String ? String(message.resourceId) : message.resourceId;
                else
                    object.resourceId = options.longs === String ? $util.Long.prototype.toString.call(message.resourceId) : options.longs === Number ? new $util.LongBits(message.resourceId.low >>> 0, message.resourceId.high >>> 0).toNumber(true) : message.resourceId;
            if (message.isLoggingEnabled != null && message.hasOwnProperty("isLoggingEnabled"))
                object.isLoggingEnabled = message.isLoggingEnabled;
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                object.logLevel = message.logLevel;
            if (message.ruleStart != null && message.hasOwnProperty("ruleStart"))
                object.ruleStart = message.ruleStart;
            if (message.ruleEnd != null && message.hasOwnProperty("ruleEnd"))
                object.ruleEnd = message.ruleEnd;
            if (message.dateModified != null && message.hasOwnProperty("dateModified"))
                object.dateModified = message.dateModified;
            return object;
        };

        /**
         * Converts this ServiceRuleRecord to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceRuleRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceRuleRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceRuleRecord;
    })();

    ServiceLogger.ServiceRuleResponse = (function() {

        /**
         * Properties of a ServiceRuleResponse.
         * @memberof ServiceLogger
         * @interface IServiceRuleResponse
         * @property {Array.<ServiceLogger.IServiceRuleRecord>|null} [serviceRule] ServiceRuleResponse serviceRule
         */

        /**
         * Constructs a new ServiceRuleResponse.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceRuleResponse.
         * @implements IServiceRuleResponse
         * @constructor
         * @param {ServiceLogger.IServiceRuleResponse=} [properties] Properties to set
         */
        function ServiceRuleResponse(properties) {
            this.serviceRule = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceRuleResponse serviceRule.
         * @member {Array.<ServiceLogger.IServiceRuleRecord>} serviceRule
         * @memberof ServiceLogger.ServiceRuleResponse
         * @instance
         */
        ServiceRuleResponse.prototype.serviceRule = $util.emptyArray;

        /**
         * Creates a new ServiceRuleResponse instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {ServiceLogger.IServiceRuleResponse=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceRuleResponse} ServiceRuleResponse instance
         */
        ServiceRuleResponse.create = function create(properties) {
            return new ServiceRuleResponse(properties);
        };

        /**
         * Encodes the specified ServiceRuleResponse message. Does not implicitly {@link ServiceLogger.ServiceRuleResponse.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {ServiceLogger.IServiceRuleResponse} message ServiceRuleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceRule != null && message.serviceRule.length)
                for (let i = 0; i < message.serviceRule.length; ++i)
                    $root.ServiceLogger.ServiceRuleRecord.encode(message.serviceRule[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceRuleResponse message, length delimited. Does not implicitly {@link ServiceLogger.ServiceRuleResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {ServiceLogger.IServiceRuleResponse} message ServiceRuleResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceRuleResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceRuleResponse} ServiceRuleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceRuleResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceRule && message.serviceRule.length))
                        message.serviceRule = [];
                    message.serviceRule.push($root.ServiceLogger.ServiceRuleRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceRuleResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceRuleResponse} ServiceRuleResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceRuleResponse message.
         * @function verify
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceRuleResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceRule != null && message.hasOwnProperty("serviceRule")) {
                if (!Array.isArray(message.serviceRule))
                    return "serviceRule: array expected";
                for (let i = 0; i < message.serviceRule.length; ++i) {
                    let error = $root.ServiceLogger.ServiceRuleRecord.verify(message.serviceRule[i]);
                    if (error)
                        return "serviceRule." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceRuleResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceRuleResponse} ServiceRuleResponse
         */
        ServiceRuleResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceRuleResponse)
                return object;
            let message = new $root.ServiceLogger.ServiceRuleResponse();
            if (object.serviceRule) {
                if (!Array.isArray(object.serviceRule))
                    throw TypeError(".ServiceLogger.ServiceRuleResponse.serviceRule: array expected");
                message.serviceRule = [];
                for (let i = 0; i < object.serviceRule.length; ++i) {
                    if (typeof object.serviceRule[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceRuleResponse.serviceRule: object expected");
                    message.serviceRule[i] = $root.ServiceLogger.ServiceRuleRecord.fromObject(object.serviceRule[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceRuleResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceRuleResponse
         * @static
         * @param {ServiceLogger.ServiceRuleResponse} message ServiceRuleResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceRuleResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceRule = [];
            if (message.serviceRule && message.serviceRule.length) {
                object.serviceRule = [];
                for (let j = 0; j < message.serviceRule.length; ++j)
                    object.serviceRule[j] = $root.ServiceLogger.ServiceRuleRecord.toObject(message.serviceRule[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceRuleResponse to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceRuleResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceRuleResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceRuleResponse;
    })();

    ServiceLogger.ServiceRuleUpdateRequest = (function() {

        /**
         * Properties of a ServiceRuleUpdateRequest.
         * @memberof ServiceLogger
         * @interface IServiceRuleUpdateRequest
         * @property {Array.<ServiceLogger.IServiceRuleRecord>|null} [serviceRuleRecord] ServiceRuleUpdateRequest serviceRuleRecord
         */

        /**
         * Constructs a new ServiceRuleUpdateRequest.
         * @memberof ServiceLogger
         * @classdesc Update one or more ServiceRule records by their IDs
         * @implements IServiceRuleUpdateRequest
         * @constructor
         * @param {ServiceLogger.IServiceRuleUpdateRequest=} [properties] Properties to set
         */
        function ServiceRuleUpdateRequest(properties) {
            this.serviceRuleRecord = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceRuleUpdateRequest serviceRuleRecord.
         * @member {Array.<ServiceLogger.IServiceRuleRecord>} serviceRuleRecord
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @instance
         */
        ServiceRuleUpdateRequest.prototype.serviceRuleRecord = $util.emptyArray;

        /**
         * Creates a new ServiceRuleUpdateRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceRuleUpdateRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceRuleUpdateRequest} ServiceRuleUpdateRequest instance
         */
        ServiceRuleUpdateRequest.create = function create(properties) {
            return new ServiceRuleUpdateRequest(properties);
        };

        /**
         * Encodes the specified ServiceRuleUpdateRequest message. Does not implicitly {@link ServiceLogger.ServiceRuleUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceRuleUpdateRequest} message ServiceRuleUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceRuleRecord != null && message.serviceRuleRecord.length)
                for (let i = 0; i < message.serviceRuleRecord.length; ++i)
                    $root.ServiceLogger.ServiceRuleRecord.encode(message.serviceRuleRecord[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceRuleUpdateRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceRuleUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {ServiceLogger.IServiceRuleUpdateRequest} message ServiceRuleUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceRuleUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceRuleUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceRuleUpdateRequest} ServiceRuleUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceRuleUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceRuleRecord && message.serviceRuleRecord.length))
                        message.serviceRuleRecord = [];
                    message.serviceRuleRecord.push($root.ServiceLogger.ServiceRuleRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceRuleUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceRuleUpdateRequest} ServiceRuleUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceRuleUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceRuleUpdateRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceRuleUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceRuleRecord != null && message.hasOwnProperty("serviceRuleRecord")) {
                if (!Array.isArray(message.serviceRuleRecord))
                    return "serviceRuleRecord: array expected";
                for (let i = 0; i < message.serviceRuleRecord.length; ++i) {
                    let error = $root.ServiceLogger.ServiceRuleRecord.verify(message.serviceRuleRecord[i]);
                    if (error)
                        return "serviceRuleRecord." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceRuleUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceRuleUpdateRequest} ServiceRuleUpdateRequest
         */
        ServiceRuleUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceRuleUpdateRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceRuleUpdateRequest();
            if (object.serviceRuleRecord) {
                if (!Array.isArray(object.serviceRuleRecord))
                    throw TypeError(".ServiceLogger.ServiceRuleUpdateRequest.serviceRuleRecord: array expected");
                message.serviceRuleRecord = [];
                for (let i = 0; i < object.serviceRuleRecord.length; ++i) {
                    if (typeof object.serviceRuleRecord[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceRuleUpdateRequest.serviceRuleRecord: object expected");
                    message.serviceRuleRecord[i] = $root.ServiceLogger.ServiceRuleRecord.fromObject(object.serviceRuleRecord[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceRuleUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @static
         * @param {ServiceLogger.ServiceRuleUpdateRequest} message ServiceRuleUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceRuleUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceRuleRecord = [];
            if (message.serviceRuleRecord && message.serviceRuleRecord.length) {
                object.serviceRuleRecord = [];
                for (let j = 0; j < message.serviceRuleRecord.length; ++j)
                    object.serviceRuleRecord[j] = $root.ServiceLogger.ServiceRuleRecord.toObject(message.serviceRuleRecord[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceRuleUpdateRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceRuleUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceRuleUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceRuleUpdateRequest;
    })();

    ServiceLogger.ServiceLogSpecifier = (function() {

        /**
         * Properties of a ServiceLogSpecifier.
         * @memberof ServiceLogger
         * @interface IServiceLogSpecifier
         * @property {boolean|null} [all] ServiceLogSpecifier all
         * @property {number|Long|null} [serviceLogId] ServiceLogSpecifier serviceLogId
         * @property {Array.<ServiceLogger.IIdRange>|null} [serviceIdRange] ServiceLogSpecifier serviceIdRange
         * @property {Array.<ServiceLogger.IIdRange>|null} [resourceIdRange] ServiceLogSpecifier resourceIdRange
         * @property {string|null} [startDateTime] ServiceLogSpecifier startDateTime
         * @property {string|null} [endDateTime] ServiceLogSpecifier endDateTime
         */

        /**
         * Constructs a new ServiceLogSpecifier.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceLogSpecifier.
         * @implements IServiceLogSpecifier
         * @constructor
         * @param {ServiceLogger.IServiceLogSpecifier=} [properties] Properties to set
         */
        function ServiceLogSpecifier(properties) {
            this.serviceIdRange = [];
            this.resourceIdRange = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogSpecifier all.
         * @member {boolean} all
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.all = false;

        /**
         * ServiceLogSpecifier serviceLogId.
         * @member {number|Long} serviceLogId
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.serviceLogId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogSpecifier serviceIdRange.
         * @member {Array.<ServiceLogger.IIdRange>} serviceIdRange
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.serviceIdRange = $util.emptyArray;

        /**
         * ServiceLogSpecifier resourceIdRange.
         * @member {Array.<ServiceLogger.IIdRange>} resourceIdRange
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.resourceIdRange = $util.emptyArray;

        /**
         * ServiceLogSpecifier startDateTime.
         * @member {string} startDateTime
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.startDateTime = "";

        /**
         * ServiceLogSpecifier endDateTime.
         * @member {string} endDateTime
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         */
        ServiceLogSpecifier.prototype.endDateTime = "";

        /**
         * Creates a new ServiceLogSpecifier instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {ServiceLogger.IServiceLogSpecifier=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogSpecifier} ServiceLogSpecifier instance
         */
        ServiceLogSpecifier.create = function create(properties) {
            return new ServiceLogSpecifier(properties);
        };

        /**
         * Encodes the specified ServiceLogSpecifier message. Does not implicitly {@link ServiceLogger.ServiceLogSpecifier.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {ServiceLogger.IServiceLogSpecifier} message ServiceLogSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogSpecifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.all != null && message.hasOwnProperty("all"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.all);
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceLogId);
            if (message.serviceIdRange != null && message.serviceIdRange.length)
                for (let i = 0; i < message.serviceIdRange.length; ++i)
                    $root.ServiceLogger.IdRange.encode(message.serviceIdRange[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.resourceIdRange != null && message.resourceIdRange.length)
                for (let i = 0; i < message.resourceIdRange.length; ++i)
                    $root.ServiceLogger.IdRange.encode(message.resourceIdRange[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.startDateTime != null && message.hasOwnProperty("startDateTime"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.startDateTime);
            if (message.endDateTime != null && message.hasOwnProperty("endDateTime"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.endDateTime);
            return writer;
        };

        /**
         * Encodes the specified ServiceLogSpecifier message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogSpecifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {ServiceLogger.IServiceLogSpecifier} message ServiceLogSpecifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogSpecifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogSpecifier message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogSpecifier} ServiceLogSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogSpecifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogSpecifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.all = reader.bool();
                    break;
                case 2:
                    message.serviceLogId = reader.uint64();
                    break;
                case 3:
                    if (!(message.serviceIdRange && message.serviceIdRange.length))
                        message.serviceIdRange = [];
                    message.serviceIdRange.push($root.ServiceLogger.IdRange.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.resourceIdRange && message.resourceIdRange.length))
                        message.resourceIdRange = [];
                    message.resourceIdRange.push($root.ServiceLogger.IdRange.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.startDateTime = reader.string();
                    break;
                case 6:
                    message.endDateTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogSpecifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogSpecifier} ServiceLogSpecifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogSpecifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogSpecifier message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogSpecifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.all != null && message.hasOwnProperty("all"))
                if (typeof message.all !== "boolean")
                    return "all: boolean expected";
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                if (!$util.isInteger(message.serviceLogId) && !(message.serviceLogId && $util.isInteger(message.serviceLogId.low) && $util.isInteger(message.serviceLogId.high)))
                    return "serviceLogId: integer|Long expected";
            if (message.serviceIdRange != null && message.hasOwnProperty("serviceIdRange")) {
                if (!Array.isArray(message.serviceIdRange))
                    return "serviceIdRange: array expected";
                for (let i = 0; i < message.serviceIdRange.length; ++i) {
                    let error = $root.ServiceLogger.IdRange.verify(message.serviceIdRange[i]);
                    if (error)
                        return "serviceIdRange." + error;
                }
            }
            if (message.resourceIdRange != null && message.hasOwnProperty("resourceIdRange")) {
                if (!Array.isArray(message.resourceIdRange))
                    return "resourceIdRange: array expected";
                for (let i = 0; i < message.resourceIdRange.length; ++i) {
                    let error = $root.ServiceLogger.IdRange.verify(message.resourceIdRange[i]);
                    if (error)
                        return "resourceIdRange." + error;
                }
            }
            if (message.startDateTime != null && message.hasOwnProperty("startDateTime"))
                if (!$util.isString(message.startDateTime))
                    return "startDateTime: string expected";
            if (message.endDateTime != null && message.hasOwnProperty("endDateTime"))
                if (!$util.isString(message.endDateTime))
                    return "endDateTime: string expected";
            return null;
        };

        /**
         * Creates a ServiceLogSpecifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogSpecifier} ServiceLogSpecifier
         */
        ServiceLogSpecifier.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogSpecifier)
                return object;
            let message = new $root.ServiceLogger.ServiceLogSpecifier();
            if (object.all != null)
                message.all = Boolean(object.all);
            if (object.serviceLogId != null)
                if ($util.Long)
                    (message.serviceLogId = $util.Long.fromValue(object.serviceLogId)).unsigned = true;
                else if (typeof object.serviceLogId === "string")
                    message.serviceLogId = parseInt(object.serviceLogId, 10);
                else if (typeof object.serviceLogId === "number")
                    message.serviceLogId = object.serviceLogId;
                else if (typeof object.serviceLogId === "object")
                    message.serviceLogId = new $util.LongBits(object.serviceLogId.low >>> 0, object.serviceLogId.high >>> 0).toNumber(true);
            if (object.serviceIdRange) {
                if (!Array.isArray(object.serviceIdRange))
                    throw TypeError(".ServiceLogger.ServiceLogSpecifier.serviceIdRange: array expected");
                message.serviceIdRange = [];
                for (let i = 0; i < object.serviceIdRange.length; ++i) {
                    if (typeof object.serviceIdRange[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogSpecifier.serviceIdRange: object expected");
                    message.serviceIdRange[i] = $root.ServiceLogger.IdRange.fromObject(object.serviceIdRange[i]);
                }
            }
            if (object.resourceIdRange) {
                if (!Array.isArray(object.resourceIdRange))
                    throw TypeError(".ServiceLogger.ServiceLogSpecifier.resourceIdRange: array expected");
                message.resourceIdRange = [];
                for (let i = 0; i < object.resourceIdRange.length; ++i) {
                    if (typeof object.resourceIdRange[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogSpecifier.resourceIdRange: object expected");
                    message.resourceIdRange[i] = $root.ServiceLogger.IdRange.fromObject(object.resourceIdRange[i]);
                }
            }
            if (object.startDateTime != null)
                message.startDateTime = String(object.startDateTime);
            if (object.endDateTime != null)
                message.endDateTime = String(object.endDateTime);
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogSpecifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @static
         * @param {ServiceLogger.ServiceLogSpecifier} message ServiceLogSpecifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogSpecifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.serviceIdRange = [];
                object.resourceIdRange = [];
            }
            if (options.defaults) {
                object.all = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceLogId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceLogId = options.longs === String ? "0" : 0;
                object.startDateTime = "";
                object.endDateTime = "";
            }
            if (message.all != null && message.hasOwnProperty("all"))
                object.all = message.all;
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                if (typeof message.serviceLogId === "number")
                    object.serviceLogId = options.longs === String ? String(message.serviceLogId) : message.serviceLogId;
                else
                    object.serviceLogId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceLogId) : options.longs === Number ? new $util.LongBits(message.serviceLogId.low >>> 0, message.serviceLogId.high >>> 0).toNumber(true) : message.serviceLogId;
            if (message.serviceIdRange && message.serviceIdRange.length) {
                object.serviceIdRange = [];
                for (let j = 0; j < message.serviceIdRange.length; ++j)
                    object.serviceIdRange[j] = $root.ServiceLogger.IdRange.toObject(message.serviceIdRange[j], options);
            }
            if (message.resourceIdRange && message.resourceIdRange.length) {
                object.resourceIdRange = [];
                for (let j = 0; j < message.resourceIdRange.length; ++j)
                    object.resourceIdRange[j] = $root.ServiceLogger.IdRange.toObject(message.resourceIdRange[j], options);
            }
            if (message.startDateTime != null && message.hasOwnProperty("startDateTime"))
                object.startDateTime = message.startDateTime;
            if (message.endDateTime != null && message.hasOwnProperty("endDateTime"))
                object.endDateTime = message.endDateTime;
            return object;
        };

        /**
         * Converts this ServiceLogSpecifier to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogSpecifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogSpecifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogSpecifier;
    })();

    ServiceLogger.ServiceLogGetRequest = (function() {

        /**
         * Properties of a ServiceLogGetRequest.
         * @memberof ServiceLogger
         * @interface IServiceLogGetRequest
         * @property {Array.<ServiceLogger.IServiceLogSpecifier>|null} [serviceLogSpecifier] ServiceLogGetRequest serviceLogSpecifier
         */

        /**
         * Constructs a new ServiceLogGetRequest.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceLogGetRequest.
         * @implements IServiceLogGetRequest
         * @constructor
         * @param {ServiceLogger.IServiceLogGetRequest=} [properties] Properties to set
         */
        function ServiceLogGetRequest(properties) {
            this.serviceLogSpecifier = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogGetRequest serviceLogSpecifier.
         * @member {Array.<ServiceLogger.IServiceLogSpecifier>} serviceLogSpecifier
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @instance
         */
        ServiceLogGetRequest.prototype.serviceLogSpecifier = $util.emptyArray;

        /**
         * Creates a new ServiceLogGetRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {ServiceLogger.IServiceLogGetRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogGetRequest} ServiceLogGetRequest instance
         */
        ServiceLogGetRequest.create = function create(properties) {
            return new ServiceLogGetRequest(properties);
        };

        /**
         * Encodes the specified ServiceLogGetRequest message. Does not implicitly {@link ServiceLogger.ServiceLogGetRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {ServiceLogger.IServiceLogGetRequest} message ServiceLogGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogGetRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceLogSpecifier != null && message.serviceLogSpecifier.length)
                for (let i = 0; i < message.serviceLogSpecifier.length; ++i)
                    $root.ServiceLogger.ServiceLogSpecifier.encode(message.serviceLogSpecifier[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceLogGetRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogGetRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {ServiceLogger.IServiceLogGetRequest} message ServiceLogGetRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogGetRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogGetRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogGetRequest} ServiceLogGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogGetRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogGetRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.serviceLogSpecifier && message.serviceLogSpecifier.length))
                        message.serviceLogSpecifier = [];
                    message.serviceLogSpecifier.push($root.ServiceLogger.ServiceLogSpecifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogGetRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogGetRequest} ServiceLogGetRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogGetRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogGetRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogGetRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceLogSpecifier != null && message.hasOwnProperty("serviceLogSpecifier")) {
                if (!Array.isArray(message.serviceLogSpecifier))
                    return "serviceLogSpecifier: array expected";
                for (let i = 0; i < message.serviceLogSpecifier.length; ++i) {
                    let error = $root.ServiceLogger.ServiceLogSpecifier.verify(message.serviceLogSpecifier[i]);
                    if (error)
                        return "serviceLogSpecifier." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceLogGetRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogGetRequest} ServiceLogGetRequest
         */
        ServiceLogGetRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogGetRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceLogGetRequest();
            if (object.serviceLogSpecifier) {
                if (!Array.isArray(object.serviceLogSpecifier))
                    throw TypeError(".ServiceLogger.ServiceLogGetRequest.serviceLogSpecifier: array expected");
                message.serviceLogSpecifier = [];
                for (let i = 0; i < object.serviceLogSpecifier.length; ++i) {
                    if (typeof object.serviceLogSpecifier[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogGetRequest.serviceLogSpecifier: object expected");
                    message.serviceLogSpecifier[i] = $root.ServiceLogger.ServiceLogSpecifier.fromObject(object.serviceLogSpecifier[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogGetRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @static
         * @param {ServiceLogger.ServiceLogGetRequest} message ServiceLogGetRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogGetRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.serviceLogSpecifier = [];
            if (message.serviceLogSpecifier && message.serviceLogSpecifier.length) {
                object.serviceLogSpecifier = [];
                for (let j = 0; j < message.serviceLogSpecifier.length; ++j)
                    object.serviceLogSpecifier[j] = $root.ServiceLogger.ServiceLogSpecifier.toObject(message.serviceLogSpecifier[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceLogGetRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogGetRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogGetRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogGetRequest;
    })();

    ServiceLogger.ServiceLogRecord = (function() {

        /**
         * Properties of a ServiceLogRecord.
         * @memberof ServiceLogger
         * @interface IServiceLogRecord
         * @property {number|Long|null} [serviceLogId] ServiceLogRecord serviceLogId
         * @property {number|Long|null} [serviceInfoId] ServiceLogRecord serviceInfoId
         * @property {number|Long|null} [resourceId] ServiceLogRecord resourceId
         * @property {string|null} [logger] ServiceLogRecord logger
         * @property {string|null} [logLevel] ServiceLogRecord logLevel
         * @property {string|null} [message] ServiceLogRecord message
         * @property {string|null} [exception] ServiceLogRecord exception
         * @property {string|null} [dateCreated] ServiceLogRecord dateCreated
         */

        /**
         * Constructs a new ServiceLogRecord.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceLogRecord.
         * @implements IServiceLogRecord
         * @constructor
         * @param {ServiceLogger.IServiceLogRecord=} [properties] Properties to set
         */
        function ServiceLogRecord(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogRecord serviceLogId.
         * @member {number|Long} serviceLogId
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.serviceLogId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogRecord serviceInfoId.
         * @member {number|Long} serviceInfoId
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.serviceInfoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogRecord resourceId.
         * @member {number|Long} resourceId
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.resourceId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogRecord logger.
         * @member {string} logger
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.logger = "";

        /**
         * ServiceLogRecord logLevel.
         * @member {string} logLevel
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.logLevel = "";

        /**
         * ServiceLogRecord message.
         * @member {string} message
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.message = "";

        /**
         * ServiceLogRecord exception.
         * @member {string} exception
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.exception = "";

        /**
         * ServiceLogRecord dateCreated.
         * @member {string} dateCreated
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         */
        ServiceLogRecord.prototype.dateCreated = "";

        /**
         * Creates a new ServiceLogRecord instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {ServiceLogger.IServiceLogRecord=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogRecord} ServiceLogRecord instance
         */
        ServiceLogRecord.create = function create(properties) {
            return new ServiceLogRecord(properties);
        };

        /**
         * Encodes the specified ServiceLogRecord message. Does not implicitly {@link ServiceLogger.ServiceLogRecord.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {ServiceLogger.IServiceLogRecord} message ServiceLogRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serviceLogId);
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceInfoId);
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.resourceId);
            if (message.logger != null && message.hasOwnProperty("logger"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.logger);
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.logLevel);
            if (message.message != null && message.hasOwnProperty("message"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.message);
            if (message.exception != null && message.hasOwnProperty("exception"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.exception);
            if (message.dateCreated != null && message.hasOwnProperty("dateCreated"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.dateCreated);
            return writer;
        };

        /**
         * Encodes the specified ServiceLogRecord message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {ServiceLogger.IServiceLogRecord} message ServiceLogRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogRecord message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogRecord} ServiceLogRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogRecord();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceLogId = reader.uint64();
                    break;
                case 2:
                    message.serviceInfoId = reader.uint64();
                    break;
                case 3:
                    message.resourceId = reader.uint64();
                    break;
                case 4:
                    message.logger = reader.string();
                    break;
                case 5:
                    message.logLevel = reader.string();
                    break;
                case 6:
                    message.message = reader.string();
                    break;
                case 7:
                    message.exception = reader.string();
                    break;
                case 8:
                    message.dateCreated = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogRecord} ServiceLogRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogRecord message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                if (!$util.isInteger(message.serviceLogId) && !(message.serviceLogId && $util.isInteger(message.serviceLogId.low) && $util.isInteger(message.serviceLogId.high)))
                    return "serviceLogId: integer|Long expected";
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (!$util.isInteger(message.serviceInfoId) && !(message.serviceInfoId && $util.isInteger(message.serviceInfoId.low) && $util.isInteger(message.serviceInfoId.high)))
                    return "serviceInfoId: integer|Long expected";
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                if (!$util.isInteger(message.resourceId) && !(message.resourceId && $util.isInteger(message.resourceId.low) && $util.isInteger(message.resourceId.high)))
                    return "resourceId: integer|Long expected";
            if (message.logger != null && message.hasOwnProperty("logger"))
                if (!$util.isString(message.logger))
                    return "logger: string expected";
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                if (!$util.isString(message.logLevel))
                    return "logLevel: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.exception != null && message.hasOwnProperty("exception"))
                if (!$util.isString(message.exception))
                    return "exception: string expected";
            if (message.dateCreated != null && message.hasOwnProperty("dateCreated"))
                if (!$util.isString(message.dateCreated))
                    return "dateCreated: string expected";
            return null;
        };

        /**
         * Creates a ServiceLogRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogRecord} ServiceLogRecord
         */
        ServiceLogRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogRecord)
                return object;
            let message = new $root.ServiceLogger.ServiceLogRecord();
            if (object.serviceLogId != null)
                if ($util.Long)
                    (message.serviceLogId = $util.Long.fromValue(object.serviceLogId)).unsigned = true;
                else if (typeof object.serviceLogId === "string")
                    message.serviceLogId = parseInt(object.serviceLogId, 10);
                else if (typeof object.serviceLogId === "number")
                    message.serviceLogId = object.serviceLogId;
                else if (typeof object.serviceLogId === "object")
                    message.serviceLogId = new $util.LongBits(object.serviceLogId.low >>> 0, object.serviceLogId.high >>> 0).toNumber(true);
            if (object.serviceInfoId != null)
                if ($util.Long)
                    (message.serviceInfoId = $util.Long.fromValue(object.serviceInfoId)).unsigned = true;
                else if (typeof object.serviceInfoId === "string")
                    message.serviceInfoId = parseInt(object.serviceInfoId, 10);
                else if (typeof object.serviceInfoId === "number")
                    message.serviceInfoId = object.serviceInfoId;
                else if (typeof object.serviceInfoId === "object")
                    message.serviceInfoId = new $util.LongBits(object.serviceInfoId.low >>> 0, object.serviceInfoId.high >>> 0).toNumber(true);
            if (object.resourceId != null)
                if ($util.Long)
                    (message.resourceId = $util.Long.fromValue(object.resourceId)).unsigned = true;
                else if (typeof object.resourceId === "string")
                    message.resourceId = parseInt(object.resourceId, 10);
                else if (typeof object.resourceId === "number")
                    message.resourceId = object.resourceId;
                else if (typeof object.resourceId === "object")
                    message.resourceId = new $util.LongBits(object.resourceId.low >>> 0, object.resourceId.high >>> 0).toNumber(true);
            if (object.logger != null)
                message.logger = String(object.logger);
            if (object.logLevel != null)
                message.logLevel = String(object.logLevel);
            if (object.message != null)
                message.message = String(object.message);
            if (object.exception != null)
                message.exception = String(object.exception);
            if (object.dateCreated != null)
                message.dateCreated = String(object.dateCreated);
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogRecord
         * @static
         * @param {ServiceLogger.ServiceLogRecord} message ServiceLogRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceLogId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceLogId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceInfoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceInfoId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.resourceId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.resourceId = options.longs === String ? "0" : 0;
                object.logger = "";
                object.logLevel = "";
                object.message = "";
                object.exception = "";
                object.dateCreated = "";
            }
            if (message.serviceLogId != null && message.hasOwnProperty("serviceLogId"))
                if (typeof message.serviceLogId === "number")
                    object.serviceLogId = options.longs === String ? String(message.serviceLogId) : message.serviceLogId;
                else
                    object.serviceLogId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceLogId) : options.longs === Number ? new $util.LongBits(message.serviceLogId.low >>> 0, message.serviceLogId.high >>> 0).toNumber(true) : message.serviceLogId;
            if (message.serviceInfoId != null && message.hasOwnProperty("serviceInfoId"))
                if (typeof message.serviceInfoId === "number")
                    object.serviceInfoId = options.longs === String ? String(message.serviceInfoId) : message.serviceInfoId;
                else
                    object.serviceInfoId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceInfoId) : options.longs === Number ? new $util.LongBits(message.serviceInfoId.low >>> 0, message.serviceInfoId.high >>> 0).toNumber(true) : message.serviceInfoId;
            if (message.resourceId != null && message.hasOwnProperty("resourceId"))
                if (typeof message.resourceId === "number")
                    object.resourceId = options.longs === String ? String(message.resourceId) : message.resourceId;
                else
                    object.resourceId = options.longs === String ? $util.Long.prototype.toString.call(message.resourceId) : options.longs === Number ? new $util.LongBits(message.resourceId.low >>> 0, message.resourceId.high >>> 0).toNumber(true) : message.resourceId;
            if (message.logger != null && message.hasOwnProperty("logger"))
                object.logger = message.logger;
            if (message.logLevel != null && message.hasOwnProperty("logLevel"))
                object.logLevel = message.logLevel;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.exception != null && message.hasOwnProperty("exception"))
                object.exception = message.exception;
            if (message.dateCreated != null && message.hasOwnProperty("dateCreated"))
                object.dateCreated = message.dateCreated;
            return object;
        };

        /**
         * Converts this ServiceLogRecord to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogRecord;
    })();

    ServiceLogger.ServiceLogAddRequest = (function() {

        /**
         * Properties of a ServiceLogAddRequest.
         * @memberof ServiceLogger
         * @interface IServiceLogAddRequest
         * @property {Array.<ServiceLogger.IServiceLogRecord>|null} [entry] ServiceLogAddRequest entry
         */

        /**
         * Constructs a new ServiceLogAddRequest.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceLogAddRequest.
         * @implements IServiceLogAddRequest
         * @constructor
         * @param {ServiceLogger.IServiceLogAddRequest=} [properties] Properties to set
         */
        function ServiceLogAddRequest(properties) {
            this.entry = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogAddRequest entry.
         * @member {Array.<ServiceLogger.IServiceLogRecord>} entry
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @instance
         */
        ServiceLogAddRequest.prototype.entry = $util.emptyArray;

        /**
         * Creates a new ServiceLogAddRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {ServiceLogger.IServiceLogAddRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogAddRequest} ServiceLogAddRequest instance
         */
        ServiceLogAddRequest.create = function create(properties) {
            return new ServiceLogAddRequest(properties);
        };

        /**
         * Encodes the specified ServiceLogAddRequest message. Does not implicitly {@link ServiceLogger.ServiceLogAddRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {ServiceLogger.IServiceLogAddRequest} message ServiceLogAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogAddRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entry != null && message.entry.length)
                for (let i = 0; i < message.entry.length; ++i)
                    $root.ServiceLogger.ServiceLogRecord.encode(message.entry[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceLogAddRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogAddRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {ServiceLogger.IServiceLogAddRequest} message ServiceLogAddRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogAddRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogAddRequest} ServiceLogAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogAddRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogAddRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.entry && message.entry.length))
                        message.entry = [];
                    message.entry.push($root.ServiceLogger.ServiceLogRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogAddRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogAddRequest} ServiceLogAddRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogAddRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogAddRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogAddRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entry != null && message.hasOwnProperty("entry")) {
                if (!Array.isArray(message.entry))
                    return "entry: array expected";
                for (let i = 0; i < message.entry.length; ++i) {
                    let error = $root.ServiceLogger.ServiceLogRecord.verify(message.entry[i]);
                    if (error)
                        return "entry." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceLogAddRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogAddRequest} ServiceLogAddRequest
         */
        ServiceLogAddRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogAddRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceLogAddRequest();
            if (object.entry) {
                if (!Array.isArray(object.entry))
                    throw TypeError(".ServiceLogger.ServiceLogAddRequest.entry: array expected");
                message.entry = [];
                for (let i = 0; i < object.entry.length; ++i) {
                    if (typeof object.entry[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogAddRequest.entry: object expected");
                    message.entry[i] = $root.ServiceLogger.ServiceLogRecord.fromObject(object.entry[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogAddRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @static
         * @param {ServiceLogger.ServiceLogAddRequest} message ServiceLogAddRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogAddRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.entry = [];
            if (message.entry && message.entry.length) {
                object.entry = [];
                for (let j = 0; j < message.entry.length; ++j)
                    object.entry[j] = $root.ServiceLogger.ServiceLogRecord.toObject(message.entry[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceLogAddRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogAddRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogAddRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogAddRequest;
    })();

    ServiceLogger.ServiceLogResponse = (function() {

        /**
         * Properties of a ServiceLogResponse.
         * @memberof ServiceLogger
         * @interface IServiceLogResponse
         * @property {Array.<ServiceLogger.IServiceLogRecord>|null} [entry] ServiceLogResponse entry
         */

        /**
         * Constructs a new ServiceLogResponse.
         * @memberof ServiceLogger
         * @classdesc Represents a ServiceLogResponse.
         * @implements IServiceLogResponse
         * @constructor
         * @param {ServiceLogger.IServiceLogResponse=} [properties] Properties to set
         */
        function ServiceLogResponse(properties) {
            this.entry = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogResponse entry.
         * @member {Array.<ServiceLogger.IServiceLogRecord>} entry
         * @memberof ServiceLogger.ServiceLogResponse
         * @instance
         */
        ServiceLogResponse.prototype.entry = $util.emptyArray;

        /**
         * Creates a new ServiceLogResponse instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {ServiceLogger.IServiceLogResponse=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogResponse} ServiceLogResponse instance
         */
        ServiceLogResponse.create = function create(properties) {
            return new ServiceLogResponse(properties);
        };

        /**
         * Encodes the specified ServiceLogResponse message. Does not implicitly {@link ServiceLogger.ServiceLogResponse.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {ServiceLogger.IServiceLogResponse} message ServiceLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.entry != null && message.entry.length)
                for (let i = 0; i < message.entry.length; ++i)
                    $root.ServiceLogger.ServiceLogRecord.encode(message.entry[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceLogResponse message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {ServiceLogger.IServiceLogResponse} message ServiceLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogResponse} ServiceLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.entry && message.entry.length))
                        message.entry = [];
                    message.entry.push($root.ServiceLogger.ServiceLogRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogResponse} ServiceLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogResponse message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.entry != null && message.hasOwnProperty("entry")) {
                if (!Array.isArray(message.entry))
                    return "entry: array expected";
                for (let i = 0; i < message.entry.length; ++i) {
                    let error = $root.ServiceLogger.ServiceLogRecord.verify(message.entry[i]);
                    if (error)
                        return "entry." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceLogResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogResponse} ServiceLogResponse
         */
        ServiceLogResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogResponse)
                return object;
            let message = new $root.ServiceLogger.ServiceLogResponse();
            if (object.entry) {
                if (!Array.isArray(object.entry))
                    throw TypeError(".ServiceLogger.ServiceLogResponse.entry: array expected");
                message.entry = [];
                for (let i = 0; i < object.entry.length; ++i) {
                    if (typeof object.entry[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogResponse.entry: object expected");
                    message.entry[i] = $root.ServiceLogger.ServiceLogRecord.fromObject(object.entry[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogResponse
         * @static
         * @param {ServiceLogger.ServiceLogResponse} message ServiceLogResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.entry = [];
            if (message.entry && message.entry.length) {
                object.entry = [];
                for (let j = 0; j < message.entry.length; ++j)
                    object.entry[j] = $root.ServiceLogger.ServiceLogRecord.toObject(message.entry[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceLogResponse to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogResponse;
    })();

    ServiceLogger.ServiceLogClearRequest = (function() {

        /**
         * Properties of a ServiceLogClearRequest.
         * @memberof ServiceLogger
         * @interface IServiceLogClearRequest
         * @property {boolean|null} [useDefaults] ServiceLogClearRequest useDefaults
         * @property {number|Long|null} [serviceTypeId] ServiceLogClearRequest serviceTypeId
         * @property {number|null} [daysOld] ServiceLogClearRequest daysOld
         * @property {number|null} [hoursOld] ServiceLogClearRequest hoursOld
         * @property {Array.<ServiceLogger.IIdRange>|null} [resourceIdRange] ServiceLogClearRequest resourceIdRange
         */

        /**
         * Constructs a new ServiceLogClearRequest.
         * @memberof ServiceLogger
         * @classdesc This is a request to clear the SSO Service Provider log
         * @implements IServiceLogClearRequest
         * @constructor
         * @param {ServiceLogger.IServiceLogClearRequest=} [properties] Properties to set
         */
        function ServiceLogClearRequest(properties) {
            this.resourceIdRange = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogClearRequest useDefaults.
         * @member {boolean} useDefaults
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         */
        ServiceLogClearRequest.prototype.useDefaults = false;

        /**
         * ServiceLogClearRequest serviceTypeId.
         * @member {number|Long} serviceTypeId
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         */
        ServiceLogClearRequest.prototype.serviceTypeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogClearRequest daysOld.
         * @member {number} daysOld
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         */
        ServiceLogClearRequest.prototype.daysOld = 0;

        /**
         * ServiceLogClearRequest hoursOld.
         * @member {number} hoursOld
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         */
        ServiceLogClearRequest.prototype.hoursOld = 0;

        /**
         * ServiceLogClearRequest resourceIdRange.
         * @member {Array.<ServiceLogger.IIdRange>} resourceIdRange
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         */
        ServiceLogClearRequest.prototype.resourceIdRange = $util.emptyArray;

        /**
         * Creates a new ServiceLogClearRequest instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {ServiceLogger.IServiceLogClearRequest=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogClearRequest} ServiceLogClearRequest instance
         */
        ServiceLogClearRequest.create = function create(properties) {
            return new ServiceLogClearRequest(properties);
        };

        /**
         * Encodes the specified ServiceLogClearRequest message. Does not implicitly {@link ServiceLogger.ServiceLogClearRequest.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {ServiceLogger.IServiceLogClearRequest} message ServiceLogClearRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogClearRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.useDefaults != null && message.hasOwnProperty("useDefaults"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.useDefaults);
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.serviceTypeId);
            if (message.daysOld != null && message.hasOwnProperty("daysOld"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.daysOld);
            if (message.hoursOld != null && message.hasOwnProperty("hoursOld"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.hoursOld);
            if (message.resourceIdRange != null && message.resourceIdRange.length)
                for (let i = 0; i < message.resourceIdRange.length; ++i)
                    $root.ServiceLogger.IdRange.encode(message.resourceIdRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServiceLogClearRequest message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogClearRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {ServiceLogger.IServiceLogClearRequest} message ServiceLogClearRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogClearRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogClearRequest message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogClearRequest} ServiceLogClearRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogClearRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogClearRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.useDefaults = reader.bool();
                    break;
                case 2:
                    message.serviceTypeId = reader.uint64();
                    break;
                case 3:
                    message.daysOld = reader.uint32();
                    break;
                case 4:
                    message.hoursOld = reader.uint32();
                    break;
                case 5:
                    if (!(message.resourceIdRange && message.resourceIdRange.length))
                        message.resourceIdRange = [];
                    message.resourceIdRange.push($root.ServiceLogger.IdRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogClearRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogClearRequest} ServiceLogClearRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogClearRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogClearRequest message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogClearRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.useDefaults != null && message.hasOwnProperty("useDefaults"))
                if (typeof message.useDefaults !== "boolean")
                    return "useDefaults: boolean expected";
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                if (!$util.isInteger(message.serviceTypeId) && !(message.serviceTypeId && $util.isInteger(message.serviceTypeId.low) && $util.isInteger(message.serviceTypeId.high)))
                    return "serviceTypeId: integer|Long expected";
            if (message.daysOld != null && message.hasOwnProperty("daysOld"))
                if (!$util.isInteger(message.daysOld))
                    return "daysOld: integer expected";
            if (message.hoursOld != null && message.hasOwnProperty("hoursOld"))
                if (!$util.isInteger(message.hoursOld))
                    return "hoursOld: integer expected";
            if (message.resourceIdRange != null && message.hasOwnProperty("resourceIdRange")) {
                if (!Array.isArray(message.resourceIdRange))
                    return "resourceIdRange: array expected";
                for (let i = 0; i < message.resourceIdRange.length; ++i) {
                    let error = $root.ServiceLogger.IdRange.verify(message.resourceIdRange[i]);
                    if (error)
                        return "resourceIdRange." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServiceLogClearRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogClearRequest} ServiceLogClearRequest
         */
        ServiceLogClearRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogClearRequest)
                return object;
            let message = new $root.ServiceLogger.ServiceLogClearRequest();
            if (object.useDefaults != null)
                message.useDefaults = Boolean(object.useDefaults);
            if (object.serviceTypeId != null)
                if ($util.Long)
                    (message.serviceTypeId = $util.Long.fromValue(object.serviceTypeId)).unsigned = true;
                else if (typeof object.serviceTypeId === "string")
                    message.serviceTypeId = parseInt(object.serviceTypeId, 10);
                else if (typeof object.serviceTypeId === "number")
                    message.serviceTypeId = object.serviceTypeId;
                else if (typeof object.serviceTypeId === "object")
                    message.serviceTypeId = new $util.LongBits(object.serviceTypeId.low >>> 0, object.serviceTypeId.high >>> 0).toNumber(true);
            if (object.daysOld != null)
                message.daysOld = object.daysOld >>> 0;
            if (object.hoursOld != null)
                message.hoursOld = object.hoursOld >>> 0;
            if (object.resourceIdRange) {
                if (!Array.isArray(object.resourceIdRange))
                    throw TypeError(".ServiceLogger.ServiceLogClearRequest.resourceIdRange: array expected");
                message.resourceIdRange = [];
                for (let i = 0; i < object.resourceIdRange.length; ++i) {
                    if (typeof object.resourceIdRange[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogClearRequest.resourceIdRange: object expected");
                    message.resourceIdRange[i] = $root.ServiceLogger.IdRange.fromObject(object.resourceIdRange[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogClearRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @static
         * @param {ServiceLogger.ServiceLogClearRequest} message ServiceLogClearRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogClearRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resourceIdRange = [];
            if (options.defaults) {
                object.useDefaults = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceTypeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceTypeId = options.longs === String ? "0" : 0;
                object.daysOld = 0;
                object.hoursOld = 0;
            }
            if (message.useDefaults != null && message.hasOwnProperty("useDefaults"))
                object.useDefaults = message.useDefaults;
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                if (typeof message.serviceTypeId === "number")
                    object.serviceTypeId = options.longs === String ? String(message.serviceTypeId) : message.serviceTypeId;
                else
                    object.serviceTypeId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceTypeId) : options.longs === Number ? new $util.LongBits(message.serviceTypeId.low >>> 0, message.serviceTypeId.high >>> 0).toNumber(true) : message.serviceTypeId;
            if (message.daysOld != null && message.hasOwnProperty("daysOld"))
                object.daysOld = message.daysOld;
            if (message.hoursOld != null && message.hasOwnProperty("hoursOld"))
                object.hoursOld = message.hoursOld;
            if (message.resourceIdRange && message.resourceIdRange.length) {
                object.resourceIdRange = [];
                for (let j = 0; j < message.resourceIdRange.length; ++j)
                    object.resourceIdRange[j] = $root.ServiceLogger.IdRange.toObject(message.resourceIdRange[j], options);
            }
            return object;
        };

        /**
         * Converts this ServiceLogClearRequest to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogClearRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogClearRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogClearRequest;
    })();

    ServiceLogger.ServiceLogClearResponse = (function() {

        /**
         * Properties of a ServiceLogClearResponse.
         * @memberof ServiceLogger
         * @interface IServiceLogClearResponse
         * @property {number|Long|null} [serviceTypeId] ServiceLogClearResponse serviceTypeId
         * @property {string|null} [serviceName] ServiceLogClearResponse serviceName
         * @property {Array.<ServiceLogger.IIdRange>|null} [resourceIdRange] ServiceLogClearResponse resourceIdRange
         * @property {number|null} [numDeleted] ServiceLogClearResponse numDeleted
         * @property {number|null} [numRemaining] ServiceLogClearResponse numRemaining
         */

        /**
         * Constructs a new ServiceLogClearResponse.
         * @memberof ServiceLogger
         * @classdesc This is the response from the sso_log_clear command
         * @implements IServiceLogClearResponse
         * @constructor
         * @param {ServiceLogger.IServiceLogClearResponse=} [properties] Properties to set
         */
        function ServiceLogClearResponse(properties) {
            this.resourceIdRange = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServiceLogClearResponse serviceTypeId.
         * @member {number|Long} serviceTypeId
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         */
        ServiceLogClearResponse.prototype.serviceTypeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ServiceLogClearResponse serviceName.
         * @member {string} serviceName
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         */
        ServiceLogClearResponse.prototype.serviceName = "";

        /**
         * ServiceLogClearResponse resourceIdRange.
         * @member {Array.<ServiceLogger.IIdRange>} resourceIdRange
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         */
        ServiceLogClearResponse.prototype.resourceIdRange = $util.emptyArray;

        /**
         * ServiceLogClearResponse numDeleted.
         * @member {number} numDeleted
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         */
        ServiceLogClearResponse.prototype.numDeleted = 0;

        /**
         * ServiceLogClearResponse numRemaining.
         * @member {number} numRemaining
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         */
        ServiceLogClearResponse.prototype.numRemaining = 0;

        /**
         * Creates a new ServiceLogClearResponse instance using the specified properties.
         * @function create
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {ServiceLogger.IServiceLogClearResponse=} [properties] Properties to set
         * @returns {ServiceLogger.ServiceLogClearResponse} ServiceLogClearResponse instance
         */
        ServiceLogClearResponse.create = function create(properties) {
            return new ServiceLogClearResponse(properties);
        };

        /**
         * Encodes the specified ServiceLogClearResponse message. Does not implicitly {@link ServiceLogger.ServiceLogClearResponse.verify|verify} messages.
         * @function encode
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {ServiceLogger.IServiceLogClearResponse} message ServiceLogClearResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogClearResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.serviceTypeId);
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.serviceName);
            if (message.resourceIdRange != null && message.resourceIdRange.length)
                for (let i = 0; i < message.resourceIdRange.length; ++i)
                    $root.ServiceLogger.IdRange.encode(message.resourceIdRange[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.numDeleted != null && message.hasOwnProperty("numDeleted"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numDeleted);
            if (message.numRemaining != null && message.hasOwnProperty("numRemaining"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numRemaining);
            return writer;
        };

        /**
         * Encodes the specified ServiceLogClearResponse message, length delimited. Does not implicitly {@link ServiceLogger.ServiceLogClearResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {ServiceLogger.IServiceLogClearResponse} message ServiceLogClearResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServiceLogClearResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServiceLogClearResponse message from the specified reader or buffer.
         * @function decode
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ServiceLogger.ServiceLogClearResponse} ServiceLogClearResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogClearResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServiceLogger.ServiceLogClearResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serviceTypeId = reader.uint64();
                    break;
                case 2:
                    message.serviceName = reader.string();
                    break;
                case 3:
                    if (!(message.resourceIdRange && message.resourceIdRange.length))
                        message.resourceIdRange = [];
                    message.resourceIdRange.push($root.ServiceLogger.IdRange.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.numDeleted = reader.uint32();
                    break;
                case 5:
                    message.numRemaining = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServiceLogClearResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ServiceLogger.ServiceLogClearResponse} ServiceLogClearResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServiceLogClearResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServiceLogClearResponse message.
         * @function verify
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServiceLogClearResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                if (!$util.isInteger(message.serviceTypeId) && !(message.serviceTypeId && $util.isInteger(message.serviceTypeId.low) && $util.isInteger(message.serviceTypeId.high)))
                    return "serviceTypeId: integer|Long expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                if (!$util.isString(message.serviceName))
                    return "serviceName: string expected";
            if (message.resourceIdRange != null && message.hasOwnProperty("resourceIdRange")) {
                if (!Array.isArray(message.resourceIdRange))
                    return "resourceIdRange: array expected";
                for (let i = 0; i < message.resourceIdRange.length; ++i) {
                    let error = $root.ServiceLogger.IdRange.verify(message.resourceIdRange[i]);
                    if (error)
                        return "resourceIdRange." + error;
                }
            }
            if (message.numDeleted != null && message.hasOwnProperty("numDeleted"))
                if (!$util.isInteger(message.numDeleted))
                    return "numDeleted: integer expected";
            if (message.numRemaining != null && message.hasOwnProperty("numRemaining"))
                if (!$util.isInteger(message.numRemaining))
                    return "numRemaining: integer expected";
            return null;
        };

        /**
         * Creates a ServiceLogClearResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ServiceLogger.ServiceLogClearResponse} ServiceLogClearResponse
         */
        ServiceLogClearResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.ServiceLogger.ServiceLogClearResponse)
                return object;
            let message = new $root.ServiceLogger.ServiceLogClearResponse();
            if (object.serviceTypeId != null)
                if ($util.Long)
                    (message.serviceTypeId = $util.Long.fromValue(object.serviceTypeId)).unsigned = true;
                else if (typeof object.serviceTypeId === "string")
                    message.serviceTypeId = parseInt(object.serviceTypeId, 10);
                else if (typeof object.serviceTypeId === "number")
                    message.serviceTypeId = object.serviceTypeId;
                else if (typeof object.serviceTypeId === "object")
                    message.serviceTypeId = new $util.LongBits(object.serviceTypeId.low >>> 0, object.serviceTypeId.high >>> 0).toNumber(true);
            if (object.serviceName != null)
                message.serviceName = String(object.serviceName);
            if (object.resourceIdRange) {
                if (!Array.isArray(object.resourceIdRange))
                    throw TypeError(".ServiceLogger.ServiceLogClearResponse.resourceIdRange: array expected");
                message.resourceIdRange = [];
                for (let i = 0; i < object.resourceIdRange.length; ++i) {
                    if (typeof object.resourceIdRange[i] !== "object")
                        throw TypeError(".ServiceLogger.ServiceLogClearResponse.resourceIdRange: object expected");
                    message.resourceIdRange[i] = $root.ServiceLogger.IdRange.fromObject(object.resourceIdRange[i]);
                }
            }
            if (object.numDeleted != null)
                message.numDeleted = object.numDeleted >>> 0;
            if (object.numRemaining != null)
                message.numRemaining = object.numRemaining >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServiceLogClearResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @static
         * @param {ServiceLogger.ServiceLogClearResponse} message ServiceLogClearResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServiceLogClearResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.resourceIdRange = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.serviceTypeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.serviceTypeId = options.longs === String ? "0" : 0;
                object.serviceName = "";
                object.numDeleted = 0;
                object.numRemaining = 0;
            }
            if (message.serviceTypeId != null && message.hasOwnProperty("serviceTypeId"))
                if (typeof message.serviceTypeId === "number")
                    object.serviceTypeId = options.longs === String ? String(message.serviceTypeId) : message.serviceTypeId;
                else
                    object.serviceTypeId = options.longs === String ? $util.Long.prototype.toString.call(message.serviceTypeId) : options.longs === Number ? new $util.LongBits(message.serviceTypeId.low >>> 0, message.serviceTypeId.high >>> 0).toNumber(true) : message.serviceTypeId;
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                object.serviceName = message.serviceName;
            if (message.resourceIdRange && message.resourceIdRange.length) {
                object.resourceIdRange = [];
                for (let j = 0; j < message.resourceIdRange.length; ++j)
                    object.resourceIdRange[j] = $root.ServiceLogger.IdRange.toObject(message.resourceIdRange[j], options);
            }
            if (message.numDeleted != null && message.hasOwnProperty("numDeleted"))
                object.numDeleted = message.numDeleted;
            if (message.numRemaining != null && message.hasOwnProperty("numRemaining"))
                object.numRemaining = message.numRemaining;
            return object;
        };

        /**
         * Converts this ServiceLogClearResponse to JSON.
         * @function toJSON
         * @memberof ServiceLogger.ServiceLogClearResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServiceLogClearResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ServiceLogClearResponse;
    })();

    return ServiceLogger;
})();

export const SsoCloud = $root.SsoCloud = (() => {

    /**
     * Namespace SsoCloud.
     * @exports SsoCloud
     * @namespace
     */
    const SsoCloud = {};

    /**
     * Authentication protocols we support.
     * @name SsoCloud.AuthProtocolType
     * @enum {string}
     * @property {number} SAML2=0 SAML2 value
     */
    SsoCloud.AuthProtocolType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SAML2"] = 0;
        return values;
    })();

    /**
     * Datatypes of SsoCloudSettings
     * @name SsoCloud.DataType
     * @enum {string}
     * @property {number} ANY=0 ANY value
     * @property {number} BOOLEAN=1 BOOLEAN value
     * @property {number} INTEGER=2 INTEGER value
     * @property {number} STRING=3 STRING value
     * @property {number} BYTES=4 BYTES value
     * @property {number} URL=5 URL value
     * @property {number} com_keepersecurity_proto_SsoCloud_DataType=6 com_keepersecurity_proto_SsoCloud_DataType value
     * @property {number} com_keepersecurity_proto_SsoCloud_AuthProtocolType=7 com_keepersecurity_proto_SsoCloud_AuthProtocolType value
     * @property {number} com_keepersecurity_proto_SsoCloud_SsoIdpType=8 com_keepersecurity_proto_SsoCloud_SsoIdpType value
     */
    SsoCloud.DataType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ANY"] = 0;
        values[valuesById[1] = "BOOLEAN"] = 1;
        values[valuesById[2] = "INTEGER"] = 2;
        values[valuesById[3] = "STRING"] = 3;
        values[valuesById[4] = "BYTES"] = 4;
        values[valuesById[5] = "URL"] = 5;
        values[valuesById[6] = "com_keepersecurity_proto_SsoCloud_DataType"] = 6;
        values[valuesById[7] = "com_keepersecurity_proto_SsoCloud_AuthProtocolType"] = 7;
        values[valuesById[8] = "com_keepersecurity_proto_SsoCloud_SsoIdpType"] = 8;
        return values;
    })();

    /**
     * This is how the client can change a Configuration setting
     * @name SsoCloud.SsoCloudSettingOperationType
     * @enum {string}
     * @property {number} SET=0 SET value
     * @property {number} GET=1 GET value
     * @property {number} DELETE=2 DELETE value
     * @property {number} RESET_TO_DEFAULT=3 RESET_TO_DEFAULT value
     */
    SsoCloud.SsoCloudSettingOperationType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SET"] = 0;
        values[valuesById[1] = "GET"] = 1;
        values[valuesById[2] = "DELETE"] = 2;
        values[valuesById[3] = "RESET_TO_DEFAULT"] = 3;
        return values;
    })();

    /**
     * SsoIdpType enum.
     * @name SsoCloud.SsoIdpType
     * @enum {string}
     * @property {number} XX_UNUSED=0 XX_UNUSED value
     * @property {number} GENERIC=1 GENERIC value
     * @property {number} F5=2 F5 value
     * @property {number} GOOGLE=3 GOOGLE value
     * @property {number} OKTA=4 OKTA value
     * @property {number} ADFS=5 ADFS value
     * @property {number} AZURE=6 AZURE value
     * @property {number} ONELOGIN=7 ONELOGIN value
     * @property {number} PING=8 PING value
     * @property {number} JUMPCLOUD=9 JUMPCLOUD value
     */
    SsoCloud.SsoIdpType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "XX_UNUSED"] = 0;
        values[valuesById[1] = "GENERIC"] = 1;
        values[valuesById[2] = "F5"] = 2;
        values[valuesById[3] = "GOOGLE"] = 3;
        values[valuesById[4] = "OKTA"] = 4;
        values[valuesById[5] = "ADFS"] = 5;
        values[valuesById[6] = "AZURE"] = 6;
        values[valuesById[7] = "ONELOGIN"] = 7;
        values[valuesById[8] = "PING"] = 8;
        values[valuesById[9] = "JUMPCLOUD"] = 9;
        return values;
    })();

    SsoCloud.SsoCloudSettingValue = (function() {

        /**
         * Properties of a SsoCloudSettingValue.
         * @memberof SsoCloud
         * @interface ISsoCloudSettingValue
         * @property {number|Long|null} [settingId] SsoCloudSettingValue settingId
         * @property {string|null} [settingName] SsoCloudSettingValue settingName
         * @property {string|null} [label] SsoCloudSettingValue label
         * @property {string|null} [value] SsoCloudSettingValue value
         * @property {SsoCloud.DataType|null} [valueType] SsoCloudSettingValue valueType
         * @property {string|null} [lastModified] SsoCloudSettingValue lastModified
         * @property {boolean|null} [isFromFile] SsoCloudSettingValue isFromFile
         * @property {boolean|null} [isEditable] SsoCloudSettingValue isEditable
         * @property {boolean|null} [isRequired] SsoCloudSettingValue isRequired
         */

        /**
         * Constructs a new SsoCloudSettingValue.
         * @memberof SsoCloud
         * @classdesc This is the value of a Configuration setting
         * @implements ISsoCloudSettingValue
         * @constructor
         * @param {SsoCloud.ISsoCloudSettingValue=} [properties] Properties to set
         */
        function SsoCloudSettingValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudSettingValue settingId.
         * @member {number|Long} settingId
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.settingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudSettingValue settingName.
         * @member {string} settingName
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.settingName = "";

        /**
         * SsoCloudSettingValue label.
         * @member {string} label
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.label = "";

        /**
         * SsoCloudSettingValue value.
         * @member {string} value
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.value = "";

        /**
         * SsoCloudSettingValue valueType.
         * @member {SsoCloud.DataType} valueType
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.valueType = 0;

        /**
         * SsoCloudSettingValue lastModified.
         * @member {string} lastModified
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.lastModified = "";

        /**
         * SsoCloudSettingValue isFromFile.
         * @member {boolean} isFromFile
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.isFromFile = false;

        /**
         * SsoCloudSettingValue isEditable.
         * @member {boolean} isEditable
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.isEditable = false;

        /**
         * SsoCloudSettingValue isRequired.
         * @member {boolean} isRequired
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         */
        SsoCloudSettingValue.prototype.isRequired = false;

        /**
         * Creates a new SsoCloudSettingValue instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {SsoCloud.ISsoCloudSettingValue=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudSettingValue} SsoCloudSettingValue instance
         */
        SsoCloudSettingValue.create = function create(properties) {
            return new SsoCloudSettingValue(properties);
        };

        /**
         * Encodes the specified SsoCloudSettingValue message. Does not implicitly {@link SsoCloud.SsoCloudSettingValue.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {SsoCloud.ISsoCloudSettingValue} message SsoCloudSettingValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSettingValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.settingId);
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.settingName);
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.value);
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.valueType);
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.lastModified);
            if (message.isFromFile != null && message.hasOwnProperty("isFromFile"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isFromFile);
            if (message.isEditable != null && message.hasOwnProperty("isEditable"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isEditable);
            if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isRequired);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudSettingValue message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudSettingValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {SsoCloud.ISsoCloudSettingValue} message SsoCloudSettingValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSettingValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudSettingValue message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudSettingValue} SsoCloudSettingValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSettingValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudSettingValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.settingId = reader.uint64();
                    break;
                case 2:
                    message.settingName = reader.string();
                    break;
                case 3:
                    message.label = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                case 5:
                    message.valueType = reader.int32();
                    break;
                case 7:
                    message.lastModified = reader.string();
                    break;
                case 8:
                    message.isFromFile = reader.bool();
                    break;
                case 9:
                    message.isEditable = reader.bool();
                    break;
                case 10:
                    message.isRequired = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudSettingValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudSettingValue} SsoCloudSettingValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSettingValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudSettingValue message.
         * @function verify
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudSettingValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                if (!$util.isInteger(message.settingId) && !(message.settingId && $util.isInteger(message.settingId.low) && $util.isInteger(message.settingId.high)))
                    return "settingId: integer|Long expected";
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                if (!$util.isString(message.settingName))
                    return "settingName: string expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                switch (message.valueType) {
                default:
                    return "valueType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                if (!$util.isString(message.lastModified))
                    return "lastModified: string expected";
            if (message.isFromFile != null && message.hasOwnProperty("isFromFile"))
                if (typeof message.isFromFile !== "boolean")
                    return "isFromFile: boolean expected";
            if (message.isEditable != null && message.hasOwnProperty("isEditable"))
                if (typeof message.isEditable !== "boolean")
                    return "isEditable: boolean expected";
            if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                if (typeof message.isRequired !== "boolean")
                    return "isRequired: boolean expected";
            return null;
        };

        /**
         * Creates a SsoCloudSettingValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudSettingValue} SsoCloudSettingValue
         */
        SsoCloudSettingValue.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudSettingValue)
                return object;
            let message = new $root.SsoCloud.SsoCloudSettingValue();
            if (object.settingId != null)
                if ($util.Long)
                    (message.settingId = $util.Long.fromValue(object.settingId)).unsigned = true;
                else if (typeof object.settingId === "string")
                    message.settingId = parseInt(object.settingId, 10);
                else if (typeof object.settingId === "number")
                    message.settingId = object.settingId;
                else if (typeof object.settingId === "object")
                    message.settingId = new $util.LongBits(object.settingId.low >>> 0, object.settingId.high >>> 0).toNumber(true);
            if (object.settingName != null)
                message.settingName = String(object.settingName);
            if (object.label != null)
                message.label = String(object.label);
            if (object.value != null)
                message.value = String(object.value);
            switch (object.valueType) {
            case "ANY":
            case 0:
                message.valueType = 0;
                break;
            case "BOOLEAN":
            case 1:
                message.valueType = 1;
                break;
            case "INTEGER":
            case 2:
                message.valueType = 2;
                break;
            case "STRING":
            case 3:
                message.valueType = 3;
                break;
            case "BYTES":
            case 4:
                message.valueType = 4;
                break;
            case "URL":
            case 5:
                message.valueType = 5;
                break;
            case "com_keepersecurity_proto_SsoCloud_DataType":
            case 6:
                message.valueType = 6;
                break;
            case "com_keepersecurity_proto_SsoCloud_AuthProtocolType":
            case 7:
                message.valueType = 7;
                break;
            case "com_keepersecurity_proto_SsoCloud_SsoIdpType":
            case 8:
                message.valueType = 8;
                break;
            }
            if (object.lastModified != null)
                message.lastModified = String(object.lastModified);
            if (object.isFromFile != null)
                message.isFromFile = Boolean(object.isFromFile);
            if (object.isEditable != null)
                message.isEditable = Boolean(object.isEditable);
            if (object.isRequired != null)
                message.isRequired = Boolean(object.isRequired);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudSettingValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudSettingValue
         * @static
         * @param {SsoCloud.SsoCloudSettingValue} message SsoCloudSettingValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudSettingValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settingId = options.longs === String ? "0" : 0;
                object.settingName = "";
                object.label = "";
                object.value = "";
                object.valueType = options.enums === String ? "ANY" : 0;
                object.lastModified = "";
                object.isFromFile = false;
                object.isEditable = false;
                object.isRequired = false;
            }
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                if (typeof message.settingId === "number")
                    object.settingId = options.longs === String ? String(message.settingId) : message.settingId;
                else
                    object.settingId = options.longs === String ? $util.Long.prototype.toString.call(message.settingId) : options.longs === Number ? new $util.LongBits(message.settingId.low >>> 0, message.settingId.high >>> 0).toNumber(true) : message.settingId;
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                object.settingName = message.settingName;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            if (message.valueType != null && message.hasOwnProperty("valueType"))
                object.valueType = options.enums === String ? $root.SsoCloud.DataType[message.valueType] : message.valueType;
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                object.lastModified = message.lastModified;
            if (message.isFromFile != null && message.hasOwnProperty("isFromFile"))
                object.isFromFile = message.isFromFile;
            if (message.isEditable != null && message.hasOwnProperty("isEditable"))
                object.isEditable = message.isEditable;
            if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                object.isRequired = message.isRequired;
            return object;
        };

        /**
         * Converts this SsoCloudSettingValue to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudSettingValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudSettingValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudSettingValue;
    })();

    SsoCloud.SsoCloudSettingAction = (function() {

        /**
         * Properties of a SsoCloudSettingAction.
         * @memberof SsoCloud
         * @interface ISsoCloudSettingAction
         * @property {number|Long|null} [settingId] SsoCloudSettingAction settingId
         * @property {string|null} [settingName] SsoCloudSettingAction settingName
         * @property {SsoCloud.SsoCloudSettingOperationType|null} [operation] SsoCloudSettingAction operation
         * @property {string|null} [value] SsoCloudSettingAction value
         */

        /**
         * Constructs a new SsoCloudSettingAction.
         * @memberof SsoCloud
         * @classdesc This performs an edit operation on a Configuration setting
         * @implements ISsoCloudSettingAction
         * @constructor
         * @param {SsoCloud.ISsoCloudSettingAction=} [properties] Properties to set
         */
        function SsoCloudSettingAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudSettingAction settingId.
         * @member {number|Long} settingId
         * @memberof SsoCloud.SsoCloudSettingAction
         * @instance
         */
        SsoCloudSettingAction.prototype.settingId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudSettingAction settingName.
         * @member {string} settingName
         * @memberof SsoCloud.SsoCloudSettingAction
         * @instance
         */
        SsoCloudSettingAction.prototype.settingName = "";

        /**
         * SsoCloudSettingAction operation.
         * @member {SsoCloud.SsoCloudSettingOperationType} operation
         * @memberof SsoCloud.SsoCloudSettingAction
         * @instance
         */
        SsoCloudSettingAction.prototype.operation = 0;

        /**
         * SsoCloudSettingAction value.
         * @member {string} value
         * @memberof SsoCloud.SsoCloudSettingAction
         * @instance
         */
        SsoCloudSettingAction.prototype.value = "";

        /**
         * Creates a new SsoCloudSettingAction instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {SsoCloud.ISsoCloudSettingAction=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudSettingAction} SsoCloudSettingAction instance
         */
        SsoCloudSettingAction.create = function create(properties) {
            return new SsoCloudSettingAction(properties);
        };

        /**
         * Encodes the specified SsoCloudSettingAction message. Does not implicitly {@link SsoCloud.SsoCloudSettingAction.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {SsoCloud.ISsoCloudSettingAction} message SsoCloudSettingAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSettingAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.settingId);
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.settingName);
            if (message.operation != null && message.hasOwnProperty("operation"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.operation);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudSettingAction message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudSettingAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {SsoCloud.ISsoCloudSettingAction} message SsoCloudSettingAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSettingAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudSettingAction message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudSettingAction} SsoCloudSettingAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSettingAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudSettingAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.settingId = reader.uint64();
                    break;
                case 2:
                    message.settingName = reader.string();
                    break;
                case 3:
                    message.operation = reader.int32();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudSettingAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudSettingAction} SsoCloudSettingAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSettingAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudSettingAction message.
         * @function verify
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudSettingAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                if (!$util.isInteger(message.settingId) && !(message.settingId && $util.isInteger(message.settingId.low) && $util.isInteger(message.settingId.high)))
                    return "settingId: integer|Long expected";
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                if (!$util.isString(message.settingName))
                    return "settingName: string expected";
            if (message.operation != null && message.hasOwnProperty("operation"))
                switch (message.operation) {
                default:
                    return "operation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a SsoCloudSettingAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudSettingAction} SsoCloudSettingAction
         */
        SsoCloudSettingAction.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudSettingAction)
                return object;
            let message = new $root.SsoCloud.SsoCloudSettingAction();
            if (object.settingId != null)
                if ($util.Long)
                    (message.settingId = $util.Long.fromValue(object.settingId)).unsigned = true;
                else if (typeof object.settingId === "string")
                    message.settingId = parseInt(object.settingId, 10);
                else if (typeof object.settingId === "number")
                    message.settingId = object.settingId;
                else if (typeof object.settingId === "object")
                    message.settingId = new $util.LongBits(object.settingId.low >>> 0, object.settingId.high >>> 0).toNumber(true);
            if (object.settingName != null)
                message.settingName = String(object.settingName);
            switch (object.operation) {
            case "SET":
            case 0:
                message.operation = 0;
                break;
            case "GET":
            case 1:
                message.operation = 1;
                break;
            case "DELETE":
            case 2:
                message.operation = 2;
                break;
            case "RESET_TO_DEFAULT":
            case 3:
                message.operation = 3;
                break;
            }
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudSettingAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudSettingAction
         * @static
         * @param {SsoCloud.SsoCloudSettingAction} message SsoCloudSettingAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudSettingAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settingId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settingId = options.longs === String ? "0" : 0;
                object.settingName = "";
                object.operation = options.enums === String ? "SET" : 0;
                object.value = "";
            }
            if (message.settingId != null && message.hasOwnProperty("settingId"))
                if (typeof message.settingId === "number")
                    object.settingId = options.longs === String ? String(message.settingId) : message.settingId;
                else
                    object.settingId = options.longs === String ? $util.Long.prototype.toString.call(message.settingId) : options.longs === Number ? new $util.LongBits(message.settingId.low >>> 0, message.settingId.high >>> 0).toNumber(true) : message.settingId;
            if (message.settingName != null && message.hasOwnProperty("settingName"))
                object.settingName = message.settingName;
            if (message.operation != null && message.hasOwnProperty("operation"))
                object.operation = options.enums === String ? $root.SsoCloud.SsoCloudSettingOperationType[message.operation] : message.operation;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this SsoCloudSettingAction to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudSettingAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudSettingAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudSettingAction;
    })();

    SsoCloud.SsoCloudConfigurationRequest = (function() {

        /**
         * Properties of a SsoCloudConfigurationRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudConfigurationRequest
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudConfigurationRequest ssoServiceProviderId
         * @property {number|Long|null} [ssoSpConfigurationId] SsoCloudConfigurationRequest ssoSpConfigurationId
         * @property {string|null} [name] SsoCloudConfigurationRequest name
         * @property {SsoCloud.AuthProtocolType|null} [ssoAuthProtocolType] SsoCloudConfigurationRequest ssoAuthProtocolType
         * @property {Array.<SsoCloud.ISsoCloudSettingAction>|null} [ssoCloudSettingAction] SsoCloudConfigurationRequest ssoCloudSettingAction
         */

        /**
         * Constructs a new SsoCloudConfigurationRequest.
         * @memberof SsoCloud
         * @classdesc Requesting the value of or a change to an SSO Configuration
         * @implements ISsoCloudConfigurationRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudConfigurationRequest=} [properties] Properties to set
         */
        function SsoCloudConfigurationRequest(properties) {
            this.ssoCloudSettingAction = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudConfigurationRequest ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         */
        SsoCloudConfigurationRequest.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudConfigurationRequest ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         */
        SsoCloudConfigurationRequest.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudConfigurationRequest name.
         * @member {string} name
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         */
        SsoCloudConfigurationRequest.prototype.name = "";

        /**
         * SsoCloudConfigurationRequest ssoAuthProtocolType.
         * @member {SsoCloud.AuthProtocolType} ssoAuthProtocolType
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         */
        SsoCloudConfigurationRequest.prototype.ssoAuthProtocolType = 0;

        /**
         * SsoCloudConfigurationRequest ssoCloudSettingAction.
         * @member {Array.<SsoCloud.ISsoCloudSettingAction>} ssoCloudSettingAction
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         */
        SsoCloudConfigurationRequest.prototype.ssoCloudSettingAction = $util.emptyArray;

        /**
         * Creates a new SsoCloudConfigurationRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudConfigurationRequest} SsoCloudConfigurationRequest instance
         */
        SsoCloudConfigurationRequest.create = function create(properties) {
            return new SsoCloudConfigurationRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudConfigurationRequest message. Does not implicitly {@link SsoCloud.SsoCloudConfigurationRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationRequest} message SsoCloudConfigurationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ssoSpConfigurationId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.ssoAuthProtocolType != null && message.hasOwnProperty("ssoAuthProtocolType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ssoAuthProtocolType);
            if (message.ssoCloudSettingAction != null && message.ssoCloudSettingAction.length)
                for (let i = 0; i < message.ssoCloudSettingAction.length; ++i)
                    $root.SsoCloud.SsoCloudSettingAction.encode(message.ssoCloudSettingAction[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SsoCloudConfigurationRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudConfigurationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationRequest} message SsoCloudConfigurationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudConfigurationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudConfigurationRequest} SsoCloudConfigurationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudConfigurationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                case 2:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.ssoAuthProtocolType = reader.int32();
                    break;
                case 5:
                    if (!(message.ssoCloudSettingAction && message.ssoCloudSettingAction.length))
                        message.ssoCloudSettingAction = [];
                    message.ssoCloudSettingAction.push($root.SsoCloud.SsoCloudSettingAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudConfigurationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudConfigurationRequest} SsoCloudConfigurationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudConfigurationRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudConfigurationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.ssoAuthProtocolType != null && message.hasOwnProperty("ssoAuthProtocolType"))
                switch (message.ssoAuthProtocolType) {
                default:
                    return "ssoAuthProtocolType: enum value expected";
                case 0:
                    break;
                }
            if (message.ssoCloudSettingAction != null && message.hasOwnProperty("ssoCloudSettingAction")) {
                if (!Array.isArray(message.ssoCloudSettingAction))
                    return "ssoCloudSettingAction: array expected";
                for (let i = 0; i < message.ssoCloudSettingAction.length; ++i) {
                    let error = $root.SsoCloud.SsoCloudSettingAction.verify(message.ssoCloudSettingAction[i]);
                    if (error)
                        return "ssoCloudSettingAction." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SsoCloudConfigurationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudConfigurationRequest} SsoCloudConfigurationRequest
         */
        SsoCloudConfigurationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudConfigurationRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudConfigurationRequest();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            switch (object.ssoAuthProtocolType) {
            case "SAML2":
            case 0:
                message.ssoAuthProtocolType = 0;
                break;
            }
            if (object.ssoCloudSettingAction) {
                if (!Array.isArray(object.ssoCloudSettingAction))
                    throw TypeError(".SsoCloud.SsoCloudConfigurationRequest.ssoCloudSettingAction: array expected");
                message.ssoCloudSettingAction = [];
                for (let i = 0; i < object.ssoCloudSettingAction.length; ++i) {
                    if (typeof object.ssoCloudSettingAction[i] !== "object")
                        throw TypeError(".SsoCloud.SsoCloudConfigurationRequest.ssoCloudSettingAction: object expected");
                    message.ssoCloudSettingAction[i] = $root.SsoCloud.SsoCloudSettingAction.fromObject(object.ssoCloudSettingAction[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudConfigurationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @static
         * @param {SsoCloud.SsoCloudConfigurationRequest} message SsoCloudConfigurationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudConfigurationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ssoCloudSettingAction = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
                object.name = "";
                object.ssoAuthProtocolType = options.enums === String ? "SAML2" : 0;
            }
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.ssoAuthProtocolType != null && message.hasOwnProperty("ssoAuthProtocolType"))
                object.ssoAuthProtocolType = options.enums === String ? $root.SsoCloud.AuthProtocolType[message.ssoAuthProtocolType] : message.ssoAuthProtocolType;
            if (message.ssoCloudSettingAction && message.ssoCloudSettingAction.length) {
                object.ssoCloudSettingAction = [];
                for (let j = 0; j < message.ssoCloudSettingAction.length; ++j)
                    object.ssoCloudSettingAction[j] = $root.SsoCloud.SsoCloudSettingAction.toObject(message.ssoCloudSettingAction[j], options);
            }
            return object;
        };

        /**
         * Converts this SsoCloudConfigurationRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudConfigurationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudConfigurationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudConfigurationRequest;
    })();

    SsoCloud.SsoCloudConfigurationResponse = (function() {

        /**
         * Properties of a SsoCloudConfigurationResponse.
         * @memberof SsoCloud
         * @interface ISsoCloudConfigurationResponse
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudConfigurationResponse ssoServiceProviderId
         * @property {number|Long|null} [ssoSpConfigurationId] SsoCloudConfigurationResponse ssoSpConfigurationId
         * @property {number|Long|null} [enterpriseId] SsoCloudConfigurationResponse enterpriseId
         * @property {string|null} [name] SsoCloudConfigurationResponse name
         * @property {string|null} [protocol] SsoCloudConfigurationResponse protocol
         * @property {string|null} [lastModified] SsoCloudConfigurationResponse lastModified
         * @property {Array.<SsoCloud.ISsoCloudSettingValue>|null} [ssoCloudSettingValue] SsoCloudConfigurationResponse ssoCloudSettingValue
         */

        /**
         * Constructs a new SsoCloudConfigurationResponse.
         * @memberof SsoCloud
         * @classdesc This is the response to an SsoConfigurationRequest
         * @implements ISsoCloudConfigurationResponse
         * @constructor
         * @param {SsoCloud.ISsoCloudConfigurationResponse=} [properties] Properties to set
         */
        function SsoCloudConfigurationResponse(properties) {
            this.ssoCloudSettingValue = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudConfigurationResponse ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudConfigurationResponse ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudConfigurationResponse enterpriseId.
         * @member {number|Long} enterpriseId
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.enterpriseId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudConfigurationResponse name.
         * @member {string} name
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.name = "";

        /**
         * SsoCloudConfigurationResponse protocol.
         * @member {string} protocol
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.protocol = "";

        /**
         * SsoCloudConfigurationResponse lastModified.
         * @member {string} lastModified
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.lastModified = "";

        /**
         * SsoCloudConfigurationResponse ssoCloudSettingValue.
         * @member {Array.<SsoCloud.ISsoCloudSettingValue>} ssoCloudSettingValue
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         */
        SsoCloudConfigurationResponse.prototype.ssoCloudSettingValue = $util.emptyArray;

        /**
         * Creates a new SsoCloudConfigurationResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudConfigurationResponse} SsoCloudConfigurationResponse instance
         */
        SsoCloudConfigurationResponse.create = function create(properties) {
            return new SsoCloudConfigurationResponse(properties);
        };

        /**
         * Encodes the specified SsoCloudConfigurationResponse message. Does not implicitly {@link SsoCloud.SsoCloudConfigurationResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationResponse} message SsoCloudConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ssoSpConfigurationId);
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.enterpriseId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.protocol);
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.lastModified);
            if (message.ssoCloudSettingValue != null && message.ssoCloudSettingValue.length)
                for (let i = 0; i < message.ssoCloudSettingValue.length; ++i)
                    $root.SsoCloud.SsoCloudSettingValue.encode(message.ssoCloudSettingValue[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SsoCloudConfigurationResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudConfigurationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationResponse} message SsoCloudConfigurationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudConfigurationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudConfigurationResponse} SsoCloudConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudConfigurationResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                case 2:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                case 3:
                    message.enterpriseId = reader.uint64();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.protocol = reader.string();
                    break;
                case 6:
                    message.lastModified = reader.string();
                    break;
                case 7:
                    if (!(message.ssoCloudSettingValue && message.ssoCloudSettingValue.length))
                        message.ssoCloudSettingValue = [];
                    message.ssoCloudSettingValue.push($root.SsoCloud.SsoCloudSettingValue.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudConfigurationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudConfigurationResponse} SsoCloudConfigurationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudConfigurationResponse message.
         * @function verify
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudConfigurationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (!$util.isInteger(message.enterpriseId) && !(message.enterpriseId && $util.isInteger(message.enterpriseId.low) && $util.isInteger(message.enterpriseId.high)))
                    return "enterpriseId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                if (!$util.isString(message.protocol))
                    return "protocol: string expected";
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                if (!$util.isString(message.lastModified))
                    return "lastModified: string expected";
            if (message.ssoCloudSettingValue != null && message.hasOwnProperty("ssoCloudSettingValue")) {
                if (!Array.isArray(message.ssoCloudSettingValue))
                    return "ssoCloudSettingValue: array expected";
                for (let i = 0; i < message.ssoCloudSettingValue.length; ++i) {
                    let error = $root.SsoCloud.SsoCloudSettingValue.verify(message.ssoCloudSettingValue[i]);
                    if (error)
                        return "ssoCloudSettingValue." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SsoCloudConfigurationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudConfigurationResponse} SsoCloudConfigurationResponse
         */
        SsoCloudConfigurationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudConfigurationResponse)
                return object;
            let message = new $root.SsoCloud.SsoCloudConfigurationResponse();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            if (object.enterpriseId != null)
                if ($util.Long)
                    (message.enterpriseId = $util.Long.fromValue(object.enterpriseId)).unsigned = true;
                else if (typeof object.enterpriseId === "string")
                    message.enterpriseId = parseInt(object.enterpriseId, 10);
                else if (typeof object.enterpriseId === "number")
                    message.enterpriseId = object.enterpriseId;
                else if (typeof object.enterpriseId === "object")
                    message.enterpriseId = new $util.LongBits(object.enterpriseId.low >>> 0, object.enterpriseId.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            if (object.protocol != null)
                message.protocol = String(object.protocol);
            if (object.lastModified != null)
                message.lastModified = String(object.lastModified);
            if (object.ssoCloudSettingValue) {
                if (!Array.isArray(object.ssoCloudSettingValue))
                    throw TypeError(".SsoCloud.SsoCloudConfigurationResponse.ssoCloudSettingValue: array expected");
                message.ssoCloudSettingValue = [];
                for (let i = 0; i < object.ssoCloudSettingValue.length; ++i) {
                    if (typeof object.ssoCloudSettingValue[i] !== "object")
                        throw TypeError(".SsoCloud.SsoCloudConfigurationResponse.ssoCloudSettingValue: object expected");
                    message.ssoCloudSettingValue[i] = $root.SsoCloud.SsoCloudSettingValue.fromObject(object.ssoCloudSettingValue[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudConfigurationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @static
         * @param {SsoCloud.SsoCloudConfigurationResponse} message SsoCloudConfigurationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudConfigurationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ssoCloudSettingValue = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.enterpriseId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.enterpriseId = options.longs === String ? "0" : 0;
                object.name = "";
                object.protocol = "";
                object.lastModified = "";
            }
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            if (message.enterpriseId != null && message.hasOwnProperty("enterpriseId"))
                if (typeof message.enterpriseId === "number")
                    object.enterpriseId = options.longs === String ? String(message.enterpriseId) : message.enterpriseId;
                else
                    object.enterpriseId = options.longs === String ? $util.Long.prototype.toString.call(message.enterpriseId) : options.longs === Number ? new $util.LongBits(message.enterpriseId.low >>> 0, message.enterpriseId.high >>> 0).toNumber(true) : message.enterpriseId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.protocol != null && message.hasOwnProperty("protocol"))
                object.protocol = message.protocol;
            if (message.lastModified != null && message.hasOwnProperty("lastModified"))
                object.lastModified = message.lastModified;
            if (message.ssoCloudSettingValue && message.ssoCloudSettingValue.length) {
                object.ssoCloudSettingValue = [];
                for (let j = 0; j < message.ssoCloudSettingValue.length; ++j)
                    object.ssoCloudSettingValue[j] = $root.SsoCloud.SsoCloudSettingValue.toObject(message.ssoCloudSettingValue[j], options);
            }
            return object;
        };

        /**
         * Converts this SsoCloudConfigurationResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudConfigurationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudConfigurationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudConfigurationResponse;
    })();

    SsoCloud.SsoIdpTypeRequest = (function() {

        /**
         * Properties of a SsoIdpTypeRequest.
         * @memberof SsoCloud
         * @interface ISsoIdpTypeRequest
         * @property {number|null} [ssoIdpTypeId] SsoIdpTypeRequest ssoIdpTypeId
         * @property {string|null} [tag] SsoIdpTypeRequest tag
         * @property {string|null} [label] SsoIdpTypeRequest label
         */

        /**
         * Constructs a new SsoIdpTypeRequest.
         * @memberof SsoCloud
         * @classdesc This is a request to the IdpType API.
         * @implements ISsoIdpTypeRequest
         * @constructor
         * @param {SsoCloud.ISsoIdpTypeRequest=} [properties] Properties to set
         */
        function SsoIdpTypeRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoIdpTypeRequest ssoIdpTypeId.
         * @member {number} ssoIdpTypeId
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @instance
         */
        SsoIdpTypeRequest.prototype.ssoIdpTypeId = 0;

        /**
         * SsoIdpTypeRequest tag.
         * @member {string} tag
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @instance
         */
        SsoIdpTypeRequest.prototype.tag = "";

        /**
         * SsoIdpTypeRequest label.
         * @member {string} label
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @instance
         */
        SsoIdpTypeRequest.prototype.label = "";

        /**
         * Creates a new SsoIdpTypeRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {SsoCloud.ISsoIdpTypeRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoIdpTypeRequest} SsoIdpTypeRequest instance
         */
        SsoIdpTypeRequest.create = function create(properties) {
            return new SsoIdpTypeRequest(properties);
        };

        /**
         * Encodes the specified SsoIdpTypeRequest message. Does not implicitly {@link SsoCloud.SsoIdpTypeRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {SsoCloud.ISsoIdpTypeRequest} message SsoIdpTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoIdpTypeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ssoIdpTypeId);
            if (message.tag != null && message.hasOwnProperty("tag"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tag);
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.label);
            return writer;
        };

        /**
         * Encodes the specified SsoIdpTypeRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoIdpTypeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {SsoCloud.ISsoIdpTypeRequest} message SsoIdpTypeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoIdpTypeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoIdpTypeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoIdpTypeRequest} SsoIdpTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoIdpTypeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoIdpTypeRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoIdpTypeId = reader.uint32();
                    break;
                case 2:
                    message.tag = reader.string();
                    break;
                case 3:
                    message.label = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoIdpTypeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoIdpTypeRequest} SsoIdpTypeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoIdpTypeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoIdpTypeRequest message.
         * @function verify
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoIdpTypeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                if (!$util.isInteger(message.ssoIdpTypeId))
                    return "ssoIdpTypeId: integer expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isString(message.tag))
                    return "tag: string expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            return null;
        };

        /**
         * Creates a SsoIdpTypeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoIdpTypeRequest} SsoIdpTypeRequest
         */
        SsoIdpTypeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoIdpTypeRequest)
                return object;
            let message = new $root.SsoCloud.SsoIdpTypeRequest();
            if (object.ssoIdpTypeId != null)
                message.ssoIdpTypeId = object.ssoIdpTypeId >>> 0;
            if (object.tag != null)
                message.tag = String(object.tag);
            if (object.label != null)
                message.label = String(object.label);
            return message;
        };

        /**
         * Creates a plain object from a SsoIdpTypeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @static
         * @param {SsoCloud.SsoIdpTypeRequest} message SsoIdpTypeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoIdpTypeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ssoIdpTypeId = 0;
                object.tag = "";
                object.label = "";
            }
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                object.ssoIdpTypeId = message.ssoIdpTypeId;
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            return object;
        };

        /**
         * Converts this SsoIdpTypeRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoIdpTypeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoIdpTypeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoIdpTypeRequest;
    })();

    SsoCloud.SsoIdpTypeResponse = (function() {

        /**
         * Properties of a SsoIdpTypeResponse.
         * @memberof SsoCloud
         * @interface ISsoIdpTypeResponse
         * @property {number|null} [ssoIdpTypeId] SsoIdpTypeResponse ssoIdpTypeId
         * @property {number|null} [tag] SsoIdpTypeResponse tag
         * @property {number|null} [label] SsoIdpTypeResponse label
         */

        /**
         * Constructs a new SsoIdpTypeResponse.
         * @memberof SsoCloud
         * @classdesc This is a response from the IdpType API calls.
         * @implements ISsoIdpTypeResponse
         * @constructor
         * @param {SsoCloud.ISsoIdpTypeResponse=} [properties] Properties to set
         */
        function SsoIdpTypeResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoIdpTypeResponse ssoIdpTypeId.
         * @member {number} ssoIdpTypeId
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @instance
         */
        SsoIdpTypeResponse.prototype.ssoIdpTypeId = 0;

        /**
         * SsoIdpTypeResponse tag.
         * @member {number} tag
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @instance
         */
        SsoIdpTypeResponse.prototype.tag = 0;

        /**
         * SsoIdpTypeResponse label.
         * @member {number} label
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @instance
         */
        SsoIdpTypeResponse.prototype.label = 0;

        /**
         * Creates a new SsoIdpTypeResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {SsoCloud.ISsoIdpTypeResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoIdpTypeResponse} SsoIdpTypeResponse instance
         */
        SsoIdpTypeResponse.create = function create(properties) {
            return new SsoIdpTypeResponse(properties);
        };

        /**
         * Encodes the specified SsoIdpTypeResponse message. Does not implicitly {@link SsoCloud.SsoIdpTypeResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {SsoCloud.ISsoIdpTypeResponse} message SsoIdpTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoIdpTypeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ssoIdpTypeId);
            if (message.tag != null && message.hasOwnProperty("tag"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tag);
            if (message.label != null && message.hasOwnProperty("label"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.label);
            return writer;
        };

        /**
         * Encodes the specified SsoIdpTypeResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoIdpTypeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {SsoCloud.ISsoIdpTypeResponse} message SsoIdpTypeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoIdpTypeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoIdpTypeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoIdpTypeResponse} SsoIdpTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoIdpTypeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoIdpTypeResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoIdpTypeId = reader.int32();
                    break;
                case 2:
                    message.tag = reader.int32();
                    break;
                case 3:
                    message.label = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoIdpTypeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoIdpTypeResponse} SsoIdpTypeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoIdpTypeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoIdpTypeResponse message.
         * @function verify
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoIdpTypeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                if (!$util.isInteger(message.ssoIdpTypeId))
                    return "ssoIdpTypeId: integer expected";
            if (message.tag != null && message.hasOwnProperty("tag"))
                if (!$util.isInteger(message.tag))
                    return "tag: integer expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isInteger(message.label))
                    return "label: integer expected";
            return null;
        };

        /**
         * Creates a SsoIdpTypeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoIdpTypeResponse} SsoIdpTypeResponse
         */
        SsoIdpTypeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoIdpTypeResponse)
                return object;
            let message = new $root.SsoCloud.SsoIdpTypeResponse();
            if (object.ssoIdpTypeId != null)
                message.ssoIdpTypeId = object.ssoIdpTypeId | 0;
            if (object.tag != null)
                message.tag = object.tag | 0;
            if (object.label != null)
                message.label = object.label | 0;
            return message;
        };

        /**
         * Creates a plain object from a SsoIdpTypeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @static
         * @param {SsoCloud.SsoIdpTypeResponse} message SsoIdpTypeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoIdpTypeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ssoIdpTypeId = 0;
                object.tag = 0;
                object.label = 0;
            }
            if (message.ssoIdpTypeId != null && message.hasOwnProperty("ssoIdpTypeId"))
                object.ssoIdpTypeId = message.ssoIdpTypeId;
            if (message.tag != null && message.hasOwnProperty("tag"))
                object.tag = message.tag;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            return object;
        };

        /**
         * Converts this SsoIdpTypeResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoIdpTypeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoIdpTypeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoIdpTypeResponse;
    })();

    SsoCloud.SsoCloudSAMLLogRequest = (function() {

        /**
         * Properties of a SsoCloudSAMLLogRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudSAMLLogRequest
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudSAMLLogRequest ssoServiceProviderId
         */

        /**
         * Constructs a new SsoCloudSAMLLogRequest.
         * @memberof SsoCloud
         * @classdesc This is the request for the SAML logs of a service provider.  Used for both saml_log_get and saml_log_clear
         * @implements ISsoCloudSAMLLogRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudSAMLLogRequest=} [properties] Properties to set
         */
        function SsoCloudSAMLLogRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudSAMLLogRequest ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @instance
         */
        SsoCloudSAMLLogRequest.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SsoCloudSAMLLogRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudSAMLLogRequest} SsoCloudSAMLLogRequest instance
         */
        SsoCloudSAMLLogRequest.create = function create(properties) {
            return new SsoCloudSAMLLogRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudSAMLLogRequest message. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogRequest} message SsoCloudSAMLLogRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudSAMLLogRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogRequest} message SsoCloudSAMLLogRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudSAMLLogRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudSAMLLogRequest} SsoCloudSAMLLogRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudSAMLLogRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudSAMLLogRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudSAMLLogRequest} SsoCloudSAMLLogRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudSAMLLogRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudSAMLLogRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            return null;
        };

        /**
         * Creates a SsoCloudSAMLLogRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudSAMLLogRequest} SsoCloudSAMLLogRequest
         */
        SsoCloudSAMLLogRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudSAMLLogRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudSAMLLogRequest();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudSAMLLogRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @static
         * @param {SsoCloud.SsoCloudSAMLLogRequest} message SsoCloudSAMLLogRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudSAMLLogRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            return object;
        };

        /**
         * Converts this SsoCloudSAMLLogRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudSAMLLogRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudSAMLLogRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudSAMLLogRequest;
    })();

    SsoCloud.SsoCloudSAMLLogEntry = (function() {

        /**
         * Properties of a SsoCloudSAMLLogEntry.
         * @memberof SsoCloud
         * @interface ISsoCloudSAMLLogEntry
         * @property {string|null} [serverTime] SsoCloudSAMLLogEntry serverTime
         * @property {string|null} [direction] SsoCloudSAMLLogEntry direction
         * @property {string|null} [messageType] SsoCloudSAMLLogEntry messageType
         * @property {string|null} [messageIssued] SsoCloudSAMLLogEntry messageIssued
         * @property {string|null} [fromEntityId] SsoCloudSAMLLogEntry fromEntityId
         * @property {string|null} [samlStatus] SsoCloudSAMLLogEntry samlStatus
         * @property {string|null} [relayState] SsoCloudSAMLLogEntry relayState
         * @property {string|null} [samlContent] SsoCloudSAMLLogEntry samlContent
         * @property {boolean|null} [isSigned] SsoCloudSAMLLogEntry isSigned
         * @property {boolean|null} [isOK] SsoCloudSAMLLogEntry isOK
         */

        /**
         * Constructs a new SsoCloudSAMLLogEntry.
         * @memberof SsoCloud
         * @classdesc This represents one SAML message in the log.
         * @implements ISsoCloudSAMLLogEntry
         * @constructor
         * @param {SsoCloud.ISsoCloudSAMLLogEntry=} [properties] Properties to set
         */
        function SsoCloudSAMLLogEntry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudSAMLLogEntry serverTime.
         * @member {string} serverTime
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.serverTime = "";

        /**
         * SsoCloudSAMLLogEntry direction.
         * @member {string} direction
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.direction = "";

        /**
         * SsoCloudSAMLLogEntry messageType.
         * @member {string} messageType
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.messageType = "";

        /**
         * SsoCloudSAMLLogEntry messageIssued.
         * @member {string} messageIssued
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.messageIssued = "";

        /**
         * SsoCloudSAMLLogEntry fromEntityId.
         * @member {string} fromEntityId
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.fromEntityId = "";

        /**
         * SsoCloudSAMLLogEntry samlStatus.
         * @member {string} samlStatus
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.samlStatus = "";

        /**
         * SsoCloudSAMLLogEntry relayState.
         * @member {string} relayState
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.relayState = "";

        /**
         * SsoCloudSAMLLogEntry samlContent.
         * @member {string} samlContent
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.samlContent = "";

        /**
         * SsoCloudSAMLLogEntry isSigned.
         * @member {boolean} isSigned
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.isSigned = false;

        /**
         * SsoCloudSAMLLogEntry isOK.
         * @member {boolean} isOK
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         */
        SsoCloudSAMLLogEntry.prototype.isOK = false;

        /**
         * Creates a new SsoCloudSAMLLogEntry instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogEntry=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudSAMLLogEntry} SsoCloudSAMLLogEntry instance
         */
        SsoCloudSAMLLogEntry.create = function create(properties) {
            return new SsoCloudSAMLLogEntry(properties);
        };

        /**
         * Encodes the specified SsoCloudSAMLLogEntry message. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogEntry.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogEntry} message SsoCloudSAMLLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogEntry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverTime);
            if (message.direction != null && message.hasOwnProperty("direction"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.direction);
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.messageType);
            if (message.messageIssued != null && message.hasOwnProperty("messageIssued"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.messageIssued);
            if (message.fromEntityId != null && message.hasOwnProperty("fromEntityId"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.fromEntityId);
            if (message.samlStatus != null && message.hasOwnProperty("samlStatus"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.samlStatus);
            if (message.relayState != null && message.hasOwnProperty("relayState"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.relayState);
            if (message.samlContent != null && message.hasOwnProperty("samlContent"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.samlContent);
            if (message.isSigned != null && message.hasOwnProperty("isSigned"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isSigned);
            if (message.isOK != null && message.hasOwnProperty("isOK"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isOK);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudSAMLLogEntry message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogEntry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogEntry} message SsoCloudSAMLLogEntry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogEntry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudSAMLLogEntry message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudSAMLLogEntry} SsoCloudSAMLLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudSAMLLogEntry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.serverTime = reader.string();
                    break;
                case 2:
                    message.direction = reader.string();
                    break;
                case 3:
                    message.messageType = reader.string();
                    break;
                case 4:
                    message.messageIssued = reader.string();
                    break;
                case 5:
                    message.fromEntityId = reader.string();
                    break;
                case 6:
                    message.samlStatus = reader.string();
                    break;
                case 7:
                    message.relayState = reader.string();
                    break;
                case 8:
                    message.samlContent = reader.string();
                    break;
                case 9:
                    message.isSigned = reader.bool();
                    break;
                case 10:
                    message.isOK = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudSAMLLogEntry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudSAMLLogEntry} SsoCloudSAMLLogEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogEntry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudSAMLLogEntry message.
         * @function verify
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudSAMLLogEntry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                if (!$util.isString(message.serverTime))
                    return "serverTime: string expected";
            if (message.direction != null && message.hasOwnProperty("direction"))
                if (!$util.isString(message.direction))
                    return "direction: string expected";
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                if (!$util.isString(message.messageType))
                    return "messageType: string expected";
            if (message.messageIssued != null && message.hasOwnProperty("messageIssued"))
                if (!$util.isString(message.messageIssued))
                    return "messageIssued: string expected";
            if (message.fromEntityId != null && message.hasOwnProperty("fromEntityId"))
                if (!$util.isString(message.fromEntityId))
                    return "fromEntityId: string expected";
            if (message.samlStatus != null && message.hasOwnProperty("samlStatus"))
                if (!$util.isString(message.samlStatus))
                    return "samlStatus: string expected";
            if (message.relayState != null && message.hasOwnProperty("relayState"))
                if (!$util.isString(message.relayState))
                    return "relayState: string expected";
            if (message.samlContent != null && message.hasOwnProperty("samlContent"))
                if (!$util.isString(message.samlContent))
                    return "samlContent: string expected";
            if (message.isSigned != null && message.hasOwnProperty("isSigned"))
                if (typeof message.isSigned !== "boolean")
                    return "isSigned: boolean expected";
            if (message.isOK != null && message.hasOwnProperty("isOK"))
                if (typeof message.isOK !== "boolean")
                    return "isOK: boolean expected";
            return null;
        };

        /**
         * Creates a SsoCloudSAMLLogEntry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudSAMLLogEntry} SsoCloudSAMLLogEntry
         */
        SsoCloudSAMLLogEntry.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudSAMLLogEntry)
                return object;
            let message = new $root.SsoCloud.SsoCloudSAMLLogEntry();
            if (object.serverTime != null)
                message.serverTime = String(object.serverTime);
            if (object.direction != null)
                message.direction = String(object.direction);
            if (object.messageType != null)
                message.messageType = String(object.messageType);
            if (object.messageIssued != null)
                message.messageIssued = String(object.messageIssued);
            if (object.fromEntityId != null)
                message.fromEntityId = String(object.fromEntityId);
            if (object.samlStatus != null)
                message.samlStatus = String(object.samlStatus);
            if (object.relayState != null)
                message.relayState = String(object.relayState);
            if (object.samlContent != null)
                message.samlContent = String(object.samlContent);
            if (object.isSigned != null)
                message.isSigned = Boolean(object.isSigned);
            if (object.isOK != null)
                message.isOK = Boolean(object.isOK);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudSAMLLogEntry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @static
         * @param {SsoCloud.SsoCloudSAMLLogEntry} message SsoCloudSAMLLogEntry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudSAMLLogEntry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.serverTime = "";
                object.direction = "";
                object.messageType = "";
                object.messageIssued = "";
                object.fromEntityId = "";
                object.samlStatus = "";
                object.relayState = "";
                object.samlContent = "";
                object.isSigned = false;
                object.isOK = false;
            }
            if (message.serverTime != null && message.hasOwnProperty("serverTime"))
                object.serverTime = message.serverTime;
            if (message.direction != null && message.hasOwnProperty("direction"))
                object.direction = message.direction;
            if (message.messageType != null && message.hasOwnProperty("messageType"))
                object.messageType = message.messageType;
            if (message.messageIssued != null && message.hasOwnProperty("messageIssued"))
                object.messageIssued = message.messageIssued;
            if (message.fromEntityId != null && message.hasOwnProperty("fromEntityId"))
                object.fromEntityId = message.fromEntityId;
            if (message.samlStatus != null && message.hasOwnProperty("samlStatus"))
                object.samlStatus = message.samlStatus;
            if (message.relayState != null && message.hasOwnProperty("relayState"))
                object.relayState = message.relayState;
            if (message.samlContent != null && message.hasOwnProperty("samlContent"))
                object.samlContent = message.samlContent;
            if (message.isSigned != null && message.hasOwnProperty("isSigned"))
                object.isSigned = message.isSigned;
            if (message.isOK != null && message.hasOwnProperty("isOK"))
                object.isOK = message.isOK;
            return object;
        };

        /**
         * Converts this SsoCloudSAMLLogEntry to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudSAMLLogEntry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudSAMLLogEntry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudSAMLLogEntry;
    })();

    SsoCloud.SsoCloudSAMLLogResponse = (function() {

        /**
         * Properties of a SsoCloudSAMLLogResponse.
         * @memberof SsoCloud
         * @interface ISsoCloudSAMLLogResponse
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudSAMLLogResponse ssoServiceProviderId
         * @property {Array.<SsoCloud.ISsoCloudSAMLLogEntry>|null} [entry] SsoCloudSAMLLogResponse entry
         */

        /**
         * Constructs a new SsoCloudSAMLLogResponse.
         * @memberof SsoCloud
         * @classdesc This represents an array of SAML responses from the log.
         * @implements ISsoCloudSAMLLogResponse
         * @constructor
         * @param {SsoCloud.ISsoCloudSAMLLogResponse=} [properties] Properties to set
         */
        function SsoCloudSAMLLogResponse(properties) {
            this.entry = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudSAMLLogResponse ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @instance
         */
        SsoCloudSAMLLogResponse.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudSAMLLogResponse entry.
         * @member {Array.<SsoCloud.ISsoCloudSAMLLogEntry>} entry
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @instance
         */
        SsoCloudSAMLLogResponse.prototype.entry = $util.emptyArray;

        /**
         * Creates a new SsoCloudSAMLLogResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudSAMLLogResponse} SsoCloudSAMLLogResponse instance
         */
        SsoCloudSAMLLogResponse.create = function create(properties) {
            return new SsoCloudSAMLLogResponse(properties);
        };

        /**
         * Encodes the specified SsoCloudSAMLLogResponse message. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogResponse} message SsoCloudSAMLLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            if (message.entry != null && message.entry.length)
                for (let i = 0; i < message.entry.length; ++i)
                    $root.SsoCloud.SsoCloudSAMLLogEntry.encode(message.entry[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SsoCloudSAMLLogResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudSAMLLogResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {SsoCloud.ISsoCloudSAMLLogResponse} message SsoCloudSAMLLogResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudSAMLLogResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudSAMLLogResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudSAMLLogResponse} SsoCloudSAMLLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudSAMLLogResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                case 2:
                    if (!(message.entry && message.entry.length))
                        message.entry = [];
                    message.entry.push($root.SsoCloud.SsoCloudSAMLLogEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudSAMLLogResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudSAMLLogResponse} SsoCloudSAMLLogResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudSAMLLogResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudSAMLLogResponse message.
         * @function verify
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudSAMLLogResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.entry != null && message.hasOwnProperty("entry")) {
                if (!Array.isArray(message.entry))
                    return "entry: array expected";
                for (let i = 0; i < message.entry.length; ++i) {
                    let error = $root.SsoCloud.SsoCloudSAMLLogEntry.verify(message.entry[i]);
                    if (error)
                        return "entry." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SsoCloudSAMLLogResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudSAMLLogResponse} SsoCloudSAMLLogResponse
         */
        SsoCloudSAMLLogResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudSAMLLogResponse)
                return object;
            let message = new $root.SsoCloud.SsoCloudSAMLLogResponse();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            if (object.entry) {
                if (!Array.isArray(object.entry))
                    throw TypeError(".SsoCloud.SsoCloudSAMLLogResponse.entry: array expected");
                message.entry = [];
                for (let i = 0; i < object.entry.length; ++i) {
                    if (typeof object.entry[i] !== "object")
                        throw TypeError(".SsoCloud.SsoCloudSAMLLogResponse.entry: object expected");
                    message.entry[i] = $root.SsoCloud.SsoCloudSAMLLogEntry.fromObject(object.entry[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudSAMLLogResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @static
         * @param {SsoCloud.SsoCloudSAMLLogResponse} message SsoCloudSAMLLogResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudSAMLLogResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.entry = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            if (message.entry && message.entry.length) {
                object.entry = [];
                for (let j = 0; j < message.entry.length; ++j)
                    object.entry[j] = $root.SsoCloud.SsoCloudSAMLLogEntry.toObject(message.entry[j], options);
            }
            return object;
        };

        /**
         * Converts this SsoCloudSAMLLogResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudSAMLLogResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudSAMLLogResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudSAMLLogResponse;
    })();

    SsoCloud.SsoCloudServiceProviderUpdateRequest = (function() {

        /**
         * Properties of a SsoCloudServiceProviderUpdateRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudServiceProviderUpdateRequest
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudServiceProviderUpdateRequest ssoServiceProviderId
         * @property {number|Long|null} [ssoSpConfigurationId] SsoCloudServiceProviderUpdateRequest ssoSpConfigurationId
         */

        /**
         * Constructs a new SsoCloudServiceProviderUpdateRequest.
         * @memberof SsoCloud
         * @classdesc This is a request to set the SSO Configuration for an SSO Service Provider, by ID.
         * The response is an instance of SsoCloudConfigurationRequest.
         * @implements ISsoCloudServiceProviderUpdateRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudServiceProviderUpdateRequest=} [properties] Properties to set
         */
        function SsoCloudServiceProviderUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudServiceProviderUpdateRequest ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @instance
         */
        SsoCloudServiceProviderUpdateRequest.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudServiceProviderUpdateRequest ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @instance
         */
        SsoCloudServiceProviderUpdateRequest.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SsoCloudServiceProviderUpdateRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderUpdateRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudServiceProviderUpdateRequest} SsoCloudServiceProviderUpdateRequest instance
         */
        SsoCloudServiceProviderUpdateRequest.create = function create(properties) {
            return new SsoCloudServiceProviderUpdateRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudServiceProviderUpdateRequest message. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderUpdateRequest} message SsoCloudServiceProviderUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ssoSpConfigurationId);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudServiceProviderUpdateRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderUpdateRequest} message SsoCloudServiceProviderUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudServiceProviderUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudServiceProviderUpdateRequest} SsoCloudServiceProviderUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudServiceProviderUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                case 2:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudServiceProviderUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudServiceProviderUpdateRequest} SsoCloudServiceProviderUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudServiceProviderUpdateRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudServiceProviderUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            return null;
        };

        /**
         * Creates a SsoCloudServiceProviderUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudServiceProviderUpdateRequest} SsoCloudServiceProviderUpdateRequest
         */
        SsoCloudServiceProviderUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudServiceProviderUpdateRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudServiceProviderUpdateRequest();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudServiceProviderUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @static
         * @param {SsoCloud.SsoCloudServiceProviderUpdateRequest} message SsoCloudServiceProviderUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudServiceProviderUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
            }
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            return object;
        };

        /**
         * Converts this SsoCloudServiceProviderUpdateRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudServiceProviderUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudServiceProviderUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudServiceProviderUpdateRequest;
    })();

    SsoCloud.SsoCloudIdpMetadataRequest = (function() {

        /**
         * Properties of a SsoCloudIdpMetadataRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudIdpMetadataRequest
         * @property {number|Long|null} [ssoSpConfigurationId] SsoCloudIdpMetadataRequest ssoSpConfigurationId
         * @property {string|null} [filename] SsoCloudIdpMetadataRequest filename
         * @property {Uint8Array|null} [content] SsoCloudIdpMetadataRequest content
         */

        /**
         * Constructs a new SsoCloudIdpMetadataRequest.
         * @memberof SsoCloud
         * @classdesc This request is to upload the IdP metadata file as its UTF-8 byte content.
         * The response is an SsoCloudConfigurationValidationResponse.
         * @implements ISsoCloudIdpMetadataRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudIdpMetadataRequest=} [properties] Properties to set
         */
        function SsoCloudIdpMetadataRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudIdpMetadataRequest ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @instance
         */
        SsoCloudIdpMetadataRequest.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudIdpMetadataRequest filename.
         * @member {string} filename
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @instance
         */
        SsoCloudIdpMetadataRequest.prototype.filename = "";

        /**
         * SsoCloudIdpMetadataRequest content.
         * @member {Uint8Array} content
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @instance
         */
        SsoCloudIdpMetadataRequest.prototype.content = $util.newBuffer([]);

        /**
         * Creates a new SsoCloudIdpMetadataRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {SsoCloud.ISsoCloudIdpMetadataRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudIdpMetadataRequest} SsoCloudIdpMetadataRequest instance
         */
        SsoCloudIdpMetadataRequest.create = function create(properties) {
            return new SsoCloudIdpMetadataRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudIdpMetadataRequest message. Does not implicitly {@link SsoCloud.SsoCloudIdpMetadataRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {SsoCloud.ISsoCloudIdpMetadataRequest} message SsoCloudIdpMetadataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudIdpMetadataRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoSpConfigurationId);
            if (message.filename != null && message.hasOwnProperty("filename"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.filename);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.content);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudIdpMetadataRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudIdpMetadataRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {SsoCloud.ISsoCloudIdpMetadataRequest} message SsoCloudIdpMetadataRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudIdpMetadataRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudIdpMetadataRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudIdpMetadataRequest} SsoCloudIdpMetadataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudIdpMetadataRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudIdpMetadataRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                case 2:
                    message.filename = reader.string();
                    break;
                case 3:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudIdpMetadataRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudIdpMetadataRequest} SsoCloudIdpMetadataRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudIdpMetadataRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudIdpMetadataRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudIdpMetadataRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            if (message.filename != null && message.hasOwnProperty("filename"))
                if (!$util.isString(message.filename))
                    return "filename: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                    return "content: buffer expected";
            return null;
        };

        /**
         * Creates a SsoCloudIdpMetadataRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudIdpMetadataRequest} SsoCloudIdpMetadataRequest
         */
        SsoCloudIdpMetadataRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudIdpMetadataRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudIdpMetadataRequest();
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            if (object.filename != null)
                message.filename = String(object.filename);
            if (object.content != null)
                if (typeof object.content === "string")
                    $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                else if (object.content.length)
                    message.content = object.content;
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudIdpMetadataRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @static
         * @param {SsoCloud.SsoCloudIdpMetadataRequest} message SsoCloudIdpMetadataRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudIdpMetadataRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
                object.filename = "";
                if (options.bytes === String)
                    object.content = "";
                else {
                    object.content = [];
                    if (options.bytes !== Array)
                        object.content = $util.newBuffer(object.content);
                }
            }
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            if (message.filename != null && message.hasOwnProperty("filename"))
                object.filename = message.filename;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
            return object;
        };

        /**
         * Converts this SsoCloudIdpMetadataRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudIdpMetadataRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudIdpMetadataRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudIdpMetadataRequest;
    })();

    SsoCloud.SsoCloudConfigurationValidationRequest = (function() {

        /**
         * Properties of a SsoCloudConfigurationValidationRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudConfigurationValidationRequest
         * @property {Array.<number|Long>|null} [ssoSpConfigurationId] SsoCloudConfigurationValidationRequest ssoSpConfigurationId
         */

        /**
         * Constructs a new SsoCloudConfigurationValidationRequest.
         * @memberof SsoCloud
         * @classdesc Request validation of one or more SsoCloudConfigurations.
         * The response is SsoCloudConfigurationValidationResponse.
         * @implements ISsoCloudConfigurationValidationRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudConfigurationValidationRequest=} [properties] Properties to set
         */
        function SsoCloudConfigurationValidationRequest(properties) {
            this.ssoSpConfigurationId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudConfigurationValidationRequest ssoSpConfigurationId.
         * @member {Array.<number|Long>} ssoSpConfigurationId
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @instance
         */
        SsoCloudConfigurationValidationRequest.prototype.ssoSpConfigurationId = $util.emptyArray;

        /**
         * Creates a new SsoCloudConfigurationValidationRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudConfigurationValidationRequest} SsoCloudConfigurationValidationRequest instance
         */
        SsoCloudConfigurationValidationRequest.create = function create(properties) {
            return new SsoCloudConfigurationValidationRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudConfigurationValidationRequest message. Does not implicitly {@link SsoCloud.SsoCloudConfigurationValidationRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationRequest} message SsoCloudConfigurationValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationValidationRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoSpConfigurationId != null && message.ssoSpConfigurationId.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (let i = 0; i < message.ssoSpConfigurationId.length; ++i)
                    writer.uint64(message.ssoSpConfigurationId[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SsoCloudConfigurationValidationRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudConfigurationValidationRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationRequest} message SsoCloudConfigurationValidationRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationValidationRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudConfigurationValidationRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudConfigurationValidationRequest} SsoCloudConfigurationValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationValidationRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudConfigurationValidationRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ssoSpConfigurationId && message.ssoSpConfigurationId.length))
                        message.ssoSpConfigurationId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ssoSpConfigurationId.push(reader.uint64());
                    } else
                        message.ssoSpConfigurationId.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudConfigurationValidationRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudConfigurationValidationRequest} SsoCloudConfigurationValidationRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationValidationRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudConfigurationValidationRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudConfigurationValidationRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId")) {
                if (!Array.isArray(message.ssoSpConfigurationId))
                    return "ssoSpConfigurationId: array expected";
                for (let i = 0; i < message.ssoSpConfigurationId.length; ++i)
                    if (!$util.isInteger(message.ssoSpConfigurationId[i]) && !(message.ssoSpConfigurationId[i] && $util.isInteger(message.ssoSpConfigurationId[i].low) && $util.isInteger(message.ssoSpConfigurationId[i].high)))
                        return "ssoSpConfigurationId: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a SsoCloudConfigurationValidationRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudConfigurationValidationRequest} SsoCloudConfigurationValidationRequest
         */
        SsoCloudConfigurationValidationRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudConfigurationValidationRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudConfigurationValidationRequest();
            if (object.ssoSpConfigurationId) {
                if (!Array.isArray(object.ssoSpConfigurationId))
                    throw TypeError(".SsoCloud.SsoCloudConfigurationValidationRequest.ssoSpConfigurationId: array expected");
                message.ssoSpConfigurationId = [];
                for (let i = 0; i < object.ssoSpConfigurationId.length; ++i)
                    if ($util.Long)
                        (message.ssoSpConfigurationId[i] = $util.Long.fromValue(object.ssoSpConfigurationId[i])).unsigned = true;
                    else if (typeof object.ssoSpConfigurationId[i] === "string")
                        message.ssoSpConfigurationId[i] = parseInt(object.ssoSpConfigurationId[i], 10);
                    else if (typeof object.ssoSpConfigurationId[i] === "number")
                        message.ssoSpConfigurationId[i] = object.ssoSpConfigurationId[i];
                    else if (typeof object.ssoSpConfigurationId[i] === "object")
                        message.ssoSpConfigurationId[i] = new $util.LongBits(object.ssoSpConfigurationId[i].low >>> 0, object.ssoSpConfigurationId[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudConfigurationValidationRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @static
         * @param {SsoCloud.SsoCloudConfigurationValidationRequest} message SsoCloudConfigurationValidationRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudConfigurationValidationRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ssoSpConfigurationId = [];
            if (message.ssoSpConfigurationId && message.ssoSpConfigurationId.length) {
                object.ssoSpConfigurationId = [];
                for (let j = 0; j < message.ssoSpConfigurationId.length; ++j)
                    if (typeof message.ssoSpConfigurationId[j] === "number")
                        object.ssoSpConfigurationId[j] = options.longs === String ? String(message.ssoSpConfigurationId[j]) : message.ssoSpConfigurationId[j];
                    else
                        object.ssoSpConfigurationId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId[j]) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId[j].low >>> 0, message.ssoSpConfigurationId[j].high >>> 0).toNumber(true) : message.ssoSpConfigurationId[j];
            }
            return object;
        };

        /**
         * Converts this SsoCloudConfigurationValidationRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudConfigurationValidationRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudConfigurationValidationRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudConfigurationValidationRequest;
    })();

    SsoCloud.ValidationContent = (function() {

        /**
         * Properties of a ValidationContent.
         * @memberof SsoCloud
         * @interface IValidationContent
         * @property {number|Long|null} [ssoSpConfigurationId] ValidationContent ssoSpConfigurationId
         * @property {boolean|null} [isSuccessful] ValidationContent isSuccessful
         * @property {Array.<string>|null} [errorMessage] ValidationContent errorMessage
         */

        /**
         * Constructs a new ValidationContent.
         * @memberof SsoCloud
         * @classdesc This is part of SsoCloudConfigurationValidationResponse.
         * @implements IValidationContent
         * @constructor
         * @param {SsoCloud.IValidationContent=} [properties] Properties to set
         */
        function ValidationContent(properties) {
            this.errorMessage = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValidationContent ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.ValidationContent
         * @instance
         */
        ValidationContent.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ValidationContent isSuccessful.
         * @member {boolean} isSuccessful
         * @memberof SsoCloud.ValidationContent
         * @instance
         */
        ValidationContent.prototype.isSuccessful = false;

        /**
         * ValidationContent errorMessage.
         * @member {Array.<string>} errorMessage
         * @memberof SsoCloud.ValidationContent
         * @instance
         */
        ValidationContent.prototype.errorMessage = $util.emptyArray;

        /**
         * Creates a new ValidationContent instance using the specified properties.
         * @function create
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {SsoCloud.IValidationContent=} [properties] Properties to set
         * @returns {SsoCloud.ValidationContent} ValidationContent instance
         */
        ValidationContent.create = function create(properties) {
            return new ValidationContent(properties);
        };

        /**
         * Encodes the specified ValidationContent message. Does not implicitly {@link SsoCloud.ValidationContent.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {SsoCloud.IValidationContent} message ValidationContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationContent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoSpConfigurationId);
            if (message.isSuccessful != null && message.hasOwnProperty("isSuccessful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isSuccessful);
            if (message.errorMessage != null && message.errorMessage.length)
                for (let i = 0; i < message.errorMessage.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.errorMessage[i]);
            return writer;
        };

        /**
         * Encodes the specified ValidationContent message, length delimited. Does not implicitly {@link SsoCloud.ValidationContent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {SsoCloud.IValidationContent} message ValidationContent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValidationContent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValidationContent message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.ValidationContent} ValidationContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationContent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.ValidationContent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                case 2:
                    message.isSuccessful = reader.bool();
                    break;
                case 3:
                    if (!(message.errorMessage && message.errorMessage.length))
                        message.errorMessage = [];
                    message.errorMessage.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValidationContent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.ValidationContent} ValidationContent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValidationContent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValidationContent message.
         * @function verify
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValidationContent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            if (message.isSuccessful != null && message.hasOwnProperty("isSuccessful"))
                if (typeof message.isSuccessful !== "boolean")
                    return "isSuccessful: boolean expected";
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage")) {
                if (!Array.isArray(message.errorMessage))
                    return "errorMessage: array expected";
                for (let i = 0; i < message.errorMessage.length; ++i)
                    if (!$util.isString(message.errorMessage[i]))
                        return "errorMessage: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ValidationContent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.ValidationContent} ValidationContent
         */
        ValidationContent.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.ValidationContent)
                return object;
            let message = new $root.SsoCloud.ValidationContent();
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            if (object.isSuccessful != null)
                message.isSuccessful = Boolean(object.isSuccessful);
            if (object.errorMessage) {
                if (!Array.isArray(object.errorMessage))
                    throw TypeError(".SsoCloud.ValidationContent.errorMessage: array expected");
                message.errorMessage = [];
                for (let i = 0; i < object.errorMessage.length; ++i)
                    message.errorMessage[i] = String(object.errorMessage[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ValidationContent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.ValidationContent
         * @static
         * @param {SsoCloud.ValidationContent} message ValidationContent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValidationContent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.errorMessage = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
                object.isSuccessful = false;
            }
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            if (message.isSuccessful != null && message.hasOwnProperty("isSuccessful"))
                object.isSuccessful = message.isSuccessful;
            if (message.errorMessage && message.errorMessage.length) {
                object.errorMessage = [];
                for (let j = 0; j < message.errorMessage.length; ++j)
                    object.errorMessage[j] = message.errorMessage[j];
            }
            return object;
        };

        /**
         * Converts this ValidationContent to JSON.
         * @function toJSON
         * @memberof SsoCloud.ValidationContent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValidationContent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValidationContent;
    })();

    SsoCloud.SsoCloudConfigurationValidationResponse = (function() {

        /**
         * Properties of a SsoCloudConfigurationValidationResponse.
         * @memberof SsoCloud
         * @interface ISsoCloudConfigurationValidationResponse
         * @property {Array.<SsoCloud.IValidationContent>|null} [validationContent] SsoCloudConfigurationValidationResponse validationContent
         */

        /**
         * Constructs a new SsoCloudConfigurationValidationResponse.
         * @memberof SsoCloud
         * @classdesc This response is sent for a configuration validation request and for a Metadata upload request.
         * @implements ISsoCloudConfigurationValidationResponse
         * @constructor
         * @param {SsoCloud.ISsoCloudConfigurationValidationResponse=} [properties] Properties to set
         */
        function SsoCloudConfigurationValidationResponse(properties) {
            this.validationContent = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudConfigurationValidationResponse validationContent.
         * @member {Array.<SsoCloud.IValidationContent>} validationContent
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @instance
         */
        SsoCloudConfigurationValidationResponse.prototype.validationContent = $util.emptyArray;

        /**
         * Creates a new SsoCloudConfigurationValidationResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudConfigurationValidationResponse} SsoCloudConfigurationValidationResponse instance
         */
        SsoCloudConfigurationValidationResponse.create = function create(properties) {
            return new SsoCloudConfigurationValidationResponse(properties);
        };

        /**
         * Encodes the specified SsoCloudConfigurationValidationResponse message. Does not implicitly {@link SsoCloud.SsoCloudConfigurationValidationResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationResponse} message SsoCloudConfigurationValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationValidationResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.validationContent != null && message.validationContent.length)
                for (let i = 0; i < message.validationContent.length; ++i)
                    $root.SsoCloud.ValidationContent.encode(message.validationContent[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SsoCloudConfigurationValidationResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudConfigurationValidationResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {SsoCloud.ISsoCloudConfigurationValidationResponse} message SsoCloudConfigurationValidationResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudConfigurationValidationResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudConfigurationValidationResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudConfigurationValidationResponse} SsoCloudConfigurationValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationValidationResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudConfigurationValidationResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.validationContent && message.validationContent.length))
                        message.validationContent = [];
                    message.validationContent.push($root.SsoCloud.ValidationContent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudConfigurationValidationResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudConfigurationValidationResponse} SsoCloudConfigurationValidationResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudConfigurationValidationResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudConfigurationValidationResponse message.
         * @function verify
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudConfigurationValidationResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.validationContent != null && message.hasOwnProperty("validationContent")) {
                if (!Array.isArray(message.validationContent))
                    return "validationContent: array expected";
                for (let i = 0; i < message.validationContent.length; ++i) {
                    let error = $root.SsoCloud.ValidationContent.verify(message.validationContent[i]);
                    if (error)
                        return "validationContent." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SsoCloudConfigurationValidationResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudConfigurationValidationResponse} SsoCloudConfigurationValidationResponse
         */
        SsoCloudConfigurationValidationResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudConfigurationValidationResponse)
                return object;
            let message = new $root.SsoCloud.SsoCloudConfigurationValidationResponse();
            if (object.validationContent) {
                if (!Array.isArray(object.validationContent))
                    throw TypeError(".SsoCloud.SsoCloudConfigurationValidationResponse.validationContent: array expected");
                message.validationContent = [];
                for (let i = 0; i < object.validationContent.length; ++i) {
                    if (typeof object.validationContent[i] !== "object")
                        throw TypeError(".SsoCloud.SsoCloudConfigurationValidationResponse.validationContent: object expected");
                    message.validationContent[i] = $root.SsoCloud.ValidationContent.fromObject(object.validationContent[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudConfigurationValidationResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @static
         * @param {SsoCloud.SsoCloudConfigurationValidationResponse} message SsoCloudConfigurationValidationResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudConfigurationValidationResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.validationContent = [];
            if (message.validationContent && message.validationContent.length) {
                object.validationContent = [];
                for (let j = 0; j < message.validationContent.length; ++j)
                    object.validationContent[j] = $root.SsoCloud.ValidationContent.toObject(message.validationContent[j], options);
            }
            return object;
        };

        /**
         * Converts this SsoCloudConfigurationValidationResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudConfigurationValidationResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudConfigurationValidationResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudConfigurationValidationResponse;
    })();

    SsoCloud.SsoCloudServiceProviderConfigurationListRequest = (function() {

        /**
         * Properties of a SsoCloudServiceProviderConfigurationListRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudServiceProviderConfigurationListRequest
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudServiceProviderConfigurationListRequest ssoServiceProviderId
         */

        /**
         * Constructs a new SsoCloudServiceProviderConfigurationListRequest.
         * @memberof SsoCloud
         * @classdesc This request is sent to retrieve the list of configurations availble to a service provider.
         * @implements ISsoCloudServiceProviderConfigurationListRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListRequest=} [properties] Properties to set
         */
        function SsoCloudServiceProviderConfigurationListRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudServiceProviderConfigurationListRequest ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @instance
         */
        SsoCloudServiceProviderConfigurationListRequest.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SsoCloudServiceProviderConfigurationListRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListRequest} SsoCloudServiceProviderConfigurationListRequest instance
         */
        SsoCloudServiceProviderConfigurationListRequest.create = function create(properties) {
            return new SsoCloudServiceProviderConfigurationListRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudServiceProviderConfigurationListRequest message. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderConfigurationListRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListRequest} message SsoCloudServiceProviderConfigurationListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderConfigurationListRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudServiceProviderConfigurationListRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderConfigurationListRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListRequest} message SsoCloudServiceProviderConfigurationListRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderConfigurationListRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudServiceProviderConfigurationListRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListRequest} SsoCloudServiceProviderConfigurationListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderConfigurationListRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudServiceProviderConfigurationListRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudServiceProviderConfigurationListRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListRequest} SsoCloudServiceProviderConfigurationListRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderConfigurationListRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudServiceProviderConfigurationListRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudServiceProviderConfigurationListRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            return null;
        };

        /**
         * Creates a SsoCloudServiceProviderConfigurationListRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListRequest} SsoCloudServiceProviderConfigurationListRequest
         */
        SsoCloudServiceProviderConfigurationListRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudServiceProviderConfigurationListRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudServiceProviderConfigurationListRequest();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudServiceProviderConfigurationListRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @static
         * @param {SsoCloud.SsoCloudServiceProviderConfigurationListRequest} message SsoCloudServiceProviderConfigurationListRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudServiceProviderConfigurationListRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            return object;
        };

        /**
         * Converts this SsoCloudServiceProviderConfigurationListRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudServiceProviderConfigurationListRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudServiceProviderConfigurationListRequest;
    })();

    SsoCloud.ConfigurationListItem = (function() {

        /**
         * Properties of a ConfigurationListItem.
         * @memberof SsoCloud
         * @interface IConfigurationListItem
         * @property {number|Long|null} [ssoSpConfigurationId] ConfigurationListItem ssoSpConfigurationId
         * @property {string|null} [name] ConfigurationListItem name
         * @property {boolean|null} [isSelected] ConfigurationListItem isSelected
         */

        /**
         * Constructs a new ConfigurationListItem.
         * @memberof SsoCloud
         * @classdesc This represents one configuration in the list.
         * If isSelected is true this configuration is the one currently being used.
         * @implements IConfigurationListItem
         * @constructor
         * @param {SsoCloud.IConfigurationListItem=} [properties] Properties to set
         */
        function ConfigurationListItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfigurationListItem ssoSpConfigurationId.
         * @member {number|Long} ssoSpConfigurationId
         * @memberof SsoCloud.ConfigurationListItem
         * @instance
         */
        ConfigurationListItem.prototype.ssoSpConfigurationId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ConfigurationListItem name.
         * @member {string} name
         * @memberof SsoCloud.ConfigurationListItem
         * @instance
         */
        ConfigurationListItem.prototype.name = "";

        /**
         * ConfigurationListItem isSelected.
         * @member {boolean} isSelected
         * @memberof SsoCloud.ConfigurationListItem
         * @instance
         */
        ConfigurationListItem.prototype.isSelected = false;

        /**
         * Creates a new ConfigurationListItem instance using the specified properties.
         * @function create
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {SsoCloud.IConfigurationListItem=} [properties] Properties to set
         * @returns {SsoCloud.ConfigurationListItem} ConfigurationListItem instance
         */
        ConfigurationListItem.create = function create(properties) {
            return new ConfigurationListItem(properties);
        };

        /**
         * Encodes the specified ConfigurationListItem message. Does not implicitly {@link SsoCloud.ConfigurationListItem.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {SsoCloud.IConfigurationListItem} message ConfigurationListItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigurationListItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoSpConfigurationId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isSelected);
            return writer;
        };

        /**
         * Encodes the specified ConfigurationListItem message, length delimited. Does not implicitly {@link SsoCloud.ConfigurationListItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {SsoCloud.IConfigurationListItem} message ConfigurationListItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfigurationListItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfigurationListItem message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.ConfigurationListItem} ConfigurationListItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigurationListItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.ConfigurationListItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoSpConfigurationId = reader.uint64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.isSelected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfigurationListItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.ConfigurationListItem} ConfigurationListItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfigurationListItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfigurationListItem message.
         * @function verify
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfigurationListItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (!$util.isInteger(message.ssoSpConfigurationId) && !(message.ssoSpConfigurationId && $util.isInteger(message.ssoSpConfigurationId.low) && $util.isInteger(message.ssoSpConfigurationId.high)))
                    return "ssoSpConfigurationId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                if (typeof message.isSelected !== "boolean")
                    return "isSelected: boolean expected";
            return null;
        };

        /**
         * Creates a ConfigurationListItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.ConfigurationListItem} ConfigurationListItem
         */
        ConfigurationListItem.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.ConfigurationListItem)
                return object;
            let message = new $root.SsoCloud.ConfigurationListItem();
            if (object.ssoSpConfigurationId != null)
                if ($util.Long)
                    (message.ssoSpConfigurationId = $util.Long.fromValue(object.ssoSpConfigurationId)).unsigned = true;
                else if (typeof object.ssoSpConfigurationId === "string")
                    message.ssoSpConfigurationId = parseInt(object.ssoSpConfigurationId, 10);
                else if (typeof object.ssoSpConfigurationId === "number")
                    message.ssoSpConfigurationId = object.ssoSpConfigurationId;
                else if (typeof object.ssoSpConfigurationId === "object")
                    message.ssoSpConfigurationId = new $util.LongBits(object.ssoSpConfigurationId.low >>> 0, object.ssoSpConfigurationId.high >>> 0).toNumber(true);
            if (object.name != null)
                message.name = String(object.name);
            if (object.isSelected != null)
                message.isSelected = Boolean(object.isSelected);
            return message;
        };

        /**
         * Creates a plain object from a ConfigurationListItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.ConfigurationListItem
         * @static
         * @param {SsoCloud.ConfigurationListItem} message ConfigurationListItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfigurationListItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoSpConfigurationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoSpConfigurationId = options.longs === String ? "0" : 0;
                object.name = "";
                object.isSelected = false;
            }
            if (message.ssoSpConfigurationId != null && message.hasOwnProperty("ssoSpConfigurationId"))
                if (typeof message.ssoSpConfigurationId === "number")
                    object.ssoSpConfigurationId = options.longs === String ? String(message.ssoSpConfigurationId) : message.ssoSpConfigurationId;
                else
                    object.ssoSpConfigurationId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoSpConfigurationId) : options.longs === Number ? new $util.LongBits(message.ssoSpConfigurationId.low >>> 0, message.ssoSpConfigurationId.high >>> 0).toNumber(true) : message.ssoSpConfigurationId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.isSelected != null && message.hasOwnProperty("isSelected"))
                object.isSelected = message.isSelected;
            return object;
        };

        /**
         * Converts this ConfigurationListItem to JSON.
         * @function toJSON
         * @memberof SsoCloud.ConfigurationListItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfigurationListItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfigurationListItem;
    })();

    SsoCloud.SsoCloudServiceProviderConfigurationListResponse = (function() {

        /**
         * Properties of a SsoCloudServiceProviderConfigurationListResponse.
         * @memberof SsoCloud
         * @interface ISsoCloudServiceProviderConfigurationListResponse
         * @property {Array.<SsoCloud.IConfigurationListItem>|null} [configurationItem] SsoCloudServiceProviderConfigurationListResponse configurationItem
         */

        /**
         * Constructs a new SsoCloudServiceProviderConfigurationListResponse.
         * @memberof SsoCloud
         * @classdesc This represents a list of Configuration entries.
         * @implements ISsoCloudServiceProviderConfigurationListResponse
         * @constructor
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListResponse=} [properties] Properties to set
         */
        function SsoCloudServiceProviderConfigurationListResponse(properties) {
            this.configurationItem = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudServiceProviderConfigurationListResponse configurationItem.
         * @member {Array.<SsoCloud.IConfigurationListItem>} configurationItem
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @instance
         */
        SsoCloudServiceProviderConfigurationListResponse.prototype.configurationItem = $util.emptyArray;

        /**
         * Creates a new SsoCloudServiceProviderConfigurationListResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListResponse} SsoCloudServiceProviderConfigurationListResponse instance
         */
        SsoCloudServiceProviderConfigurationListResponse.create = function create(properties) {
            return new SsoCloudServiceProviderConfigurationListResponse(properties);
        };

        /**
         * Encodes the specified SsoCloudServiceProviderConfigurationListResponse message. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderConfigurationListResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListResponse} message SsoCloudServiceProviderConfigurationListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderConfigurationListResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.configurationItem != null && message.configurationItem.length)
                for (let i = 0; i < message.configurationItem.length; ++i)
                    $root.SsoCloud.ConfigurationListItem.encode(message.configurationItem[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SsoCloudServiceProviderConfigurationListResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudServiceProviderConfigurationListResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {SsoCloud.ISsoCloudServiceProviderConfigurationListResponse} message SsoCloudServiceProviderConfigurationListResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudServiceProviderConfigurationListResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudServiceProviderConfigurationListResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListResponse} SsoCloudServiceProviderConfigurationListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderConfigurationListResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudServiceProviderConfigurationListResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.configurationItem && message.configurationItem.length))
                        message.configurationItem = [];
                    message.configurationItem.push($root.SsoCloud.ConfigurationListItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudServiceProviderConfigurationListResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListResponse} SsoCloudServiceProviderConfigurationListResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudServiceProviderConfigurationListResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudServiceProviderConfigurationListResponse message.
         * @function verify
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudServiceProviderConfigurationListResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.configurationItem != null && message.hasOwnProperty("configurationItem")) {
                if (!Array.isArray(message.configurationItem))
                    return "configurationItem: array expected";
                for (let i = 0; i < message.configurationItem.length; ++i) {
                    let error = $root.SsoCloud.ConfigurationListItem.verify(message.configurationItem[i]);
                    if (error)
                        return "configurationItem." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SsoCloudServiceProviderConfigurationListResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudServiceProviderConfigurationListResponse} SsoCloudServiceProviderConfigurationListResponse
         */
        SsoCloudServiceProviderConfigurationListResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudServiceProviderConfigurationListResponse)
                return object;
            let message = new $root.SsoCloud.SsoCloudServiceProviderConfigurationListResponse();
            if (object.configurationItem) {
                if (!Array.isArray(object.configurationItem))
                    throw TypeError(".SsoCloud.SsoCloudServiceProviderConfigurationListResponse.configurationItem: array expected");
                message.configurationItem = [];
                for (let i = 0; i < object.configurationItem.length; ++i) {
                    if (typeof object.configurationItem[i] !== "object")
                        throw TypeError(".SsoCloud.SsoCloudServiceProviderConfigurationListResponse.configurationItem: object expected");
                    message.configurationItem[i] = $root.SsoCloud.ConfigurationListItem.fromObject(object.configurationItem[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudServiceProviderConfigurationListResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @static
         * @param {SsoCloud.SsoCloudServiceProviderConfigurationListResponse} message SsoCloudServiceProviderConfigurationListResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudServiceProviderConfigurationListResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.configurationItem = [];
            if (message.configurationItem && message.configurationItem.length) {
                object.configurationItem = [];
                for (let j = 0; j < message.configurationItem.length; ++j)
                    object.configurationItem[j] = $root.SsoCloud.ConfigurationListItem.toObject(message.configurationItem[j], options);
            }
            return object;
        };

        /**
         * Converts this SsoCloudServiceProviderConfigurationListResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudServiceProviderConfigurationListResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudServiceProviderConfigurationListResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudServiceProviderConfigurationListResponse;
    })();

    SsoCloud.SsoCloudRequest = (function() {

        /**
         * Properties of a SsoCloudRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudRequest
         * @property {Uint8Array|null} [messageSessionUid] SsoCloudRequest messageSessionUid
         * @property {string|null} [clientVersion] SsoCloudRequest clientVersion
         * @property {boolean|null} [embedded] SsoCloudRequest embedded
         * @property {boolean|null} [json] SsoCloudRequest json
         * @property {string|null} [dest] SsoCloudRequest dest
         * @property {string|null} [idpSessionId] SsoCloudRequest idpSessionId
         * @property {boolean|null} [forceLogin] SsoCloudRequest forceLogin
         * @property {string|null} [username] SsoCloudRequest username
         */

        /**
         * Constructs a new SsoCloudRequest.
         * @memberof SsoCloud
         * @classdesc For security, this structure is used to make a Cloud SSO login or logout request rather than sending the parameters in the URL or in a form.
         * A typical call is: https://www.keepersecurity.com/api/rest/sso/saml/login/123456789?payload=encodedEncryptedAPIRequestContainingAnSsoCloudRequest
         * @implements ISsoCloudRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudRequest=} [properties] Properties to set
         */
        function SsoCloudRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudRequest messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * SsoCloudRequest clientVersion.
         * @member {string} clientVersion
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.clientVersion = "";

        /**
         * SsoCloudRequest embedded.
         * @member {boolean} embedded
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.embedded = false;

        /**
         * SsoCloudRequest json.
         * @member {boolean} json
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.json = false;

        /**
         * SsoCloudRequest dest.
         * @member {string} dest
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.dest = "";

        /**
         * SsoCloudRequest idpSessionId.
         * @member {string} idpSessionId
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.idpSessionId = "";

        /**
         * SsoCloudRequest forceLogin.
         * @member {boolean} forceLogin
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.forceLogin = false;

        /**
         * SsoCloudRequest username.
         * @member {string} username
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         */
        SsoCloudRequest.prototype.username = "";

        /**
         * Creates a new SsoCloudRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {SsoCloud.ISsoCloudRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudRequest} SsoCloudRequest instance
         */
        SsoCloudRequest.create = function create(properties) {
            return new SsoCloudRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudRequest message. Does not implicitly {@link SsoCloud.SsoCloudRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {SsoCloud.ISsoCloudRequest} message SsoCloudRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageSessionUid);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientVersion);
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.embedded);
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.json);
            if (message.dest != null && message.hasOwnProperty("dest"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.dest);
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.idpSessionId);
            if (message.forceLogin != null && message.hasOwnProperty("forceLogin"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.forceLogin);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.username);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {SsoCloud.ISsoCloudRequest} message SsoCloudRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudRequest} SsoCloudRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 2:
                    message.clientVersion = reader.string();
                    break;
                case 3:
                    message.embedded = reader.bool();
                    break;
                case 4:
                    message.json = reader.bool();
                    break;
                case 5:
                    message.dest = reader.string();
                    break;
                case 6:
                    message.idpSessionId = reader.string();
                    break;
                case 7:
                    message.forceLogin = reader.bool();
                    break;
                case 8:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudRequest} SsoCloudRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                if (typeof message.embedded !== "boolean")
                    return "embedded: boolean expected";
            if (message.json != null && message.hasOwnProperty("json"))
                if (typeof message.json !== "boolean")
                    return "json: boolean expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!$util.isString(message.dest))
                    return "dest: string expected";
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                if (!$util.isString(message.idpSessionId))
                    return "idpSessionId: string expected";
            if (message.forceLogin != null && message.hasOwnProperty("forceLogin"))
                if (typeof message.forceLogin !== "boolean")
                    return "forceLogin: boolean expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            return null;
        };

        /**
         * Creates a SsoCloudRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudRequest} SsoCloudRequest
         */
        SsoCloudRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudRequest();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.embedded != null)
                message.embedded = Boolean(object.embedded);
            if (object.json != null)
                message.json = Boolean(object.json);
            if (object.dest != null)
                message.dest = String(object.dest);
            if (object.idpSessionId != null)
                message.idpSessionId = String(object.idpSessionId);
            if (object.forceLogin != null)
                message.forceLogin = Boolean(object.forceLogin);
            if (object.username != null)
                message.username = String(object.username);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudRequest
         * @static
         * @param {SsoCloud.SsoCloudRequest} message SsoCloudRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.clientVersion = "";
                object.embedded = false;
                object.json = false;
                object.dest = "";
                object.idpSessionId = "";
                object.forceLogin = false;
                object.username = "";
            }
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                object.embedded = message.embedded;
            if (message.json != null && message.hasOwnProperty("json"))
                object.json = message.json;
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = message.dest;
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                object.idpSessionId = message.idpSessionId;
            if (message.forceLogin != null && message.hasOwnProperty("forceLogin"))
                object.forceLogin = message.forceLogin;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };

        /**
         * Converts this SsoCloudRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudRequest;
    })();

    SsoCloud.SsoCloudResponse = (function() {

        /**
         * Properties of a SsoCloudResponse.
         * @memberof SsoCloud
         * @interface ISsoCloudResponse
         * @property {string|null} [command] SsoCloudResponse command
         * @property {Uint8Array|null} [messageSessionUid] SsoCloudResponse messageSessionUid
         * @property {string|null} [email] SsoCloudResponse email
         * @property {Uint8Array|null} [encryptedLoginToken] SsoCloudResponse encryptedLoginToken
         * @property {string|null} [providerName] SsoCloudResponse providerName
         * @property {string|null} [idpSessionId] SsoCloudResponse idpSessionId
         * @property {Uint8Array|null} [encryptedSessionToken] SsoCloudResponse encryptedSessionToken
         * @property {string|null} [errorToken] SsoCloudResponse errorToken
         */

        /**
         * Constructs a new SsoCloudResponse.
         * @memberof SsoCloud
         * @classdesc For security, this structure is used to return values from a Cloud SSO login or logout.
         * It is encrypted with the key sent along with the SsoCloudRequest.
         * @implements ISsoCloudResponse
         * @constructor
         * @param {SsoCloud.ISsoCloudResponse=} [properties] Properties to set
         */
        function SsoCloudResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudResponse command.
         * @member {string} command
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.command = "";

        /**
         * SsoCloudResponse messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * SsoCloudResponse email.
         * @member {string} email
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.email = "";

        /**
         * SsoCloudResponse encryptedLoginToken.
         * @member {Uint8Array} encryptedLoginToken
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.encryptedLoginToken = $util.newBuffer([]);

        /**
         * SsoCloudResponse providerName.
         * @member {string} providerName
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.providerName = "";

        /**
         * SsoCloudResponse idpSessionId.
         * @member {string} idpSessionId
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.idpSessionId = "";

        /**
         * SsoCloudResponse encryptedSessionToken.
         * @member {Uint8Array} encryptedSessionToken
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.encryptedSessionToken = $util.newBuffer([]);

        /**
         * SsoCloudResponse errorToken.
         * @member {string} errorToken
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         */
        SsoCloudResponse.prototype.errorToken = "";

        /**
         * Creates a new SsoCloudResponse instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {SsoCloud.ISsoCloudResponse=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudResponse} SsoCloudResponse instance
         */
        SsoCloudResponse.create = function create(properties) {
            return new SsoCloudResponse(properties);
        };

        /**
         * Encodes the specified SsoCloudResponse message. Does not implicitly {@link SsoCloud.SsoCloudResponse.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {SsoCloud.ISsoCloudResponse} message SsoCloudResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && message.hasOwnProperty("command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.messageSessionUid);
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.encryptedLoginToken);
            if (message.providerName != null && message.hasOwnProperty("providerName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.providerName);
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.idpSessionId);
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.encryptedSessionToken);
            if (message.errorToken != null && message.hasOwnProperty("errorToken"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.errorToken);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudResponse message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {SsoCloud.ISsoCloudResponse} message SsoCloudResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudResponse message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudResponse} SsoCloudResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 3:
                    message.email = reader.string();
                    break;
                case 4:
                    message.encryptedLoginToken = reader.bytes();
                    break;
                case 5:
                    message.providerName = reader.string();
                    break;
                case 6:
                    message.idpSessionId = reader.string();
                    break;
                case 7:
                    message.encryptedSessionToken = reader.bytes();
                    break;
                case 8:
                    message.errorToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudResponse} SsoCloudResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudResponse message.
         * @function verify
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                if (!(message.encryptedLoginToken && typeof message.encryptedLoginToken.length === "number" || $util.isString(message.encryptedLoginToken)))
                    return "encryptedLoginToken: buffer expected";
            if (message.providerName != null && message.hasOwnProperty("providerName"))
                if (!$util.isString(message.providerName))
                    return "providerName: string expected";
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                if (!$util.isString(message.idpSessionId))
                    return "idpSessionId: string expected";
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                if (!(message.encryptedSessionToken && typeof message.encryptedSessionToken.length === "number" || $util.isString(message.encryptedSessionToken)))
                    return "encryptedSessionToken: buffer expected";
            if (message.errorToken != null && message.hasOwnProperty("errorToken"))
                if (!$util.isString(message.errorToken))
                    return "errorToken: string expected";
            return null;
        };

        /**
         * Creates a SsoCloudResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudResponse} SsoCloudResponse
         */
        SsoCloudResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudResponse)
                return object;
            let message = new $root.SsoCloud.SsoCloudResponse();
            if (object.command != null)
                message.command = String(object.command);
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.email != null)
                message.email = String(object.email);
            if (object.encryptedLoginToken != null)
                if (typeof object.encryptedLoginToken === "string")
                    $util.base64.decode(object.encryptedLoginToken, message.encryptedLoginToken = $util.newBuffer($util.base64.length(object.encryptedLoginToken)), 0);
                else if (object.encryptedLoginToken.length)
                    message.encryptedLoginToken = object.encryptedLoginToken;
            if (object.providerName != null)
                message.providerName = String(object.providerName);
            if (object.idpSessionId != null)
                message.idpSessionId = String(object.idpSessionId);
            if (object.encryptedSessionToken != null)
                if (typeof object.encryptedSessionToken === "string")
                    $util.base64.decode(object.encryptedSessionToken, message.encryptedSessionToken = $util.newBuffer($util.base64.length(object.encryptedSessionToken)), 0);
                else if (object.encryptedSessionToken.length)
                    message.encryptedSessionToken = object.encryptedSessionToken;
            if (object.errorToken != null)
                message.errorToken = String(object.errorToken);
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudResponse
         * @static
         * @param {SsoCloud.SsoCloudResponse} message SsoCloudResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.command = "";
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.email = "";
                if (options.bytes === String)
                    object.encryptedLoginToken = "";
                else {
                    object.encryptedLoginToken = [];
                    if (options.bytes !== Array)
                        object.encryptedLoginToken = $util.newBuffer(object.encryptedLoginToken);
                }
                object.providerName = "";
                object.idpSessionId = "";
                if (options.bytes === String)
                    object.encryptedSessionToken = "";
                else {
                    object.encryptedSessionToken = [];
                    if (options.bytes !== Array)
                        object.encryptedSessionToken = $util.newBuffer(object.encryptedSessionToken);
                }
                object.errorToken = "";
            }
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = message.command;
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.encryptedLoginToken != null && message.hasOwnProperty("encryptedLoginToken"))
                object.encryptedLoginToken = options.bytes === String ? $util.base64.encode(message.encryptedLoginToken, 0, message.encryptedLoginToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedLoginToken) : message.encryptedLoginToken;
            if (message.providerName != null && message.hasOwnProperty("providerName"))
                object.providerName = message.providerName;
            if (message.idpSessionId != null && message.hasOwnProperty("idpSessionId"))
                object.idpSessionId = message.idpSessionId;
            if (message.encryptedSessionToken != null && message.hasOwnProperty("encryptedSessionToken"))
                object.encryptedSessionToken = options.bytes === String ? $util.base64.encode(message.encryptedSessionToken, 0, message.encryptedSessionToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedSessionToken) : message.encryptedSessionToken;
            if (message.errorToken != null && message.hasOwnProperty("errorToken"))
                object.errorToken = message.errorToken;
            return object;
        };

        /**
         * Converts this SsoCloudResponse to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudResponse;
    })();

    SsoCloud.SsoCloudLogRequest = (function() {

        /**
         * Properties of a SsoCloudLogRequest.
         * @memberof SsoCloud
         * @interface ISsoCloudLogRequest
         * @property {number|Long|null} [ssoServiceProviderId] SsoCloudLogRequest ssoServiceProviderId
         * @property {string|null} [serviceName] SsoCloudLogRequest serviceName
         * @property {number|null} [serviceId] SsoCloudLogRequest serviceId
         */

        /**
         * Constructs a new SsoCloudLogRequest.
         * @memberof SsoCloud
         * @classdesc This allows the user to retrieve or clear SSO logs related to a service provider.
         * @implements ISsoCloudLogRequest
         * @constructor
         * @param {SsoCloud.ISsoCloudLogRequest=} [properties] Properties to set
         */
        function SsoCloudLogRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SsoCloudLogRequest ssoServiceProviderId.
         * @member {number|Long} ssoServiceProviderId
         * @memberof SsoCloud.SsoCloudLogRequest
         * @instance
         */
        SsoCloudLogRequest.prototype.ssoServiceProviderId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SsoCloudLogRequest serviceName.
         * @member {string} serviceName
         * @memberof SsoCloud.SsoCloudLogRequest
         * @instance
         */
        SsoCloudLogRequest.prototype.serviceName = "";

        /**
         * SsoCloudLogRequest serviceId.
         * @member {number} serviceId
         * @memberof SsoCloud.SsoCloudLogRequest
         * @instance
         */
        SsoCloudLogRequest.prototype.serviceId = 0;

        /**
         * Creates a new SsoCloudLogRequest instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudLogRequest=} [properties] Properties to set
         * @returns {SsoCloud.SsoCloudLogRequest} SsoCloudLogRequest instance
         */
        SsoCloudLogRequest.create = function create(properties) {
            return new SsoCloudLogRequest(properties);
        };

        /**
         * Encodes the specified SsoCloudLogRequest message. Does not implicitly {@link SsoCloud.SsoCloudLogRequest.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudLogRequest} message SsoCloudLogRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudLogRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ssoServiceProviderId);
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.serviceName);
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.serviceId);
            return writer;
        };

        /**
         * Encodes the specified SsoCloudLogRequest message, length delimited. Does not implicitly {@link SsoCloud.SsoCloudLogRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {SsoCloud.ISsoCloudLogRequest} message SsoCloudLogRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SsoCloudLogRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SsoCloudLogRequest message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SsoCloudLogRequest} SsoCloudLogRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudLogRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SsoCloudLogRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ssoServiceProviderId = reader.uint64();
                    break;
                case 2:
                    message.serviceName = reader.string();
                    break;
                case 3:
                    message.serviceId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SsoCloudLogRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SsoCloudLogRequest} SsoCloudLogRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SsoCloudLogRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SsoCloudLogRequest message.
         * @function verify
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SsoCloudLogRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (!$util.isInteger(message.ssoServiceProviderId) && !(message.ssoServiceProviderId && $util.isInteger(message.ssoServiceProviderId.low) && $util.isInteger(message.ssoServiceProviderId.high)))
                    return "ssoServiceProviderId: integer|Long expected";
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                if (!$util.isString(message.serviceName))
                    return "serviceName: string expected";
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                if (!$util.isInteger(message.serviceId))
                    return "serviceId: integer expected";
            return null;
        };

        /**
         * Creates a SsoCloudLogRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SsoCloudLogRequest} SsoCloudLogRequest
         */
        SsoCloudLogRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SsoCloudLogRequest)
                return object;
            let message = new $root.SsoCloud.SsoCloudLogRequest();
            if (object.ssoServiceProviderId != null)
                if ($util.Long)
                    (message.ssoServiceProviderId = $util.Long.fromValue(object.ssoServiceProviderId)).unsigned = true;
                else if (typeof object.ssoServiceProviderId === "string")
                    message.ssoServiceProviderId = parseInt(object.ssoServiceProviderId, 10);
                else if (typeof object.ssoServiceProviderId === "number")
                    message.ssoServiceProviderId = object.ssoServiceProviderId;
                else if (typeof object.ssoServiceProviderId === "object")
                    message.ssoServiceProviderId = new $util.LongBits(object.ssoServiceProviderId.low >>> 0, object.ssoServiceProviderId.high >>> 0).toNumber(true);
            if (object.serviceName != null)
                message.serviceName = String(object.serviceName);
            if (object.serviceId != null)
                message.serviceId = object.serviceId >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SsoCloudLogRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SsoCloudLogRequest
         * @static
         * @param {SsoCloud.SsoCloudLogRequest} message SsoCloudLogRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SsoCloudLogRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.ssoServiceProviderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ssoServiceProviderId = options.longs === String ? "0" : 0;
                object.serviceName = "";
                object.serviceId = 0;
            }
            if (message.ssoServiceProviderId != null && message.hasOwnProperty("ssoServiceProviderId"))
                if (typeof message.ssoServiceProviderId === "number")
                    object.ssoServiceProviderId = options.longs === String ? String(message.ssoServiceProviderId) : message.ssoServiceProviderId;
                else
                    object.ssoServiceProviderId = options.longs === String ? $util.Long.prototype.toString.call(message.ssoServiceProviderId) : options.longs === Number ? new $util.LongBits(message.ssoServiceProviderId.low >>> 0, message.ssoServiceProviderId.high >>> 0).toNumber(true) : message.ssoServiceProviderId;
            if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                object.serviceName = message.serviceName;
            if (message.serviceId != null && message.hasOwnProperty("serviceId"))
                object.serviceId = message.serviceId;
            return object;
        };

        /**
         * Converts this SsoCloudLogRequest to JSON.
         * @function toJSON
         * @memberof SsoCloud.SsoCloudLogRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SsoCloudLogRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SsoCloudLogRequest;
    })();

    SsoCloud.SamlRelayState = (function() {

        /**
         * Properties of a SamlRelayState.
         * @memberof SsoCloud
         * @interface ISamlRelayState
         * @property {Uint8Array|null} [messageSessionUid] SamlRelayState messageSessionUid
         * @property {string|null} [username] SamlRelayState username
         * @property {boolean|null} [embedded] SamlRelayState embedded
         * @property {boolean|null} [json] SamlRelayState json
         * @property {number|null} [destId] SamlRelayState destId
         * @property {number|null} [keyId] SamlRelayState keyId
         * @property {Authentication.SupportedLanguage|null} [supportedLanguage] SamlRelayState supportedLanguage
         * @property {number|Long|null} [checksum] SamlRelayState checksum
         * @property {boolean|null} [isGeneratedUid] SamlRelayState isGeneratedUid
         */

        /**
         * Constructs a new SamlRelayState.
         * @memberof SsoCloud
         * @classdesc This is used internally by Cloud SSO.  Clients do not use it.
         * @implements ISamlRelayState
         * @constructor
         * @param {SsoCloud.ISamlRelayState=} [properties] Properties to set
         */
        function SamlRelayState(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SamlRelayState messageSessionUid.
         * @member {Uint8Array} messageSessionUid
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.messageSessionUid = $util.newBuffer([]);

        /**
         * SamlRelayState username.
         * @member {string} username
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.username = "";

        /**
         * SamlRelayState embedded.
         * @member {boolean} embedded
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.embedded = false;

        /**
         * SamlRelayState json.
         * @member {boolean} json
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.json = false;

        /**
         * SamlRelayState destId.
         * @member {number} destId
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.destId = 0;

        /**
         * SamlRelayState keyId.
         * @member {number} keyId
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.keyId = 0;

        /**
         * SamlRelayState supportedLanguage.
         * @member {Authentication.SupportedLanguage} supportedLanguage
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.supportedLanguage = 0;

        /**
         * SamlRelayState checksum.
         * @member {number|Long} checksum
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.checksum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SamlRelayState isGeneratedUid.
         * @member {boolean} isGeneratedUid
         * @memberof SsoCloud.SamlRelayState
         * @instance
         */
        SamlRelayState.prototype.isGeneratedUid = false;

        /**
         * Creates a new SamlRelayState instance using the specified properties.
         * @function create
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {SsoCloud.ISamlRelayState=} [properties] Properties to set
         * @returns {SsoCloud.SamlRelayState} SamlRelayState instance
         */
        SamlRelayState.create = function create(properties) {
            return new SamlRelayState(properties);
        };

        /**
         * Encodes the specified SamlRelayState message. Does not implicitly {@link SsoCloud.SamlRelayState.verify|verify} messages.
         * @function encode
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {SsoCloud.ISamlRelayState} message SamlRelayState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SamlRelayState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.messageSessionUid);
            if (message.username != null && message.hasOwnProperty("username"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.embedded);
            if (message.json != null && message.hasOwnProperty("json"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.json);
            if (message.destId != null && message.hasOwnProperty("destId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.destId);
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.keyId);
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.supportedLanguage);
            if (message.checksum != null && message.hasOwnProperty("checksum"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.checksum);
            if (message.isGeneratedUid != null && message.hasOwnProperty("isGeneratedUid"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isGeneratedUid);
            return writer;
        };

        /**
         * Encodes the specified SamlRelayState message, length delimited. Does not implicitly {@link SsoCloud.SamlRelayState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {SsoCloud.ISamlRelayState} message SamlRelayState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SamlRelayState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SamlRelayState message from the specified reader or buffer.
         * @function decode
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SsoCloud.SamlRelayState} SamlRelayState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SamlRelayState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SsoCloud.SamlRelayState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.messageSessionUid = reader.bytes();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                case 3:
                    message.embedded = reader.bool();
                    break;
                case 4:
                    message.json = reader.bool();
                    break;
                case 5:
                    message.destId = reader.uint32();
                    break;
                case 6:
                    message.keyId = reader.int32();
                    break;
                case 7:
                    message.supportedLanguage = reader.int32();
                    break;
                case 8:
                    message.checksum = reader.uint64();
                    break;
                case 9:
                    message.isGeneratedUid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SamlRelayState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SsoCloud.SamlRelayState} SamlRelayState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SamlRelayState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SamlRelayState message.
         * @function verify
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SamlRelayState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                if (!(message.messageSessionUid && typeof message.messageSessionUid.length === "number" || $util.isString(message.messageSessionUid)))
                    return "messageSessionUid: buffer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                if (typeof message.embedded !== "boolean")
                    return "embedded: boolean expected";
            if (message.json != null && message.hasOwnProperty("json"))
                if (typeof message.json !== "boolean")
                    return "json: boolean expected";
            if (message.destId != null && message.hasOwnProperty("destId"))
                if (!$util.isInteger(message.destId))
                    return "destId: integer expected";
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                if (!$util.isInteger(message.keyId))
                    return "keyId: integer expected";
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                switch (message.supportedLanguage) {
                default:
                    return "supportedLanguage: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                    break;
                }
            if (message.checksum != null && message.hasOwnProperty("checksum"))
                if (!$util.isInteger(message.checksum) && !(message.checksum && $util.isInteger(message.checksum.low) && $util.isInteger(message.checksum.high)))
                    return "checksum: integer|Long expected";
            if (message.isGeneratedUid != null && message.hasOwnProperty("isGeneratedUid"))
                if (typeof message.isGeneratedUid !== "boolean")
                    return "isGeneratedUid: boolean expected";
            return null;
        };

        /**
         * Creates a SamlRelayState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SsoCloud.SamlRelayState} SamlRelayState
         */
        SamlRelayState.fromObject = function fromObject(object) {
            if (object instanceof $root.SsoCloud.SamlRelayState)
                return object;
            let message = new $root.SsoCloud.SamlRelayState();
            if (object.messageSessionUid != null)
                if (typeof object.messageSessionUid === "string")
                    $util.base64.decode(object.messageSessionUid, message.messageSessionUid = $util.newBuffer($util.base64.length(object.messageSessionUid)), 0);
                else if (object.messageSessionUid.length)
                    message.messageSessionUid = object.messageSessionUid;
            if (object.username != null)
                message.username = String(object.username);
            if (object.embedded != null)
                message.embedded = Boolean(object.embedded);
            if (object.json != null)
                message.json = Boolean(object.json);
            if (object.destId != null)
                message.destId = object.destId >>> 0;
            if (object.keyId != null)
                message.keyId = object.keyId | 0;
            switch (object.supportedLanguage) {
            case "ENGLISH":
            case 0:
                message.supportedLanguage = 0;
                break;
            case "ARABIC":
            case 1:
                message.supportedLanguage = 1;
                break;
            case "BRITISH":
            case 2:
                message.supportedLanguage = 2;
                break;
            case "CHINESE":
            case 3:
                message.supportedLanguage = 3;
                break;
            case "CHINESE_HONG_KONG":
            case 4:
                message.supportedLanguage = 4;
                break;
            case "CHINESE_TAIWAN":
            case 5:
                message.supportedLanguage = 5;
                break;
            case "DUTCH":
            case 6:
                message.supportedLanguage = 6;
                break;
            case "FRENCH":
            case 7:
                message.supportedLanguage = 7;
                break;
            case "GERMAN":
            case 8:
                message.supportedLanguage = 8;
                break;
            case "GREEK":
            case 9:
                message.supportedLanguage = 9;
                break;
            case "HEBREW":
            case 10:
                message.supportedLanguage = 10;
                break;
            case "ITALIAN":
            case 11:
                message.supportedLanguage = 11;
                break;
            case "JAPANESE":
            case 12:
                message.supportedLanguage = 12;
                break;
            case "KOREAN":
            case 13:
                message.supportedLanguage = 13;
                break;
            case "POLISH":
            case 14:
                message.supportedLanguage = 14;
                break;
            case "PORTUGUESE":
            case 15:
                message.supportedLanguage = 15;
                break;
            case "PORTUGUESE_BRAZIL":
            case 16:
                message.supportedLanguage = 16;
                break;
            case "ROMANIAN":
            case 17:
                message.supportedLanguage = 17;
                break;
            case "RUSSIAN":
            case 18:
                message.supportedLanguage = 18;
                break;
            case "SLOVAK":
            case 19:
                message.supportedLanguage = 19;
                break;
            case "SPANISH":
            case 20:
                message.supportedLanguage = 20;
                break;
            }
            if (object.checksum != null)
                if ($util.Long)
                    (message.checksum = $util.Long.fromValue(object.checksum)).unsigned = true;
                else if (typeof object.checksum === "string")
                    message.checksum = parseInt(object.checksum, 10);
                else if (typeof object.checksum === "number")
                    message.checksum = object.checksum;
                else if (typeof object.checksum === "object")
                    message.checksum = new $util.LongBits(object.checksum.low >>> 0, object.checksum.high >>> 0).toNumber(true);
            if (object.isGeneratedUid != null)
                message.isGeneratedUid = Boolean(object.isGeneratedUid);
            return message;
        };

        /**
         * Creates a plain object from a SamlRelayState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SsoCloud.SamlRelayState
         * @static
         * @param {SsoCloud.SamlRelayState} message SamlRelayState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SamlRelayState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.messageSessionUid = "";
                else {
                    object.messageSessionUid = [];
                    if (options.bytes !== Array)
                        object.messageSessionUid = $util.newBuffer(object.messageSessionUid);
                }
                object.username = "";
                object.embedded = false;
                object.json = false;
                object.destId = 0;
                object.keyId = 0;
                object.supportedLanguage = options.enums === String ? "ENGLISH" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.checksum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.checksum = options.longs === String ? "0" : 0;
                object.isGeneratedUid = false;
            }
            if (message.messageSessionUid != null && message.hasOwnProperty("messageSessionUid"))
                object.messageSessionUid = options.bytes === String ? $util.base64.encode(message.messageSessionUid, 0, message.messageSessionUid.length) : options.bytes === Array ? Array.prototype.slice.call(message.messageSessionUid) : message.messageSessionUid;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.embedded != null && message.hasOwnProperty("embedded"))
                object.embedded = message.embedded;
            if (message.json != null && message.hasOwnProperty("json"))
                object.json = message.json;
            if (message.destId != null && message.hasOwnProperty("destId"))
                object.destId = message.destId;
            if (message.keyId != null && message.hasOwnProperty("keyId"))
                object.keyId = message.keyId;
            if (message.supportedLanguage != null && message.hasOwnProperty("supportedLanguage"))
                object.supportedLanguage = options.enums === String ? $root.Authentication.SupportedLanguage[message.supportedLanguage] : message.supportedLanguage;
            if (message.checksum != null && message.hasOwnProperty("checksum"))
                if (typeof message.checksum === "number")
                    object.checksum = options.longs === String ? String(message.checksum) : message.checksum;
                else
                    object.checksum = options.longs === String ? $util.Long.prototype.toString.call(message.checksum) : options.longs === Number ? new $util.LongBits(message.checksum.low >>> 0, message.checksum.high >>> 0).toNumber(true) : message.checksum;
            if (message.isGeneratedUid != null && message.hasOwnProperty("isGeneratedUid"))
                object.isGeneratedUid = message.isGeneratedUid;
            return object;
        };

        /**
         * Converts this SamlRelayState to JSON.
         * @function toJSON
         * @memberof SsoCloud.SamlRelayState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SamlRelayState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SamlRelayState;
    })();

    return SsoCloud;
})();

export const Upsell = $root.Upsell = (() => {

    /**
     * Namespace Upsell.
     * @exports Upsell
     * @namespace
     */
    const Upsell = {};

    Upsell.UpsellRequest = (function() {

        /**
         * Properties of an UpsellRequest.
         * @memberof Upsell
         * @interface IUpsellRequest
         * @property {string|null} [email] UpsellRequest email
         * @property {string|null} [locale] UpsellRequest locale
         * @property {string|null} [clientVersion] UpsellRequest clientVersion
         * @property {string|null} [sessionToken] UpsellRequest sessionToken
         */

        /**
         * Constructs a new UpsellRequest.
         * @memberof Upsell
         * @classdesc Represents an UpsellRequest.
         * @implements IUpsellRequest
         * @constructor
         * @param {Upsell.IUpsellRequest=} [properties] Properties to set
         */
        function UpsellRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellRequest email.
         * @member {string} email
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.email = "";

        /**
         * UpsellRequest locale.
         * @member {string} locale
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.locale = "";

        /**
         * UpsellRequest clientVersion.
         * @member {string} clientVersion
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.clientVersion = "";

        /**
         * UpsellRequest sessionToken.
         * @member {string} sessionToken
         * @memberof Upsell.UpsellRequest
         * @instance
         */
        UpsellRequest.prototype.sessionToken = "";

        /**
         * Creates a new UpsellRequest instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest=} [properties] Properties to set
         * @returns {Upsell.UpsellRequest} UpsellRequest instance
         */
        UpsellRequest.create = function create(properties) {
            return new UpsellRequest(properties);
        };

        /**
         * Encodes the specified UpsellRequest message. Does not implicitly {@link Upsell.UpsellRequest.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest} message UpsellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.email != null && message.hasOwnProperty("email"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.email);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.locale);
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sessionToken);
            return writer;
        };

        /**
         * Encodes the specified UpsellRequest message, length delimited. Does not implicitly {@link Upsell.UpsellRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.IUpsellRequest} message UpsellRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellRequest message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellRequest} UpsellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.email = reader.string();
                    break;
                case 2:
                    message.locale = reader.string();
                    break;
                case 3:
                    message.clientVersion = reader.string();
                    break;
                case 4:
                    message.sessionToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellRequest} UpsellRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellRequest message.
         * @function verify
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.email != null && message.hasOwnProperty("email"))
                if (!$util.isString(message.email))
                    return "email: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                if (!$util.isString(message.clientVersion))
                    return "clientVersion: string expected";
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                if (!$util.isString(message.sessionToken))
                    return "sessionToken: string expected";
            return null;
        };

        /**
         * Creates an UpsellRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellRequest} UpsellRequest
         */
        UpsellRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellRequest)
                return object;
            let message = new $root.Upsell.UpsellRequest();
            if (object.email != null)
                message.email = String(object.email);
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.clientVersion != null)
                message.clientVersion = String(object.clientVersion);
            if (object.sessionToken != null)
                message.sessionToken = String(object.sessionToken);
            return message;
        };

        /**
         * Creates a plain object from an UpsellRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellRequest
         * @static
         * @param {Upsell.UpsellRequest} message UpsellRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.email = "";
                object.locale = "";
                object.clientVersion = "";
                object.sessionToken = "";
            }
            if (message.email != null && message.hasOwnProperty("email"))
                object.email = message.email;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.clientVersion != null && message.hasOwnProperty("clientVersion"))
                object.clientVersion = message.clientVersion;
            if (message.sessionToken != null && message.hasOwnProperty("sessionToken"))
                object.sessionToken = message.sessionToken;
            return object;
        };

        /**
         * Converts this UpsellRequest to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellRequest;
    })();

    Upsell.UpsellResponse = (function() {

        /**
         * Properties of an UpsellResponse.
         * @memberof Upsell
         * @interface IUpsellResponse
         * @property {Array.<Upsell.IUpsellBanner>|null} [UpsellBanner] UpsellResponse UpsellBanner
         */

        /**
         * Constructs a new UpsellResponse.
         * @memberof Upsell
         * @classdesc Represents an UpsellResponse.
         * @implements IUpsellResponse
         * @constructor
         * @param {Upsell.IUpsellResponse=} [properties] Properties to set
         */
        function UpsellResponse(properties) {
            this.UpsellBanner = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellResponse UpsellBanner.
         * @member {Array.<Upsell.IUpsellBanner>} UpsellBanner
         * @memberof Upsell.UpsellResponse
         * @instance
         */
        UpsellResponse.prototype.UpsellBanner = $util.emptyArray;

        /**
         * Creates a new UpsellResponse instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse=} [properties] Properties to set
         * @returns {Upsell.UpsellResponse} UpsellResponse instance
         */
        UpsellResponse.create = function create(properties) {
            return new UpsellResponse(properties);
        };

        /**
         * Encodes the specified UpsellResponse message. Does not implicitly {@link Upsell.UpsellResponse.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse} message UpsellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.UpsellBanner != null && message.UpsellBanner.length)
                for (let i = 0; i < message.UpsellBanner.length; ++i)
                    $root.Upsell.UpsellBanner.encode(message.UpsellBanner[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpsellResponse message, length delimited. Does not implicitly {@link Upsell.UpsellResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.IUpsellResponse} message UpsellResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellResponse message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellResponse} UpsellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.UpsellBanner && message.UpsellBanner.length))
                        message.UpsellBanner = [];
                    message.UpsellBanner.push($root.Upsell.UpsellBanner.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellResponse} UpsellResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellResponse message.
         * @function verify
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.UpsellBanner != null && message.hasOwnProperty("UpsellBanner")) {
                if (!Array.isArray(message.UpsellBanner))
                    return "UpsellBanner: array expected";
                for (let i = 0; i < message.UpsellBanner.length; ++i) {
                    let error = $root.Upsell.UpsellBanner.verify(message.UpsellBanner[i]);
                    if (error)
                        return "UpsellBanner." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UpsellResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellResponse} UpsellResponse
         */
        UpsellResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellResponse)
                return object;
            let message = new $root.Upsell.UpsellResponse();
            if (object.UpsellBanner) {
                if (!Array.isArray(object.UpsellBanner))
                    throw TypeError(".Upsell.UpsellResponse.UpsellBanner: array expected");
                message.UpsellBanner = [];
                for (let i = 0; i < object.UpsellBanner.length; ++i) {
                    if (typeof object.UpsellBanner[i] !== "object")
                        throw TypeError(".Upsell.UpsellResponse.UpsellBanner: object expected");
                    message.UpsellBanner[i] = $root.Upsell.UpsellBanner.fromObject(object.UpsellBanner[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UpsellResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellResponse
         * @static
         * @param {Upsell.UpsellResponse} message UpsellResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.UpsellBanner = [];
            if (message.UpsellBanner && message.UpsellBanner.length) {
                object.UpsellBanner = [];
                for (let j = 0; j < message.UpsellBanner.length; ++j)
                    object.UpsellBanner[j] = $root.Upsell.UpsellBanner.toObject(message.UpsellBanner[j], options);
            }
            return object;
        };

        /**
         * Converts this UpsellResponse to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellResponse;
    })();

    Upsell.UpsellBanner = (function() {

        /**
         * Properties of an UpsellBanner.
         * @memberof Upsell
         * @interface IUpsellBanner
         * @property {number|null} [bannerId] UpsellBanner bannerId
         * @property {string|null} [bannerOkAction] UpsellBanner bannerOkAction
         * @property {string|null} [bannerOkButton] UpsellBanner bannerOkButton
         * @property {string|null} [bannerCancelAction] UpsellBanner bannerCancelAction
         * @property {string|null} [bannerCancelButton] UpsellBanner bannerCancelButton
         * @property {string|null} [bannerMessage] UpsellBanner bannerMessage
         * @property {string|null} [locale] UpsellBanner locale
         */

        /**
         * Constructs a new UpsellBanner.
         * @memberof Upsell
         * @classdesc Represents an UpsellBanner.
         * @implements IUpsellBanner
         * @constructor
         * @param {Upsell.IUpsellBanner=} [properties] Properties to set
         */
        function UpsellBanner(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpsellBanner bannerId.
         * @member {number} bannerId
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerId = 0;

        /**
         * UpsellBanner bannerOkAction.
         * @member {string} bannerOkAction
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerOkAction = "";

        /**
         * UpsellBanner bannerOkButton.
         * @member {string} bannerOkButton
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerOkButton = "";

        /**
         * UpsellBanner bannerCancelAction.
         * @member {string} bannerCancelAction
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerCancelAction = "";

        /**
         * UpsellBanner bannerCancelButton.
         * @member {string} bannerCancelButton
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerCancelButton = "";

        /**
         * UpsellBanner bannerMessage.
         * @member {string} bannerMessage
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.bannerMessage = "";

        /**
         * UpsellBanner locale.
         * @member {string} locale
         * @memberof Upsell.UpsellBanner
         * @instance
         */
        UpsellBanner.prototype.locale = "";

        /**
         * Creates a new UpsellBanner instance using the specified properties.
         * @function create
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner=} [properties] Properties to set
         * @returns {Upsell.UpsellBanner} UpsellBanner instance
         */
        UpsellBanner.create = function create(properties) {
            return new UpsellBanner(properties);
        };

        /**
         * Encodes the specified UpsellBanner message. Does not implicitly {@link Upsell.UpsellBanner.verify|verify} messages.
         * @function encode
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner} message UpsellBanner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellBanner.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bannerId);
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.bannerOkAction);
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.bannerOkButton);
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.bannerCancelAction);
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.bannerCancelButton);
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.bannerMessage);
            if (message.locale != null && message.hasOwnProperty("locale"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.locale);
            return writer;
        };

        /**
         * Encodes the specified UpsellBanner message, length delimited. Does not implicitly {@link Upsell.UpsellBanner.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.IUpsellBanner} message UpsellBanner message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpsellBanner.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpsellBanner message from the specified reader or buffer.
         * @function decode
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Upsell.UpsellBanner} UpsellBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellBanner.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Upsell.UpsellBanner();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bannerId = reader.int32();
                    break;
                case 2:
                    message.bannerOkAction = reader.string();
                    break;
                case 3:
                    message.bannerOkButton = reader.string();
                    break;
                case 4:
                    message.bannerCancelAction = reader.string();
                    break;
                case 5:
                    message.bannerCancelButton = reader.string();
                    break;
                case 6:
                    message.bannerMessage = reader.string();
                    break;
                case 7:
                    message.locale = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpsellBanner message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Upsell.UpsellBanner} UpsellBanner
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpsellBanner.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpsellBanner message.
         * @function verify
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpsellBanner.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                if (!$util.isInteger(message.bannerId))
                    return "bannerId: integer expected";
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                if (!$util.isString(message.bannerOkAction))
                    return "bannerOkAction: string expected";
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                if (!$util.isString(message.bannerOkButton))
                    return "bannerOkButton: string expected";
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                if (!$util.isString(message.bannerCancelAction))
                    return "bannerCancelAction: string expected";
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                if (!$util.isString(message.bannerCancelButton))
                    return "bannerCancelButton: string expected";
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                if (!$util.isString(message.bannerMessage))
                    return "bannerMessage: string expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            return null;
        };

        /**
         * Creates an UpsellBanner message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Upsell.UpsellBanner} UpsellBanner
         */
        UpsellBanner.fromObject = function fromObject(object) {
            if (object instanceof $root.Upsell.UpsellBanner)
                return object;
            let message = new $root.Upsell.UpsellBanner();
            if (object.bannerId != null)
                message.bannerId = object.bannerId | 0;
            if (object.bannerOkAction != null)
                message.bannerOkAction = String(object.bannerOkAction);
            if (object.bannerOkButton != null)
                message.bannerOkButton = String(object.bannerOkButton);
            if (object.bannerCancelAction != null)
                message.bannerCancelAction = String(object.bannerCancelAction);
            if (object.bannerCancelButton != null)
                message.bannerCancelButton = String(object.bannerCancelButton);
            if (object.bannerMessage != null)
                message.bannerMessage = String(object.bannerMessage);
            if (object.locale != null)
                message.locale = String(object.locale);
            return message;
        };

        /**
         * Creates a plain object from an UpsellBanner message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Upsell.UpsellBanner
         * @static
         * @param {Upsell.UpsellBanner} message UpsellBanner
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpsellBanner.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.bannerId = 0;
                object.bannerOkAction = "";
                object.bannerOkButton = "";
                object.bannerCancelAction = "";
                object.bannerCancelButton = "";
                object.bannerMessage = "";
                object.locale = "";
            }
            if (message.bannerId != null && message.hasOwnProperty("bannerId"))
                object.bannerId = message.bannerId;
            if (message.bannerOkAction != null && message.hasOwnProperty("bannerOkAction"))
                object.bannerOkAction = message.bannerOkAction;
            if (message.bannerOkButton != null && message.hasOwnProperty("bannerOkButton"))
                object.bannerOkButton = message.bannerOkButton;
            if (message.bannerCancelAction != null && message.hasOwnProperty("bannerCancelAction"))
                object.bannerCancelAction = message.bannerCancelAction;
            if (message.bannerCancelButton != null && message.hasOwnProperty("bannerCancelButton"))
                object.bannerCancelButton = message.bannerCancelButton;
            if (message.bannerMessage != null && message.hasOwnProperty("bannerMessage"))
                object.bannerMessage = message.bannerMessage;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            return object;
        };

        /**
         * Converts this UpsellBanner to JSON.
         * @function toJSON
         * @memberof Upsell.UpsellBanner
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpsellBanner.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpsellBanner;
    })();

    /**
     * ClientType enum.
     * @name Upsell.ClientType
     * @enum {string}
     * @property {number} DEFAULT_CLIENT_TYPE=0 DEFAULT_CLIENT_TYPE value
     * @property {number} ALL=1 ALL value
     * @property {number} ANDROID=2 ANDROID value
     * @property {number} IOS=3 IOS value
     * @property {number} MICROSOFT=4 MICROSOFT value
     * @property {number} WEBAPP=5 WEBAPP value
     */
    Upsell.ClientType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_CLIENT_TYPE"] = 0;
        values[valuesById[1] = "ALL"] = 1;
        values[valuesById[2] = "ANDROID"] = 2;
        values[valuesById[3] = "IOS"] = 3;
        values[valuesById[4] = "MICROSOFT"] = 4;
        values[valuesById[5] = "WEBAPP"] = 5;
        return values;
    })();

    /**
     * ClientVersion enum.
     * @name Upsell.ClientVersion
     * @enum {string}
     * @property {number} DEFAULT_VERSION=0 DEFAULT_VERSION value
     * @property {number} SUPPORTS_ALL=1 SUPPORTS_ALL value
     * @property {number} BASEVERSION=14 BASEVERSION value
     * @property {number} ABOVERANGE=15 ABOVERANGE value
     */
    Upsell.ClientVersion = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_VERSION"] = 0;
        values[valuesById[1] = "SUPPORTS_ALL"] = 1;
        values[valuesById[14] = "BASEVERSION"] = 14;
        values[valuesById[15] = "ABOVERANGE"] = 15;
        return values;
    })();

    return Upsell;
})();

export { $root as default };
